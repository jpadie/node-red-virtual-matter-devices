{
  "version": 3,
  "sources": ["../../../src/crypto/CryptoNode.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    CRYPTO_AUTH_TAG_LENGTH,\n    CRYPTO_EC_CURVE,\n    CRYPTO_EC_KEY_BYTES,\n    CRYPTO_ENCRYPT_ALGORITHM,\n    CRYPTO_HASH_ALGORITHM,\n    CRYPTO_SYMMETRIC_KEY_LENGTH,\n    Crypto,\n    CryptoDsaEncoding,\n    CryptoVerifyError,\n    PrivateKey,\n} from \"@project-chip/matter.js/crypto\";\nimport { ByteArray } from \"@project-chip/matter.js/util\";\nimport * as crypto from \"crypto\";\n\nexport class CryptoNode extends Crypto {\n    encrypt(key: ByteArray, data: ByteArray, nonce: ByteArray, aad?: ByteArray): ByteArray {\n        const cipher = crypto.createCipheriv(CRYPTO_ENCRYPT_ALGORITHM, key, nonce, {\n            authTagLength: CRYPTO_AUTH_TAG_LENGTH,\n        });\n        if (aad !== undefined) {\n            cipher.setAAD(aad, { plaintextLength: data.length });\n        }\n        const encrypted = cipher.update(data);\n        cipher.final();\n        return ByteArray.concat(encrypted, cipher.getAuthTag());\n    }\n\n    decrypt(key: ByteArray, data: ByteArray, nonce: ByteArray, aad?: ByteArray): ByteArray {\n        const cipher = crypto.createDecipheriv(CRYPTO_ENCRYPT_ALGORITHM, key, nonce, {\n            authTagLength: CRYPTO_AUTH_TAG_LENGTH,\n        });\n        const plaintextLength = data.length - CRYPTO_AUTH_TAG_LENGTH;\n        if (aad !== undefined) {\n            cipher.setAAD(aad, { plaintextLength });\n        }\n        cipher.setAuthTag(data.slice(plaintextLength));\n        const result = cipher.update(data.slice(0, plaintextLength));\n        cipher.final();\n        return new ByteArray(result);\n    }\n\n    getRandomData(length: number): ByteArray {\n        return new ByteArray(crypto.randomBytes(length));\n    }\n\n    ecdhGeneratePublicKey(): { publicKey: ByteArray; ecdh: any } {\n        const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);\n        ecdh.generateKeys();\n        return { publicKey: new ByteArray(ecdh.getPublicKey()), ecdh: ecdh };\n    }\n\n    ecdhGeneratePublicKeyAndSecret(peerPublicKey: ByteArray): { publicKey: ByteArray; sharedSecret: ByteArray } {\n        const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);\n        ecdh.generateKeys();\n        return {\n            publicKey: new ByteArray(ecdh.getPublicKey()),\n            sharedSecret: new ByteArray(ecdh.computeSecret(peerPublicKey)),\n        };\n    }\n\n    ecdhGenerateSecret(peerPublicKey: ByteArray, ecdh: crypto.ECDH): ByteArray {\n        return new ByteArray(ecdh.computeSecret(peerPublicKey));\n    }\n\n    hash(data: ByteArray | ByteArray[]): ByteArray {\n        const hasher = crypto.createHash(CRYPTO_HASH_ALGORITHM);\n        if (Array.isArray(data)) {\n            data.forEach(chunk => hasher.update(chunk));\n        } else {\n            hasher.update(data);\n        }\n        return new ByteArray(hasher.digest());\n    }\n\n    pbkdf2(secret: ByteArray, salt: ByteArray, iteration: number, keyLength: number): Promise<ByteArray> {\n        return new Promise<ByteArray>((resolver, rejecter) => {\n            crypto.pbkdf2(secret, salt, iteration, keyLength, CRYPTO_HASH_ALGORITHM, (error, key) => {\n                if (error !== null) rejecter(error);\n                resolver(new ByteArray(key));\n            });\n        });\n    }\n\n    hkdf(\n        secret: ByteArray,\n        salt: ByteArray,\n        info: ByteArray,\n        length: number = CRYPTO_SYMMETRIC_KEY_LENGTH,\n    ): Promise<ByteArray> {\n        return new Promise<ByteArray>((resolver, rejecter) => {\n            crypto.hkdf(CRYPTO_HASH_ALGORITHM, secret, salt, info, length, (error, key) => {\n                if (error !== null) rejecter(error);\n                resolver(new ByteArray(key));\n            });\n        });\n    }\n\n    hmac(key: ByteArray, data: ByteArray): ByteArray {\n        const hmac = crypto.createHmac(CRYPTO_HASH_ALGORITHM, key);\n        hmac.update(data);\n        return new ByteArray(hmac.digest());\n    }\n\n    sign(\n        privateKey: JsonWebKey,\n        data: ByteArray | ByteArray[],\n        dsaEncoding: CryptoDsaEncoding = \"ieee-p1363\",\n    ): ByteArray {\n        const signer = crypto.createSign(CRYPTO_HASH_ALGORITHM);\n        if (Array.isArray(data)) {\n            data.forEach(chunk => signer.update(chunk));\n        } else {\n            signer.update(data);\n        }\n        return new ByteArray(\n            signer.sign({\n                key: privateKey as any,\n                format: \"jwk\",\n                type: \"pkcs8\",\n                dsaEncoding,\n            }),\n        );\n    }\n\n    verify(\n        publicKey: JsonWebKey,\n        data: ByteArray,\n        signature: ByteArray,\n        dsaEncoding: CryptoDsaEncoding = \"ieee-p1363\",\n    ) {\n        const verifier = crypto.createVerify(CRYPTO_HASH_ALGORITHM);\n        verifier.update(data);\n        const success = verifier.verify(\n            {\n                key: publicKey as any,\n                format: \"jwk\",\n                type: \"spki\",\n                dsaEncoding,\n            },\n            signature,\n        );\n        if (!success) throw new CryptoVerifyError(\"Signature verification failed\");\n    }\n\n    createKeyPair() {\n        const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);\n        ecdh.generateKeys();\n\n        // The key exported from Node doesn't include most-significant bytes that are 0.  This doesn't affect how we\n        // currently use keys but it's a little weird so 0 pad to avoid future confusion\n        const privateKey = new ByteArray(CRYPTO_EC_KEY_BYTES);\n        const nodePrivateKey = ecdh.getPrivateKey();\n        privateKey.set(nodePrivateKey, CRYPTO_EC_KEY_BYTES - nodePrivateKey.length);\n\n        return PrivateKey(privateKey, { publicKey: ecdh.getPublicKey() });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
