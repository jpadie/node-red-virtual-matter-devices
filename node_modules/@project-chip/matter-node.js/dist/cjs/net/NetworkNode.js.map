{
  "version": 3,
  "sources": ["../../../src/net/NetworkNode.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Logger } from \"@project-chip/matter.js/log\";\nimport {\n    InterfaceType,\n    Network,\n    NetworkError,\n    NetworkInterface,\n    NetworkInterfaceDetails,\n    UdpChannel,\n    UdpChannelOptions,\n} from \"@project-chip/matter.js/net\";\nimport { Cache, isIPv6, onSameNetwork } from \"@project-chip/matter.js/util\";\nimport { NetworkInterfaceInfo, networkInterfaces } from \"os\";\nimport { UdpChannelNode } from \"./UdpChannelNode.js\";\n\nconst logger = Logger.get(\"NetworkNode\");\n\nexport class NetworkNode extends Network {\n    static getMulticastInterfaceIpv4(netInterface: string): string | undefined {\n        const netInterfaceInfo = networkInterfaces()[netInterface];\n        if (netInterfaceInfo === undefined) throw new NetworkError(`Unknown interface: ${netInterface}`);\n        for (const { address, family } of netInterfaceInfo) {\n            if (family === \"IPv4\") {\n                return address;\n            }\n        }\n        return undefined;\n    }\n\n    static getMembershipMulticastInterfaces(netInterface: string | undefined, ipv4: boolean): (string | undefined)[] {\n        if (ipv4) {\n            return [undefined];\n        } else {\n            let networkInterfaceEntries = Object.entries(networkInterfaces());\n            if (netInterface !== undefined) {\n                networkInterfaceEntries = networkInterfaceEntries.filter(([name]) => name === netInterface);\n            }\n            const multicastInterfaces = networkInterfaceEntries.flatMap(([netInterface, netInterfaceInfo]) => {\n                if (netInterfaceInfo === undefined) return [];\n                const zone = this.getNetInterfaceZoneIpv6Internal(netInterface, netInterfaceInfo);\n                return zone === undefined ? [] : [`::%${zone}`];\n            });\n            if (multicastInterfaces.length === 0) {\n                logger.warn(\n                    `No IPv6 multicast interface found${\n                        netInterface !== undefined ? ` for interface ${netInterface}` : \"\"\n                    }.`,\n                );\n            }\n            return multicastInterfaces;\n        }\n    }\n\n    static getNetInterfaceZoneIpv6(netInterface: string): string | undefined {\n        const netInterfaceInfo = networkInterfaces()[netInterface];\n        if (netInterfaceInfo === undefined) throw new NetworkError(`Unknown interface: ${netInterface}`);\n        return this.getNetInterfaceZoneIpv6Internal(netInterface, netInterfaceInfo);\n    }\n\n    static getNetInterfaceForIp(ip: string) {\n        // Finding the local interface on the same interface is complex and won't change\n        // So let's cache the results for 5mn\n        return this.netInterfaces.get(ip);\n    }\n\n    private static readonly netInterfaces = new Cache<string | undefined>(\n        \"Network interface\",\n        (ip: string) => this.getNetInterfaceForRemoveAddress(ip),\n        5 * 60 * 1000 /* 5mn */,\n    );\n\n    override async close() {\n        await NetworkNode.netInterfaces.close();\n    }\n\n    private static getNetInterfaceForRemoveAddress(ip: string) {\n        if (ip.includes(\"%\")) {\n            // IPv6 address with scope\n            return ip.split(\"%\")[1];\n        } else {\n            const interfaces = networkInterfaces();\n            for (const name in interfaces) {\n                const netInterfaces = interfaces[name] as NetworkInterfaceInfo[];\n                for (const { address, netmask } of netInterfaces) {\n                    if (onSameNetwork(ip, address, netmask)) {\n                        return this.getNetInterfaceZoneIpv6Internal(name, netInterfaces);\n                    }\n                }\n            }\n            if (isIPv6(ip)) {\n                if (ip.startsWith(\"fd\")) {\n                    // IPv6 address is an ULA\n                    return \"\"; // consider it as being ok and using the \"Default interface\"\n                }\n            }\n            return undefined;\n        }\n    }\n\n    private static getNetInterfaceZoneIpv6Internal(\n        netInterface: string,\n        netInterfaceInfos: NetworkInterfaceInfo[] | undefined,\n    ): string | undefined {\n        if (process.platform !== \"win32\") {\n            return netInterface;\n        }\n        if (netInterfaceInfos === undefined) return undefined;\n        return netInterfaceInfos\n            .find(({ address, family }) => family === \"IPv6\" && address.startsWith(\"fe80::\"))\n            ?.scopeid?.toString();\n    }\n\n    /**\n     * Get all network interfaces.\n     * The optional configuration parameter allows to map interface names to types if this mapping is known.\n     * Each network interface which has no mapped type is returned as Ethernet for now.\n     *\n     * @param configuration - An array of objects with the name and type properties.\n     */\n    getNetInterfaces(configuration: NetworkInterface[] = []): NetworkInterface[] {\n        const result = new Array<NetworkInterface>();\n        const interfaces = networkInterfaces();\n        for (const name in interfaces) {\n            const netInterfaces = interfaces[name] as NetworkInterfaceInfo[];\n            if (netInterfaces.length === 0) continue;\n            if (netInterfaces[0].internal) continue;\n            let type = InterfaceType.Ethernet;\n            if (configuration.length > 0) {\n                const nameType = configuration.find(({ name: mapName }) => name === mapName);\n                if (nameType !== undefined && nameType.type !== undefined) {\n                    type = nameType.type;\n                }\n            }\n            result.push({ name, type });\n        }\n        return result;\n    }\n\n    getIpMac(netInterface: string): NetworkInterfaceDetails | undefined {\n        const netInterfaceInfo = networkInterfaces()[netInterface];\n        if (netInterfaceInfo === undefined) return undefined;\n        const ipV4 = netInterfaceInfo.filter(({ family }) => family === \"IPv4\").map(({ address }) => address);\n        const ipV6 = netInterfaceInfo.filter(({ family }) => family === \"IPv6\").map(({ address }) => address);\n        return { mac: netInterfaceInfo[0].mac, ipV4, ipV6 };\n    }\n\n    override createUdpChannel(options: UdpChannelOptions): Promise<UdpChannel> {\n        return UdpChannelNode.create(options);\n    }\n}\n"],
  "mappings": "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",
  "names": ["netInterface"]
}
