/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  CRYPTO_AUTH_TAG_LENGTH,
  CRYPTO_EC_CURVE,
  CRYPTO_EC_KEY_BYTES,
  CRYPTO_ENCRYPT_ALGORITHM,
  CRYPTO_HASH_ALGORITHM,
  CRYPTO_SYMMETRIC_KEY_LENGTH,
  Crypto,
  CryptoVerifyError,
  PrivateKey
} from "@project-chip/matter.js/crypto";
import { ByteArray } from "@project-chip/matter.js/util";
import * as crypto from "crypto";
class CryptoNode extends Crypto {
  encrypt(key, data, nonce, aad) {
    const cipher = crypto.createCipheriv(CRYPTO_ENCRYPT_ALGORITHM, key, nonce, {
      authTagLength: CRYPTO_AUTH_TAG_LENGTH
    });
    if (aad !== void 0) {
      cipher.setAAD(aad, { plaintextLength: data.length });
    }
    const encrypted = cipher.update(data);
    cipher.final();
    return ByteArray.concat(encrypted, cipher.getAuthTag());
  }
  decrypt(key, data, nonce, aad) {
    const cipher = crypto.createDecipheriv(CRYPTO_ENCRYPT_ALGORITHM, key, nonce, {
      authTagLength: CRYPTO_AUTH_TAG_LENGTH
    });
    const plaintextLength = data.length - CRYPTO_AUTH_TAG_LENGTH;
    if (aad !== void 0) {
      cipher.setAAD(aad, { plaintextLength });
    }
    cipher.setAuthTag(data.slice(plaintextLength));
    const result = cipher.update(data.slice(0, plaintextLength));
    cipher.final();
    return new ByteArray(result);
  }
  getRandomData(length) {
    return new ByteArray(crypto.randomBytes(length));
  }
  ecdhGeneratePublicKey() {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.generateKeys();
    return { publicKey: new ByteArray(ecdh.getPublicKey()), ecdh };
  }
  ecdhGeneratePublicKeyAndSecret(peerPublicKey) {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.generateKeys();
    return {
      publicKey: new ByteArray(ecdh.getPublicKey()),
      sharedSecret: new ByteArray(ecdh.computeSecret(peerPublicKey))
    };
  }
  ecdhGenerateSecret(peerPublicKey, ecdh) {
    return new ByteArray(ecdh.computeSecret(peerPublicKey));
  }
  hash(data) {
    const hasher = crypto.createHash(CRYPTO_HASH_ALGORITHM);
    if (Array.isArray(data)) {
      data.forEach((chunk) => hasher.update(chunk));
    } else {
      hasher.update(data);
    }
    return new ByteArray(hasher.digest());
  }
  pbkdf2(secret, salt, iteration, keyLength) {
    return new Promise((resolver, rejecter) => {
      crypto.pbkdf2(secret, salt, iteration, keyLength, CRYPTO_HASH_ALGORITHM, (error, key) => {
        if (error !== null) rejecter(error);
        resolver(new ByteArray(key));
      });
    });
  }
  hkdf(secret, salt, info, length = CRYPTO_SYMMETRIC_KEY_LENGTH) {
    return new Promise((resolver, rejecter) => {
      crypto.hkdf(CRYPTO_HASH_ALGORITHM, secret, salt, info, length, (error, key) => {
        if (error !== null) rejecter(error);
        resolver(new ByteArray(key));
      });
    });
  }
  hmac(key, data) {
    const hmac = crypto.createHmac(CRYPTO_HASH_ALGORITHM, key);
    hmac.update(data);
    return new ByteArray(hmac.digest());
  }
  sign(privateKey, data, dsaEncoding = "ieee-p1363") {
    const signer = crypto.createSign(CRYPTO_HASH_ALGORITHM);
    if (Array.isArray(data)) {
      data.forEach((chunk) => signer.update(chunk));
    } else {
      signer.update(data);
    }
    return new ByteArray(
      signer.sign({
        key: privateKey,
        format: "jwk",
        type: "pkcs8",
        dsaEncoding
      })
    );
  }
  verify(publicKey, data, signature, dsaEncoding = "ieee-p1363") {
    const verifier = crypto.createVerify(CRYPTO_HASH_ALGORITHM);
    verifier.update(data);
    const success = verifier.verify(
      {
        key: publicKey,
        format: "jwk",
        type: "spki",
        dsaEncoding
      },
      signature
    );
    if (!success) throw new CryptoVerifyError("Signature verification failed");
  }
  createKeyPair() {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.generateKeys();
    const privateKey = new ByteArray(CRYPTO_EC_KEY_BYTES);
    const nodePrivateKey = ecdh.getPrivateKey();
    privateKey.set(nodePrivateKey, CRYPTO_EC_KEY_BYTES - nodePrivateKey.length);
    return PrivateKey(privateKey, { publicKey: ecdh.getPublicKey() });
  }
}
export {
  CryptoNode
};
//# sourceMappingURL=CryptoNode.js.map
