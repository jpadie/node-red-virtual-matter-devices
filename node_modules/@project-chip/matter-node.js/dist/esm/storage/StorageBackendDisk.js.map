{
  "version": 3,
  "sources": ["../../../src/storage/StorageBackendDisk.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { fromJson, StorageError, SupportedStorageTypes, SyncStorage, toJson } from \"@project-chip/matter.js/storage\";\nimport { LocalStorage } from \"node-localstorage\";\n\nexport class StorageBackendDisk extends SyncStorage {\n    private readonly localStorage;\n    protected isInitialized = false;\n\n    constructor(path: string, clear = false) {\n        super();\n        this.localStorage = new LocalStorage(path);\n        if (clear) this.clear();\n    }\n\n    get initialized() {\n        return this.isInitialized;\n    }\n\n    initialize() {\n        this.isInitialized = true;\n    }\n\n    close() {\n        this.isInitialized = false;\n    }\n\n    clear() {\n        this.localStorage.clear();\n    }\n\n    getContextBaseKey(contexts: string[], allowEmptyContext = false) {\n        const contextKey = contexts.join(\".\");\n        if (\n            (!contextKey.length && !allowEmptyContext) ||\n            contextKey.includes(\"..\") ||\n            contextKey.startsWith(\".\") ||\n            contextKey.endsWith(\".\")\n        )\n            throw new StorageError(\"Context must not be an empty and not contain dots.\");\n        return contextKey;\n    }\n\n    buildStorageKey(contexts: string[], key: string) {\n        if (!key.length) {\n            throw new StorageError(\"Key must not be an empty string.\");\n        }\n        const contextKey = this.getContextBaseKey(contexts);\n        return `${contextKey}.${key}`;\n    }\n\n    get<T extends SupportedStorageTypes>(contexts: string[], key: string): T | undefined {\n        const value = this.localStorage.getItem(this.buildStorageKey(contexts, key));\n        if (value === null) return undefined;\n        return fromJson(value) as T;\n    }\n\n    set(contexts: string[], key: string, value: SupportedStorageTypes): void;\n    set(contexts: string[], values: Record<string, SupportedStorageTypes>): void;\n    set(\n        contexts: string[],\n        keyOrValues: string | Record<string, SupportedStorageTypes>,\n        value?: SupportedStorageTypes,\n    ) {\n        if (typeof keyOrValues === \"string\") {\n            this.localStorage.setItem(this.buildStorageKey(contexts, keyOrValues), toJson(value));\n        } else {\n            for (const [key, value] of Object.entries(keyOrValues)) {\n                this.localStorage.setItem(this.buildStorageKey(contexts, key), toJson(value));\n            }\n        }\n    }\n\n    delete(contexts: string[], key: string) {\n        this.localStorage.removeItem(this.buildStorageKey(contexts, key));\n    }\n\n    /** Returns all keys of a storage context without keys of sub-contexts */\n    keys(contexts: string[]) {\n        const contextKey = this.getContextBaseKey(contexts);\n        const keys = [];\n        const contextKeyStart = `${contextKey}.`;\n        const len = contextKeyStart.length;\n        for (const key of Object.keys(this.localStorage)) {\n            if (key.startsWith(contextKeyStart) && !key.includes(\".\", len)) {\n                keys.push(key.substring(len));\n            }\n        }\n        return keys;\n    }\n\n    values(contexts: string[]) {\n        // Initialize and context checks are done by keys method\n        const values = {} as Record<string, SupportedStorageTypes>;\n        for (const key of this.keys(contexts)) {\n            values[key] = this.get(contexts, key);\n        }\n        return values;\n    }\n\n    contexts(contexts: string[]) {\n        const contextKey = this.getContextBaseKey(contexts, true);\n        const startContextKey = contextKey.length ? `${contextKey}.` : \"\";\n        const len = startContextKey.length;\n        const foundContexts = new Array<string>();\n        for (const key of Object.keys(this.localStorage)) {\n            if (key.startsWith(startContextKey)) {\n                const subKeys = key.substring(len).split(\".\");\n                if (subKeys.length === 1) continue; // found leaf key\n                const context = subKeys[0];\n                if (!foundContexts.includes(context)) {\n                    foundContexts.push(context);\n                }\n            }\n        }\n        return foundContexts;\n    }\n\n    clearAll(contexts: string[]) {\n        const contextKey = this.getContextBaseKey(contexts, true);\n        const startContextKey = contextKey.length ? `${contextKey}.` : \"\";\n        for (const key of Object.keys(this.localStorage)) {\n            if (key.startsWith(startContextKey)) {\n                this.localStorage.removeItem(key);\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
