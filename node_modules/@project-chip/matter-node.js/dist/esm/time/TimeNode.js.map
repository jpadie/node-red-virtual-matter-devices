{
  "version": 3,
  "sources": ["../../../src/time/TimeNode.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"@project-chip/matter.js/common\";\nimport { Time, Timer, TimerCallback } from \"@project-chip/matter.js/time\";\n\nclass TimerNode implements Timer {\n    #timerId: NodeJS.Timeout | undefined;\n    #utility = false;\n    isRunning = false;\n\n    get systemId() {\n        return Number(this.#timerId);\n    }\n\n    constructor(\n        readonly name: string,\n        readonly intervalMs: number,\n        private readonly callback: TimerCallback,\n        readonly isPeriodic: boolean,\n    ) {\n        if (intervalMs < 0 || intervalMs > 2147483647) {\n            throw new ImplementationError(\n                `Invalid intervalMs: ${intervalMs}. The value must be between 0 and 32-bit maximum value (2147483647)`,\n            );\n        }\n    }\n\n    get utility() {\n        return this.#utility;\n    }\n\n    set utility(utility: boolean) {\n        if (utility === this.#utility) {\n            return;\n        }\n\n        if (utility) {\n            this.#timerId?.unref();\n        } else {\n            this.#timerId?.ref();\n        }\n\n        this.#utility = utility;\n    }\n\n    start() {\n        if (this.isRunning) this.stop();\n        Time.register(this);\n        this.isRunning = true;\n        this.#timerId = (this.isPeriodic ? setInterval : setTimeout)(() => {\n            if (!this.isPeriodic) {\n                Time.unregister(this);\n                this.isRunning = false;\n            }\n            this.callback();\n        }, this.intervalMs);\n        return this;\n    }\n\n    stop() {\n        (this.isPeriodic ? clearInterval : clearTimeout)(this.#timerId);\n        Time.unregister(this);\n        this.isRunning = false;\n        return this;\n    }\n}\n\nexport class TimeNode extends Time {\n    now(): Date {\n        return new Date();\n    }\n\n    nowMs(): number {\n        return this.now().getTime();\n    }\n\n    getTimer(name: string, durationMs: number, callback: TimerCallback): Timer {\n        return new TimerNode(name, durationMs, callback, false);\n    }\n\n    getPeriodicTimer(name: string, intervalMs: number, callback: TimerCallback): Timer {\n        return new TimerNode(name, intervalMs, callback, true);\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,2BAA2B;AACpC,SAAS,YAAkC;AAE3C,MAAM,UAA2B;AAAA,EAS7B,YACa,MACA,YACQ,UACR,YACX;AAJW;AACA;AACQ;AACR;AAET,QAAI,aAAa,KAAK,aAAa,YAAY;AAC3C,YAAM,IAAI;AAAA,QACN,uBAAuB,UAAU;AAAA,MACrC;AAAA,IACJ;AAAA,EACJ;AAAA,EAnBA;AAAA,EACA,WAAW;AAAA,EACX,YAAY;AAAA,EAEZ,IAAI,WAAW;AACX,WAAO,OAAO,KAAK,QAAQ;AAAA,EAC/B;AAAA,EAeA,IAAI,UAAU;AACV,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQ,SAAkB;AAC1B,QAAI,YAAY,KAAK,UAAU;AAC3B;AAAA,IACJ;AAEA,QAAI,SAAS;AACT,WAAK,UAAU,MAAM;AAAA,IACzB,OAAO;AACH,WAAK,UAAU,IAAI;AAAA,IACvB;AAEA,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,QAAQ;AACJ,QAAI,KAAK,UAAW,MAAK,KAAK;AAC9B,SAAK,SAAS,IAAI;AAClB,SAAK,YAAY;AACjB,SAAK,YAAY,KAAK,aAAa,cAAc,YAAY,MAAM;AAC/D,UAAI,CAAC,KAAK,YAAY;AAClB,aAAK,WAAW,IAAI;AACpB,aAAK,YAAY;AAAA,MACrB;AACA,WAAK,SAAS;AAAA,IAClB,GAAG,KAAK,UAAU;AAClB,WAAO;AAAA,EACX;AAAA,EAEA,OAAO;AACH,KAAC,KAAK,aAAa,gBAAgB,cAAc,KAAK,QAAQ;AAC9D,SAAK,WAAW,IAAI;AACpB,SAAK,YAAY;AACjB,WAAO;AAAA,EACX;AACJ;AAEO,MAAM,iBAAiB,KAAK;AAAA,EAC/B,MAAY;AACR,WAAO,oBAAI,KAAK;AAAA,EACpB;AAAA,EAEA,QAAgB;AACZ,WAAO,KAAK,IAAI,EAAE,QAAQ;AAAA,EAC9B;AAAA,EAEA,SAAS,MAAc,YAAoB,UAAgC;AACvE,WAAO,IAAI,UAAU,MAAM,YAAY,UAAU,KAAK;AAAA,EAC1D;AAAA,EAEA,iBAAiB,MAAc,YAAoB,UAAgC;AAC/E,WAAO,IAAI,UAAU,MAAM,YAAY,UAAU,IAAI;AAAA,EACzD;AACJ;",
  "names": []
}
