import { ImplementationError } from "../../../common/MatterError.js";
import { DatasourceStore } from "../../../endpoint/storage/DatasourceStore.js";
import { Construction } from "../../../util/Construction.js";
const NUMBER_KEY = "__number__";
class ServerPartStore {
  #storage;
  #initialValues = {};
  #number;
  #construction;
  #childStorage;
  #childStores = {};
  #knownBehaviors = /* @__PURE__ */ new Set();
  toString() {
    return `storage:${this.#storage.thisContexts.join(".")}`;
  }
  get construction() {
    return this.#construction;
  }
  get initialValues() {
    return this.#initialValues;
  }
  get number() {
    this.#construction.assert();
    return this.#number;
  }
  set number(number) {
    this.#construction.assert();
    if (this.#number !== number) {
      this.#number = number;
    }
  }
  constructor(storage, load = true) {
    this.#storage = storage;
    this.#childStorage = storage.createContext("parts");
    this.#construction = Construction(this, () => {
      if (!load) {
        return;
      }
      return this.#load();
    });
  }
  async #load() {
    this.#knownBehaviors = new Set(await this.#storage.contexts());
    for (const behaviorId of this.#knownBehaviors) {
      const behaviorValues = this.#initialValues[behaviorId] = {};
      const behaviorStorage = this.#storage.createContext(behaviorId);
      for (const key of await behaviorStorage.keys()) {
        behaviorValues[key] = await behaviorStorage.get(key);
      }
    }
    const number = await this.#storage.get(NUMBER_KEY, -1);
    if (number !== -1) {
      this.#number = number;
    }
    await this.#loadSubparts();
  }
  storeForBehavior(behaviorId) {
    this.#construction.assert();
    return DatasourceStore(this, behaviorId);
  }
  childStoreFor(endpoint) {
    if (!endpoint.lifecycle.hasId) {
      throw new ImplementationError("Cannot access endpoint storage because endpoint has no assigned ID");
    }
    return this.#storeForPartId(endpoint.id);
  }
  #storeForPartId(partId) {
    this.#construction.assert();
    let store = this.#childStores[partId];
    if (store === void 0) {
      store = this.#childStores[partId] = new ServerPartStore(this.#childStorage.createContext(partId), false);
    }
    return store;
  }
  async saveNumber() {
    await this.#construction;
    await this.#storage.set(NUMBER_KEY, this.number);
  }
  async set(values) {
    await this.#construction;
    for (const behaviorId in values) {
      const behaviorValues = values[behaviorId];
      const behaviorStorage = this.#storage.createContext(behaviorId);
      if (behaviorValues === void 0) {
        if (this.#knownBehaviors.has(behaviorId)) {
          await behaviorStorage.clearAll();
          this.#knownBehaviors.delete(behaviorId);
        }
        continue;
      }
      if (!this.#knownBehaviors.has(behaviorId)) {
        this.#knownBehaviors.add(behaviorId);
      }
      for (const key in behaviorValues) {
        const value = behaviorValues[key];
        if (value === void 0) {
          await behaviorStorage.delete(key);
        } else {
          await behaviorStorage.set(key, behaviorValues[key]);
        }
      }
    }
  }
  async delete() {
    await this.#construction;
    await this.#storage.clearAll();
  }
  async #loadSubparts() {
    const knownParts = await this.#childStorage.contexts();
    for (const partId of knownParts) {
      await this.#loadKnownChildStores(partId);
    }
  }
  async #loadKnownChildStores(partId) {
    const partStore = new ServerPartStore(this.#childStorage.createContext(partId));
    this.#childStores[partId] = partStore;
    await partStore.construction;
  }
}
export {
  ServerPartStore
};
//# sourceMappingURL=ServerPartStore.js.map
