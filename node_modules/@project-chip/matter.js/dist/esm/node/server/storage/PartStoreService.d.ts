/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Endpoint } from "../../../endpoint/Endpoint.js";
import { PartStore } from "../../../endpoint/storage/PartStore.js";
import type { StorageContext } from "../../../storage/StorageContext.js";
import { Construction } from "../../../util/Construction.js";
import { ServerPartStore } from "./ServerPartStore.js";
/**
 * Manages all {@link ServerPartStore}s for a {@link NodeServer}.
 *
 * We eagerly load all available endpoint data from disk because this allows us to keep {@link Endpoint} initialization
 * more synchronous.  We can initialize most behaviors synchronously if their state is already in memory.
 *
 * TODO - cleanup of storage for permanently removed endpoints
 */
export declare abstract class PartStoreService {
    /**
     * Allocate an endpoint number.
     *
     * Either allocates a new number for a {@link Endpoint} or reserves the endpoint's number.  If the {@link Endpoint}
     * already has a number but it is allocated to a different endpoint it is an error.
     *
     * We must persist the assigned number and next endpoint number.  We are fairly resilient to the small chance that
     * persistence fails so we persist lazily and return synchronously.
     */
    abstract assignNumber(endpoint: Endpoint): void;
    /**
     * Obtain the store for a single {@link Endpoint}.
     *
     * These stores are cached internally by ID.
     *
     * TODO - when StorageContext becomes async we can keep this synchronous if we add "StorageContext.subcontexts" or
     * somesuch
     */
    abstract storeForPart(endpoint: Endpoint): PartStore;
}
export declare class PartStoreFactory extends PartStoreService {
    #private;
    get construction(): Construction<PartStoreFactory>;
    constructor({ storage, nextNumber }: PartStoreService.Options);
    [Construction.construct](): Promise<void>;
    erase(): Promise<void>;
    close(): Promise<void>;
    assignNumber(endpoint: Endpoint): void;
    storeForPart(endpoint: Endpoint): ServerPartStore;
}
export declare namespace PartStoreService {
    interface Options {
        storage: StorageContext;
        nextNumber?: number;
        load?: boolean;
    }
}
//# sourceMappingURL=PartStoreService.d.ts.map