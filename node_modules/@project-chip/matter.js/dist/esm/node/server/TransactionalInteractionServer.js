var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __using = (stack, value, async) => {
  if (value != null) {
    if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
    var dispose, inner;
    if (async) dispose = value[__knownSymbol("asyncDispose")];
    if (dispose === void 0) {
      dispose = value[__knownSymbol("dispose")];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value]);
  } else if (async) {
    stack.push([async]);
  }
  return value;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionTracer } from "../../behavior/context/ActionTracer.js";
import { NodeActivity } from "../../behavior/context/NodeActivity.js";
import { OnlineContext } from "../../behavior/context/server/OnlineContext.js";
import { AccessControlServer } from "../../behavior/definitions/access-control/AccessControlServer.js";
import { BasicInformationServer } from "../../behavior/definitions/basic-information/BasicInformationServer.js";
import { AccessControlCluster } from "../../cluster/definitions/AccessControlCluster.js";
import { InternalError } from "../../common/MatterError.js";
import { EndpointServer } from "../../endpoint/EndpointServer.js";
import { EndpointLifecycle } from "../../endpoint/properties/EndpointLifecycle.js";
import { Diagnostic } from "../../log/Diagnostic.js";
import { AccessDeniedError } from "../../protocol/interaction/AccessControlManager.js";
import { InteractionEndpointStructure } from "../../protocol/interaction/InteractionEndpointStructure.js";
import {
  InteractionServerMessenger
} from "../../protocol/interaction/InteractionMessenger.js";
import {
  InteractionServer
} from "../../protocol/interaction/InteractionServer.js";
import { MaybePromise } from "../../util/Promises.js";
const activityKey = Symbol("activity");
const AclClusterId = AccessControlCluster.id;
const AclAttributeId = AccessControlCluster.attributes.acl.id;
class TransactionalInteractionServer extends InteractionServer {
  #endpointStructure;
  #changeListener;
  #endpoint;
  #activity;
  #newActivityBlocked = false;
  #aclServer;
  #aclUpdateIsDelayed = false;
  static async create(endpoint) {
    const endpointStructure = new InteractionEndpointStructure();
    const maxPathsPerInvoke = await endpoint.act(
      (agent) => agent.get(BasicInformationServer).state.maxPathsPerInvoke
    );
    return new TransactionalInteractionServer(endpoint, {
      endpointStructure,
      subscriptionOptions: endpoint.state.network.subscriptionOptions,
      maxPathsPerInvoke
    });
  }
  constructor(endpoint, config) {
    super(config);
    const { endpointStructure } = config;
    this.#activity = endpoint.env.get(NodeActivity);
    this.#endpoint = endpoint;
    this.#endpointStructure = endpointStructure;
    this.#updateStructure();
    this.#changeListener = (type) => {
      switch (type) {
        case EndpointLifecycle.Change.PartsReady:
        case EndpointLifecycle.Change.ClientsChanged:
        case EndpointLifecycle.Change.ServersChanged:
        case EndpointLifecycle.Change.Destroyed:
          this.#updateStructure();
          break;
      }
    };
    endpoint.lifecycle.changed.on(this.#changeListener);
  }
  async [Symbol.asyncDispose]() {
    this.#endpoint.lifecycle.changed.off(this.#changeListener);
    await this.close();
    this.#endpointStructure.close();
  }
  blockNewActivity() {
    this.#newActivityBlocked = true;
  }
  async onNewExchange(exchange) {
    var _stack = [];
    try {
      if (this.#newActivityBlocked || this.isClosing) {
        return;
      }
      const activity = __using(_stack, this.#activity.begin(`session#${exchange.session.id.toString(16)}`));
      exchange[activityKey] = activity;
      return new InteractionServerMessenger(exchange).handleRequest(this).finally(() => delete exchange[activityKey]);
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  }
  get aclServer() {
    if (this.#aclServer !== void 0) {
      return this.#aclServer;
    }
    const aclServer = this.#endpoint.act((agent) => agent.get(AccessControlServer));
    if (MaybePromise.is(aclServer)) {
      throw new InternalError("AccessControlServer should already be initialized.");
    }
    return this.#aclServer = aclServer;
  }
  async readAttribute(path, attribute, exchange, fabricFiltered, message, endpoint) {
    const readAttribute = () => super.readAttribute(path, attribute, exchange, fabricFiltered, message, endpoint);
    return OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      endpoint,
      root: this.#endpoint
    }).act(readAttribute);
  }
  async readEvent(path, eventFilters, event, exchange, fabricFiltered, message, endpoint) {
    const readEvent = (context) => {
      if (!context.authorizedFor(event.readAcl, { cluster: path.clusterId })) {
        throw new AccessDeniedError(
          `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.readEvent(path, eventFilters, event, exchange, fabricFiltered, message, endpoint);
    };
    return OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      endpoint,
      root: this.#endpoint
    }).act(readEvent);
  }
  async handleWriteRequest(exchange, writeRequest, message) {
    const result = await super.handleWriteRequest(exchange, writeRequest, message);
    if (this.#aclUpdateIsDelayed) {
      this.aclServer.aclUpdateDelayed = false;
      this.#aclUpdateIsDelayed = false;
    }
    return result;
  }
  async writeAttribute(path, attribute, value, exchange, message, endpoint, timed = false, isListWrite) {
    const writeAttribute = () => super.writeAttribute(path, attribute, value, exchange, message, endpoint, timed, isListWrite);
    if (path.endpointId === 0 && path.clusterId === AclClusterId && path.attributeId === AclAttributeId) {
      this.aclServer.aclUpdateDelayed = true;
      this.#aclUpdateIsDelayed = true;
    } else if (this.#aclUpdateIsDelayed) {
      this.aclServer.aclUpdateDelayed = false;
      this.#aclUpdateIsDelayed = false;
    }
    return OnlineContext({
      activity: exchange[activityKey],
      timed,
      message,
      exchange,
      fabricFiltered: true,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Write,
      endpoint,
      root: this.#endpoint
    }).act(writeAttribute);
  }
  async invokeCommand(path, command, exchange, commandFields, message, endpoint, timed = false) {
    const invokeCommand = (context) => {
      if (!context.authorizedFor(command.invokeAcl, { cluster: path.clusterId })) {
        throw new AccessDeniedError(
          `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.invokeCommand(path, command, exchange, commandFields, message, endpoint, timed);
    };
    return OnlineContext({
      activity: exchange[activityKey],
      command: true,
      timed,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Invoke,
      endpoint,
      root: this.#endpoint
    }).act(invokeCommand);
  }
  get #tracer() {
    if (this.#endpoint.env.has(ActionTracer)) {
      return this.#endpoint.env.get(ActionTracer);
    }
  }
  #updateStructure() {
    if (this.#endpoint.lifecycle.isPartsReady) {
      this.#endpointStructure.initializeFromEndpoint(EndpointServer.forEndpoint(this.#endpoint));
    }
  }
}
export {
  TransactionalInteractionServer
};
//# sourceMappingURL=TransactionalInteractionServer.js.map
