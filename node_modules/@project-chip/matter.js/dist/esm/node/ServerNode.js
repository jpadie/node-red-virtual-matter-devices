/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CommissioningBehavior } from "../behavior/system/commissioning/CommissioningBehavior.js";
import { NetworkServer } from "../behavior/system/network/NetworkServer.js";
import { ServerNetworkRuntime } from "../behavior/system/network/ServerNetworkRuntime.js";
import { ProductDescriptionServer } from "../behavior/system/product-description/ProductDescriptionServer.js";
import { SessionsBehavior } from "../behavior/system/sessions/SessionsBehavior.js";
import { MatterError } from "../common/MatterError.js";
import { EndpointServer } from "../endpoint/EndpointServer.js";
import { RootEndpoint as BaseRootEndpoint } from "../endpoint/definitions/system/RootEndpoint.js";
import { EndpointInitializer } from "../endpoint/properties/EndpointInitializer.js";
import { DiagnosticSource } from "../log/DiagnosticSource.js";
import { Construction, asyncNew } from "../util/Construction.js";
import { errorOf } from "../util/Error.js";
import { Node } from "./Node.js";
import { IdentityService } from "./server/IdentityService.js";
import { ServerEndpointInitializer } from "./server/ServerEndpointInitializer.js";
import { ServerStore } from "./server/storage/ServerStore.js";
class FactoryResetError extends MatterError {
  constructor(message, cause) {
    super(message);
    this.cause = errorOf(cause);
  }
}
class ServerNode extends Node {
  constructor(definition, options) {
    super(Node.nodeConfigFor(ServerNode.RootEndpoint, definition, options));
    DiagnosticSource.add(this);
  }
  static async create(definition, options) {
    return await asyncNew(this, definition, options);
  }
  createRuntime() {
    return new ServerNetworkRuntime(this);
  }
  async [Construction.destruct]() {
    await super[Construction.destruct]();
    if (this.env.has(ServerStore)) {
      const store = this.env.get(ServerStore);
      await store.close();
      this.env.delete(ServerStore, store);
    }
  }
  async reset() {
    await super.reset();
    await EndpointServer.forEndpoint(this)[Symbol.asyncDispose]();
  }
  /**
   * Perform a factory reset of the node.
   */
  async factoryReset() {
    try {
      await this.construction;
      const isOnline = this.lifecycle.isOnline;
      if (isOnline) {
        await this.cancel();
      }
      this.statusUpdate("resetting to factory defaults");
      await this.reset();
      await this.resetStorage();
      this.construction.start();
      if (isOnline) {
        await this.start();
      } else {
        await this.construction.ready;
      }
    } catch (e) {
      this.construction.crash();
      throw new FactoryResetError(`Error during factory reset of ${this}`, e);
    }
  }
  async advertiseNow() {
    await this.act(`advertiseNow<${this}>`, (agent) => agent.get(NetworkServer).advertiseNow());
  }
  async initialize() {
    const serverStore = await ServerStore.create(this.env, this.id);
    this.env.set(ServerStore, serverStore);
    this.env.set(EndpointInitializer, new ServerEndpointInitializer(this.env));
    this.env.set(IdentityService, new IdentityService(this));
    return super.initialize();
  }
  /**
   * By default on factory reset we erase all stored data.
   *
   * If this is inappropriate for your application you may override to alter the behavior.   Matter requires that all
   * "security- and privacy-related data and key material" is removed on factory reset.
   *
   * @see {@link MatterSpecification.v12.Core} ยง 13.4
   */
  async resetStorage() {
    await this.env.get(ServerStore).erase();
  }
}
((ServerNode2) => {
  ServerNode2.RootEndpoint = BaseRootEndpoint.with(
    CommissioningBehavior,
    NetworkServer,
    ProductDescriptionServer,
    SessionsBehavior
  );
})(ServerNode || (ServerNode = {}));
export {
  ServerNode
};
//# sourceMappingURL=ServerNode.js.map
