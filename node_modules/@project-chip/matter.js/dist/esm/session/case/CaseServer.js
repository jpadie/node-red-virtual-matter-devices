/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { TlvOperationalCertificate } from "../../certificate/CertificateManager.js";
import { UnexpectedDataError } from "../../common/MatterError.js";
import { Crypto } from "../../crypto/Crypto.js";
import { PublicKey } from "../../crypto/Key.js";
import { NodeId } from "../../datatype/NodeId.js";
import { FabricNotFoundError } from "../../fabric/FabricManager.js";
import { Logger } from "../../log/Logger.js";
import { ProtocolStatusCode, SECURE_CHANNEL_PROTOCOL_ID } from "../../protocol/securechannel/SecureChannelMessages.js";
import { ChannelStatusResponseError } from "../../protocol/securechannel/SecureChannelMessenger.js";
import { ByteArray } from "../../util/ByteArray.js";
import {
  KDFSR1_KEY_INFO,
  KDFSR2_INFO,
  KDFSR2_KEY_INFO,
  KDFSR3_INFO,
  RESUME1_MIC_NONCE,
  RESUME2_MIC_NONCE,
  TBE_DATA2_NONCE,
  TBE_DATA3_NONCE,
  TlvEncryptedDataSigma2,
  TlvEncryptedDataSigma3,
  TlvSignedData
} from "./CaseMessages.js";
import { CaseServerMessenger } from "./CaseMessenger.js";
const logger = Logger.get("CaseServer");
class CaseServer {
  async onNewExchange(exchange) {
    const messenger = new CaseServerMessenger(exchange);
    try {
      await this.handleSigma1(exchange.session.context, messenger);
    } catch (error) {
      logger.error("An error occurred during the commissioning", error);
      if (error instanceof FabricNotFoundError) {
        await messenger.sendError(ProtocolStatusCode.NoSharedTrustRoots);
      } else if (!(error instanceof ChannelStatusResponseError)) {
        await messenger.sendError(ProtocolStatusCode.InvalidParam);
      }
    } finally {
      await exchange.session.destroy();
    }
  }
  getId() {
    return SECURE_CHANNEL_PROTOCOL_ID;
  }
  async handleSigma1(server, messenger) {
    logger.info(`Received pairing request from ${messenger.getChannelName()}`);
    const responderRandom = Crypto.getRandom();
    const { sigma1Bytes, sigma1 } = await messenger.readSigma1();
    const {
      initiatorSessionId: peerSessionId,
      resumptionId: peerResumptionId,
      initiatorResumeMic: peerResumeMic,
      destinationId,
      initiatorRandom: peerRandom,
      initiatorEcdhPublicKey: peerEcdhPublicKey,
      initiatorSessionParams
    } = sigma1;
    const resumptionId = Crypto.getRandomData(16);
    const resumptionRecord = peerResumptionId !== void 0 && peerResumeMic !== void 0 ? server.findResumptionRecordById(peerResumptionId) : void 0;
    if (peerResumptionId !== void 0 && peerResumeMic !== void 0 && resumptionRecord !== void 0) {
      const { sharedSecret, fabric, peerNodeId, caseAuthenticatedTags } = resumptionRecord;
      const peerResumeKey = await Crypto.hkdf(
        sharedSecret,
        ByteArray.concat(peerRandom, peerResumptionId),
        KDFSR1_KEY_INFO
      );
      Crypto.decrypt(peerResumeKey, peerResumeMic, RESUME1_MIC_NONCE);
      const responderSessionId = await server.getNextAvailableSessionId();
      const secureSessionSalt = ByteArray.concat(peerRandom, peerResumptionId);
      const secureSession = await server.sessionManager.createSecureSession({
        sessionId: responderSessionId,
        fabric,
        peerNodeId,
        peerSessionId,
        sharedSecret,
        salt: secureSessionSalt,
        isInitiator: false,
        isResumption: true,
        peerSessionParameters: initiatorSessionParams,
        caseAuthenticatedTags
      });
      const resumeSalt = ByteArray.concat(peerRandom, resumptionId);
      const resumeKey = await Crypto.hkdf(sharedSecret, resumeSalt, KDFSR2_KEY_INFO);
      const resumeMic = Crypto.encrypt(resumeKey, new ByteArray(0), RESUME2_MIC_NONCE);
      try {
        await messenger.sendSigma2Resume({
          resumptionId,
          resumeMic,
          responderSessionId,
          responderSessionParams: server.sessionParameters
          // responder session parameters
        });
      } catch (error) {
        await secureSession.destroy(false);
        throw error;
      }
      logger.info(
        `session ${secureSession.id} resumed with ${messenger.getChannelName()} for Fabric ${NodeId.toHexString(
          fabric.nodeId
        )}(index ${fabric.fabricIndex}) and PeerNode ${NodeId.toHexString(peerNodeId)}`
      );
      resumptionRecord.resumptionId = resumptionId;
      await messenger.waitForSuccess("Success after CASE Sigma2Resume");
      await messenger.close();
      await server.saveResumptionRecord(resumptionRecord);
    } else if (peerResumptionId === void 0 && peerResumeMic === void 0 || peerResumptionId !== void 0 && peerResumeMic !== void 0 && resumptionRecord === void 0) {
      const fabric = server.findFabricFromDestinationId(destinationId, peerRandom);
      const { operationalCert: nodeOpCert, intermediateCACert, operationalIdentityProtectionKey } = fabric;
      const { publicKey: responderEcdhPublicKey, sharedSecret } = Crypto.ecdhGeneratePublicKeyAndSecret(peerEcdhPublicKey);
      const sigma2Salt = ByteArray.concat(
        operationalIdentityProtectionKey,
        responderRandom,
        responderEcdhPublicKey,
        Crypto.hash(sigma1Bytes)
      );
      const sigma2Key = await Crypto.hkdf(sharedSecret, sigma2Salt, KDFSR2_INFO);
      const signatureData = TlvSignedData.encode({
        nodeOpCert,
        intermediateCACert,
        ecdhPublicKey: responderEcdhPublicKey,
        peerEcdhPublicKey
      });
      const signature = fabric.sign(signatureData);
      const encryptedData = TlvEncryptedDataSigma2.encode({
        nodeOpCert,
        intermediateCACert,
        signature,
        resumptionId
      });
      const encrypted = Crypto.encrypt(sigma2Key, encryptedData, TBE_DATA2_NONCE);
      const responderSessionId = await server.getNextAvailableSessionId();
      const sigma2Bytes = await messenger.sendSigma2({
        responderRandom,
        responderSessionId,
        responderEcdhPublicKey,
        encrypted,
        responderSessionParams: server.sessionParameters
        // responder session parameters
      });
      const {
        sigma3Bytes,
        sigma3: { encrypted: peerEncrypted }
      } = await messenger.readSigma3();
      const sigma3Salt = ByteArray.concat(
        operationalIdentityProtectionKey,
        Crypto.hash([sigma1Bytes, sigma2Bytes])
      );
      const sigma3Key = await Crypto.hkdf(sharedSecret, sigma3Salt, KDFSR3_INFO);
      const peerDecryptedData = Crypto.decrypt(sigma3Key, peerEncrypted, TBE_DATA3_NONCE);
      const {
        nodeOpCert: peerNewOpCert,
        intermediateCACert: peerIntermediateCACert,
        signature: peerSignature
      } = TlvEncryptedDataSigma3.decode(peerDecryptedData);
      fabric.verifyCredentials(peerNewOpCert, peerIntermediateCACert);
      const peerSignatureData = TlvSignedData.encode({
        nodeOpCert: peerNewOpCert,
        intermediateCACert: peerIntermediateCACert,
        ecdhPublicKey: peerEcdhPublicKey,
        peerEcdhPublicKey: responderEcdhPublicKey
      });
      const {
        ellipticCurvePublicKey: peerPublicKey,
        subject: { fabricId: peerFabricId, nodeId: peerNodeId, caseAuthenticatedTags }
      } = TlvOperationalCertificate.decode(peerNewOpCert);
      if (fabric.fabricId !== peerFabricId) {
        throw new UnexpectedDataError(`Fabric ID mismatch: ${fabric.fabricId} !== ${peerFabricId}`);
      }
      Crypto.verify(PublicKey(peerPublicKey), peerSignatureData, peerSignature);
      const secureSessionSalt = ByteArray.concat(
        operationalIdentityProtectionKey,
        Crypto.hash([sigma1Bytes, sigma2Bytes, sigma3Bytes])
      );
      const secureSession = await server.sessionManager.createSecureSession({
        sessionId: responderSessionId,
        fabric,
        peerNodeId,
        peerSessionId,
        sharedSecret,
        salt: secureSessionSalt,
        isInitiator: false,
        isResumption: false,
        peerSessionParameters: initiatorSessionParams,
        caseAuthenticatedTags
      });
      logger.info(
        `session ${secureSession.id} created with ${messenger.getChannelName()} for Fabric ${NodeId.toHexString(
          fabric.nodeId
        )}(index ${fabric.fabricIndex}) and PeerNode ${NodeId.toHexString(peerNodeId)}`
      );
      await messenger.sendSuccess();
      const resumptionRecord2 = {
        peerNodeId,
        fabric,
        sharedSecret,
        resumptionId,
        sessionParameters: secureSession.parameters,
        caseAuthenticatedTags
      };
      await messenger.close();
      await server.saveResumptionRecord(resumptionRecord2);
    } else {
      logger.info(
        `Invalid resumption ID or resume MIC received from ${messenger.getChannelName()}`,
        peerResumptionId,
        peerResumeMic
      );
      throw new UnexpectedDataError("Invalid resumption ID or resume MIC.");
    }
  }
  async close() {
  }
}
export {
  CaseServer
};
//# sourceMappingURL=CaseServer.js.map
