/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterFlowError } from "../common/MatterError.js";
import { Crypto } from "../crypto/Crypto.js";
import { NodeId } from "../datatype/NodeId.js";
import { Logger } from "../log/Logger.js";
import { MessageCounter } from "../protocol/MessageCounter.js";
import { AsyncObservable, Observable } from "../util/Observable.js";
import { BasicSet } from "../util/Set.js";
import { InsecureSession } from "./InsecureSession.js";
import { SecureSession } from "./SecureSession.js";
import {
  FALLBACK_DATAMODEL_REVISION,
  FALLBACK_INTERACTIONMODEL_REVISION,
  FALLBACK_MAX_PATHS_PER_INVOKE,
  FALLBACK_SPECIFICATION_VERSION,
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "./Session.js";
const logger = Logger.get("SessionManager");
const UNICAST_UNSECURE_SESSION_ID = 0;
class SessionManager {
  constructor(context, sessionStorage) {
    this.context = context;
    this.#sessionStorage = sessionStorage;
  }
  #insecureSessions = /* @__PURE__ */ new Map();
  #sessions = new BasicSet();
  #nextSessionId = Crypto.getRandomUInt16();
  #resumptionRecords = /* @__PURE__ */ new Map();
  #sessionStorage;
  #globalUnencryptedMessageCounter = new MessageCounter();
  #subscriptionsChanged = Observable();
  #sessionOpened = Observable();
  #sessionClosed = AsyncObservable();
  get subscriptionsChanged() {
    return this.#subscriptionsChanged;
  }
  get sessionOpened() {
    return this.#sessionOpened;
  }
  get sessionClosed() {
    return this.#sessionClosed;
  }
  createUnsecureSession(options) {
    const { initiatorNodeId, sessionParameters, isInitiator } = options;
    if (initiatorNodeId !== void 0) {
      if (this.#insecureSessions.has(initiatorNodeId)) {
        throw new MatterFlowError(`UnsecureSession with NodeId ${initiatorNodeId} already exists.`);
      }
    }
    while (true) {
      const session = new InsecureSession({
        context: this.context,
        messageCounter: this.#globalUnencryptedMessageCounter,
        closeCallback: async () => {
          logger.info(`End insecure session ${session.name}`);
          this.#insecureSessions.delete(session.nodeId);
        },
        initiatorNodeId,
        sessionParameters,
        isInitiator: isInitiator ?? false
      });
      const ephermalNodeId = session.nodeId;
      if (this.#insecureSessions.has(ephermalNodeId)) continue;
      this.#insecureSessions.set(ephermalNodeId, session);
      return session;
    }
  }
  async createSecureSession(args) {
    const {
      sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    } = args;
    const session = await SecureSession.create({
      context: this.context,
      id: sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      closeCallback: async () => {
        logger.info(`End ${session.isPase ? "PASE" : "CASE"} session ${session.name}`);
        this.#sessions.delete(session);
        await this.#sessionClosed.emit(session);
      },
      peerSessionParameters,
      caseAuthenticatedTags,
      subscriptionChangedCallback: () => {
        this.#subscriptionsChanged.emit(session);
      }
    });
    this.#sessions.add(session);
    this.#sessionOpened.emit(session);
    return session;
  }
  removeSession(sessionId) {
    const session = this.getSession(sessionId);
    if (session !== void 0) {
      this.#sessions.delete(session);
    }
  }
  async removeResumptionRecord(peerNodeId) {
    this.#resumptionRecords.delete(peerNodeId);
    await this.storeResumptionRecords();
  }
  findOldestInactiveSession() {
    let oldestSession = void 0;
    for (const session of this.#sessions) {
      if (!oldestSession || session.activeTimestamp < oldestSession.activeTimestamp) {
        oldestSession = session;
      }
    }
    if (oldestSession === void 0) {
      throw new MatterFlowError("No session found to close and all session ids are taken.");
    }
    return oldestSession;
  }
  async getNextAvailableSessionId() {
    for (let i = 0; i < 65535; i++) {
      const id = this.#nextSessionId;
      this.#nextSessionId = this.#nextSessionId + 1 & 65535;
      if (this.#nextSessionId === 0) this.#nextSessionId++;
      if (this.getSession(id) === void 0) {
        return id;
      }
    }
    const oldestSession = this.findOldestInactiveSession();
    await oldestSession.end(true, false);
    this.#nextSessionId = oldestSession.id;
    return this.#nextSessionId++;
  }
  getSession(sessionId) {
    return this.#sessions.get("id", sessionId);
  }
  getPaseSession() {
    return [...this.#sessions].find(
      (session) => session.isSecure && session.isPase && !session.closingAfterExchangeFinished
    );
  }
  getSessionForNode(fabric, nodeId) {
    return [...this.#sessions].find((session) => {
      if (!session.isSecure) return false;
      const secureSession = session;
      return secureSession.fabric?.fabricId === fabric.fabricId && secureSession.peerNodeId === nodeId;
    });
  }
  async removeAllSessionsForNode(nodeId, sendClose = false) {
    for (const session of this.#sessions) {
      if (!session.isSecure) continue;
      const secureSession = session;
      if (secureSession.peerNodeId === nodeId) {
        await secureSession.destroy(sendClose, false);
      }
    }
  }
  getUnsecureSession(sourceNodeId) {
    if (sourceNodeId === void 0) {
      return this.#insecureSessions.get(NodeId.UNSPECIFIED_NODE_ID);
    }
    return this.#insecureSessions.get(sourceNodeId);
  }
  findGroupSession(groupId, groupSessionId) {
    throw new Error(`Not implemented ${groupId} ${groupSessionId}`);
  }
  findResumptionRecordById(resumptionId) {
    return [...this.#resumptionRecords.values()].find((record) => record.resumptionId.equals(resumptionId));
  }
  findResumptionRecordByNodeId(nodeId) {
    return this.#resumptionRecords.get(nodeId);
  }
  async saveResumptionRecord(resumptionRecord) {
    this.#resumptionRecords.set(resumptionRecord.peerNodeId, resumptionRecord);
    await this.storeResumptionRecords();
  }
  async updateFabricForResumptionRecords(fabric) {
    const record = this.#resumptionRecords.get(fabric.rootNodeId);
    if (record === void 0) {
      throw new MatterFlowError("Resumption record not found. Should never happen.");
    }
    this.#resumptionRecords.set(fabric.rootNodeId, { ...record, fabric });
    await this.storeResumptionRecords();
  }
  async storeResumptionRecords() {
    await this.#sessionStorage.set(
      "resumptionRecords",
      [...this.#resumptionRecords].map(
        ([
          nodeId,
          { sharedSecret, resumptionId, peerNodeId, fabric, sessionParameters, caseAuthenticatedTags }
        ]) => ({
          nodeId,
          sharedSecret,
          resumptionId,
          fabricId: fabric.fabricId,
          peerNodeId,
          sessionParameters,
          caseAuthenticatedTags
        })
      )
    );
  }
  async initFromStorage(fabrics) {
    const storedResumptionRecords = await this.#sessionStorage.get(
      "resumptionRecords",
      []
    );
    storedResumptionRecords.forEach(
      ({
        nodeId,
        sharedSecret,
        resumptionId,
        fabricId,
        peerNodeId,
        sessionParameters: {
          idleIntervalMs,
          activeIntervalMs,
          activeThresholdMs,
          dataModelRevision,
          interactionModelRevision,
          specificationVersion,
          maxPathsPerInvoke
        } = {},
        caseAuthenticatedTags
      }) => {
        logger.info("restoring resumption record for node", nodeId);
        const fabric = fabrics.find((fabric2) => fabric2.fabricId === fabricId);
        if (!fabric) {
          logger.error("fabric not found for resumption record", fabricId);
          return;
        }
        this.#resumptionRecords.set(nodeId, {
          sharedSecret,
          resumptionId,
          fabric,
          peerNodeId,
          sessionParameters: {
            // Make sure to initialize default values when restoring an older resumption record
            idleIntervalMs: idleIntervalMs ?? SESSION_IDLE_INTERVAL_MS,
            activeIntervalMs: activeIntervalMs ?? SESSION_ACTIVE_INTERVAL_MS,
            activeThresholdMs: activeThresholdMs ?? SESSION_ACTIVE_THRESHOLD_MS,
            dataModelRevision: dataModelRevision ?? FALLBACK_DATAMODEL_REVISION,
            interactionModelRevision: interactionModelRevision ?? FALLBACK_INTERACTIONMODEL_REVISION,
            specificationVersion: specificationVersion ?? FALLBACK_SPECIFICATION_VERSION,
            maxPathsPerInvoke: maxPathsPerInvoke ?? FALLBACK_MAX_PATHS_PER_INVOKE
          },
          caseAuthenticatedTags
        });
      }
    );
  }
  getActiveSessionInformation() {
    return [...this.#sessions].filter((session) => session.isSecure && !session.isPase).map((session) => ({
      name: session.name,
      nodeId: session.nodeId,
      peerNodeId: session.peerNodeId,
      fabric: session instanceof SecureSession ? session.fabric?.externalInformation : void 0,
      isPeerActive: session.isPeerActive(),
      secure: session.isSecure,
      lastInteractionTimestamp: session instanceof SecureSession ? session.timestamp : void 0,
      lastActiveTimestamp: session instanceof SecureSession ? session.activeTimestamp : void 0,
      numberOfActiveSubscriptions: session instanceof SecureSession ? session.numberOfActiveSubscriptions : 0
    }));
  }
  async clearSubscriptionsForNode(fabricIndex, nodeId, flushSubscriptions) {
    for (const session of this.#sessions) {
      if (session.fabric?.fabricIndex === fabricIndex && session.peerNodeId === nodeId) {
        await session.clearSubscriptions(flushSubscriptions);
      }
    }
  }
  async close() {
    await this.storeResumptionRecords();
    for (const session of this.#sessions) {
      await session?.end(false);
      this.#sessions.delete(session);
    }
    for (const session of this.#insecureSessions.values()) {
      await session?.end();
      this.#insecureSessions.delete(session.nodeId);
    }
  }
}
export {
  SessionManager,
  UNICAST_UNSECURE_SESSION_ID
};
//# sourceMappingURL=SessionManager.js.map
