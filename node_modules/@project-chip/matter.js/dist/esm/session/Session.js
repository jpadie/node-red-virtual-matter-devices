/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Time } from "../time/Time.js";
const SESSION_ACTIVE_INTERVAL_MS = 300;
const SESSION_IDLE_INTERVAL_MS = 500;
const SESSION_ACTIVE_THRESHOLD_MS = 4e3;
const FALLBACK_DATAMODEL_REVISION = 17;
const FALLBACK_INTERACTIONMODEL_REVISION = 11;
const FALLBACK_SPECIFICATION_VERSION = 0;
const FALLBACK_MAX_PATHS_PER_INVOKE = 1;
class Session {
  timestamp = Time.nowMs();
  activeTimestamp = 0;
  idleIntervalMs;
  activeIntervalMs;
  activeThresholdMs;
  dataModelRevision;
  interactionModelRevision;
  specificationVersion;
  maxPathsPerInvoke;
  closeCallback;
  messageCounter;
  messageReceptionState;
  constructor(args) {
    const {
      messageCounter,
      messageReceptionState,
      closeCallback,
      sessionParameters: {
        idleIntervalMs = SESSION_IDLE_INTERVAL_MS,
        activeIntervalMs = SESSION_ACTIVE_INTERVAL_MS,
        activeThresholdMs = SESSION_ACTIVE_THRESHOLD_MS,
        dataModelRevision = FALLBACK_DATAMODEL_REVISION,
        interactionModelRevision = FALLBACK_INTERACTIONMODEL_REVISION,
        specificationVersion = FALLBACK_SPECIFICATION_VERSION,
        maxPathsPerInvoke = FALLBACK_MAX_PATHS_PER_INVOKE
      } = {},
      setActiveTimestamp
    } = args;
    this.messageCounter = messageCounter;
    this.messageReceptionState = messageReceptionState;
    this.closeCallback = closeCallback;
    this.idleIntervalMs = idleIntervalMs;
    this.activeIntervalMs = activeIntervalMs;
    this.activeThresholdMs = activeThresholdMs;
    this.dataModelRevision = dataModelRevision;
    this.interactionModelRevision = interactionModelRevision;
    this.specificationVersion = specificationVersion;
    this.maxPathsPerInvoke = maxPathsPerInvoke;
    if (setActiveTimestamp) {
      this.activeTimestamp = this.timestamp;
    }
  }
  notifyActivity(messageReceived) {
    this.timestamp = Time.nowMs();
    if (messageReceived) {
      this.activeTimestamp = this.timestamp;
    }
  }
  isPeerActive() {
    return Time.nowMs() - this.activeTimestamp < this.activeThresholdMs;
  }
  getIncrementedMessageCounter() {
    return this.messageCounter.getIncrementedCounter();
  }
  updateMessageCounter(messageCounter, _sourceNodeId) {
    this.messageReceptionState.updateMessageCounter(messageCounter);
  }
  get parameters() {
    const {
      idleIntervalMs,
      activeIntervalMs,
      activeThresholdMs,
      dataModelRevision,
      interactionModelRevision,
      specificationVersion,
      maxPathsPerInvoke
    } = this;
    return {
      idleIntervalMs,
      activeIntervalMs,
      activeThresholdMs,
      dataModelRevision,
      interactionModelRevision,
      specificationVersion,
      maxPathsPerInvoke
    };
  }
}
export {
  FALLBACK_DATAMODEL_REVISION,
  FALLBACK_INTERACTIONMODEL_REVISION,
  FALLBACK_MAX_PATHS_PER_INVOKE,
  FALLBACK_SPECIFICATION_VERSION,
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS,
  Session
};
//# sourceMappingURL=Session.js.map
