{
  "version": 3,
  "sources": ["../../../src/session/Session.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DecodedMessage, DecodedPacket, Message, Packet } from \"../codec/MessageCodec.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { MessageCounter } from \"../protocol/MessageCounter.js\";\nimport { MessageReceptionState } from \"../protocol/MessageReceptionState.js\";\nimport { Time } from \"../time/Time.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\n\n/**\n * Minimum amount of time between sender retries when the destination node is Active. This SHALL be greater than or\n * equal to the maximum amount of time a node may be non-responsive to incoming messages when Active.\n */\nexport const SESSION_ACTIVE_INTERVAL_MS = 300;\n\n/**\n * Minimum amount of time between sender retries when the destination node is Idle. This SHALL be greater than or equal\n * to the maximum amount of time a node may be non-responsive to incoming messages when Idle.\n */\nexport const SESSION_IDLE_INTERVAL_MS = 500;\n\n/** Minimum amount of time the node SHOULD stay active after network activity. */\nexport const SESSION_ACTIVE_THRESHOLD_MS = 4000;\n\n/** Fallback value for Data Model Revision when not provided in Session parameters. We use Matter 1.2 as assumption. */\nexport const FALLBACK_DATAMODEL_REVISION = 17;\n\n/** Fallback value for Interaction Model Revision when not provided in Session parameters. We use Matter 1.2 as assumption. */\nexport const FALLBACK_INTERACTIONMODEL_REVISION = 11;\n\n/**\n * Fallback value for Specification Version when not provided in Session parameters. We use 0 as assumption which is\n * \"before 1.3\".\n */\nexport const FALLBACK_SPECIFICATION_VERSION = 0;\n\n/**\n * Fallback value for the maximum number of paths that can be included in a single invoke message when not provided in\n * Session parameters.\n */\nexport const FALLBACK_MAX_PATHS_PER_INVOKE = 1;\n\nexport interface SessionParameters {\n    idleIntervalMs: number;\n    activeIntervalMs: number;\n    activeThresholdMs: number;\n    dataModelRevision: number;\n    interactionModelRevision: number;\n    specificationVersion: number;\n    maxPathsPerInvoke: number;\n}\n\nexport type SessionParameterOptions = Partial<SessionParameters>;\n\nexport abstract class Session<T> {\n    abstract get name(): string;\n    abstract get closingAfterExchangeFinished(): boolean;\n    timestamp = Time.nowMs();\n    activeTimestamp = 0;\n    protected readonly idleIntervalMs: number;\n    protected readonly activeIntervalMs: number;\n    protected readonly activeThresholdMs: number;\n    protected readonly dataModelRevision: number;\n    protected readonly interactionModelRevision: number;\n    protected readonly specificationVersion: number;\n    protected readonly maxPathsPerInvoke: number;\n    protected readonly closeCallback: () => Promise<void>;\n    protected readonly messageCounter: MessageCounter;\n    protected readonly messageReceptionState: MessageReceptionState;\n\n    constructor(args: {\n        messageCounter: MessageCounter;\n        messageReceptionState: MessageReceptionState;\n        closeCallback: () => Promise<void>;\n        sessionParameters?: SessionParameterOptions;\n        setActiveTimestamp: boolean;\n    }) {\n        const {\n            messageCounter,\n            messageReceptionState,\n            closeCallback,\n            sessionParameters: {\n                idleIntervalMs = SESSION_IDLE_INTERVAL_MS,\n                activeIntervalMs = SESSION_ACTIVE_INTERVAL_MS,\n                activeThresholdMs = SESSION_ACTIVE_THRESHOLD_MS,\n                dataModelRevision = FALLBACK_DATAMODEL_REVISION,\n                interactionModelRevision = FALLBACK_INTERACTIONMODEL_REVISION,\n                specificationVersion = FALLBACK_SPECIFICATION_VERSION,\n                maxPathsPerInvoke = FALLBACK_MAX_PATHS_PER_INVOKE,\n            } = {},\n            setActiveTimestamp,\n        } = args;\n        this.messageCounter = messageCounter;\n        this.messageReceptionState = messageReceptionState;\n        this.closeCallback = closeCallback;\n        this.idleIntervalMs = idleIntervalMs;\n        this.activeIntervalMs = activeIntervalMs;\n        this.activeThresholdMs = activeThresholdMs;\n        this.dataModelRevision = dataModelRevision;\n        this.interactionModelRevision = interactionModelRevision;\n        this.specificationVersion = specificationVersion;\n        this.maxPathsPerInvoke = maxPathsPerInvoke;\n        if (setActiveTimestamp) {\n            this.activeTimestamp = this.timestamp;\n        }\n    }\n\n    notifyActivity(messageReceived: boolean) {\n        this.timestamp = Time.nowMs();\n        if (messageReceived) {\n            // only update active timestamp if we received a message\n            this.activeTimestamp = this.timestamp;\n        }\n    }\n\n    isPeerActive(): boolean {\n        return Time.nowMs() - this.activeTimestamp < this.activeThresholdMs;\n    }\n\n    getIncrementedMessageCounter() {\n        return this.messageCounter.getIncrementedCounter();\n    }\n\n    updateMessageCounter(messageCounter: number, _sourceNodeId?: NodeId) {\n        this.messageReceptionState.updateMessageCounter(messageCounter);\n    }\n\n    get parameters(): SessionParameters {\n        const {\n            idleIntervalMs,\n            activeIntervalMs,\n            activeThresholdMs,\n            dataModelRevision,\n            interactionModelRevision,\n            specificationVersion,\n            maxPathsPerInvoke,\n        } = this;\n        return {\n            idleIntervalMs,\n            activeIntervalMs,\n            activeThresholdMs,\n            dataModelRevision,\n            interactionModelRevision,\n            specificationVersion,\n            maxPathsPerInvoke,\n        };\n    }\n\n    abstract isSecure: boolean;\n    abstract isPase: boolean;\n    abstract context: T;\n    abstract id: number;\n    abstract peerSessionId: number;\n    abstract nodeId: NodeId | undefined;\n    abstract peerNodeId: NodeId | undefined;\n    abstract associatedFabric: Fabric;\n    abstract supportsMRP: boolean; // TODO: always false for Group Sessions\n\n    abstract decode(packet: DecodedPacket, aad?: ByteArray): DecodedMessage;\n    abstract encode(message: Message): Packet;\n    abstract end(sendClose: boolean): Promise<void>;\n    abstract destroy(sendClose?: boolean, closeAfterExchangeFinished?: boolean): Promise<void>;\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAWA,SAAS,YAAY;AAOd,MAAM,6BAA6B;AAMnC,MAAM,2BAA2B;AAGjC,MAAM,8BAA8B;AAGpC,MAAM,8BAA8B;AAGpC,MAAM,qCAAqC;AAM3C,MAAM,iCAAiC;AAMvC,MAAM,gCAAgC;AActC,MAAe,QAAW;AAAA,EAG7B,YAAY,KAAK,MAAM;AAAA,EACvB,kBAAkB;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEnB,YAAY,MAMT;AACC,UAAM;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA,mBAAmB;AAAA,QACf,iBAAiB;AAAA,QACjB,mBAAmB;AAAA,QACnB,oBAAoB;AAAA,QACpB,oBAAoB;AAAA,QACpB,2BAA2B;AAAA,QAC3B,uBAAuB;AAAA,QACvB,oBAAoB;AAAA,MACxB,IAAI,CAAC;AAAA,MACL;AAAA,IACJ,IAAI;AACJ,SAAK,iBAAiB;AACtB,SAAK,wBAAwB;AAC7B,SAAK,gBAAgB;AACrB,SAAK,iBAAiB;AACtB,SAAK,mBAAmB;AACxB,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AACzB,SAAK,2BAA2B;AAChC,SAAK,uBAAuB;AAC5B,SAAK,oBAAoB;AACzB,QAAI,oBAAoB;AACpB,WAAK,kBAAkB,KAAK;AAAA,IAChC;AAAA,EACJ;AAAA,EAEA,eAAe,iBAA0B;AACrC,SAAK,YAAY,KAAK,MAAM;AAC5B,QAAI,iBAAiB;AAEjB,WAAK,kBAAkB,KAAK;AAAA,IAChC;AAAA,EACJ;AAAA,EAEA,eAAwB;AACpB,WAAO,KAAK,MAAM,IAAI,KAAK,kBAAkB,KAAK;AAAA,EACtD;AAAA,EAEA,+BAA+B;AAC3B,WAAO,KAAK,eAAe,sBAAsB;AAAA,EACrD;AAAA,EAEA,qBAAqB,gBAAwB,eAAwB;AACjE,SAAK,sBAAsB,qBAAqB,cAAc;AAAA,EAClE;AAAA,EAEA,IAAI,aAAgC;AAChC,UAAM;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAI;AACJ,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAgBJ;",
  "names": []
}
