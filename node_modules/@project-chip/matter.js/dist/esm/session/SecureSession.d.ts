/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { DecodedMessage, DecodedPacket, Message, Packet } from "../codec/MessageCodec.js";
import { CaseAuthenticatedTag } from "../datatype/CaseAuthenticatedTag.js";
import { NodeId } from "../datatype/NodeId.js";
import { Fabric } from "../fabric/Fabric.js";
import { StatusResponseError } from "../protocol/interaction/StatusCode.js";
import { SubscriptionHandler } from "../protocol/interaction/SubscriptionHandler.js";
import { ByteArray } from "../util/ByteArray.js";
import { Session, SessionParameterOptions } from "./Session.js";
export declare class NoAssociatedFabricError extends StatusResponseError {
    constructor(message: string);
}
export declare class SecureSession<T> extends Session<T> {
    #private;
    readonly supportsMRP = true;
    static create<T>(args: {
        context: T;
        id: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        sharedSecret: ByteArray;
        salt: ByteArray;
        isInitiator: boolean;
        isResumption: boolean;
        closeCallback: () => Promise<void>;
        subscriptionChangedCallback?: () => void;
        peerSessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<SecureSession<T>>;
    constructor(args: {
        context: T;
        id: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        decryptKey: ByteArray;
        encryptKey: ByteArray;
        attestationKey: ByteArray;
        closeCallback: () => Promise<void>;
        subscriptionChangedCallback?: () => void;
        sessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
        isInitiator: boolean;
    });
    get caseAuthenticatedTags(): CaseAuthenticatedTag[];
    get closingAfterExchangeFinished(): boolean;
    get sendCloseMessageWhenClosing(): boolean;
    get isSecure(): boolean;
    get isPase(): boolean;
    close(closeAfterExchangeFinished?: boolean): Promise<void>;
    decode({ header, applicationPayload, messageExtension }: DecodedPacket, aad: ByteArray): DecodedMessage;
    encode(message: Message): Packet;
    get attestationChallengeKey(): ByteArray;
    get fabric(): Fabric | undefined;
    addAssociatedFabric(fabric: Fabric): void;
    get id(): number;
    get name(): string;
    get context(): T;
    get peerSessionId(): number;
    get nodeId(): NodeId;
    get peerNodeId(): NodeId;
    get numberOfActiveSubscriptions(): number;
    get associatedFabric(): Fabric;
    addSubscription(subscription: SubscriptionHandler): void;
    removeSubscription(subscriptionId: number): void;
    clearSubscriptions(flushSubscriptions?: boolean): Promise<void>;
    /** Ends a session. Outstanding subscription data will be flushed before the session is destroyed. */
    end(sendClose: boolean, closeAfterExchangeFinished?: boolean): Promise<void>;
    /** Destroys a session. Outstanding subscription data will be discarded. */
    destroy(sendClose?: boolean, closeAfterExchangeFinished?: boolean): Promise<void>;
    private generateNonce;
}
export declare function assertSecureSession<T>(session: Session<T>, errorText?: string): asserts session is SecureSession<T>;
//# sourceMappingURL=SecureSession.d.ts.map