/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CaseAuthenticatedTag } from "../datatype/CaseAuthenticatedTag.js";
import { FabricIndex } from "../datatype/FabricIndex.js";
import { NodeId } from "../datatype/NodeId.js";
import { Fabric } from "../fabric/Fabric.js";
import { StorageContext } from "../storage/StorageContext.js";
import { ByteArray } from "../util/ByteArray.js";
import { AsyncObservable, Observable } from "../util/Observable.js";
import { InsecureSession } from "./InsecureSession.js";
import { SecureSession } from "./SecureSession.js";
import { SessionParameterOptions, SessionParameters } from "./Session.js";
export declare const UNICAST_UNSECURE_SESSION_ID = 0;
export interface ResumptionRecord {
    sharedSecret: ByteArray;
    resumptionId: ByteArray;
    fabric: Fabric;
    peerNodeId: NodeId;
    sessionParameters: SessionParameters;
    caseAuthenticatedTags?: CaseAuthenticatedTag[];
}
export declare class SessionManager<ContextT> {
    #private;
    private readonly context;
    constructor(context: ContextT, sessionStorage: StorageContext);
    get subscriptionsChanged(): Observable<[session: SecureSession<ContextT>], void>;
    get sessionOpened(): Observable<[session: SecureSession<ContextT>], void>;
    get sessionClosed(): AsyncObservable<[session: SecureSession<ContextT>], void>;
    createUnsecureSession(options: {
        initiatorNodeId?: NodeId;
        sessionParameters?: SessionParameterOptions;
        isInitiator?: boolean;
    }): InsecureSession<ContextT>;
    createSecureSession(args: {
        sessionId: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        sharedSecret: ByteArray;
        salt: ByteArray;
        isInitiator: boolean;
        isResumption: boolean;
        peerSessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<SecureSession<ContextT>>;
    removeSession(sessionId: number): void;
    removeResumptionRecord(peerNodeId: NodeId): Promise<void>;
    findOldestInactiveSession(): SecureSession<ContextT>;
    getNextAvailableSessionId(): Promise<number>;
    getSession(sessionId: number): SecureSession<ContextT> | undefined;
    getPaseSession(): SecureSession<ContextT>;
    getSessionForNode(fabric: Fabric, nodeId: NodeId): SecureSession<ContextT> | undefined;
    removeAllSessionsForNode(nodeId: NodeId, sendClose?: boolean): Promise<void>;
    getUnsecureSession(sourceNodeId?: NodeId): InsecureSession<ContextT> | undefined;
    findGroupSession(groupId: number, groupSessionId: number): void;
    findResumptionRecordById(resumptionId: ByteArray): ResumptionRecord | undefined;
    findResumptionRecordByNodeId(nodeId: NodeId): ResumptionRecord | undefined;
    saveResumptionRecord(resumptionRecord: ResumptionRecord): Promise<void>;
    updateFabricForResumptionRecords(fabric: Fabric): Promise<void>;
    storeResumptionRecords(): Promise<void>;
    initFromStorage(fabrics: Fabric[]): Promise<void>;
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("../fabric/Fabric.js").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
    clearSubscriptionsForNode(fabricIndex: FabricIndex, nodeId: NodeId, flushSubscriptions?: boolean): Promise<void>;
    close(): Promise<void>;
}
//# sourceMappingURL=SessionManager.d.ts.map