/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MessageCodec } from "../codec/MessageCodec.js";
import { MatterFlowError } from "../common/MatterError.js";
import { CRYPTO_SYMMETRIC_KEY_LENGTH, Crypto } from "../crypto/Crypto.js";
import { NodeId } from "../datatype/NodeId.js";
import { Diagnostic } from "../log/Diagnostic.js";
import { Logger } from "../log/Logger.js";
import { MessageCounter } from "../protocol/MessageCounter.js";
import { MessageReceptionStateEncryptedWithoutRollover } from "../protocol/MessageReceptionState.js";
import { StatusCode, StatusResponseError } from "../protocol/interaction/StatusCode.js";
import { ByteArray, Endian } from "../util/ByteArray.js";
import { DataWriter } from "../util/DataWriter.js";
import { Session } from "./Session.js";
const logger = Logger.get("SecureSession");
const SESSION_KEYS_INFO = ByteArray.fromString("SessionKeys");
const SESSION_RESUMPTION_KEYS_INFO = ByteArray.fromString("SessionResumptionKeys");
class NoAssociatedFabricError extends StatusResponseError {
  constructor(message) {
    super(message, StatusCode.UnsupportedAccess);
  }
}
class SecureSession extends Session {
  #subscriptions = new Array();
  #closingAfterExchangeFinished = false;
  #sendCloseMessageWhenClosing = true;
  #context;
  #id;
  #fabric;
  #peerNodeId;
  #peerSessionId;
  #decryptKey;
  #encryptKey;
  #attestationKey;
  #subscriptionChangedCallback;
  #caseAuthenticatedTags;
  supportsMRP = true;
  static async create(args) {
    const {
      context,
      id,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      closeCallback,
      peerSessionParameters,
      caseAuthenticatedTags,
      subscriptionChangedCallback
    } = args;
    const keys = await Crypto.hkdf(
      sharedSecret,
      salt,
      isResumption ? SESSION_RESUMPTION_KEYS_INFO : SESSION_KEYS_INFO,
      CRYPTO_SYMMETRIC_KEY_LENGTH * 3
    );
    const decryptKey = isInitiator ? keys.slice(16, 32) : keys.slice(0, 16);
    const encryptKey = isInitiator ? keys.slice(0, 16) : keys.slice(16, 32);
    const attestationKey = keys.slice(32, 48);
    return new SecureSession({
      context,
      id,
      fabric,
      peerNodeId,
      peerSessionId,
      decryptKey,
      encryptKey,
      attestationKey,
      closeCallback,
      subscriptionChangedCallback,
      sessionParameters: peerSessionParameters,
      isInitiator,
      caseAuthenticatedTags
    });
  }
  constructor(args) {
    super({
      ...args,
      setActiveTimestamp: true,
      // We always set the active timestamp for Secure sessions
      // Can be changed to a PersistedMessageCounter if we implement session storage
      messageCounter: new MessageCounter(() => {
        this.end(true, true).catch((error) => logger.error(`Error while closing session: ${error}`));
      }),
      messageReceptionState: new MessageReceptionStateEncryptedWithoutRollover()
    });
    const {
      context,
      id,
      fabric,
      peerNodeId,
      peerSessionId,
      decryptKey,
      encryptKey,
      attestationKey,
      subscriptionChangedCallback = () => {
      },
      caseAuthenticatedTags
    } = args;
    this.#context = context;
    this.#id = id;
    this.#fabric = fabric;
    this.#peerNodeId = peerNodeId;
    this.#peerSessionId = peerSessionId;
    this.#decryptKey = decryptKey;
    this.#encryptKey = encryptKey;
    this.#attestationKey = attestationKey;
    this.#subscriptionChangedCallback = subscriptionChangedCallback;
    this.#caseAuthenticatedTags = caseAuthenticatedTags ?? [];
    fabric?.addSession(this);
    logger.debug(
      `Created secure ${this.isPase ? "PASE" : "CASE"} session for fabric index ${fabric?.fabricIndex}`,
      this.name,
      Diagnostic.dict({
        idleIntervalMs: this.idleIntervalMs,
        activeIntervalMs: this.activeIntervalMs,
        activeThresholdMs: this.activeThresholdMs,
        dataModelRevision: this.dataModelRevision,
        interactionModelRevision: this.interactionModelRevision,
        specificationVersion: this.specificationVersion,
        maxPathsPerInvoke: this.maxPathsPerInvoke
      })
    );
  }
  get caseAuthenticatedTags() {
    return this.#caseAuthenticatedTags;
  }
  get closingAfterExchangeFinished() {
    return this.#closingAfterExchangeFinished;
  }
  get sendCloseMessageWhenClosing() {
    return this.#sendCloseMessageWhenClosing;
  }
  get isSecure() {
    return true;
  }
  get isPase() {
    return this.#peerNodeId === NodeId.UNSPECIFIED_NODE_ID;
  }
  async close(closeAfterExchangeFinished) {
    if (closeAfterExchangeFinished === void 0) {
      closeAfterExchangeFinished = this.isPeerActive();
    }
    await this.end(true, closeAfterExchangeFinished);
  }
  decode({ header, applicationPayload, messageExtension }, aad) {
    if (header.hasMessageExtensions) {
      logger.info(`Message extensions are not supported. Ignoring ${messageExtension?.toHex()}`);
    }
    const nonce = this.generateNonce(header.securityFlags, header.messageId, this.#peerNodeId);
    const message = MessageCodec.decodePayload({
      header,
      applicationPayload: Crypto.decrypt(this.#decryptKey, applicationPayload, nonce, aad)
    });
    if (message.payloadHeader.hasSecuredExtension) {
      logger.info(`Secured extensions are not supported. Ignoring ${message.securityExtension?.toHex()}`);
    }
    return message;
  }
  encode(message) {
    message.packetHeader.sessionId = this.#peerSessionId;
    const { header, applicationPayload } = MessageCodec.encodePayload(message);
    const headerBytes = MessageCodec.encodePacketHeader(message.packetHeader);
    const securityFlags = headerBytes[3];
    const sessionNodeId = this.isPase ? NodeId.UNSPECIFIED_NODE_ID : this.#fabric?.nodeId ?? NodeId.UNSPECIFIED_NODE_ID;
    const nonce = this.generateNonce(securityFlags, header.messageId, sessionNodeId);
    return { header, applicationPayload: Crypto.encrypt(this.#encryptKey, applicationPayload, nonce, headerBytes) };
  }
  get attestationChallengeKey() {
    return this.#attestationKey;
  }
  get fabric() {
    return this.#fabric;
  }
  addAssociatedFabric(fabric) {
    if (this.#fabric !== void 0) {
      throw new MatterFlowError("Session already has an associated Fabric. Cannot change this.");
    }
    this.#fabric = fabric;
  }
  get id() {
    return this.#id;
  }
  get name() {
    return `secure/${this.#id}`;
  }
  get context() {
    return this.#context;
  }
  get peerSessionId() {
    return this.#peerSessionId;
  }
  get nodeId() {
    return this.#fabric?.nodeId ?? NodeId.UNSPECIFIED_NODE_ID;
  }
  get peerNodeId() {
    return this.#peerNodeId;
  }
  get numberOfActiveSubscriptions() {
    return this.#subscriptions.length;
  }
  get associatedFabric() {
    if (this.#fabric === void 0) {
      throw new NoAssociatedFabricError(
        `${this.isPase ? "PASE " : ""}Session needs to have an associated Fabric for fabric sensitive data handling.`
      );
    }
    return this.#fabric;
  }
  addSubscription(subscription) {
    this.#subscriptions.push(subscription);
    logger.debug(`Added subscription ${subscription.subscriptionId} to ${this.name}`);
    this.#subscriptionChangedCallback();
  }
  removeSubscription(subscriptionId) {
    const index = this.#subscriptions.findIndex((subscription) => subscription.subscriptionId === subscriptionId);
    if (index !== -1) {
      this.#subscriptions.splice(index, 1);
      logger.debug(`Removed subscription ${subscriptionId} from ${this.name}`);
      this.#subscriptionChangedCallback();
    }
  }
  async clearSubscriptions(flushSubscriptions = false) {
    const subscriptions = [...this.#subscriptions];
    for (const subscription of subscriptions) {
      await subscription.cancel(flushSubscriptions);
    }
    this.#subscriptions.length = 0;
  }
  /** Ends a session. Outstanding subscription data will be flushed before the session is destroyed. */
  async end(sendClose, closeAfterExchangeFinished = false) {
    await this.clearSubscriptions(true);
    await this.destroy(sendClose, closeAfterExchangeFinished);
  }
  /** Destroys a session. Outstanding subscription data will be discarded. */
  async destroy(sendClose = false, closeAfterExchangeFinished = true) {
    await this.clearSubscriptions(false);
    this.#fabric?.removeSession(this);
    if (!sendClose) {
      this.#sendCloseMessageWhenClosing = false;
    }
    if (closeAfterExchangeFinished) {
      logger.info(`Register Session ${this.name} to send a close when exchange is ended.`);
      this.#closingAfterExchangeFinished = true;
    } else {
      await this.closeCallback();
    }
  }
  generateNonce(securityFlags, messageId, nodeId) {
    const writer = new DataWriter(Endian.Little);
    writer.writeUInt8(securityFlags);
    writer.writeUInt32(messageId);
    writer.writeUInt64(nodeId);
    return writer.toByteArray();
  }
}
function assertSecureSession(session, errorText) {
  if (!session.isSecure) {
    throw new MatterFlowError(errorText ?? "Insecure session in secure context");
  }
}
export {
  NoAssociatedFabricError,
  SecureSession,
  assertSecureSession
};
//# sourceMappingURL=SecureSession.js.map
