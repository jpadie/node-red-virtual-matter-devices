{
  "version": 3,
  "sources": ["../../src/MatterServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CommissioningController } from \"./CommissioningController.js\";\nimport { CommissioningServer } from \"./CommissioningServer.js\";\nimport { MatterNode } from \"./MatterNode.js\";\nimport { Logger } from \"./log/Logger.js\";\nimport { MdnsBroadcaster } from \"./mdns/MdnsBroadcaster.js\";\nimport { MdnsScanner } from \"./mdns/MdnsScanner.js\";\nimport { Network, NetworkError } from \"./net/Network.js\";\nimport { SyncStorage } from \"./storage/Storage.js\";\nimport { StorageManager } from \"./storage/StorageManager.js\";\n\nconst logger = Logger.get(\"MatterServer\");\n\nconst MATTER_PORT = 5540;\n\nexport type NodeOptions = {\n    /** Unique storage key for this node to use for the storage context of this node. If not provided the order of node addition is used. */\n    uniqueStorageKey?: string;\n\n    /**\n     * Deprecated name for uniqueStorageKey\n     * TODO: Remove with 0.8 or such\n     * @deprecated\n     */\n    uniqueNodeId?: string;\n};\n\nexport type MatterServerOptions = {\n    /** If set to true no IPv4 socket listener is sed and only IPv6 is supported. */\n    disableIpv4?: boolean;\n\n    /**\n     * Interface to use for MDNS announcements. If not provided announcements will be sent from all network interfaces\n     * TODO: Remove in later versions then 0.7\n     * @deprecated\n     */\n    mdnsAnnounceInterface?: string;\n\n    /**\n     * Interface to use for MDNS announcements and scanning. If not provided announcements/scanning will be done on all\n     * network interfaces\n     */\n    mdnsInterface?: string;\n};\n\n/**\n * Main Matter server class that represents the process on the host allowing to commission and pair multiple devices\n * by reusing MDNS scanner and broadcaster\n */\nexport class MatterServer {\n    private started = false;\n    private readonly nodes = new Map<string, MatterNode>();\n\n    private mdnsScanner?: MdnsScanner;\n    private mdnsBroadcaster?: MdnsBroadcaster;\n\n    private readonly formerlyUsedPorts = new Array<number>();\n\n    /**\n     * Create a new Matter server instance\n     *\n     * @param storageManager Storage manager instance to use for all nodes\n     * @param options Optional MatterServer options\n     */\n    constructor(\n        private readonly storageManager: StorageManager<SyncStorage>,\n        private readonly options?: MatterServerOptions,\n    ) {}\n\n    get ipv4Disabled() {\n        return !!this.options?.disableIpv4;\n    }\n\n    private getNextMatterPort(desiredPort?: number) {\n        // Build a temporary map with all ports in use\n        const portCheckMap = new Map<number, boolean>();\n        for (const node of this.nodes.values()) {\n            const nodePort = node.getPort();\n            if (nodePort === undefined) continue;\n            if (portCheckMap.has(nodePort)) {\n                throw new NetworkError(`Port ${nodePort} is already in use by other node.`);\n            }\n            portCheckMap.set(nodePort, true);\n        }\n\n        if (desiredPort !== undefined) {\n            if (portCheckMap.has(desiredPort)) {\n                throw new NetworkError(`Port ${desiredPort} is already in use by other node.`);\n            }\n            return desiredPort;\n        }\n\n        // Try to find a free port with consideration of currently blocked ports, we start at the matter default port\n        let portToCheck = MATTER_PORT;\n        while ((portCheckMap.has(portToCheck) || this.formerlyUsedPorts.includes(portToCheck)) && portToCheck < 65536) {\n            portToCheck++;\n        }\n        // If we did not find an available port, check the oldest blocked ones\n        if (portToCheck === 65536) {\n            for (let i = 0; i < this.formerlyUsedPorts.length; i++) {\n                const port = this.formerlyUsedPorts[i];\n                this.formerlyUsedPorts.splice(i, 1); // Irrelevant of next check result, remove from blocked ports\n                if (!portCheckMap.has(port)) {\n                    // Should normally be always the case, but lets make sure\n                    portToCheck = port;\n                    break;\n                }\n            }\n            if (portToCheck === 65536) {\n                throw new NetworkError(\"No free port available for Matter server.\");\n            }\n        }\n\n        return portToCheck;\n    }\n\n    /**\n     * Add a CommissioningServer node to the server\n     *\n     * @param commissioningServer CommissioningServer node to add\n     * @param nodeOptions Optional options for the node (e.g. unique node id)\n     */\n    async addCommissioningServer(commissioningServer: CommissioningServer, nodeOptions?: NodeOptions) {\n        const storageKey = nodeOptions?.uniqueStorageKey ?? nodeOptions?.uniqueNodeId ?? this.nodes.size.toString();\n        if (this.nodes.has(storageKey)) {\n            throw new Error(`Node with storage key \"${storageKey}\" already exists.`);\n        }\n        commissioningServer.setPort(this.getNextMatterPort(commissioningServer.getPort()));\n        await commissioningServer.setStorage(this.storageManager.createContext(storageKey));\n        logger.debug(`Adding CommissioningServer using storage key \"${storageKey}\".`);\n        await this.prepareNode(commissioningServer);\n        this.nodes.set(storageKey, commissioningServer);\n    }\n\n    /**\n     * Remove a CommissioningServer node from the server, close the CommissioningServer and optionally destroy the\n     * storage context.\n     *\n     * @param commissioningServer CommissioningServer node to remove\n     * @param destroyStorage If true the storage context will be destroyed\n     */\n    async removeCommissioningServer(commissioningServer: CommissioningServer, destroyStorage = false) {\n        // Find instance from list\n        for (const [key, value] of this.nodes.entries()) {\n            if (value === commissioningServer) {\n                this.nodes.delete(key);\n\n                const port = commissioningServer.getPort();\n                if (port !== undefined) {\n                    // Remember port to not reuse for this run if not needed to prevent issues with controllers\n                    this.formerlyUsedPorts.push(port);\n                }\n\n                // Close instance\n                await commissioningServer.close();\n\n                if (destroyStorage) {\n                    // Destroy storage\n                    await commissioningServer.factoryReset();\n                }\n                return;\n            }\n        }\n\n        throw new Error(\"CommissioningServer to remove not found.\");\n    }\n\n    /**\n     * Add a Controller node to the server\n     *\n     * @param commissioningController Controller node to add\n     * @param nodeOptions Optional options for the node (e.g. unique node id)\n     */\n    async addCommissioningController(commissioningController: CommissioningController, nodeOptions?: NodeOptions) {\n        const storageKey = nodeOptions?.uniqueStorageKey ?? nodeOptions?.uniqueNodeId ?? this.nodes.size.toString();\n        if (this.nodes.has(storageKey)) {\n            throw new Error(`Node with storage key \"${storageKey}\" already exists.`);\n        }\n\n        const localPort = commissioningController.getPort();\n        if (localPort !== undefined) {\n            // If a local port for controller is defined verify that the port is not overlapping with other nodes\n            // Method throws if port is already used\n            this.getNextMatterPort(localPort);\n        }\n        commissioningController.setStorage(this.storageManager.createContext(storageKey));\n        logger.debug(`Adding CommissioningController using storage key \"${storageKey}\".`);\n        await this.prepareNode(commissioningController);\n        this.nodes.set(storageKey, commissioningController);\n    }\n\n    /**\n     * Remove a Controller node from the server, close the Controller and optionally destroy the storage context.\n     *\n     * @param commissioningController Controller node to remove\n     * @param destroyStorage If true the storage context will be destroyed\n     */\n    async removeCommissioningController(commissioningController: CommissioningController, destroyStorage = false) {\n        // Find instance from list\n        for (const [key, value] of this.nodes.entries()) {\n            if (value === commissioningController) {\n                this.nodes.delete(key);\n\n                // Close instance\n                await commissioningController.close();\n\n                if (destroyStorage) {\n                    // Destroy storage\n                    await commissioningController.resetStorage();\n                }\n                return;\n            }\n        }\n\n        throw new Error(\"CommissioningController to remove not found.\");\n    }\n\n    /**\n     * Start the server and all nodes. If the nodes do not have specified a delayed announcement or pairing they will\n     * be announced/paired immediately.\n     */\n    async start() {\n        if (this.mdnsBroadcaster === undefined) {\n            this.mdnsBroadcaster = await MdnsBroadcaster.create(Network.get(), {\n                enableIpv4: !this.ipv4Disabled,\n                multicastInterface: this.options?.mdnsInterface ?? this.options?.mdnsAnnounceInterface,\n            });\n        }\n        if (this.mdnsScanner === undefined) {\n            this.mdnsScanner = await MdnsScanner.create(Network.get(), {\n                enableIpv4: !this.ipv4Disabled,\n                netInterface: this.options?.mdnsInterface,\n            });\n        }\n        this.started = true;\n        for (const [key, node] of this.nodes.entries()) {\n            try {\n                await this.prepareNode(node);\n            } catch (error: any) {\n                // TODO: Find a better way how to report back such issues and which nodes errored\n                logger.error(`Failed to start node with storageKey ${key}:`, error);\n            }\n        }\n    }\n\n    private async prepareNode(node: MatterNode) {\n        node.initialize(this.ipv4Disabled);\n        if (this.mdnsBroadcaster === undefined || this.mdnsScanner === undefined) {\n            logger.debug(\"Mdns instances not yet created, delaying node preparation.\");\n            return;\n        }\n        node.setMdnsBroadcaster(this.mdnsBroadcaster);\n        node.setMdnsScanner(this.mdnsScanner);\n        if (this.started) {\n            await node.start();\n        }\n    }\n\n    /**\n     * Close the server and all nodes\n     */\n    async close() {\n        for (const [key, node] of this.nodes.entries()) {\n            try {\n                await node.close();\n            } catch (error) {\n                logger.error(`Failed to close node with storageKey ${key}: ${error}`);\n            }\n        }\n        await this.mdnsBroadcaster?.close();\n        this.mdnsBroadcaster = undefined;\n        await this.mdnsScanner?.close();\n        this.mdnsScanner = undefined;\n        this.started = false;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
