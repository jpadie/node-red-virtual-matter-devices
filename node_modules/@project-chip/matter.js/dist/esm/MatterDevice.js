/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  DEVICE_ANNOUNCEMENT_DURATION_MS,
  DEVICE_ANNOUNCEMENT_INTERVAL_MS
} from "./behavior/definitions/administrator-commissioning/AdministratorCommissioningConstants.js";
import { AdministratorCommissioning } from "./cluster/definitions/AdministratorCommissioningCluster.js";
import { Lifecycle } from "./common/Lifecycle.js";
import { InternalError, MatterFlowError } from "./common/MatterError.js";
import { Crypto } from "./crypto/Crypto.js";
import { FabricAction, FabricManager } from "./fabric/FabricManager.js";
import { Diagnostic } from "./log/Diagnostic.js";
import { Logger } from "./log/Logger.js";
import { Specification } from "./model/index.js";
import { isNetworkInterface } from "./net/NetInterface.js";
import { NetworkError } from "./net/Network.js";
import { ChannelManager } from "./protocol/ChannelManager.js";
import { ExchangeManager } from "./protocol/ExchangeManager.js";
import { DEFAULT_MAX_PATHS_PER_INVOKE } from "./protocol/interaction/InteractionServer.js";
import { StatusCode, StatusResponseError } from "./protocol/interaction/StatusCode.js";
import { SecureChannelProtocol } from "./protocol/securechannel/SecureChannelProtocol.js";
import {
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "./session/Session.js";
import { SessionManager } from "./session/SessionManager.js";
import { PaseServer } from "./session/pase/PaseServer.js";
import { Time } from "./time/Time.js";
import { Construction, asyncNew } from "./util/Construction.js";
import { Mutex } from "./util/Mutex.js";
const logger = Logger.get("MatterDevice");
class MatterDevice {
  constructor(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode, commissioningChangedCallback, sessionChangedCallback, sessionParameters = {}) {
    this.sessionStorage = sessionStorage;
    this.fabricStorage = fabricStorage;
    this.getCommissioningConfig = getCommissioningConfig;
    this.commissioningChangedCallback = commissioningChangedCallback;
    this.sessionChangedCallback = sessionChangedCallback;
    this.sessionParameters = {
      idleIntervalMs: SESSION_IDLE_INTERVAL_MS,
      activeIntervalMs: SESSION_ACTIVE_INTERVAL_MS,
      activeThresholdMs: SESSION_ACTIVE_THRESHOLD_MS,
      dataModelRevision: Specification.DATA_MODEL_REVISION,
      interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
      specificationVersion: Specification.SPECIFICATION_VERSION,
      maxPathsPerInvoke: DEFAULT_MAX_PATHS_PER_INVOKE,
      ...sessionParameters
    };
    this.channelManager = new ChannelManager(minimumCaseSessionsPerFabricAndNode);
    this.#fabricManager = new FabricManager(fabricStorage);
    this.#fabricManager.events.deleted.on(async (fabric) => {
      const { fabricIndex, rootNodeId } = fabric;
      await this.#sessionManager.removeResumptionRecord(rootNodeId);
      this.commissioningChangedCallback(fabricIndex, FabricAction.Removed);
      if (this.#fabricManager.getFabrics().length === 0) {
        await this.expireAllFabricAnnouncements();
      }
      this.reAnnounceAsCommissionable();
    });
    this.#fabricManager.events.updated.on(
      ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, FabricAction.Updated)
    );
    this.#sessionManager = new SessionManager(this, sessionStorage);
    this.#exchangeManager = new ExchangeManager(this.#sessionManager, this.channelManager);
    this.addProtocolHandler(this.secureChannelProtocol);
    this.announceInterval = Time.getPeriodicTimer(
      "Server node announcement",
      DEVICE_ANNOUNCEMENT_INTERVAL_MS,
      () => (
        // Announcement needs to await a previous announcement because otherwise in testing at least announcement
        // may crash if started simultaneously
        this.#announcementMutex.run(() => this.announce())
      )
    );
    this.#sessionManager.sessionOpened.on((session) => {
      if (session.fabric) {
        this.sessionChangedCallback(session.fabric.fabricIndex);
      }
    });
    this.#sessionManager.sessionClosed.on(async (session) => {
      if (!session.closingAfterExchangeFinished) {
        await this.exchangeManager.closeSession(session);
      }
      const currentFabricIndex = session.fabric?.fabricIndex;
      if (currentFabricIndex !== void 0) {
        this.sessionChangedCallback(currentFabricIndex);
      }
      if (this.isClosing) {
        return;
      }
      const existingSessionFabric = currentFabricIndex === void 0 ? void 0 : this.getFabricByIndex(currentFabricIndex)?.fabricIndex;
      if (this.#fabricManager.getFabrics().length > 0 || session.isPase || !existingSessionFabric) {
        this.startAnnouncement().catch((error) => logger.warn(`Error while announcing`, error));
      }
    });
    this.#sessionManager.subscriptionsChanged.on((session) => {
      const currentFabric = session.fabric;
      if (currentFabric !== void 0) {
        this.sessionChangedCallback(currentFabric.fabricIndex);
      }
    });
    this.#construction = Construction(this, async () => {
      await this.#fabricManager.initFromStorage();
      this.#fabricManager.events.added.on(
        ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, FabricAction.Added)
      );
      await this.#sessionManager.initFromStorage(this.#fabricManager.getFabrics());
    });
  }
  scanners = new Array();
  broadcasters = new Array();
  transportInterfaces = new Array();
  channelManager;
  secureChannelProtocol = new SecureChannelProtocol(() => this.endCommissioning());
  activeCommissioningMode = AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
  activeCommissioningDiscriminator;
  activeCommissioningEndCallback;
  announceInterval;
  announcementStartedTime = null;
  #isClosing = false;
  #exchangeManager;
  #fabricManager;
  #sessionManager;
  #failsafeContext;
  sessionParameters;
  // Currently we do not put much effort into synchronizing announcements as it probably isn't really necessary.  But
  // this mutex prevents automated announcements from piling up and allows us to ensure announcements are complete
  // on close
  #announcementMutex = new Mutex(this);
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode = 3, commissioningChangedCallback, sessionChangedCallback, sessionParameters) {
    return asyncNew(
      MatterDevice,
      sessionStorage,
      fabricStorage,
      getCommissioningConfig,
      minimumCaseSessionsPerFabricAndNode,
      commissioningChangedCallback,
      sessionChangedCallback,
      sessionParameters
    );
  }
  get fabricManager() {
    return this.#fabricManager;
  }
  get sessionManager() {
    return this.#sessionManager;
  }
  get exchangeManager() {
    return this.#exchangeManager;
  }
  get failsafeContext() {
    this.assertFailSafeArmed();
    return this.#failsafeContext;
  }
  get isClosing() {
    return this.#isClosing;
  }
  async beginTimed(failsafeContext) {
    await failsafeContext.construction;
    this.#failsafeContext = failsafeContext;
    this.#fabricManager.events.added.on((fabric) => {
      const fabrics = this.#fabricManager.getFabrics();
      this.sendFabricAnnouncements(fabrics, true).catch(
        (error) => logger.warn(`Error sending Fabric announcement for Index ${fabric.fabricIndex}`, error)
      );
      logger.info("Announce done", Diagnostic.dict({ fabric: fabric.fabricId, fabricIndex: fabric.fabricIndex }));
    });
    failsafeContext.commissioned.on(async () => await this.endCommissioning());
    failsafeContext.construction.change.on((status) => {
      if (status === Lifecycle.Status.Destroyed) {
        this.#failsafeContext = void 0;
      }
    });
  }
  assertFailSafeArmed(message) {
    if (this.isFailsafeArmed()) return;
    throw new StatusResponseError(
      message ?? "Failsafe timer needs to be armed to execute this action.",
      StatusCode.FailsafeRequired
    );
  }
  isFailsafeArmed() {
    return this.#failsafeContext !== void 0;
  }
  addScanner(scanner) {
    this.scanners.push(scanner);
    return this;
  }
  hasBroadcaster(broadcaster) {
    return this.broadcasters.includes(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.broadcasters.push(broadcaster);
    return this;
  }
  async deleteBroadcaster(broadcaster) {
    const pos = this.broadcasters.findIndex((b) => b === broadcaster);
    if (pos !== -1) {
      this.broadcasters.splice(pos, 1);
      await broadcaster.expireAllAnnouncements();
    }
  }
  addTransportInterface(transport) {
    this.exchangeManager.addTransportInterface(transport);
    this.transportInterfaces.push(transport);
    return this;
  }
  async deleteTransportInterface(transport) {
    const pos = this.transportInterfaces.findIndex((t) => t === transport);
    if (pos !== -1) {
      this.transportInterfaces.splice(pos, 1);
      await transport.close();
    }
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  addProtocolHandler(protocol) {
    this.exchangeManager.addProtocolHandler(protocol);
    return this;
  }
  async start() {
    await this.startAnnouncement();
  }
  async startAnnouncement() {
    if (this.isClosing) return;
    if (this.announceInterval.isRunning) {
      this.announceInterval.stop();
    }
    this.announcementStartedTime = Time.nowMs();
    this.announceInterval.start();
    await this.announce();
  }
  async expireAllFabricAnnouncements() {
    for (const broadcaster of this.broadcasters) {
      await broadcaster.expireFabricAnnouncement();
    }
  }
  async announce(announceOnce = false) {
    if (!announceOnce) {
      if (this.announcementStartedTime !== null && Time.nowMs() - this.announcementStartedTime > DEVICE_ANNOUNCEMENT_DURATION_MS) {
        await this.endCommissioning();
        logger.debug("Announcement duration reached, stop announcing");
        return;
      }
      if (this.activeCommissioningMode !== AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
        for (const broadcaster of this.broadcasters) {
          await broadcaster.announce();
        }
        return;
      }
    }
    const fabrics = this.#fabricManager.getFabrics();
    if (fabrics.length) {
      let fabricsWithoutSessions = 0;
      for (const fabric of fabrics) {
        const session = this.#sessionManager.getSessionForNode(fabric, fabric.rootNodeId);
        if (session === void 0 || !session.isSecure || session.numberOfActiveSubscriptions === 0) {
          fabricsWithoutSessions++;
          logger.debug("Announcing", Diagnostic.dict({ fabric: fabric.fabricId }));
        }
      }
      for (const broadcaster of this.broadcasters) {
        await broadcaster.setFabrics(fabrics);
        if (fabricsWithoutSessions > 0 || this.activeCommissioningMode !== AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
          await broadcaster.announce();
        }
      }
    } else {
      await this.expireAllFabricAnnouncements();
      await this.allowBasicCommissioning();
    }
  }
  async announceAsCommissionable(mode, activeCommissioningEndCallback, discriminator) {
    if (this.activeCommissioningMode === mode && (discriminator === void 0 || discriminator === this.activeCommissioningDiscriminator)) {
      return this.reAnnounceAsCommissionable();
    }
    if (this.activeCommissioningMode !== AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      throw new InternalError(
        `Commissioning window already open with different mode (${this.activeCommissioningMode})!`
      );
    }
    if (this.activeCommissioningEndCallback !== void 0) {
      throw new InternalError("Commissioning window already open with different callback!");
    }
    this.activeCommissioningMode = mode;
    this.activeCommissioningDiscriminator = discriminator;
    if (activeCommissioningEndCallback !== void 0) {
      this.activeCommissioningEndCallback = activeCommissioningEndCallback;
    }
    this.sendCommissionableAnnouncement(mode, discriminator).catch(
      (error) => logger.warn("Error sending announcement:", error)
    );
  }
  reAnnounceAsCommissionable() {
    if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      return;
    }
    this.sendCommissionableAnnouncement(this.activeCommissioningMode, this.activeCommissioningDiscriminator).catch(
      (error) => logger.warn("Error sending announcement:", error)
    );
  }
  async sendCommissionableAnnouncement(mode, discriminator) {
    const commissioningConfig = this.getCommissioningConfig();
    for (const broadcaster of this.broadcasters) {
      await broadcaster.setCommissionMode(
        mode === AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen ? 2 : 1,
        {
          ...commissioningConfig.productDescription,
          discriminator: discriminator ?? commissioningConfig.discriminator
        }
      );
    }
    await this.startAnnouncement();
  }
  async getNextAvailableSessionId() {
    return this.#sessionManager.getNextAvailableSessionId();
  }
  findFabricFromDestinationId(destinationId, peerRandom) {
    return this.#fabricManager.findFabricFromDestinationId(destinationId, peerRandom);
  }
  async sendFabricAnnouncements(fabrics, expireCommissioningAnnouncement = false) {
    for (const broadcaster of this.broadcasters) {
      await broadcaster.setFabrics(fabrics, expireCommissioningAnnouncement);
      await broadcaster.announce();
    }
  }
  getFabricByIndex(fabricIndex) {
    return this.#fabricManager.getFabrics().find((fabric) => fabric.fabricIndex === fabricIndex);
  }
  initiateExchange(fabric, nodeId, protocolId) {
    return this.exchangeManager.initiateExchange(fabric, nodeId, protocolId);
  }
  findResumptionRecordById(resumptionId) {
    return this.#sessionManager.findResumptionRecordById(resumptionId);
  }
  async saveResumptionRecord(resumptionRecord) {
    return this.#sessionManager.saveResumptionRecord(resumptionRecord);
  }
  getFabrics() {
    return this.#fabricManager.getFabrics();
  }
  isCommissioned() {
    return !!this.#fabricManager.getFabrics().length;
  }
  async allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback) {
    if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen) {
      throw new MatterFlowError(
        "Basic commissioning window is already open! Cannot set Enhanced commissioning mode."
      );
    }
    this.secureChannelProtocol.setPaseCommissioner(paseServer);
    await this.announceAsCommissionable(
      AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen,
      commissioningEndCallback,
      discriminator
    );
  }
  async allowBasicCommissioning(commissioningEndCallback) {
    if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen) {
      throw new MatterFlowError(
        "Enhanced commissioning window is already open! Cannot set Basic commissioning mode."
      );
    }
    this.secureChannelProtocol.setPaseCommissioner(
      await PaseServer.fromPin(this.getCommissioningConfig().passcode, {
        iterations: 1e3,
        salt: Crypto.get().getRandomData(32)
      })
    );
    await this.announceAsCommissionable(
      AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen,
      commissioningEndCallback
    );
  }
  async endCommissioning() {
    logger.debug("Commissioning mode ended, stop announcements.");
    if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen || this.isCommissioned()) {
      this.secureChannelProtocol.removePaseCommissioner();
    }
    this.activeCommissioningMode = AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
    this.announceInterval.stop();
    this.announcementStartedTime = null;
    if (this.activeCommissioningEndCallback !== void 0) {
      const activeCommissioningEndCallback = this.activeCommissioningEndCallback;
      this.activeCommissioningEndCallback = void 0;
      activeCommissioningEndCallback();
    }
    for (const broadcaster of this.broadcasters) {
      await broadcaster.expireCommissioningAnnouncement();
    }
    logger.info("All announcements expired");
  }
  existsOpenPaseSession() {
    return !!this.#sessionManager.getPaseSession();
  }
  async findDevice(fabric, nodeId, timeOutSeconds = 5) {
    const device = await this.scanners[0].findOperationalDevice(fabric, nodeId, timeOutSeconds);
    if (device === void 0) return void 0;
    const session = this.#sessionManager.getSessionForNode(fabric, nodeId);
    if (session === void 0) return void 0;
    const networkInterface = this.transportInterfaces.find((netInterface) => isNetworkInterface(netInterface));
    if (networkInterface === void 0 || !isNetworkInterface(networkInterface)) {
      throw new NetworkError("No network interface found");
    }
    return { session, channel: await networkInterface.openChannel(device.addresses[0]) };
  }
  async clearSubscriptionsForNode(fabricIndex, peerNodeId, flushSubscriptions) {
    await this.#sessionManager.clearSubscriptionsForNode(fabricIndex, peerNodeId, flushSubscriptions);
  }
  async close() {
    this.#isClosing = true;
    await this.endCommissioning();
    await this.#announcementMutex;
    for (const broadcaster of this.broadcasters) {
      await broadcaster.close();
    }
    if (this.#failsafeContext) {
      await this.#failsafeContext.close();
      this.#failsafeContext = void 0;
    }
    await this.exchangeManager.close();
    await this.#sessionManager.close();
    await this.channelManager.close();
    for (const transportInterface of this.transportInterfaces) {
      await transportInterface.close();
    }
  }
  getActiveSessionInformation() {
    return this.#sessionManager.getActiveSessionInformation();
  }
}
export {
  MatterDevice
};
//# sourceMappingURL=MatterDevice.js.map
