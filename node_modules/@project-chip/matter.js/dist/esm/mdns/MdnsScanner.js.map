{
  "version": 3,
  "sources": ["../../../src/mdns/MdnsScanner.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    DnsCodec,\n    DnsMessagePartiallyPreEncoded,\n    DnsMessageType,\n    DnsQuery,\n    DnsRecord,\n    DnsRecordClass,\n    DnsRecordType,\n    MAX_MDNS_MESSAGE_SIZE,\n    SrvRecordValue,\n} from \"../codec/DnsCodec.js\";\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport {\n    CommissionableDevice,\n    CommissionableDeviceIdentifiers,\n    DiscoveryData,\n    OperationalDevice,\n    Scanner,\n} from \"../common/Scanner.js\";\nimport { ServerAddress, ServerAddressIp } from \"../common/ServerAddress.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { VendorId } from \"../datatype/VendorId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { Network } from \"../net/Network.js\";\nimport { UdpMulticastServer } from \"../net/UdpMulticastServer.js\";\nimport { Time, Timer } from \"../time/Time.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { isIPv6 } from \"../util/Ip.js\";\nimport { createPromise } from \"../util/Promises.js\";\nimport {\n    MATTER_COMMISSION_SERVICE_QNAME,\n    MATTER_SERVICE_QNAME,\n    getCommissioningModeQname,\n    getDeviceInstanceQname,\n    getDeviceMatterQname,\n    getDeviceTypeQname,\n    getLongDiscriminatorQname,\n    getShortDiscriminatorQname,\n    getVendorQname,\n} from \"./MdnsConsts.js\";\nimport { MDNS_BROADCAST_IPV4, MDNS_BROADCAST_IPV6, MDNS_BROADCAST_PORT } from \"./MdnsServer.js\";\n\nconst logger = Logger.get(\"MdnsScanner\");\n\ntype MatterServerRecordWithExpire = ServerAddressIp & {\n    expires: number;\n};\n\ntype CommissionableDeviceRecordWithExpire = Omit<CommissionableDevice, \"addresses\"> & {\n    expires: number;\n    addresses: Map<string, MatterServerRecordWithExpire>; // Override addresses type to include expiration\n    instanceId: string; // instance ID\n    SD: number; // Additional Field for Short discriminator\n    V?: number; // Additional Field for Vendor ID\n    P?: number; // Additional Field for Product ID\n};\n\ntype OperationalDeviceRecordWithExpire = Omit<OperationalDevice, \"addresses\"> & {\n    expires: number;\n    addresses: Map<string, MatterServerRecordWithExpire>; // Override addresses type to include expiration\n};\n\n/** The initial number of seconds between two announcements. MDNS specs require 1-2 seconds, so lets use the middle. */\nconst START_ANNOUNCE_INTERVAL_SECONDS = 1.5;\n\n/**\n * This class implements the Scanner interface for a MDNS scanner via UDP messages in a IP based network.\n * It sends out queries to discover various types of Matter device types and listens for announcements.\n */\nexport class MdnsScanner implements Scanner {\n    static async create(network: Network, options?: { enableIpv4?: boolean; netInterface?: string }) {\n        const { enableIpv4, netInterface } = options ?? {};\n        return new MdnsScanner(\n            await UdpMulticastServer.create({\n                network,\n                netInterface: netInterface,\n                broadcastAddressIpv4: enableIpv4 ? MDNS_BROADCAST_IPV4 : undefined,\n                broadcastAddressIpv6: MDNS_BROADCAST_IPV6,\n                listeningPort: MDNS_BROADCAST_PORT,\n            }),\n            enableIpv4,\n        );\n    }\n\n    readonly #activeAnnounceQueries = new Map<string, { queries: DnsQuery[]; answers: DnsRecord<any>[] }>();\n    #queryTimer?: Timer;\n    #nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;\n\n    readonly #operationalDeviceRecords = new Map<string, OperationalDeviceRecordWithExpire>();\n    readonly #commissionableDeviceRecords = new Map<string, CommissionableDeviceRecordWithExpire>();\n    readonly #recordWaiters = new Map<\n        string,\n        {\n            resolver: () => void;\n            timer?: Timer;\n            resolveOnUpdatedRecords: boolean;\n        }\n    >();\n    readonly #periodicTimer: Timer;\n    #closing = false;\n\n    readonly #multicastServer: UdpMulticastServer;\n    readonly #enableIpv4?: boolean;\n\n    constructor(multicastServer: UdpMulticastServer, enableIpv4?: boolean) {\n        multicastServer.onMessage((message, remoteIp, netInterface) =>\n            this.#handleDnsMessage(message, remoteIp, netInterface),\n        );\n        this.#multicastServer = multicastServer;\n        this.#enableIpv4 = enableIpv4;\n        this.#periodicTimer = Time.getPeriodicTimer(\"Discovered node expiration\", 60 * 1000 /* 1 mn */, () =>\n            this.#expire(),\n        ).start();\n    }\n\n    /**\n     * Sends out one DNS-SD query for all collected announce records and start a timer for the next query with doubled\n     * interval, maximum 60min, as per MDNS specs. The already known answers are tried to be sent in the query as long\n     * as they fit into a maximum 1500 byte long packet (as defined in MDNS specs), else they are split into more\n     * packets and the query is sent as Truncated query.\n     */\n    async #sendQueries() {\n        this.#queryTimer?.stop();\n        const allQueries = Array.from(this.#activeAnnounceQueries.values());\n        const queries = allQueries.flatMap(({ queries }) => queries);\n        const answers = allQueries.flatMap(({ answers }) => answers);\n\n        this.#queryTimer = Time.getTimer(\"MDNS discovery\", this.#nextAnnounceIntervalSeconds * 1000, () =>\n            this.#sendQueries(),\n        ).start();\n\n        logger.debug(\n            `Sending ${queries.length} query records for ${this.#activeAnnounceQueries.size} queries with ${answers.length} known answers. Re-Announce in ${this.#nextAnnounceIntervalSeconds} seconds`,\n        );\n\n        const nextAnnounceInterval = this.#nextAnnounceIntervalSeconds * 2;\n        this.#nextAnnounceIntervalSeconds = Math.min(nextAnnounceInterval, 60 * 60 /* 1 hour */);\n\n        const answersToSend = [...answers];\n\n        const dnsMessageDataToSend = {\n            messageType: DnsMessageType.TruncatedQuery,\n            transactionId: 0,\n            queries,\n            authorities: [],\n            answers: [],\n            additionalRecords: [],\n        } as DnsMessagePartiallyPreEncoded;\n\n        const emptyDnsMessage = DnsCodec.encode(dnsMessageDataToSend);\n        let dnsMessageSize = emptyDnsMessage.length;\n\n        while (true) {\n            if (answersToSend.length > 0) {\n                const nextAnswer = answersToSend.shift();\n                if (nextAnswer === undefined) {\n                    break;\n                }\n\n                const nextAnswerEncoded = DnsCodec.encodeRecord(nextAnswer);\n                dnsMessageSize += nextAnswerEncoded.length; // Add additional record as long as size is ok\n\n                if (dnsMessageSize > MAX_MDNS_MESSAGE_SIZE) {\n                    if (dnsMessageDataToSend.answers.length === 0) {\n                        // The first answer is already too big, log at least a warning\n                        logger.warn(\n                            `MDNS Query with ${Logger.toJSON(\n                                queries,\n                            )} is too big to fit into a single MDNS message. Send anyway, but please report!`,\n                        );\n                    }\n                    // New answer do not fit anymore, send out the message\n                    await this.#multicastServer.send(DnsCodec.encode(dnsMessageDataToSend));\n\n                    // Reset the message, length counter and included answers to count for next message\n                    dnsMessageDataToSend.queries.length = 0;\n                    dnsMessageDataToSend.answers.length = 0;\n                    dnsMessageSize = emptyDnsMessage.length + nextAnswerEncoded.length;\n                }\n                dnsMessageDataToSend.answers.push(nextAnswerEncoded);\n            } else {\n                break;\n            }\n        }\n\n        await this.#multicastServer.send(\n            DnsCodec.encode({ ...dnsMessageDataToSend, messageType: DnsMessageType.Query }),\n        );\n    }\n\n    /**\n     * Set new DnsQuery records to the list of active queries to discover devices in the network and start sending them\n     * out. When entry already exists the query is overwritten and answers are always added.\n     */\n    #setQueryRecords(queryId: string, queries: DnsQuery[], answers: DnsRecord<any>[] = []) {\n        const activeExistingQuery = this.#activeAnnounceQueries.get(queryId);\n        if (activeExistingQuery) {\n            const { queries: existingQueries } = activeExistingQuery;\n            const newQueries = queries.filter(\n                query =>\n                    !existingQueries.some(\n                        existingQuery =>\n                            existingQuery.name === query.name &&\n                            existingQuery.recordType === query.recordType &&\n                            existingQuery.recordClass === query.recordClass,\n                    ),\n            );\n            if (newQueries.length === 0) {\n                // All queries already sent out\n                logger.debug(\n                    `No new query records for query ${queryId}, keeping existing queries and do not re-announce.`,\n                );\n                return;\n            }\n            queries = [...newQueries, ...existingQueries];\n            answers = [...activeExistingQuery.answers, ...answers];\n        }\n        this.#activeAnnounceQueries.set(queryId, { queries, answers });\n        logger.debug(`Set ${queries.length} query records for query ${queryId}: ${Logger.toJSON(queries)}`);\n        this.#queryTimer?.stop();\n        this.#nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS; // Reset query interval\n        this.#queryTimer = Time.getTimer(\"MDNS discovery\", 0, () => this.#sendQueries()).start();\n    }\n\n    #getActiveQueryEarlierAnswers() {\n        return Array.from(this.#activeAnnounceQueries.values()).flatMap(({ answers }) => answers);\n    }\n\n    /**\n     * Remove a query from the list of active queries because discovery has finished or timed out and stop sending it\n     * out. If it was the last query announcing will stop completely.\n     */\n    #removeQuery(queryId: string) {\n        this.#activeAnnounceQueries.delete(queryId);\n        if (this.#activeAnnounceQueries.size === 0) {\n            logger.debug(`Removing last query ${queryId} and stopping announce timer`);\n            this.#queryTimer?.stop();\n            this.#nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;\n        } else {\n            logger.debug(`Removing query ${queryId}`);\n        }\n    }\n\n    /**\n     * Returns the list of all targets (IP/port) discovered for a queried operational device record.\n     */\n    #getOperationalDeviceRecords(deviceMatterQname: string): OperationalDevice | undefined {\n        const device = this.#operationalDeviceRecords.get(deviceMatterQname);\n        if (device === undefined) {\n            return undefined;\n        }\n        const { addresses } = device;\n        if (addresses.size === 0) {\n            return undefined;\n        }\n        return {\n            ...device,\n            addresses: this.#sortServerEntries(Array.from(addresses.values())).map(({ ip, port }) => ({\n                ip,\n                port,\n                type: \"udp\",\n            })) as ServerAddressIp[],\n        };\n    }\n\n    /**\n     * Sort the list of found IP/ports and make sure link-local IPv6 addresses come first, IPv6 next and IPv4 last.\n     *\n     * @param entries\n     */\n    #sortServerEntries(entries: MatterServerRecordWithExpire[]) {\n        return entries.sort((a, b) => {\n            const aIsIPv6 = isIPv6(a.ip);\n            const bIsIPv6 = isIPv6(b.ip);\n\n            if (aIsIPv6 && !bIsIPv6) {\n                return -1; // IPv6 comes first\n            } else if (!aIsIPv6 && bIsIPv6) {\n                return 1; // IPv4 comes after IPv6\n            } else if (aIsIPv6 && bIsIPv6) {\n                if (a.ip.startsWith(\"fd\") && !b.ip.startsWith(\"fd\")) {\n                    return -1; // addresses starting with \"fd\" come before other IPv6 addresses\n                } else if (!a.ip.startsWith(\"fd\") && b.ip.startsWith(\"fd\")) {\n                    return 1; // addresses starting with \"fd\" come after other IPv6 addresses\n                } else if (a.ip.startsWith(\"fe80:\") && !b.ip.startsWith(\"fe80:\")) {\n                    return -1; // link-local IPv6 comes before other global IPv6 addresses\n                } else if (!a.ip.startsWith(\"fe80:\") && b.ip.startsWith(\"fe80:\")) {\n                    return 1; // link-local IPv6 comes after other global IPv6 addresses\n                }\n            }\n            return 0; // no preference\n        });\n    }\n\n    /**\n     * Registers a deferred promise for a specific queryId together with a timeout and return the promise.\n     * The promise will be resolved when the timer runs out latest.\n     */\n    async #registerWaiterPromise(queryId: string, timeoutSeconds?: number, resolveOnUpdatedRecords = true) {\n        const { promise, resolver } = createPromise<void>();\n        const timer =\n            timeoutSeconds !== undefined\n                ? Time.getTimer(\"MDNS timeout\", timeoutSeconds * 1000, () => this.#finishWaiter(queryId, true)).start()\n                : undefined;\n        this.#recordWaiters.set(queryId, { resolver, timer, resolveOnUpdatedRecords });\n        logger.debug(\n            `Registered waiter for query ${queryId} with ${\n                timeoutSeconds !== undefined ? `timeout ${timeoutSeconds} seconds` : \"no timeout\"\n            }${resolveOnUpdatedRecords ? \"\" : \" (not resolving on updated records)\"}`,\n        );\n        return { promise };\n    }\n\n    /**\n     * Remove a waiter promise for a specific queryId and stop the connected timer. If required also resolve the\n     * promise.\n     */\n    #finishWaiter(queryId: string, resolvePromise: boolean, isUpdatedRecord = false) {\n        const waiter = this.#recordWaiters.get(queryId);\n        if (waiter === undefined) return;\n        const { timer, resolver, resolveOnUpdatedRecords } = waiter;\n        if (isUpdatedRecord && !resolveOnUpdatedRecords) return;\n        logger.debug(`Finishing waiter for query ${queryId}, resolving: ${resolvePromise}`);\n        if (timer !== undefined) {\n            timer.stop();\n        }\n        if (resolvePromise) {\n            resolver();\n        }\n        this.#recordWaiters.delete(queryId);\n    }\n\n    /** Returns weather a waiter promise is registered for a specific queryId. */\n    #hasWaiter(queryId: string) {\n        return this.#recordWaiters.has(queryId);\n    }\n\n    #createOperationalMatterQName(operationalId: ByteArray, nodeId: NodeId) {\n        const operationalIdString = operationalId.toHex().toUpperCase();\n        return getDeviceMatterQname(operationalIdString, NodeId.toHexString(nodeId));\n    }\n\n    /**\n     * Method to find an operational device (already commissioned) and return a promise with the list of discovered\n     * IP/ports or an empty array if not found.\n     */\n    async findOperationalDevice(\n        { operationalId }: Fabric,\n        nodeId: NodeId,\n        timeoutSeconds?: number,\n        ignoreExistingRecords = false,\n    ): Promise<OperationalDevice | undefined> {\n        if (this.#closing) {\n            throw new ImplementationError(\"Cannot discover operational device because scanner is closing.\");\n        }\n        const deviceMatterQname = this.#createOperationalMatterQName(operationalId, nodeId);\n\n        let storedDevice = ignoreExistingRecords ? undefined : this.#getOperationalDeviceRecords(deviceMatterQname);\n        if (storedDevice === undefined) {\n            const { promise } = await this.#registerWaiterPromise(deviceMatterQname, timeoutSeconds);\n\n            this.#setQueryRecords(deviceMatterQname, [\n                {\n                    name: deviceMatterQname,\n                    recordClass: DnsRecordClass.IN,\n                    recordType: DnsRecordType.SRV,\n                },\n            ]);\n\n            await promise;\n            storedDevice = this.#getOperationalDeviceRecords(deviceMatterQname);\n            this.#removeQuery(deviceMatterQname);\n        }\n        return storedDevice;\n    }\n\n    cancelOperationalDeviceDiscovery(fabric: Fabric, nodeId: NodeId) {\n        const deviceMatterQname = this.#createOperationalMatterQName(fabric.operationalId, nodeId);\n        this.#finishWaiter(deviceMatterQname, true);\n    }\n\n    cancelCommissionableDeviceDiscovery(identifier: CommissionableDeviceIdentifiers) {\n        const queryId = this.#buildCommissionableQueryIdentifier(identifier);\n        this.#finishWaiter(queryId, true);\n    }\n\n    getDiscoveredOperationalDevice({ operationalId }: Fabric, nodeId: NodeId) {\n        return this.#getOperationalDeviceRecords(this.#createOperationalMatterQName(operationalId, nodeId));\n    }\n\n    /**\n     * Returns the metadata and list of all target addresses (IP/port) discovered for a queried commissionable device\n     * record.\n     */\n    #getCommissionableDeviceRecords(identifier: CommissionableDeviceIdentifiers) {\n        const storedRecords = Array.from(this.#commissionableDeviceRecords.values());\n\n        const foundRecords = new Array<CommissionableDeviceRecordWithExpire>();\n        if (\"instanceId\" in identifier) {\n            foundRecords.push(...storedRecords.filter(({ instanceId }) => instanceId === identifier.instanceId));\n        } else if (\"longDiscriminator\" in identifier) {\n            foundRecords.push(...storedRecords.filter(({ D }) => D === identifier.longDiscriminator));\n        } else if (\"shortDiscriminator\" in identifier) {\n            foundRecords.push(...storedRecords.filter(({ SD }) => SD === identifier.shortDiscriminator));\n        } else if (\"vendorId\" in identifier) {\n            foundRecords.push(...storedRecords.filter(({ V }) => V === identifier.vendorId));\n        } else if (\"deviceType\" in identifier) {\n            foundRecords.push(...storedRecords.filter(({ DT }) => DT === identifier.deviceType));\n        } else if (\"productId\" in identifier) {\n            foundRecords.push(...storedRecords.filter(({ P }) => P === identifier.productId));\n        } else if (Object.keys(identifier).length === 0) {\n            foundRecords.push(...storedRecords.filter(({ CM }) => CM === 1 || CM === 2));\n        }\n\n        return foundRecords.map(record => {\n            return {\n                ...record,\n                addresses: this.#sortServerEntries(Array.from(record.addresses.values())).map(({ ip, port }) => ({\n                    ip,\n                    port,\n                    type: \"udp\",\n                })) as ServerAddressIp[],\n                expires: undefined,\n            };\n        });\n    }\n\n    /**\n     * Builds an identifier string for commissionable queries based on the given identifier object.\n     * Some identifiers are identical to the official DNS-SD identifiers, others are custom.\n     */\n    #buildCommissionableQueryIdentifier(identifier: CommissionableDeviceIdentifiers) {\n        if (\"instanceId\" in identifier) {\n            return getDeviceInstanceQname(identifier.instanceId);\n        } else if (\"longDiscriminator\" in identifier) {\n            return getLongDiscriminatorQname(identifier.longDiscriminator);\n        } else if (\"shortDiscriminator\" in identifier) {\n            return getShortDiscriminatorQname(identifier.shortDiscriminator);\n        } else if (\"vendorId\" in identifier) {\n            return getVendorQname(identifier.vendorId);\n        } else if (\"deviceType\" in identifier) {\n            return getDeviceTypeQname(identifier.deviceType);\n        } else if (\"productId\" in identifier) {\n            // Custom identifier because normally productId is only included in TXT record\n            return `_P${identifier.productId}`;\n        } else if (Object.keys(identifier).length === 0) {\n            return getCommissioningModeQname();\n        }\n        throw new ImplementationError(`Invalid commissionable device identifier : ${Logger.toJSON(identifier)}`); // Should neven happen\n    }\n\n    #extractInstanceId(instanceName: string) {\n        const instanceNameSeparator = instanceName.indexOf(\".\");\n        if (instanceNameSeparator !== -1) {\n            return instanceName.substring(0, instanceNameSeparator);\n        }\n        return instanceName;\n    }\n\n    /**\n     * Check all options for a query identifier and return the most relevant one with an active query\n     */\n    #findCommissionableQueryIdentifier(instanceName: string, record: CommissionableDeviceRecordWithExpire) {\n        if (this.#closing) {\n            throw new ImplementationError(\"Cannot discover commissionable device because scanner is closing.\");\n        }\n        const instanceQueryId = this.#buildCommissionableQueryIdentifier({\n            instanceId: this.#extractInstanceId(instanceName),\n        });\n        if (this.#activeAnnounceQueries.has(instanceQueryId)) {\n            return instanceQueryId;\n        }\n\n        const longDiscriminatorQueryId = this.#buildCommissionableQueryIdentifier({ longDiscriminator: record.D });\n        if (this.#activeAnnounceQueries.has(longDiscriminatorQueryId)) {\n            return longDiscriminatorQueryId;\n        }\n\n        const shortDiscriminatorQueryId = this.#buildCommissionableQueryIdentifier({ shortDiscriminator: record.SD });\n        if (this.#activeAnnounceQueries.has(shortDiscriminatorQueryId)) {\n            return shortDiscriminatorQueryId;\n        }\n\n        if (record.V !== undefined) {\n            const vendorIdQueryId = this.#buildCommissionableQueryIdentifier({ vendorId: VendorId(record.V) });\n            if (this.#activeAnnounceQueries.has(vendorIdQueryId)) {\n                return vendorIdQueryId;\n            }\n        }\n\n        if (record.DT !== undefined) {\n            const deviceTypeQueryId = this.#buildCommissionableQueryIdentifier({ deviceType: record.DT });\n            if (this.#activeAnnounceQueries.has(deviceTypeQueryId)) {\n                return deviceTypeQueryId;\n            }\n        }\n\n        if (record.P !== undefined) {\n            const productIdQueryId = this.#buildCommissionableQueryIdentifier({ productId: record.P });\n            if (this.#activeAnnounceQueries.has(productIdQueryId)) {\n                return productIdQueryId;\n            }\n        }\n\n        const commissioningModeQueryId = this.#buildCommissionableQueryIdentifier({});\n        if (this.#activeAnnounceQueries.has(commissioningModeQueryId)) {\n            return commissioningModeQueryId;\n        }\n\n        return undefined;\n    }\n\n    #getCommissionableQueryRecords(identifier: CommissionableDeviceIdentifiers): DnsQuery[] {\n        const names = new Array<string>();\n\n        names.push(MATTER_COMMISSION_SERVICE_QNAME);\n\n        if (\"instanceId\" in identifier) {\n            names.push(getDeviceInstanceQname(identifier.instanceId));\n        } else if (\"longDiscriminator\" in identifier) {\n            names.push(getLongDiscriminatorQname(identifier.longDiscriminator));\n        } else if (\"shortDiscriminator\" in identifier) {\n            names.push(getShortDiscriminatorQname(identifier.shortDiscriminator));\n        } else if (\"vendorId\" in identifier) {\n            names.push(getVendorQname(identifier.vendorId));\n        } else if (\"deviceType\" in identifier) {\n            names.push(getDeviceTypeQname(identifier.deviceType));\n        } else {\n            // Other queries just scan for commissionable devices\n            names.push(getCommissioningModeQname());\n        }\n\n        return names.map(name => ({ name, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.PTR }));\n    }\n\n    /**\n     * Discovers commissionable devices based on a defined identifier for maximal given timeout, but returns the\n     * first found entries. If already a discovered device matches in the cache the response is returned directly and\n     * no query is triggered. If no record exists a query is sent out and the promise gets fulfilled as soon as at least\n     * one device is found. If no device is discovered in the defined timeframe an empty array is returned. When the\n     * promise got fulfilled no more queries are send out, but more device entries might be added when discovered later.\n     * These can be requested by the getCommissionableDevices method.\n     */\n    async findCommissionableDevices(\n        identifier: CommissionableDeviceIdentifiers,\n        timeoutSeconds = 5,\n        ignoreExistingRecords = false,\n    ): Promise<CommissionableDevice[]> {\n        let storedRecords = ignoreExistingRecords\n            ? []\n            : this.#getCommissionableDeviceRecords(identifier).filter(({ addresses }) => addresses.length > 0);\n        if (storedRecords.length === 0) {\n            const queryId = this.#buildCommissionableQueryIdentifier(identifier);\n            const { promise } = await this.#registerWaiterPromise(queryId, timeoutSeconds);\n\n            this.#setQueryRecords(queryId, this.#getCommissionableQueryRecords(identifier));\n\n            await promise;\n            storedRecords = this.#getCommissionableDeviceRecords(identifier);\n            this.#removeQuery(queryId);\n        }\n\n        return storedRecords;\n    }\n\n    /**\n     * Discovers commissionable devices based on a defined identifier and returns the first found entries. If already a\n     * @param identifier\n     * @param callback\n     * @param timeoutSeconds\n     */\n    async findCommissionableDevicesContinuously(\n        identifier: CommissionableDeviceIdentifiers,\n        callback: (device: CommissionableDevice) => void,\n        timeoutSeconds = 900,\n    ): Promise<CommissionableDevice[]> {\n        const discoveredDevices = new Set<string>();\n\n        const discoveryEndTime = Time.nowMs() + timeoutSeconds * 1000;\n        const queryId = this.#buildCommissionableQueryIdentifier(identifier);\n        this.#setQueryRecords(queryId, this.#getCommissionableQueryRecords(identifier));\n\n        while (true) {\n            this.#getCommissionableDeviceRecords(identifier).forEach(device => {\n                const { deviceIdentifier } = device;\n                if (!discoveredDevices.has(deviceIdentifier)) {\n                    discoveredDevices.add(deviceIdentifier);\n                    callback(device);\n                }\n            });\n\n            const remainingTime = Math.ceil((discoveryEndTime - Time.nowMs()) / 1000);\n            if (remainingTime <= 0) {\n                break;\n            }\n            const { promise } = await this.#registerWaiterPromise(queryId, remainingTime, false);\n            await promise;\n        }\n        return this.#getCommissionableDeviceRecords(identifier);\n    }\n\n    getDiscoveredCommissionableDevices(identifier: CommissionableDeviceIdentifiers) {\n        return this.#getCommissionableDeviceRecords(identifier);\n    }\n\n    /**\n     * Close all connects, end all timers and resolve all pending promises.\n     */\n    async close() {\n        this.#closing = true;\n        this.#periodicTimer.stop();\n        this.#queryTimer?.stop();\n        await this.#multicastServer.close();\n        // Resolve all pending promises where logic waits for the response (aka: has a timer)\n        [...this.#recordWaiters.keys()].forEach(queryId =>\n            this.#finishWaiter(queryId, !!this.#recordWaiters.get(queryId)?.timer),\n        );\n    }\n\n    /**\n     * Main method to handle all incoming DNS messages.\n     * It will parse the message and check if it contains relevant discovery records.\n     */\n    #handleDnsMessage(messageBytes: ByteArray, _remoteIp: string, netInterface: string) {\n        if (this.#closing) return;\n        const message = DnsCodec.decode(messageBytes);\n        if (message === undefined) return; // The message cannot be parsed\n        if (message.messageType !== DnsMessageType.Response && message.messageType !== DnsMessageType.TruncatedResponse)\n            return;\n\n        const answers = [...message.answers, ...message.additionalRecords];\n\n        // Check if we got operational discovery records and handle them\n        if (this.#handleOperationalRecords(answers, this.#getActiveQueryEarlierAnswers(), netInterface)) return;\n\n        // Else check if we got commissionable discovery records and handle them\n        this.#handleCommissionableRecords(answers, this.#getActiveQueryEarlierAnswers(), netInterface);\n    }\n\n    #handleIpRecords(\n        answers: DnsRecord<any>[],\n        target: string,\n        netInterface: string,\n    ): { value: string; ttl: number }[] {\n        const ipRecords = answers.filter(\n            ({ name, recordType }) =>\n                ((recordType === DnsRecordType.A && this.#enableIpv4) || recordType === DnsRecordType.AAAA) &&\n                name === target,\n        );\n        return (ipRecords as DnsRecord<string>[]).map(({ value, ttl }) => ({\n            value: value.startsWith(\"fe80::\") ? `${value}%${netInterface}` : value,\n            ttl,\n        }));\n    }\n\n    #handleOperationalRecords(answers: DnsRecord<any>[], formerAnswers: DnsRecord<any>[], netInterface: string) {\n        let recordsHandled = false;\n        // Does the message contain data for an operational service?\n        const operationalTxtRecord = answers.find(\n            ({ name, recordType }) => recordType === DnsRecordType.TXT && name.endsWith(MATTER_SERVICE_QNAME),\n        );\n        if (operationalTxtRecord !== undefined) {\n            this.#handleOperationalTxtRecord(operationalTxtRecord, netInterface);\n            recordsHandled = true;\n        }\n\n        const operationalSrvRecord =\n            answers.find(\n                ({ name, recordType }) => recordType === DnsRecordType.SRV && name.endsWith(MATTER_SERVICE_QNAME),\n            ) ??\n            formerAnswers.find(\n                ({ name, recordType }) => recordType === DnsRecordType.SRV && name.endsWith(MATTER_SERVICE_QNAME),\n            );\n\n        if (operationalSrvRecord !== undefined) {\n            this.#handleOperationalSrvRecord(operationalSrvRecord, answers, formerAnswers, netInterface);\n            recordsHandled = true;\n        }\n        return recordsHandled;\n    }\n\n    #handleOperationalTxtRecord(record: DnsRecord<any>, netInterface: string) {\n        const { name: matterName, value, ttl } = record as DnsRecord<string[]>;\n\n        // we got an expiry info, so we can remove the record if we know it already and are done\n        if (ttl === 0) {\n            if (this.#operationalDeviceRecords.has(matterName)) {\n                logger.debug(\n                    `Removing operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`,\n                );\n                this.#operationalDeviceRecords.delete(matterName);\n            }\n            return;\n        }\n        if (!Array.isArray(value)) return;\n\n        const txtData = this.#parseTxtRecord(record);\n        if (txtData === undefined) return;\n        let device = this.#operationalDeviceRecords.get(matterName);\n        if (device !== undefined) {\n            device = {\n                ...device,\n                expires: Time.nowMs() + ttl * 1000,\n                ...txtData,\n            };\n        } else {\n            logger.debug(\n                `Adding operational device ${matterName} in cache (interface ${netInterface}) with TXT data:`,\n                MdnsScanner.discoveryDataDiagnostics(txtData),\n            );\n            device = {\n                deviceIdentifier: matterName,\n                addresses: new Map<string, MatterServerRecordWithExpire>(),\n                expires: Time.nowMs() + ttl * 1000,\n                ...txtData,\n            };\n        }\n\n        this.#operationalDeviceRecords.set(matterName, device);\n    }\n\n    #handleOperationalSrvRecord(\n        record: DnsRecord<any>,\n        answers: DnsRecord<any>[],\n        formerAnswers: DnsRecord<any>[],\n        netInterface: string,\n    ) {\n        const {\n            name: matterName,\n            ttl,\n            value: { target, port },\n        } = record;\n\n        // we got an expiry info, so we can remove the record if we know it already and are done\n        if (ttl === 0) {\n            if (this.#operationalDeviceRecords.has(matterName)) {\n                logger.debug(\n                    `Removing operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`,\n                );\n                this.#operationalDeviceRecords.delete(matterName);\n            }\n            return true;\n        }\n\n        const ips = this.#handleIpRecords([...answers, ...formerAnswers], target, netInterface);\n        const deviceExisted = this.#operationalDeviceRecords.has(matterName);\n        const device = this.#operationalDeviceRecords.get(matterName) ?? {\n            deviceIdentifier: matterName,\n            addresses: new Map<string, MatterServerRecordWithExpire>(),\n            expires: Time.nowMs() + ttl * 1000,\n        };\n        const { addresses } = device;\n        if (ips.length > 0) {\n            for (const { value: ip, ttl } of ips) {\n                if (ttl === 0) {\n                    logger.debug(\n                        `Removing IP ${ip} for operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`,\n                    );\n                    addresses.delete(ip);\n                    continue;\n                }\n                const matterServer = addresses.get(ip) ?? { ip, port, type: \"udp\", expires: 0 };\n                matterServer.expires = Time.nowMs() + ttl * 1000;\n\n                addresses.set(matterServer.ip, matterServer);\n            }\n            device.addresses = addresses;\n            if (!this.#operationalDeviceRecords.has(matterName)) {\n                logger.debug(\n                    `Added IPs for operational device ${matterName} to cache (interface ${netInterface}):`,\n                    ...MdnsScanner.deviceAddressDiagnostics(addresses),\n                );\n            }\n            this.#operationalDeviceRecords.set(matterName, device);\n        }\n\n        if (addresses.size === 0 && this.#hasWaiter(matterName)) {\n            // We have no or no more (because expired) IPs, and we are interested in this particular service name, request them\n            const queries = [{ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.AAAA }];\n            if (this.#enableIpv4) {\n                queries.push({ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.A });\n            }\n            logger.debug(`Requesting IP addresses for operational device ${matterName} (interface ${netInterface}).`);\n            this.#setQueryRecords(matterName, queries, answers);\n        } else if (addresses.size > 0) {\n            this.#finishWaiter(matterName, true, deviceExisted);\n        }\n        return true;\n    }\n\n    #handleCommissionableRecords(answers: DnsRecord<any>[], formerAnswers: DnsRecord<any>[], netInterface: string) {\n        // Does the message contain a SRV record for an operational service we are interested in?\n        let commissionableRecords = answers.filter(({ name }) => name.endsWith(MATTER_COMMISSION_SERVICE_QNAME));\n        if (!commissionableRecords.length) {\n            commissionableRecords = formerAnswers.filter(({ name }) => name.endsWith(MATTER_COMMISSION_SERVICE_QNAME));\n            if (!commissionableRecords.length) return;\n        }\n\n        const queryMissingDataForInstances = new Set<string>();\n\n        // First process the TXT records\n        const txtRecords = commissionableRecords.filter(({ recordType }) => recordType === DnsRecordType.TXT);\n        for (const record of txtRecords) {\n            const { name, ttl } = record;\n            if (ttl === 0) {\n                if (this.#commissionableDeviceRecords.has(name)) {\n                    logger.debug(\n                        `Removing commissionable device ${name} from cache (interface ${netInterface}) because of ttl=0`,\n                    );\n                    this.#commissionableDeviceRecords.delete(name);\n                }\n                continue;\n            }\n            const parsedRecord = this.#parseCommissionableTxtRecord(record);\n            if (parsedRecord === undefined) continue;\n            parsedRecord.instanceId = this.#extractInstanceId(name);\n            parsedRecord.deviceIdentifier = parsedRecord.instanceId;\n            if (parsedRecord.D !== undefined && parsedRecord.SD === undefined) {\n                parsedRecord.SD = (parsedRecord.D >> 8) & 0x0f;\n            }\n            if (parsedRecord.VP !== undefined) {\n                const VpValueArr = parsedRecord.VP.split(\"+\");\n                parsedRecord.V = VpValueArr[0] !== undefined ? parseInt(VpValueArr[0]) : undefined;\n                parsedRecord.P = VpValueArr[1] !== undefined ? parseInt(VpValueArr[1]) : undefined;\n            }\n\n            const storedRecord = this.#commissionableDeviceRecords.get(name);\n            if (storedRecord === undefined) {\n                queryMissingDataForInstances.add(name);\n\n                logger.debug(\n                    `Found commissionable device ${name} with data:`,\n                    MdnsScanner.discoveryDataDiagnostics(parsedRecord),\n                );\n            } else {\n                parsedRecord.addresses = storedRecord.addresses;\n            }\n            this.#commissionableDeviceRecords.set(name, parsedRecord);\n        }\n\n        // We got SRV records for the instance ID, so we know the host name now and can collect the IP addresses\n        const srvRecords = commissionableRecords.filter(({ recordType }) => recordType === DnsRecordType.SRV);\n        for (const record of srvRecords) {\n            const storedRecord = this.#commissionableDeviceRecords.get(record.name);\n            if (storedRecord === undefined) continue;\n            const {\n                value: { target, port },\n                ttl,\n            } = record as DnsRecord<SrvRecordValue>;\n            if (ttl === 0) {\n                logger.debug(\n                    `Removing commissionable device ${record.name} from cache (interface ${netInterface}) because of ttl=0`,\n                );\n                this.#commissionableDeviceRecords.delete(record.name);\n                continue;\n            }\n\n            const recordExisting = storedRecord.addresses.size > 0;\n\n            const ips = this.#handleIpRecords([...answers, ...formerAnswers], target, netInterface);\n            if (ips.length > 0) {\n                for (const { value: ip, ttl } of ips) {\n                    if (ttl === 0) {\n                        logger.debug(\n                            `Removing IP ${ip} for commissionable device ${record.name} from cache (interface ${netInterface}) because of ttl=0`,\n                        );\n                        storedRecord.addresses.delete(ip);\n                        continue;\n                    }\n                    const matterServer = storedRecord.addresses.get(ip) ?? { ip, port, type: \"udp\", expires: 0 };\n                    matterServer.expires = Time.nowMs() + ttl * 1000;\n\n                    storedRecord.addresses.set(ip, matterServer);\n                }\n            }\n            this.#commissionableDeviceRecords.set(record.name, storedRecord);\n            if (storedRecord.addresses.size === 0) {\n                const queryId = this.#findCommissionableQueryIdentifier(\"\", storedRecord);\n                if (queryId === undefined) continue;\n                // We have no or no more (because expired) IPs and we are interested in such a service name, request them\n                const queries = [{ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.AAAA }];\n                if (this.#enableIpv4) {\n                    queries.push({ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.A });\n                }\n                logger.debug(\n                    `Requesting IP addresses for commissionable device ${record.name} (interface ${netInterface}).`,\n                );\n                this.#setQueryRecords(queryId, queries, answers);\n            }\n            if (storedRecord.addresses.size === 0) continue;\n\n            const queryId = this.#findCommissionableQueryIdentifier(record.name, storedRecord);\n            if (queryId === undefined) continue;\n\n            queryMissingDataForInstances.delete(record.name); // No need to query anymore, we have anything we need\n            this.#finishWaiter(queryId, true, recordExisting);\n        }\n\n        // We have to query for the SRV records for the missing commissionable devices where we only had TXT records\n        if (queryMissingDataForInstances.size !== 0) {\n            for (const name of Array.from(queryMissingDataForInstances.values())) {\n                const storedRecord = this.#commissionableDeviceRecords.get(name);\n                if (storedRecord === undefined) continue;\n                const queryId = this.#findCommissionableQueryIdentifier(\"\", storedRecord);\n                if (queryId === undefined) continue;\n                logger.debug(`Requesting more records for commissionable device ${name} (interface ${netInterface}).`);\n                this.#setQueryRecords(\n                    queryId,\n                    [{ name, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.ANY }],\n                    answers,\n                );\n            }\n        }\n    }\n\n    #parseTxtRecord(record: DnsRecord<any>): DiscoveryData | undefined {\n        const { value } = record as DnsRecord<string[]>;\n        const result = {} as any;\n        if (Array.isArray(value)) {\n            for (const item of value) {\n                const [key, value] = item.split(\"=\");\n                if (key === undefined || value === undefined) continue;\n                if ([\"SII\", \"SAI\", \"SAT\", \"T\", \"D\", \"CM\", \"DT\", \"PH\", \"ICD\"].includes(key)) {\n                    const intValue = parseInt(value);\n                    if (isNaN(intValue)) continue;\n                    result[key] = intValue;\n                } else if ([\"VP\", \"DN\", \"RI\", \"PI\"].includes(key)) {\n                    result[key] = value;\n                }\n            }\n        }\n\n        // Fill in some defaults for convenience\n        if (result.T === undefined) {\n            result.T = 0; // TCP not supported\n        } else if (result.T === 1) {\n            // Value 1 is reserved and should be handled as 0 according to Matter spec\n            result.T = 0; // TCP not supported\n        }\n        if (result.ICD === undefined) {\n            result.ICD = 0; // Device is not operating as Long Idle Time ICD\n        }\n\n        return result;\n    }\n\n    #parseCommissionableTxtRecord(record: DnsRecord<any>): CommissionableDeviceRecordWithExpire | undefined {\n        const { value, ttl } = record as DnsRecord<string[]>;\n        if (!Array.isArray(value)) return undefined;\n        const result = {\n            addresses: new Map<string, ServerAddress>(),\n            expires: Time.nowMs() + ttl * 1000,\n            ...this.#parseTxtRecord(record),\n        } as any;\n        if (result.D === undefined || result.CM === undefined) return undefined; // Required data fields need to be existing\n        return result as CommissionableDeviceRecordWithExpire;\n    }\n\n    #expire() {\n        const now = Time.nowMs();\n        [...this.#operationalDeviceRecords.entries()].forEach(([recordKey, { addresses, expires }]) => {\n            if (now < expires) {\n                [...addresses.entries()].forEach(([key, { expires }]) => {\n                    if (now < expires) return;\n                    addresses.delete(key);\n                });\n            }\n            if (now >= expires || addresses.size === 0) {\n                this.#operationalDeviceRecords.delete(recordKey);\n            }\n        });\n        [...this.#commissionableDeviceRecords.entries()].forEach(([recordKey, { addresses, expires }]) => {\n            if (now < expires) {\n                // Entry still ok but check addresses for expiry\n                [...addresses.entries()].forEach(([key, { expires }]) => {\n                    if (now < expires) return;\n                    addresses.delete(key);\n                });\n            }\n            if (now >= expires || addresses.size === 0) {\n                this.#commissionableDeviceRecords.delete(recordKey);\n            }\n        });\n    }\n\n    static discoveryDataDiagnostics(data: DiscoveryData) {\n        return Diagnostic.dict({\n            SII: data.SII,\n            SAI: data.SAI,\n            SAT: data.SAT,\n            T: data.T,\n            DT: data.DT,\n            PH: data.PH,\n            ICD: data.ICD,\n            VP: data.VP,\n            DN: data.DN,\n            RI: data.RI,\n            PI: data.PI,\n        });\n    }\n\n    static deviceAddressDiagnostics(addresses: Map<string, MatterServerRecordWithExpire>) {\n        return Array.from(addresses.values()).map(address =>\n            Diagnostic.dict({\n                ip: address.ip,\n                port: address.port,\n                type: address.type,\n            }),\n        );\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA,EACI;AAAA,EAEA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,OAEG;AACP,SAAS,2BAA2B;AASpC,SAAS,cAAc;AACvB,SAAS,gBAAgB;AAEzB,SAAS,kBAAkB;AAC3B,SAAS,cAAc;AAEvB,SAAS,0BAA0B;AACnC,SAAS,YAAmB;AAE5B,SAAS,cAAc;AACvB,SAAS,qBAAqB;AAC9B;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACG;AACP,SAAS,qBAAqB,qBAAqB,2BAA2B;AAE9E,MAAM,SAAS,OAAO,IAAI,aAAa;AAqBvC,MAAM,kCAAkC;AAMjC,MAAM,YAA+B;AAAA,EACxC,aAAa,OAAO,SAAkB,SAA2D;AAC7F,UAAM,EAAE,YAAY,aAAa,IAAI,WAAW,CAAC;AACjD,WAAO,IAAI;AAAA,MACP,MAAM,mBAAmB,OAAO;AAAA,QAC5B;AAAA,QACA;AAAA,QACA,sBAAsB,aAAa,sBAAsB;AAAA,QACzD,sBAAsB;AAAA,QACtB,eAAe;AAAA,MACnB,CAAC;AAAA,MACD;AAAA,IACJ;AAAA,EACJ;AAAA,EAES,yBAAyB,oBAAI,IAAgE;AAAA,EACtG;AAAA,EACA,+BAA+B;AAAA,EAEtB,4BAA4B,oBAAI,IAA+C;AAAA,EAC/E,+BAA+B,oBAAI,IAAkD;AAAA,EACrF,iBAAiB,oBAAI,IAO5B;AAAA,EACO;AAAA,EACT,WAAW;AAAA,EAEF;AAAA,EACA;AAAA,EAET,YAAY,iBAAqC,YAAsB;AACnE,oBAAgB;AAAA,MAAU,CAAC,SAAS,UAAU,iBAC1C,KAAK,kBAAkB,SAAS,UAAU,YAAY;AAAA,IAC1D;AACA,SAAK,mBAAmB;AACxB,SAAK,cAAc;AACnB,SAAK,iBAAiB,KAAK;AAAA,MAAiB;AAAA,MAA8B,KAAK;AAAA,MAAiB,MAC5F,KAAK,QAAQ;AAAA,IACjB,EAAE,MAAM;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,eAAe;AACjB,SAAK,aAAa,KAAK;AACvB,UAAM,aAAa,MAAM,KAAK,KAAK,uBAAuB,OAAO,CAAC;AAClE,UAAM,UAAU,WAAW,QAAQ,CAAC,EAAE,SAAAA,SAAQ,MAAMA,QAAO;AAC3D,UAAM,UAAU,WAAW,QAAQ,CAAC,EAAE,SAAAC,SAAQ,MAAMA,QAAO;AAE3D,SAAK,cAAc,KAAK;AAAA,MAAS;AAAA,MAAkB,KAAK,+BAA+B;AAAA,MAAM,MACzF,KAAK,aAAa;AAAA,IACtB,EAAE,MAAM;AAER,WAAO;AAAA,MACH,WAAW,QAAQ,MAAM,sBAAsB,KAAK,uBAAuB,IAAI,iBAAiB,QAAQ,MAAM,kCAAkC,KAAK,4BAA4B;AAAA,IACrL;AAEA,UAAM,uBAAuB,KAAK,+BAA+B;AACjE,SAAK,+BAA+B,KAAK;AAAA,MAAI;AAAA,MAAsB,KAAK;AAAA;AAAA,IAAe;AAEvF,UAAM,gBAAgB,CAAC,GAAG,OAAO;AAEjC,UAAM,uBAAuB;AAAA,MACzB,aAAa,eAAe;AAAA,MAC5B,eAAe;AAAA,MACf;AAAA,MACA,aAAa,CAAC;AAAA,MACd,SAAS,CAAC;AAAA,MACV,mBAAmB,CAAC;AAAA,IACxB;AAEA,UAAM,kBAAkB,SAAS,OAAO,oBAAoB;AAC5D,QAAI,iBAAiB,gBAAgB;AAErC,WAAO,MAAM;AACT,UAAI,cAAc,SAAS,GAAG;AAC1B,cAAM,aAAa,cAAc,MAAM;AACvC,YAAI,eAAe,QAAW;AAC1B;AAAA,QACJ;AAEA,cAAM,oBAAoB,SAAS,aAAa,UAAU;AAC1D,0BAAkB,kBAAkB;AAEpC,YAAI,iBAAiB,uBAAuB;AACxC,cAAI,qBAAqB,QAAQ,WAAW,GAAG;AAE3C,mBAAO;AAAA,cACH,mBAAmB,OAAO;AAAA,gBACtB;AAAA,cACJ,CAAC;AAAA,YACL;AAAA,UACJ;AAEA,gBAAM,KAAK,iBAAiB,KAAK,SAAS,OAAO,oBAAoB,CAAC;AAGtE,+BAAqB,QAAQ,SAAS;AACtC,+BAAqB,QAAQ,SAAS;AACtC,2BAAiB,gBAAgB,SAAS,kBAAkB;AAAA,QAChE;AACA,6BAAqB,QAAQ,KAAK,iBAAiB;AAAA,MACvD,OAAO;AACH;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,KAAK,iBAAiB;AAAA,MACxB,SAAS,OAAO,EAAE,GAAG,sBAAsB,aAAa,eAAe,MAAM,CAAC;AAAA,IAClF;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,SAAiB,SAAqB,UAA4B,CAAC,GAAG;AACnF,UAAM,sBAAsB,KAAK,uBAAuB,IAAI,OAAO;AACnE,QAAI,qBAAqB;AACrB,YAAM,EAAE,SAAS,gBAAgB,IAAI;AACrC,YAAM,aAAa,QAAQ;AAAA,QACvB,WACI,CAAC,gBAAgB;AAAA,UACb,mBACI,cAAc,SAAS,MAAM,QAC7B,cAAc,eAAe,MAAM,cACnC,cAAc,gBAAgB,MAAM;AAAA,QAC5C;AAAA,MACR;AACA,UAAI,WAAW,WAAW,GAAG;AAEzB,eAAO;AAAA,UACH,kCAAkC,OAAO;AAAA,QAC7C;AACA;AAAA,MACJ;AACA,gBAAU,CAAC,GAAG,YAAY,GAAG,eAAe;AAC5C,gBAAU,CAAC,GAAG,oBAAoB,SAAS,GAAG,OAAO;AAAA,IACzD;AACA,SAAK,uBAAuB,IAAI,SAAS,EAAE,SAAS,QAAQ,CAAC;AAC7D,WAAO,MAAM,OAAO,QAAQ,MAAM,4BAA4B,OAAO,KAAK,OAAO,OAAO,OAAO,CAAC,EAAE;AAClG,SAAK,aAAa,KAAK;AACvB,SAAK,+BAA+B;AACpC,SAAK,cAAc,KAAK,SAAS,kBAAkB,GAAG,MAAM,KAAK,aAAa,CAAC,EAAE,MAAM;AAAA,EAC3F;AAAA,EAEA,gCAAgC;AAC5B,WAAO,MAAM,KAAK,KAAK,uBAAuB,OAAO,CAAC,EAAE,QAAQ,CAAC,EAAE,QAAQ,MAAM,OAAO;AAAA,EAC5F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,SAAiB;AAC1B,SAAK,uBAAuB,OAAO,OAAO;AAC1C,QAAI,KAAK,uBAAuB,SAAS,GAAG;AACxC,aAAO,MAAM,uBAAuB,OAAO,8BAA8B;AACzE,WAAK,aAAa,KAAK;AACvB,WAAK,+BAA+B;AAAA,IACxC,OAAO;AACH,aAAO,MAAM,kBAAkB,OAAO,EAAE;AAAA,IAC5C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,6BAA6B,mBAA0D;AACnF,UAAM,SAAS,KAAK,0BAA0B,IAAI,iBAAiB;AACnE,QAAI,WAAW,QAAW;AACtB,aAAO;AAAA,IACX;AACA,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,UAAU,SAAS,GAAG;AACtB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,MACH,GAAG;AAAA,MACH,WAAW,KAAK,mBAAmB,MAAM,KAAK,UAAU,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,KAAK,OAAO;AAAA,QACtF;AAAA,QACA;AAAA,QACA,MAAM;AAAA,MACV,EAAE;AAAA,IACN;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,mBAAmB,SAAyC;AACxD,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM;AAC1B,YAAM,UAAU,OAAO,EAAE,EAAE;AAC3B,YAAM,UAAU,OAAO,EAAE,EAAE;AAE3B,UAAI,WAAW,CAAC,SAAS;AACrB,eAAO;AAAA,MACX,WAAW,CAAC,WAAW,SAAS;AAC5B,eAAO;AAAA,MACX,WAAW,WAAW,SAAS;AAC3B,YAAI,EAAE,GAAG,WAAW,IAAI,KAAK,CAAC,EAAE,GAAG,WAAW,IAAI,GAAG;AACjD,iBAAO;AAAA,QACX,WAAW,CAAC,EAAE,GAAG,WAAW,IAAI,KAAK,EAAE,GAAG,WAAW,IAAI,GAAG;AACxD,iBAAO;AAAA,QACX,WAAW,EAAE,GAAG,WAAW,OAAO,KAAK,CAAC,EAAE,GAAG,WAAW,OAAO,GAAG;AAC9D,iBAAO;AAAA,QACX,WAAW,CAAC,EAAE,GAAG,WAAW,OAAO,KAAK,EAAE,GAAG,WAAW,OAAO,GAAG;AAC9D,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,uBAAuB,SAAiB,gBAAyB,0BAA0B,MAAM;AACnG,UAAM,EAAE,SAAS,SAAS,IAAI,cAAoB;AAClD,UAAM,QACF,mBAAmB,SACb,KAAK,SAAS,gBAAgB,iBAAiB,KAAM,MAAM,KAAK,cAAc,SAAS,IAAI,CAAC,EAAE,MAAM,IACpG;AACV,SAAK,eAAe,IAAI,SAAS,EAAE,UAAU,OAAO,wBAAwB,CAAC;AAC7E,WAAO;AAAA,MACH,+BAA+B,OAAO,SAClC,mBAAmB,SAAY,WAAW,cAAc,aAAa,YACzE,GAAG,0BAA0B,KAAK,qCAAqC;AAAA,IAC3E;AACA,WAAO,EAAE,QAAQ;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,SAAiB,gBAAyB,kBAAkB,OAAO;AAC7E,UAAM,SAAS,KAAK,eAAe,IAAI,OAAO;AAC9C,QAAI,WAAW,OAAW;AAC1B,UAAM,EAAE,OAAO,UAAU,wBAAwB,IAAI;AACrD,QAAI,mBAAmB,CAAC,wBAAyB;AACjD,WAAO,MAAM,8BAA8B,OAAO,gBAAgB,cAAc,EAAE;AAClF,QAAI,UAAU,QAAW;AACrB,YAAM,KAAK;AAAA,IACf;AACA,QAAI,gBAAgB;AAChB,eAAS;AAAA,IACb;AACA,SAAK,eAAe,OAAO,OAAO;AAAA,EACtC;AAAA;AAAA,EAGA,WAAW,SAAiB;AACxB,WAAO,KAAK,eAAe,IAAI,OAAO;AAAA,EAC1C;AAAA,EAEA,8BAA8B,eAA0B,QAAgB;AACpE,UAAM,sBAAsB,cAAc,MAAM,EAAE,YAAY;AAC9D,WAAO,qBAAqB,qBAAqB,OAAO,YAAY,MAAM,CAAC;AAAA,EAC/E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,sBACF,EAAE,cAAc,GAChB,QACA,gBACA,wBAAwB,OACc;AACtC,QAAI,KAAK,UAAU;AACf,YAAM,IAAI,oBAAoB,gEAAgE;AAAA,IAClG;AACA,UAAM,oBAAoB,KAAK,8BAA8B,eAAe,MAAM;AAElF,QAAI,eAAe,wBAAwB,SAAY,KAAK,6BAA6B,iBAAiB;AAC1G,QAAI,iBAAiB,QAAW;AAC5B,YAAM,EAAE,QAAQ,IAAI,MAAM,KAAK,uBAAuB,mBAAmB,cAAc;AAEvF,WAAK,iBAAiB,mBAAmB;AAAA,QACrC;AAAA,UACI,MAAM;AAAA,UACN,aAAa,eAAe;AAAA,UAC5B,YAAY,cAAc;AAAA,QAC9B;AAAA,MACJ,CAAC;AAED,YAAM;AACN,qBAAe,KAAK,6BAA6B,iBAAiB;AAClE,WAAK,aAAa,iBAAiB;AAAA,IACvC;AACA,WAAO;AAAA,EACX;AAAA,EAEA,iCAAiC,QAAgB,QAAgB;AAC7D,UAAM,oBAAoB,KAAK,8BAA8B,OAAO,eAAe,MAAM;AACzF,SAAK,cAAc,mBAAmB,IAAI;AAAA,EAC9C;AAAA,EAEA,oCAAoC,YAA6C;AAC7E,UAAM,UAAU,KAAK,oCAAoC,UAAU;AACnE,SAAK,cAAc,SAAS,IAAI;AAAA,EACpC;AAAA,EAEA,+BAA+B,EAAE,cAAc,GAAW,QAAgB;AACtE,WAAO,KAAK,6BAA6B,KAAK,8BAA8B,eAAe,MAAM,CAAC;AAAA,EACtG;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gCAAgC,YAA6C;AACzE,UAAM,gBAAgB,MAAM,KAAK,KAAK,6BAA6B,OAAO,CAAC;AAE3E,UAAM,eAAe,IAAI,MAA4C;AACrE,QAAI,gBAAgB,YAAY;AAC5B,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,WAAW,MAAM,eAAe,WAAW,UAAU,CAAC;AAAA,IACvG,WAAW,uBAAuB,YAAY;AAC1C,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,EAAE,MAAM,MAAM,WAAW,iBAAiB,CAAC;AAAA,IAC5F,WAAW,wBAAwB,YAAY;AAC3C,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,GAAG,MAAM,OAAO,WAAW,kBAAkB,CAAC;AAAA,IAC/F,WAAW,cAAc,YAAY;AACjC,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,EAAE,MAAM,MAAM,WAAW,QAAQ,CAAC;AAAA,IACnF,WAAW,gBAAgB,YAAY;AACnC,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,GAAG,MAAM,OAAO,WAAW,UAAU,CAAC;AAAA,IACvF,WAAW,eAAe,YAAY;AAClC,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,EAAE,MAAM,MAAM,WAAW,SAAS,CAAC;AAAA,IACpF,WAAW,OAAO,KAAK,UAAU,EAAE,WAAW,GAAG;AAC7C,mBAAa,KAAK,GAAG,cAAc,OAAO,CAAC,EAAE,GAAG,MAAM,OAAO,KAAK,OAAO,CAAC,CAAC;AAAA,IAC/E;AAEA,WAAO,aAAa,IAAI,YAAU;AAC9B,aAAO;AAAA,QACH,GAAG;AAAA,QACH,WAAW,KAAK,mBAAmB,MAAM,KAAK,OAAO,UAAU,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,KAAK,OAAO;AAAA,UAC7F;AAAA,UACA;AAAA,UACA,MAAM;AAAA,QACV,EAAE;AAAA,QACF,SAAS;AAAA,MACb;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oCAAoC,YAA6C;AAC7E,QAAI,gBAAgB,YAAY;AAC5B,aAAO,uBAAuB,WAAW,UAAU;AAAA,IACvD,WAAW,uBAAuB,YAAY;AAC1C,aAAO,0BAA0B,WAAW,iBAAiB;AAAA,IACjE,WAAW,wBAAwB,YAAY;AAC3C,aAAO,2BAA2B,WAAW,kBAAkB;AAAA,IACnE,WAAW,cAAc,YAAY;AACjC,aAAO,eAAe,WAAW,QAAQ;AAAA,IAC7C,WAAW,gBAAgB,YAAY;AACnC,aAAO,mBAAmB,WAAW,UAAU;AAAA,IACnD,WAAW,eAAe,YAAY;AAElC,aAAO,KAAK,WAAW,SAAS;AAAA,IACpC,WAAW,OAAO,KAAK,UAAU,EAAE,WAAW,GAAG;AAC7C,aAAO,0BAA0B;AAAA,IACrC;AACA,UAAM,IAAI,oBAAoB,8CAA8C,OAAO,OAAO,UAAU,CAAC,EAAE;AAAA,EAC3G;AAAA,EAEA,mBAAmB,cAAsB;AACrC,UAAM,wBAAwB,aAAa,QAAQ,GAAG;AACtD,QAAI,0BAA0B,IAAI;AAC9B,aAAO,aAAa,UAAU,GAAG,qBAAqB;AAAA,IAC1D;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,mCAAmC,cAAsB,QAA8C;AACnG,QAAI,KAAK,UAAU;AACf,YAAM,IAAI,oBAAoB,mEAAmE;AAAA,IACrG;AACA,UAAM,kBAAkB,KAAK,oCAAoC;AAAA,MAC7D,YAAY,KAAK,mBAAmB,YAAY;AAAA,IACpD,CAAC;AACD,QAAI,KAAK,uBAAuB,IAAI,eAAe,GAAG;AAClD,aAAO;AAAA,IACX;AAEA,UAAM,2BAA2B,KAAK,oCAAoC,EAAE,mBAAmB,OAAO,EAAE,CAAC;AACzG,QAAI,KAAK,uBAAuB,IAAI,wBAAwB,GAAG;AAC3D,aAAO;AAAA,IACX;AAEA,UAAM,4BAA4B,KAAK,oCAAoC,EAAE,oBAAoB,OAAO,GAAG,CAAC;AAC5G,QAAI,KAAK,uBAAuB,IAAI,yBAAyB,GAAG;AAC5D,aAAO;AAAA,IACX;AAEA,QAAI,OAAO,MAAM,QAAW;AACxB,YAAM,kBAAkB,KAAK,oCAAoC,EAAE,UAAU,SAAS,OAAO,CAAC,EAAE,CAAC;AACjG,UAAI,KAAK,uBAAuB,IAAI,eAAe,GAAG;AAClD,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,QAAI,OAAO,OAAO,QAAW;AACzB,YAAM,oBAAoB,KAAK,oCAAoC,EAAE,YAAY,OAAO,GAAG,CAAC;AAC5F,UAAI,KAAK,uBAAuB,IAAI,iBAAiB,GAAG;AACpD,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,QAAI,OAAO,MAAM,QAAW;AACxB,YAAM,mBAAmB,KAAK,oCAAoC,EAAE,WAAW,OAAO,EAAE,CAAC;AACzF,UAAI,KAAK,uBAAuB,IAAI,gBAAgB,GAAG;AACnD,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,UAAM,2BAA2B,KAAK,oCAAoC,CAAC,CAAC;AAC5E,QAAI,KAAK,uBAAuB,IAAI,wBAAwB,GAAG;AAC3D,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,+BAA+B,YAAyD;AACpF,UAAM,QAAQ,IAAI,MAAc;AAEhC,UAAM,KAAK,+BAA+B;AAE1C,QAAI,gBAAgB,YAAY;AAC5B,YAAM,KAAK,uBAAuB,WAAW,UAAU,CAAC;AAAA,IAC5D,WAAW,uBAAuB,YAAY;AAC1C,YAAM,KAAK,0BAA0B,WAAW,iBAAiB,CAAC;AAAA,IACtE,WAAW,wBAAwB,YAAY;AAC3C,YAAM,KAAK,2BAA2B,WAAW,kBAAkB,CAAC;AAAA,IACxE,WAAW,cAAc,YAAY;AACjC,YAAM,KAAK,eAAe,WAAW,QAAQ,CAAC;AAAA,IAClD,WAAW,gBAAgB,YAAY;AACnC,YAAM,KAAK,mBAAmB,WAAW,UAAU,CAAC;AAAA,IACxD,OAAO;AAEH,YAAM,KAAK,0BAA0B,CAAC;AAAA,IAC1C;AAEA,WAAO,MAAM,IAAI,WAAS,EAAE,MAAM,aAAa,eAAe,IAAI,YAAY,cAAc,IAAI,EAAE;AAAA,EACtG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,0BACF,YACA,iBAAiB,GACjB,wBAAwB,OACO;AAC/B,QAAI,gBAAgB,wBACd,CAAC,IACD,KAAK,gCAAgC,UAAU,EAAE,OAAO,CAAC,EAAE,UAAU,MAAM,UAAU,SAAS,CAAC;AACrG,QAAI,cAAc,WAAW,GAAG;AAC5B,YAAM,UAAU,KAAK,oCAAoC,UAAU;AACnE,YAAM,EAAE,QAAQ,IAAI,MAAM,KAAK,uBAAuB,SAAS,cAAc;AAE7E,WAAK,iBAAiB,SAAS,KAAK,+BAA+B,UAAU,CAAC;AAE9E,YAAM;AACN,sBAAgB,KAAK,gCAAgC,UAAU;AAC/D,WAAK,aAAa,OAAO;AAAA,IAC7B;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,sCACF,YACA,UACA,iBAAiB,KACc;AAC/B,UAAM,oBAAoB,oBAAI,IAAY;AAE1C,UAAM,mBAAmB,KAAK,MAAM,IAAI,iBAAiB;AACzD,UAAM,UAAU,KAAK,oCAAoC,UAAU;AACnE,SAAK,iBAAiB,SAAS,KAAK,+BAA+B,UAAU,CAAC;AAE9E,WAAO,MAAM;AACT,WAAK,gCAAgC,UAAU,EAAE,QAAQ,YAAU;AAC/D,cAAM,EAAE,iBAAiB,IAAI;AAC7B,YAAI,CAAC,kBAAkB,IAAI,gBAAgB,GAAG;AAC1C,4BAAkB,IAAI,gBAAgB;AACtC,mBAAS,MAAM;AAAA,QACnB;AAAA,MACJ,CAAC;AAED,YAAM,gBAAgB,KAAK,MAAM,mBAAmB,KAAK,MAAM,KAAK,GAAI;AACxE,UAAI,iBAAiB,GAAG;AACpB;AAAA,MACJ;AACA,YAAM,EAAE,QAAQ,IAAI,MAAM,KAAK,uBAAuB,SAAS,eAAe,KAAK;AACnF,YAAM;AAAA,IACV;AACA,WAAO,KAAK,gCAAgC,UAAU;AAAA,EAC1D;AAAA,EAEA,mCAAmC,YAA6C;AAC5E,WAAO,KAAK,gCAAgC,UAAU;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACV,SAAK,WAAW;AAChB,SAAK,eAAe,KAAK;AACzB,SAAK,aAAa,KAAK;AACvB,UAAM,KAAK,iBAAiB,MAAM;AAElC,KAAC,GAAG,KAAK,eAAe,KAAK,CAAC,EAAE;AAAA,MAAQ,aACpC,KAAK,cAAc,SAAS,CAAC,CAAC,KAAK,eAAe,IAAI,OAAO,GAAG,KAAK;AAAA,IACzE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,cAAyB,WAAmB,cAAsB;AAChF,QAAI,KAAK,SAAU;AACnB,UAAM,UAAU,SAAS,OAAO,YAAY;AAC5C,QAAI,YAAY,OAAW;AAC3B,QAAI,QAAQ,gBAAgB,eAAe,YAAY,QAAQ,gBAAgB,eAAe;AAC1F;AAEJ,UAAM,UAAU,CAAC,GAAG,QAAQ,SAAS,GAAG,QAAQ,iBAAiB;AAGjE,QAAI,KAAK,0BAA0B,SAAS,KAAK,8BAA8B,GAAG,YAAY,EAAG;AAGjG,SAAK,6BAA6B,SAAS,KAAK,8BAA8B,GAAG,YAAY;AAAA,EACjG;AAAA,EAEA,iBACI,SACA,QACA,cACgC;AAChC,UAAM,YAAY,QAAQ;AAAA,MACtB,CAAC,EAAE,MAAM,WAAW,OACd,eAAe,cAAc,KAAK,KAAK,eAAgB,eAAe,cAAc,SACtF,SAAS;AAAA,IACjB;AACA,WAAQ,UAAkC,IAAI,CAAC,EAAE,OAAO,IAAI,OAAO;AAAA,MAC/D,OAAO,MAAM,WAAW,QAAQ,IAAI,GAAG,KAAK,IAAI,YAAY,KAAK;AAAA,MACjE;AAAA,IACJ,EAAE;AAAA,EACN;AAAA,EAEA,0BAA0B,SAA2B,eAAiC,cAAsB;AACxG,QAAI,iBAAiB;AAErB,UAAM,uBAAuB,QAAQ;AAAA,MACjC,CAAC,EAAE,MAAM,WAAW,MAAM,eAAe,cAAc,OAAO,KAAK,SAAS,oBAAoB;AAAA,IACpG;AACA,QAAI,yBAAyB,QAAW;AACpC,WAAK,4BAA4B,sBAAsB,YAAY;AACnE,uBAAiB;AAAA,IACrB;AAEA,UAAM,uBACF,QAAQ;AAAA,MACJ,CAAC,EAAE,MAAM,WAAW,MAAM,eAAe,cAAc,OAAO,KAAK,SAAS,oBAAoB;AAAA,IACpG,KACA,cAAc;AAAA,MACV,CAAC,EAAE,MAAM,WAAW,MAAM,eAAe,cAAc,OAAO,KAAK,SAAS,oBAAoB;AAAA,IACpG;AAEJ,QAAI,yBAAyB,QAAW;AACpC,WAAK,4BAA4B,sBAAsB,SAAS,eAAe,YAAY;AAC3F,uBAAiB;AAAA,IACrB;AACA,WAAO;AAAA,EACX;AAAA,EAEA,4BAA4B,QAAwB,cAAsB;AACtE,UAAM,EAAE,MAAM,YAAY,OAAO,IAAI,IAAI;AAGzC,QAAI,QAAQ,GAAG;AACX,UAAI,KAAK,0BAA0B,IAAI,UAAU,GAAG;AAChD,eAAO;AAAA,UACH,+BAA+B,UAAU,0BAA0B,YAAY;AAAA,QACnF;AACA,aAAK,0BAA0B,OAAO,UAAU;AAAA,MACpD;AACA;AAAA,IACJ;AACA,QAAI,CAAC,MAAM,QAAQ,KAAK,EAAG;AAE3B,UAAM,UAAU,KAAK,gBAAgB,MAAM;AAC3C,QAAI,YAAY,OAAW;AAC3B,QAAI,SAAS,KAAK,0BAA0B,IAAI,UAAU;AAC1D,QAAI,WAAW,QAAW;AACtB,eAAS;AAAA,QACL,GAAG;AAAA,QACH,SAAS,KAAK,MAAM,IAAI,MAAM;AAAA,QAC9B,GAAG;AAAA,MACP;AAAA,IACJ,OAAO;AACH,aAAO;AAAA,QACH,6BAA6B,UAAU,wBAAwB,YAAY;AAAA,QAC3E,YAAY,yBAAyB,OAAO;AAAA,MAChD;AACA,eAAS;AAAA,QACL,kBAAkB;AAAA,QAClB,WAAW,oBAAI,IAA0C;AAAA,QACzD,SAAS,KAAK,MAAM,IAAI,MAAM;AAAA,QAC9B,GAAG;AAAA,MACP;AAAA,IACJ;AAEA,SAAK,0BAA0B,IAAI,YAAY,MAAM;AAAA,EACzD;AAAA,EAEA,4BACI,QACA,SACA,eACA,cACF;AACE,UAAM;AAAA,MACF,MAAM;AAAA,MACN;AAAA,MACA,OAAO,EAAE,QAAQ,KAAK;AAAA,IAC1B,IAAI;AAGJ,QAAI,QAAQ,GAAG;AACX,UAAI,KAAK,0BAA0B,IAAI,UAAU,GAAG;AAChD,eAAO;AAAA,UACH,+BAA+B,UAAU,0BAA0B,YAAY;AAAA,QACnF;AACA,aAAK,0BAA0B,OAAO,UAAU;AAAA,MACpD;AACA,aAAO;AAAA,IACX;AAEA,UAAM,MAAM,KAAK,iBAAiB,CAAC,GAAG,SAAS,GAAG,aAAa,GAAG,QAAQ,YAAY;AACtF,UAAM,gBAAgB,KAAK,0BAA0B,IAAI,UAAU;AACnE,UAAM,SAAS,KAAK,0BAA0B,IAAI,UAAU,KAAK;AAAA,MAC7D,kBAAkB;AAAA,MAClB,WAAW,oBAAI,IAA0C;AAAA,MACzD,SAAS,KAAK,MAAM,IAAI,MAAM;AAAA,IAClC;AACA,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,IAAI,SAAS,GAAG;AAChB,iBAAW,EAAE,OAAO,IAAI,KAAAC,KAAI,KAAK,KAAK;AAClC,YAAIA,SAAQ,GAAG;AACX,iBAAO;AAAA,YACH,eAAe,EAAE,2BAA2B,UAAU,0BAA0B,YAAY;AAAA,UAChG;AACA,oBAAU,OAAO,EAAE;AACnB;AAAA,QACJ;AACA,cAAM,eAAe,UAAU,IAAI,EAAE,KAAK,EAAE,IAAI,MAAM,MAAM,OAAO,SAAS,EAAE;AAC9E,qBAAa,UAAU,KAAK,MAAM,IAAIA,OAAM;AAE5C,kBAAU,IAAI,aAAa,IAAI,YAAY;AAAA,MAC/C;AACA,aAAO,YAAY;AACnB,UAAI,CAAC,KAAK,0BAA0B,IAAI,UAAU,GAAG;AACjD,eAAO;AAAA,UACH,oCAAoC,UAAU,wBAAwB,YAAY;AAAA,UAClF,GAAG,YAAY,yBAAyB,SAAS;AAAA,QACrD;AAAA,MACJ;AACA,WAAK,0BAA0B,IAAI,YAAY,MAAM;AAAA,IACzD;AAEA,QAAI,UAAU,SAAS,KAAK,KAAK,WAAW,UAAU,GAAG;AAErD,YAAM,UAAU,CAAC,EAAE,MAAM,QAAQ,aAAa,eAAe,IAAI,YAAY,cAAc,KAAK,CAAC;AACjG,UAAI,KAAK,aAAa;AAClB,gBAAQ,KAAK,EAAE,MAAM,QAAQ,aAAa,eAAe,IAAI,YAAY,cAAc,EAAE,CAAC;AAAA,MAC9F;AACA,aAAO,MAAM,kDAAkD,UAAU,eAAe,YAAY,IAAI;AACxG,WAAK,iBAAiB,YAAY,SAAS,OAAO;AAAA,IACtD,WAAW,UAAU,OAAO,GAAG;AAC3B,WAAK,cAAc,YAAY,MAAM,aAAa;AAAA,IACtD;AACA,WAAO;AAAA,EACX;AAAA,EAEA,6BAA6B,SAA2B,eAAiC,cAAsB;AAE3G,QAAI,wBAAwB,QAAQ,OAAO,CAAC,EAAE,KAAK,MAAM,KAAK,SAAS,+BAA+B,CAAC;AACvG,QAAI,CAAC,sBAAsB,QAAQ;AAC/B,8BAAwB,cAAc,OAAO,CAAC,EAAE,KAAK,MAAM,KAAK,SAAS,+BAA+B,CAAC;AACzG,UAAI,CAAC,sBAAsB,OAAQ;AAAA,IACvC;AAEA,UAAM,+BAA+B,oBAAI,IAAY;AAGrD,UAAM,aAAa,sBAAsB,OAAO,CAAC,EAAE,WAAW,MAAM,eAAe,cAAc,GAAG;AACpG,eAAW,UAAU,YAAY;AAC7B,YAAM,EAAE,MAAM,IAAI,IAAI;AACtB,UAAI,QAAQ,GAAG;AACX,YAAI,KAAK,6BAA6B,IAAI,IAAI,GAAG;AAC7C,iBAAO;AAAA,YACH,kCAAkC,IAAI,0BAA0B,YAAY;AAAA,UAChF;AACA,eAAK,6BAA6B,OAAO,IAAI;AAAA,QACjD;AACA;AAAA,MACJ;AACA,YAAM,eAAe,KAAK,8BAA8B,MAAM;AAC9D,UAAI,iBAAiB,OAAW;AAChC,mBAAa,aAAa,KAAK,mBAAmB,IAAI;AACtD,mBAAa,mBAAmB,aAAa;AAC7C,UAAI,aAAa,MAAM,UAAa,aAAa,OAAO,QAAW;AAC/D,qBAAa,KAAM,aAAa,KAAK,IAAK;AAAA,MAC9C;AACA,UAAI,aAAa,OAAO,QAAW;AAC/B,cAAM,aAAa,aAAa,GAAG,MAAM,GAAG;AAC5C,qBAAa,IAAI,WAAW,CAAC,MAAM,SAAY,SAAS,WAAW,CAAC,CAAC,IAAI;AACzE,qBAAa,IAAI,WAAW,CAAC,MAAM,SAAY,SAAS,WAAW,CAAC,CAAC,IAAI;AAAA,MAC7E;AAEA,YAAM,eAAe,KAAK,6BAA6B,IAAI,IAAI;AAC/D,UAAI,iBAAiB,QAAW;AAC5B,qCAA6B,IAAI,IAAI;AAErC,eAAO;AAAA,UACH,+BAA+B,IAAI;AAAA,UACnC,YAAY,yBAAyB,YAAY;AAAA,QACrD;AAAA,MACJ,OAAO;AACH,qBAAa,YAAY,aAAa;AAAA,MAC1C;AACA,WAAK,6BAA6B,IAAI,MAAM,YAAY;AAAA,IAC5D;AAGA,UAAM,aAAa,sBAAsB,OAAO,CAAC,EAAE,WAAW,MAAM,eAAe,cAAc,GAAG;AACpG,eAAW,UAAU,YAAY;AAC7B,YAAM,eAAe,KAAK,6BAA6B,IAAI,OAAO,IAAI;AACtE,UAAI,iBAAiB,OAAW;AAChC,YAAM;AAAA,QACF,OAAO,EAAE,QAAQ,KAAK;AAAA,QACtB;AAAA,MACJ,IAAI;AACJ,UAAI,QAAQ,GAAG;AACX,eAAO;AAAA,UACH,kCAAkC,OAAO,IAAI,0BAA0B,YAAY;AAAA,QACvF;AACA,aAAK,6BAA6B,OAAO,OAAO,IAAI;AACpD;AAAA,MACJ;AAEA,YAAM,iBAAiB,aAAa,UAAU,OAAO;AAErD,YAAM,MAAM,KAAK,iBAAiB,CAAC,GAAG,SAAS,GAAG,aAAa,GAAG,QAAQ,YAAY;AACtF,UAAI,IAAI,SAAS,GAAG;AAChB,mBAAW,EAAE,OAAO,IAAI,KAAAA,KAAI,KAAK,KAAK;AAClC,cAAIA,SAAQ,GAAG;AACX,mBAAO;AAAA,cACH,eAAe,EAAE,8BAA8B,OAAO,IAAI,0BAA0B,YAAY;AAAA,YACpG;AACA,yBAAa,UAAU,OAAO,EAAE;AAChC;AAAA,UACJ;AACA,gBAAM,eAAe,aAAa,UAAU,IAAI,EAAE,KAAK,EAAE,IAAI,MAAM,MAAM,OAAO,SAAS,EAAE;AAC3F,uBAAa,UAAU,KAAK,MAAM,IAAIA,OAAM;AAE5C,uBAAa,UAAU,IAAI,IAAI,YAAY;AAAA,QAC/C;AAAA,MACJ;AACA,WAAK,6BAA6B,IAAI,OAAO,MAAM,YAAY;AAC/D,UAAI,aAAa,UAAU,SAAS,GAAG;AACnC,cAAMC,WAAU,KAAK,mCAAmC,IAAI,YAAY;AACxE,YAAIA,aAAY,OAAW;AAE3B,cAAM,UAAU,CAAC,EAAE,MAAM,QAAQ,aAAa,eAAe,IAAI,YAAY,cAAc,KAAK,CAAC;AACjG,YAAI,KAAK,aAAa;AAClB,kBAAQ,KAAK,EAAE,MAAM,QAAQ,aAAa,eAAe,IAAI,YAAY,cAAc,EAAE,CAAC;AAAA,QAC9F;AACA,eAAO;AAAA,UACH,qDAAqD,OAAO,IAAI,eAAe,YAAY;AAAA,QAC/F;AACA,aAAK,iBAAiBA,UAAS,SAAS,OAAO;AAAA,MACnD;AACA,UAAI,aAAa,UAAU,SAAS,EAAG;AAEvC,YAAM,UAAU,KAAK,mCAAmC,OAAO,MAAM,YAAY;AACjF,UAAI,YAAY,OAAW;AAE3B,mCAA6B,OAAO,OAAO,IAAI;AAC/C,WAAK,cAAc,SAAS,MAAM,cAAc;AAAA,IACpD;AAGA,QAAI,6BAA6B,SAAS,GAAG;AACzC,iBAAW,QAAQ,MAAM,KAAK,6BAA6B,OAAO,CAAC,GAAG;AAClE,cAAM,eAAe,KAAK,6BAA6B,IAAI,IAAI;AAC/D,YAAI,iBAAiB,OAAW;AAChC,cAAM,UAAU,KAAK,mCAAmC,IAAI,YAAY;AACxE,YAAI,YAAY,OAAW;AAC3B,eAAO,MAAM,qDAAqD,IAAI,eAAe,YAAY,IAAI;AACrG,aAAK;AAAA,UACD;AAAA,UACA,CAAC,EAAE,MAAM,aAAa,eAAe,IAAI,YAAY,cAAc,IAAI,CAAC;AAAA,UACxE;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,gBAAgB,QAAmD;AAC/D,UAAM,EAAE,MAAM,IAAI;AAClB,UAAM,SAAS,CAAC;AAChB,QAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,iBAAW,QAAQ,OAAO;AACtB,cAAM,CAAC,KAAKC,MAAK,IAAI,KAAK,MAAM,GAAG;AACnC,YAAI,QAAQ,UAAaA,WAAU,OAAW;AAC9C,YAAI,CAAC,OAAO,OAAO,OAAO,KAAK,KAAK,MAAM,MAAM,MAAM,KAAK,EAAE,SAAS,GAAG,GAAG;AACxE,gBAAM,WAAW,SAASA,MAAK;AAC/B,cAAI,MAAM,QAAQ,EAAG;AACrB,iBAAO,GAAG,IAAI;AAAA,QAClB,WAAW,CAAC,MAAM,MAAM,MAAM,IAAI,EAAE,SAAS,GAAG,GAAG;AAC/C,iBAAO,GAAG,IAAIA;AAAA,QAClB;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,OAAO,MAAM,QAAW;AACxB,aAAO,IAAI;AAAA,IACf,WAAW,OAAO,MAAM,GAAG;AAEvB,aAAO,IAAI;AAAA,IACf;AACA,QAAI,OAAO,QAAQ,QAAW;AAC1B,aAAO,MAAM;AAAA,IACjB;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,8BAA8B,QAA0E;AACpG,UAAM,EAAE,OAAO,IAAI,IAAI;AACvB,QAAI,CAAC,MAAM,QAAQ,KAAK,EAAG,QAAO;AAClC,UAAM,SAAS;AAAA,MACX,WAAW,oBAAI,IAA2B;AAAA,MAC1C,SAAS,KAAK,MAAM,IAAI,MAAM;AAAA,MAC9B,GAAG,KAAK,gBAAgB,MAAM;AAAA,IAClC;AACA,QAAI,OAAO,MAAM,UAAa,OAAO,OAAO,OAAW,QAAO;AAC9D,WAAO;AAAA,EACX;AAAA,EAEA,UAAU;AACN,UAAM,MAAM,KAAK,MAAM;AACvB,KAAC,GAAG,KAAK,0BAA0B,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC,WAAW,EAAE,WAAW,QAAQ,CAAC,MAAM;AAC3F,UAAI,MAAM,SAAS;AACf,SAAC,GAAG,UAAU,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK,EAAE,SAAAC,SAAQ,CAAC,MAAM;AACrD,cAAI,MAAMA,SAAS;AACnB,oBAAU,OAAO,GAAG;AAAA,QACxB,CAAC;AAAA,MACL;AACA,UAAI,OAAO,WAAW,UAAU,SAAS,GAAG;AACxC,aAAK,0BAA0B,OAAO,SAAS;AAAA,MACnD;AAAA,IACJ,CAAC;AACD,KAAC,GAAG,KAAK,6BAA6B,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC,WAAW,EAAE,WAAW,QAAQ,CAAC,MAAM;AAC9F,UAAI,MAAM,SAAS;AAEf,SAAC,GAAG,UAAU,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK,EAAE,SAAAA,SAAQ,CAAC,MAAM;AACrD,cAAI,MAAMA,SAAS;AACnB,oBAAU,OAAO,GAAG;AAAA,QACxB,CAAC;AAAA,MACL;AACA,UAAI,OAAO,WAAW,UAAU,SAAS,GAAG;AACxC,aAAK,6BAA6B,OAAO,SAAS;AAAA,MACtD;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,OAAO,yBAAyB,MAAqB;AACjD,WAAO,WAAW,KAAK;AAAA,MACnB,KAAK,KAAK;AAAA,MACV,KAAK,KAAK;AAAA,MACV,KAAK,KAAK;AAAA,MACV,GAAG,KAAK;AAAA,MACR,IAAI,KAAK;AAAA,MACT,IAAI,KAAK;AAAA,MACT,KAAK,KAAK;AAAA,MACV,IAAI,KAAK;AAAA,MACT,IAAI,KAAK;AAAA,MACT,IAAI,KAAK;AAAA,MACT,IAAI,KAAK;AAAA,IACb,CAAC;AAAA,EACL;AAAA,EAEA,OAAO,yBAAyB,WAAsD;AAClF,WAAO,MAAM,KAAK,UAAU,OAAO,CAAC,EAAE;AAAA,MAAI,aACtC,WAAW,KAAK;AAAA,QACZ,IAAI,QAAQ;AAAA,QACZ,MAAM,QAAQ;AAAA,QACd,MAAM,QAAQ;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;",
  "names": ["queries", "answers", "ttl", "queryId", "value", "expires"]
}
