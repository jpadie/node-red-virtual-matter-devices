{
  "version": 3,
  "sources": ["../../../src/datatype/NodeId.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { UnexpectedDataError } from \"../common/MatterError.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { TlvUInt64 } from \"../tlv/TlvNumber.js\";\nimport { TlvWrapper } from \"../tlv/TlvWrapper.js\";\nimport { Endian } from \"../util/ByteArray.js\";\nimport { DataWriter } from \"../util/DataWriter.js\";\nimport { toBigInt } from \"../util/Number.js\";\nimport { Branded } from \"../util/Type.js\";\nimport { CaseAuthenticatedTag } from \"./CaseAuthenticatedTag.js\";\n\n/**\n * A Node Identifier (Node ID) is a 64-bit number that uniquely identifies an individual Node or a\n * group of Nodes on a Fabric.\n *\n * @see {@link MatterSpecification.v10.Core} \u00A7 2.5.5\n */\nexport type NodeId = Branded<bigint, \"NodeId\">;\n\nexport function NodeId(v: bigint | number): NodeId {\n    return toBigInt(v) as NodeId;\n}\n\nexport namespace NodeId {\n    const OPERATIONAL_NODE_MIN = BigInt(\"0x0000000000000001\");\n    const OPERATIONAL_NODE_MAX = BigInt(\"0xFFFFFFEFFFFFFFFF\");\n\n    /**\n     * The Unspecified Node ID (0x0000_0000_0000_0000) is a reserved value that never appears in messages or protocol\n     * usage. It exists to mark or detect the presence of uninitialized, missing, or invalid Node IDs.\n     */\n    export const UNSPECIFIED_NODE_ID = NodeId(0);\n\n    export const toHexString = (nodeId: NodeId) => {\n        const writer = new DataWriter(Endian.Big);\n        writer.writeUInt64(nodeId);\n        return writer.toByteArray().toHex().toUpperCase();\n    };\n\n    /**\n     * An Operational Node ID is a 64-bit number that uniquely identifies an individual Node on a Fabric. All messages\n     * must have an Operational Node ID as the source address. All unicast messages must have an Operational Node ID\n     * as the destination address.\n     */\n    export const randomOperationalNodeId = (): NodeId => {\n        while (true) {\n            const randomBigInt = Crypto.getRandomBigInt(8);\n            if (randomBigInt >= OPERATIONAL_NODE_MIN && randomBigInt <= OPERATIONAL_NODE_MAX) {\n                return NodeId(randomBigInt);\n            }\n        }\n    };\n\n    /**\n     * Returns whether the given Node ID is an Operational Node ID.\n     */\n    export const isOperationalNodeId = (nodeId: NodeId): boolean => {\n        return nodeId >= OPERATIONAL_NODE_MIN && nodeId <= OPERATIONAL_NODE_MAX;\n    };\n\n    /** A Group Node ID is a 64-bit Node ID that contains a particular Group ID in the lower half of the Node ID. */\n    export const fromGroupNodeId = (groupId: number): NodeId => {\n        if (groupId < 0 || groupId > 0xffff) {\n            throw new UnexpectedDataError(`Invalid group ID: ${groupId}`);\n        }\n        return NodeId(BigInt(\"0xFFFFFFFFFFFF\" + groupId.toString(16).padStart(4, \"0\")));\n    };\n\n    /**\n     * A Temporary Local Node ID is a 64-bit Node ID that contains an implementation-dependent value in its lower\n     * 32 bits. This allows implementations to keep track of connections or transport-layer links and similar\n     * housekeeping internal usage purposes in contexts where an Operational Node ID is unavailable.\n     */\n    export const fromTemporaryLocalNodeId = (id: number): NodeId => {\n        if (id < 0 || id > 0xffffffff) {\n            throw new UnexpectedDataError(`Invalid ID: ${id}`);\n        }\n        return NodeId(BigInt(\"0xFFFFFFFE\" + id.toString(16).padStart(8, \"0\")));\n    };\n\n    /**\n     * This subrange of Node ID is used to assign an access control subject to a group of peer nodes that share a\n     * single CASE session as specified in Section 6.6.2.1.2, \u201CSubjects identified by CASE Authenticated Tag\u201D.\n     */\n    export const fromCaseAuthenticatedTag = (id: CaseAuthenticatedTag): NodeId => {\n        if (id < 0 || id > 0xffffffff) {\n            throw new UnexpectedDataError(`Invalid CASE Authenticated tag: ${id}`);\n        }\n        return NodeId(BigInt(\"0xFFFFFFFD\" + id.toString(16).padStart(8, \"0\")));\n    };\n\n    export const isCaseAuthenticatedTag = (nodeId: NodeId): boolean => {\n        const nodeIdHex = nodeId.toString(16);\n        return nodeIdHex.startsWith(\"fffffffd\") && nodeIdHex.length === 16;\n    };\n\n    export const extractAsCaseAuthenticatedTag = (nodeId: NodeId): CaseAuthenticatedTag => {\n        if (!isCaseAuthenticatedTag(nodeId)) {\n            throw new UnexpectedDataError(`Invalid CASE Authenticated tag: ${nodeId}`);\n        }\n        return CaseAuthenticatedTag(parseInt(nodeId.toString(16).slice(8), 16));\n    };\n\n    /**\n     * This subrange of Node ID is used to assign an access control subject to a particular PAKE key as specified in\n     * Section 6.6.2.1.1, \u201CPASE and Group Subjects\u201D. An example usage would be to create an ACL entry to provide\n     * administrative access to any commissioner communicating via a PASE session established with a particular pincode.\n     */\n    export const getFromPakeKeyIdentifier = (id: number): NodeId => {\n        if (id < 0 || id > 0xffffffff) {\n            throw new UnexpectedDataError(`Invalid ID: ${id}`);\n        }\n        return NodeId(BigInt(\"0xFFFFFFFB\" + id.toString(16).padStart(8, \"0\")));\n    };\n}\n\n/** Tlv schema for a Node Identifier. */\nexport const TlvNodeId = new TlvWrapper<NodeId, number | bigint>(\n    TlvUInt64,\n    nodeId => nodeId,\n    value => NodeId(BigInt(value)),\n);\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,2BAA2B;AACpC,SAAS,cAAc;AACvB,SAAS,iBAAiB;AAC1B,SAAS,kBAAkB;AAC3B,SAAS,cAAc;AACvB,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AAEzB,SAAS,4BAA4B;AAU9B,SAAS,OAAO,GAA4B;AAC/C,SAAO,SAAS,CAAC;AACrB;AAAA,CAEO,CAAUA,YAAV;AACH,QAAM,uBAAuB,OAAO,oBAAoB;AACxD,QAAM,uBAAuB,OAAO,oBAAoB;AAMjD,EAAMA,QAAA,sBAAsBA,QAAO,CAAC;AAEpC,EAAMA,QAAA,cAAc,CAAC,WAAmB;AAC3C,UAAM,SAAS,IAAI,WAAW,OAAO,GAAG;AACxC,WAAO,YAAY,MAAM;AACzB,WAAO,OAAO,YAAY,EAAE,MAAM,EAAE,YAAY;AAAA,EACpD;AAOO,EAAMA,QAAA,0BAA0B,MAAc;AACjD,WAAO,MAAM;AACT,YAAM,eAAe,OAAO,gBAAgB,CAAC;AAC7C,UAAI,gBAAgB,wBAAwB,gBAAgB,sBAAsB;AAC9E,eAAOA,QAAO,YAAY;AAAA,MAC9B;AAAA,IACJ;AAAA,EACJ;AAKO,EAAMA,QAAA,sBAAsB,CAAC,WAA4B;AAC5D,WAAO,UAAU,wBAAwB,UAAU;AAAA,EACvD;AAGO,EAAMA,QAAA,kBAAkB,CAAC,YAA4B;AACxD,QAAI,UAAU,KAAK,UAAU,OAAQ;AACjC,YAAM,IAAI,oBAAoB,qBAAqB,OAAO,EAAE;AAAA,IAChE;AACA,WAAOA,QAAO,OAAO,mBAAmB,QAAQ,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,CAAC;AAAA,EAClF;AAOO,EAAMA,QAAA,2BAA2B,CAAC,OAAuB;AAC5D,QAAI,KAAK,KAAK,KAAK,YAAY;AAC3B,YAAM,IAAI,oBAAoB,eAAe,EAAE,EAAE;AAAA,IACrD;AACA,WAAOA,QAAO,OAAO,eAAe,GAAG,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,CAAC;AAAA,EACzE;AAMO,EAAMA,QAAA,2BAA2B,CAAC,OAAqC;AAC1E,QAAI,KAAK,KAAK,KAAK,YAAY;AAC3B,YAAM,IAAI,oBAAoB,mCAAmC,EAAE,EAAE;AAAA,IACzE;AACA,WAAOA,QAAO,OAAO,eAAe,GAAG,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,CAAC;AAAA,EACzE;AAEO,EAAMA,QAAA,yBAAyB,CAAC,WAA4B;AAC/D,UAAM,YAAY,OAAO,SAAS,EAAE;AACpC,WAAO,UAAU,WAAW,UAAU,KAAK,UAAU,WAAW;AAAA,EACpE;AAEO,EAAMA,QAAA,gCAAgC,CAAC,WAAyC;AACnF,QAAI,KAACA,QAAA,wBAAuB,MAAM,GAAG;AACjC,YAAM,IAAI,oBAAoB,mCAAmC,MAAM,EAAE;AAAA,IAC7E;AACA,WAAO,qBAAqB,SAAS,OAAO,SAAS,EAAE,EAAE,MAAM,CAAC,GAAG,EAAE,CAAC;AAAA,EAC1E;AAOO,EAAMA,QAAA,2BAA2B,CAAC,OAAuB;AAC5D,QAAI,KAAK,KAAK,KAAK,YAAY;AAC3B,YAAM,IAAI,oBAAoB,eAAe,EAAE,EAAE;AAAA,IACrD;AACA,WAAOA,QAAO,OAAO,eAAe,GAAG,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,CAAC;AAAA,EACzE;AAAA,GA1Fa;AA8FV,MAAM,YAAY,IAAI;AAAA,EACzB;AAAA,EACA,YAAU;AAAA,EACV,WAAS,OAAO,OAAO,KAAK,CAAC;AACjC;",
  "names": ["NodeId"]
}
