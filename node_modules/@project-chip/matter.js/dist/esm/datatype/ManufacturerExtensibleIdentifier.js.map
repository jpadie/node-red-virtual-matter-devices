{
  "version": 3,
  "sources": ["../../../src/datatype/ManufacturerExtensibleIdentifier.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ValidationOutOfBoundsError } from \"../common/ValidationError.js\";\nimport { VendorId } from \"./VendorId.js\";\n\n/**\n * Base type for semantic identifiers per Matter specification.  Formally a 32-bit unsigned integer with assigned bit\n * functions:\n *\n *     Bits 0-15 are the identifier's scope:\n *         0x0000: Standard (global) or scoped (within cluster) ID\n *         0x0001 - 0xfff0: Manufacturer code as defined by CSA group\n *         0xfff1 - 0xfff4: Test manufacturer codes\n *     Bits 16-31 are the actual identifier\n *\n * For this and following types, the specification defines restrictions that we do not express statically with\n * TypeScript.\n */\nexport type ManufacturerExtensibleIdentifier = number;\nexport type Mei = ManufacturerExtensibleIdentifier;\n\nexport namespace Mei {\n    /** Create a Manufacturer Extensible Identifier (MEI) from a vendor prefix and type suffix. */\n    export const asMei = (vendorPrefix: VendorId, typeSuffix: number) => {\n        if (vendorPrefix < 0 || vendorPrefix > 0xfff4) {\n            throw new ValidationOutOfBoundsError(`Invalid vendor prefix for MEI: ${vendorPrefix}`);\n        }\n        if (typeSuffix < 0 || typeSuffix > 0xfffe) {\n            throw new ValidationOutOfBoundsError(`Invalid type suffix for MEI: ${typeSuffix}`);\n        }\n\n        return ((vendorPrefix << 16) + typeSuffix) >>> 0;\n    };\n\n    /** Extract the vendor prefix and type suffix from a Manufacturer Extensible Identifier (MEI). */\n    export const fromMei = (mei: number): { vendorPrefix: VendorId; typeSuffix: number } => {\n        const vendorPrefix = mei >>> 16;\n        if (vendorPrefix > 0xfff4) {\n            throw new ValidationOutOfBoundsError(`Invalid vendor prefix for MEI: ${mei}`);\n        }\n\n        const typeSuffix = mei & 0xffff;\n        if (typeSuffix > 0xfffe) {\n            throw new ValidationOutOfBoundsError(`Invalid type suffix for MEI: ${mei}`);\n        }\n\n        return {\n            vendorPrefix: VendorId(vendorPrefix),\n            typeSuffix: mei & 0xffff,\n        };\n    };\n\n    /**\n     * Check if the MEI has a custom vendor prefix.\n     *\n     * @param mei The MEI to check.\n     * @param vendorPrefix An optional vendor prefix to check against. if not provided, checks if the prefix is not equal 0\n     */\n    export const hasCustomMeiPrefix = (mei: number, vendorPrefix?: VendorId) => {\n        if (vendorPrefix === undefined) {\n            return mei > 0xfffe;\n        }\n        return mei >>> 16 === vendorPrefix;\n    };\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,SAAS,kCAAkC;AAC3C,SAAS,gBAAgB;AAkBlB,IAAU;AAAA,CAAV,CAAUA,SAAV;AAEI,EAAMA,KAAA,QAAQ,CAAC,cAAwB,eAAuB;AACjE,QAAI,eAAe,KAAK,eAAe,OAAQ;AAC3C,YAAM,IAAI,2BAA2B,kCAAkC,YAAY,EAAE;AAAA,IACzF;AACA,QAAI,aAAa,KAAK,aAAa,OAAQ;AACvC,YAAM,IAAI,2BAA2B,gCAAgC,UAAU,EAAE;AAAA,IACrF;AAEA,YAAS,gBAAgB,MAAM,eAAgB;AAAA,EACnD;AAGO,EAAMA,KAAA,UAAU,CAAC,QAAgE;AACpF,UAAM,eAAe,QAAQ;AAC7B,QAAI,eAAe,OAAQ;AACvB,YAAM,IAAI,2BAA2B,kCAAkC,GAAG,EAAE;AAAA,IAChF;AAEA,UAAM,aAAa,MAAM;AACzB,QAAI,aAAa,OAAQ;AACrB,YAAM,IAAI,2BAA2B,gCAAgC,GAAG,EAAE;AAAA,IAC9E;AAEA,WAAO;AAAA,MACH,cAAc,SAAS,YAAY;AAAA,MACnC,YAAY,MAAM;AAAA,IACtB;AAAA,EACJ;AAQO,EAAMA,KAAA,qBAAqB,CAAC,KAAa,iBAA4B;AACxE,QAAI,iBAAiB,QAAW;AAC5B,aAAO,MAAM;AAAA,IACjB;AACA,WAAO,QAAQ,OAAO;AAAA,EAC1B;AAAA,GA1Ca;",
  "names": ["Mei"]
}
