/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Ble } from "./ble/Ble.js";
import { RootCertificateManager } from "./certificate/RootCertificateManager.js";
import { ClusterClient } from "./cluster/client/ClusterClient.js";
import { GeneralCommissioning } from "./cluster/definitions/GeneralCommissioningCluster.js";
import { ImplementationError, NoProviderError } from "./common/MatterError.js";
import { serverAddressToString } from "./common/ServerAddress.js";
import { CRYPTO_SYMMETRIC_KEY_LENGTH, Crypto } from "./crypto/Crypto.js";
import { EndpointNumber } from "./datatype/EndpointNumber.js";
import { FabricId } from "./datatype/FabricId.js";
import { FabricIndex } from "./datatype/FabricIndex.js";
import { NodeId } from "./datatype/NodeId.js";
import { VendorId } from "./datatype/VendorId.js";
import { Fabric, FabricBuilder } from "./fabric/Fabric.js";
import { Logger } from "./log/Logger.js";
import { MdnsScanner } from "./mdns/MdnsScanner.js";
import { Specification } from "./model/definitions/Specification.js";
import { ChannelManager, NoChannelError } from "./protocol/ChannelManager.js";
import {
  CommissioningError,
  CommissioningSuccessfullyFinished,
  ControllerCommissioner
} from "./protocol/ControllerCommissioner.js";
import { ControllerDiscovery, DiscoveryError } from "./protocol/ControllerDiscovery.js";
import { ExchangeManager, ExchangeProvider, MessageChannel } from "./protocol/ExchangeManager.js";
import { RetransmissionLimitReachedError } from "./protocol/MessageExchange.js";
import { InteractionClient } from "./protocol/interaction/InteractionClient.js";
import { SECURE_CHANNEL_PROTOCOL_ID } from "./protocol/securechannel/SecureChannelMessages.js";
import { StatusReportOnlySecureChannelProtocol } from "./protocol/securechannel/SecureChannelProtocol.js";
import {
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "./session/Session.js";
import { SessionManager } from "./session/SessionManager.js";
import { CaseClient } from "./session/case/CaseClient.js";
import { PaseClient } from "./session/pase/PaseClient.js";
import { StorageBackendMemory } from "./storage/StorageBackendMemory.js";
import { StorageManager } from "./storage/StorageManager.js";
import { Time } from "./time/Time.js";
import { TlvEnum } from "./tlv/TlvNumber.js";
import { TlvField, TlvObject } from "./tlv/TlvObject.js";
import { TlvString } from "./tlv/TlvString.js";
import { Construction } from "./util/Construction.js";
import { isIPv6 } from "./util/Ip.js";
import { anyPromise, createPromise } from "./util/Promises.js";
const TlvCommissioningSuccessFailureResponse = TlvObject({
  /** Contain the result of the operation. */
  errorCode: TlvField(0, TlvEnum()),
  /** Should help developers in troubleshooting errors. The value MAY go into logs or crash reports, not User UIs. */
  debugText: TlvField(1, TlvString.bound({ maxLength: 128 }))
});
const DEFAULT_FABRIC_INDEX = FabricIndex(1);
const DEFAULT_FABRIC_ID = FabricId(1);
const DEFAULT_ADMIN_VENDOR_ID = VendorId(65521);
const RECONNECTION_POLLING_INTERVAL = 10 * 60 * 1e3;
const CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE = 3;
const CONTROLLER_MAX_PATHS_PER_INVOKE = 10;
const logger = Logger.get("MatterController");
class PairRetransmissionLimitReachedError extends RetransmissionLimitReachedError {
}
class MatterController {
  static async create(options) {
    const {
      sessionStorage,
      rootCertificateStorage,
      fabricStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      sessionClosedCallback,
      adminVendorId = VendorId(DEFAULT_ADMIN_VENDOR_ID),
      adminFabricId = FabricId(DEFAULT_FABRIC_ID),
      adminFabricIndex = FabricIndex(DEFAULT_FABRIC_INDEX),
      caseAuthenticatedTags
    } = options;
    const certificateManager = await RootCertificateManager.create(rootCertificateStorage);
    let controller;
    if (await fabricStorage.has("fabric")) {
      const fabric = Fabric.createFromStorageObject(await fabricStorage.get("fabric"));
      controller = new MatterController({
        sessionStorage,
        fabricStorage,
        nodesStorage,
        mdnsScanner,
        netInterfaceIpv4,
        netInterfaceIpv6,
        certificateManager,
        fabric,
        adminVendorId: fabric.rootVendorId,
        sessionClosedCallback
      });
    } else {
      const rootNodeId = NodeId.randomOperationalNodeId();
      const ipkValue = Crypto.getRandomData(CRYPTO_SYMMETRIC_KEY_LENGTH);
      const fabricBuilder = new FabricBuilder().setRootCert(certificateManager.rootCert).setRootNodeId(rootNodeId).setIdentityProtectionKey(ipkValue).setRootVendorId(adminVendorId);
      fabricBuilder.setOperationalCert(
        certificateManager.generateNoc(
          fabricBuilder.publicKey,
          adminFabricId,
          rootNodeId,
          caseAuthenticatedTags
        )
      );
      const fabric = await fabricBuilder.build(adminFabricIndex);
      controller = new MatterController({
        sessionStorage,
        fabricStorage,
        nodesStorage,
        mdnsScanner,
        netInterfaceIpv4,
        netInterfaceIpv6,
        certificateManager,
        fabric,
        adminVendorId,
        sessionClosedCallback
      });
    }
    await controller.construction;
    return controller;
  }
  static async createAsPaseCommissioner(options) {
    const {
      rootCertificateData,
      fabricData,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      sessionClosedCallback
    } = options;
    try {
      Ble.get();
    } catch (error) {
      NoProviderError.accept(error);
      if (!mdnsScanner || !netInterfaceIpv6) {
        throw new ImplementationError(
          "Ble must be initialized to create a Sub Commissioner without an IP network!"
        );
      }
      logger.info("BLE is not enabled. Using only IP network for commissioning.");
    }
    const certificateManager = await RootCertificateManager.create(rootCertificateData);
    const storageManager = new StorageManager(new StorageBackendMemory());
    await storageManager.initialize();
    const sessionStorage = storageManager.createContext("sessions");
    const nodesStorage = storageManager.createContext("nodes");
    const fabric = Fabric.createFromStorageObject(fabricData);
    const controller = new MatterController({
      sessionStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      certificateManager,
      fabric,
      adminVendorId: fabric.rootVendorId,
      sessionClosedCallback
    });
    await controller.construction;
    return controller;
  }
  sessionManager;
  channelManager = new ChannelManager(CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE);
  exchangeManager;
  paseClient = new PaseClient();
  caseClient = new CaseClient();
  netInterfaceBle;
  bleScanner;
  commissionedNodes = /* @__PURE__ */ new Map();
  #construction;
  sessionStorage;
  fabricStorage;
  nodesStorage;
  mdnsScanner;
  netInterfaceIpv4;
  netInterfaceIpv6;
  certificateManager;
  fabric;
  adminVendorId;
  sessionClosedCallback;
  get construction() {
    return this.#construction;
  }
  constructor(options) {
    const {
      sessionStorage,
      fabricStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      certificateManager,
      fabric,
      sessionClosedCallback,
      adminVendorId
    } = options;
    this.sessionStorage = sessionStorage;
    this.fabricStorage = fabricStorage;
    this.nodesStorage = nodesStorage;
    this.mdnsScanner = mdnsScanner;
    this.netInterfaceIpv4 = netInterfaceIpv4;
    this.netInterfaceIpv6 = netInterfaceIpv6;
    this.certificateManager = certificateManager;
    this.fabric = fabric;
    this.sessionClosedCallback = sessionClosedCallback;
    this.adminVendorId = adminVendorId;
    this.sessionManager = new SessionManager(this, sessionStorage);
    this.sessionManager.sessionClosed.on(async (session) => {
      if (!session.closingAfterExchangeFinished) {
        await this.exchangeManager.closeSession(session);
      }
      this.sessionClosedCallback?.(session.peerNodeId);
    });
    this.exchangeManager = new ExchangeManager(this.sessionManager, this.channelManager);
    this.exchangeManager.addProtocolHandler(new StatusReportOnlySecureChannelProtocol());
    if (netInterfaceIpv4 !== void 0) {
      this.addTransportInterface(netInterfaceIpv4);
    }
    if (netInterfaceIpv6 !== void 0) {
      this.addTransportInterface(netInterfaceIpv6);
    }
    this.#construction = Construction(this, async () => {
      if (await this.nodesStorage.has("commissionedNodes")) {
        const commissionedNodes = await this.nodesStorage.get("commissionedNodes");
        this.commissionedNodes.clear();
        for (const [nodeId, details] of commissionedNodes) {
          this.commissionedNodes.set(nodeId, details);
        }
      }
      await this.sessionManager.initFromStorage([this.fabric]);
    });
  }
  get nodeId() {
    return this.fabric.rootNodeId;
  }
  get rootCertificateData() {
    return this.certificateManager.data;
  }
  get fabricData() {
    return this.fabric.toStorageObject();
  }
  /** Returns our default session parameters for us as a controller. */
  get sessionParameters() {
    return {
      idleIntervalMs: SESSION_IDLE_INTERVAL_MS,
      activeIntervalMs: SESSION_ACTIVE_INTERVAL_MS,
      activeThresholdMs: SESSION_ACTIVE_THRESHOLD_MS,
      dataModelRevision: Specification.DATA_MODEL_REVISION,
      interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
      specificationVersion: Specification.SPECIFICATION_VERSION,
      maxPathsPerInvoke: CONTROLLER_MAX_PATHS_PER_INVOKE
    };
  }
  addTransportInterface(netInterface) {
    this.exchangeManager.addTransportInterface(netInterface);
  }
  collectScanners(discoveryCapabilities = { onIpNetwork: true }) {
    const scannersToUse = new Array();
    if (this.mdnsScanner !== void 0) {
      scannersToUse.push(this.mdnsScanner);
    }
    if (discoveryCapabilities.ble) {
      if (this.bleScanner === void 0) {
        let ble;
        try {
          ble = Ble.get();
          this.netInterfaceBle = ble.getBleCentralInterface();
          this.addTransportInterface(this.netInterfaceBle);
          this.bleScanner = ble.getBleScanner();
        } catch (error) {
          NoProviderError.accept(error);
          logger.warn("BLE is not supported on this platform. The device to commission might not be found!");
        }
      }
      if (this.bleScanner !== void 0) {
        scannersToUse.push(this.bleScanner);
      }
    }
    return scannersToUse;
  }
  /**
   * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first
   * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after
   * each other. It returns the NodeId of the commissioned device.
   * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing
   * request or the passode did not match to any discovered device/address.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commission(options, completeCommissioningCallback) {
    const {
      commissioning: commissioningOptions = {
        regulatoryLocation: GeneralCommissioning.RegulatoryLocationType.Outdoor,
        // Set to the most restrictive if relevant
        regulatoryCountryCode: "XX"
      },
      discovery: { timeoutSeconds = 30 },
      passcode
    } = options;
    const commissionableDevice = "commissionableDevice" in options.discovery ? options.discovery.commissionableDevice : void 0;
    let {
      discovery: { discoveryCapabilities = {}, knownAddress }
    } = options;
    let identifierData = "identifierData" in options.discovery ? options.discovery.identifierData : {};
    if (this.mdnsScanner !== void 0 && this.netInterfaceIpv6 !== void 0) {
      discoveryCapabilities.onIpNetwork = true;
    }
    if (commissionableDevice !== void 0) {
      let { addresses } = commissionableDevice;
      if (discoveryCapabilities.ble === true) {
        discoveryCapabilities = { onIpNetwork: true, ble: addresses.some((address) => address.type === "ble") };
      } else if (discoveryCapabilities.onIpNetwork === true) {
        addresses = addresses.filter((address) => address.type !== "ble");
      }
      addresses.sort((a) => a.type === "udp" ? -1 : 1);
      knownAddress = addresses[0];
      if ("instanceId" in commissionableDevice && commissionableDevice.instanceId !== void 0) {
        identifierData = { instanceId: commissionableDevice.instanceId };
      } else {
        identifierData = { longDiscriminator: commissionableDevice.D };
      }
    }
    const scannersToUse = this.collectScanners(discoveryCapabilities);
    logger.info(
      `Commissioning device with identifier ${Logger.toJSON(identifierData)} and ${scannersToUse.length} scanners and knownAddress ${Logger.toJSON(knownAddress)}`
    );
    let paseSecureChannel;
    let discoveryData;
    if (knownAddress !== void 0) {
      try {
        paseSecureChannel = await this.initializePaseSecureChannel(knownAddress, passcode);
      } catch (error) {
        RetransmissionLimitReachedError.accept(error);
      }
    }
    if (paseSecureChannel === void 0) {
      const discoveredDevices = await ControllerDiscovery.discoverDeviceAddressesByIdentifier(
        scannersToUse,
        identifierData,
        timeoutSeconds
      );
      const { result } = await ControllerDiscovery.iterateServerAddresses(
        discoveredDevices,
        RetransmissionLimitReachedError,
        async () => scannersToUse.flatMap((scanner) => scanner.getDiscoveredCommissionableDevices(identifierData)),
        async (address, device) => {
          const channel = await this.initializePaseSecureChannel(address, passcode, device);
          discoveryData = device;
          return channel;
        }
      );
      paseSecureChannel = result;
    }
    return await this.commissionDevice(
      paseSecureChannel,
      commissioningOptions,
      discoveryData,
      completeCommissioningCallback
    );
  }
  async disconnect(nodeId) {
    await this.sessionManager.removeAllSessionsForNode(nodeId, true);
    await this.channelManager.removeAllNodeChannels(this.fabric, nodeId);
  }
  async removeNode(nodeId) {
    logger.info(`Removing commissioned node ${nodeId} from controller.`);
    await this.sessionManager.removeAllSessionsForNode(nodeId);
    await this.sessionManager.removeResumptionRecord(nodeId);
    await this.channelManager.removeAllNodeChannels(this.fabric, nodeId);
    this.commissionedNodes.delete(nodeId);
    await this.storeCommissionedNodes();
  }
  /**
   * Method to start commission process with a PASE pairing.
   * If this not successful and throws an RetransmissionLimitReachedError the address is invalid or the passcode
   * is wrong.
   */
  async initializePaseSecureChannel(address, passcode, device) {
    let paseChannel;
    if (device !== void 0) {
      logger.info(`Commissioning device`, MdnsScanner.discoveryDataDiagnostics(device));
    }
    if (address.type === "udp") {
      const { ip } = address;
      const isIpv6Address = isIPv6(ip);
      const paseInterface = isIpv6Address ? this.netInterfaceIpv6 : this.netInterfaceIpv4;
      if (paseInterface === void 0) {
        throw new PairRetransmissionLimitReachedError(
          `IPv${isIpv6Address ? "6" : "4"} interface not initialized. Cannot use ${ip} for commissioning.`
        );
      }
      paseChannel = await paseInterface.openChannel(address);
    } else {
      if (this.netInterfaceBle === void 0) {
        throw new PairRetransmissionLimitReachedError(
          `BLE interface not initialized. Cannot use ${address.peripheralAddress} for commissioning.`
        );
      }
      paseChannel = await this.netInterfaceBle.openChannel(address);
    }
    const unsecureSession = this.sessionManager.createUnsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: device?.SII,
        activeIntervalMs: device?.SAI,
        activeThresholdMs: device?.SAT
      },
      isInitiator: true
    });
    const paseUnsecureMessageChannel = new MessageChannel(paseChannel, unsecureSession);
    const paseExchange = this.exchangeManager.initiateExchangeWithChannel(
      paseUnsecureMessageChannel,
      SECURE_CHANNEL_PROTOCOL_ID
    );
    let paseSecureSession;
    try {
      paseSecureSession = await this.paseClient.pair(this, paseExchange, passcode);
    } catch (e) {
      await paseExchange.close();
      throw e;
    }
    await unsecureSession.destroy();
    return new MessageChannel(paseChannel, paseSecureSession);
  }
  /**
   * Method to commission a device with a PASE secure channel. It returns the NodeId of the commissioned device on
   * success.
   */
  async commissionDevice(paseSecureMessageChannel, commissioningOptions, discoveryData, completeCommissioningCallback) {
    const peerNodeId = commissioningOptions.nodeId ?? NodeId.randomOperationalNodeId();
    const commissioningManager = new ControllerCommissioner(
      // Use the created secure session to do the commissioning
      new InteractionClient(new ExchangeProvider(this.exchangeManager, paseSecureMessageChannel), peerNodeId),
      this.certificateManager,
      this.fabric,
      commissioningOptions,
      peerNodeId,
      this.adminVendorId,
      async () => {
        await paseSecureMessageChannel.close();
        if (completeCommissioningCallback !== void 0) {
          if (!await completeCommissioningCallback(peerNodeId, discoveryData)) {
            throw new RetransmissionLimitReachedError("Device could not be discovered");
          }
          throw new CommissioningSuccessfullyFinished();
        }
        return await this.connect(peerNodeId, 120, discoveryData);
      }
    );
    try {
      await commissioningManager.executeCommissioning();
    } catch (error) {
      if (this.commissionedNodes.has(peerNodeId)) {
        this.commissionedNodes.delete(peerNodeId);
      }
      throw error;
    }
    await this.fabricStorage?.set("fabric", this.fabric.toStorageObject());
    return peerNodeId;
  }
  /**
   * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.
   */
  async completeCommissioning(peerNodeId, discoveryData) {
    const interactionClient = await this.connect(peerNodeId, 120, discoveryData);
    const generalCommissioningClusterClient = ClusterClient(
      GeneralCommissioning.Cluster,
      EndpointNumber(0),
      interactionClient
    );
    const { errorCode, debugText } = await generalCommissioningClusterClient.commissioningComplete(void 0, {
      useExtendedFailSafeMessageResponseTimeout: true
    });
    if (errorCode !== GeneralCommissioning.CommissioningError.Ok) {
      if (this.commissionedNodes.has(peerNodeId)) {
        this.commissionedNodes.delete(peerNodeId);
      }
      throw new CommissioningError(`Commission error on commissioningComplete: ${errorCode}, ${debugText}`);
    }
    await this.fabricStorage?.set("fabric", this.fabric.toStorageObject());
  }
  async reconnectLastKnownAddress(peerNodeId, operationalAddress, discoveryData) {
    const { ip, port } = operationalAddress;
    try {
      logger.debug(`Resume device connection to configured server at ${ip}:${port}`);
      const channel = await this.pair(peerNodeId, operationalAddress, discoveryData);
      await this.setOperationalDeviceData(peerNodeId, operationalAddress);
      return channel;
    } catch (error) {
      if (error instanceof RetransmissionLimitReachedError || error instanceof Error && error.message.includes("EHOSTUNREACH")) {
        logger.debug(`Failed to resume device connection with ${ip}:${port}, discover the device ...`, error);
        return void 0;
      } else {
        throw error;
      }
    }
  }
  async connectOrDiscoverNode(peerNodeId, operationalAddress, timeoutSeconds, discoveryData) {
    if (this.mdnsScanner === void 0) {
      throw new ImplementationError("Cannot discover device without mDNS scanner.");
    }
    const mdnsScanner = this.mdnsScanner;
    const discoveryPromises = new Array();
    let reconnectionPollingTimer;
    if (operationalAddress !== void 0) {
      const directReconnection = await this.reconnectLastKnownAddress(
        peerNodeId,
        operationalAddress,
        discoveryData
      );
      if (directReconnection !== void 0) {
        return directReconnection;
      }
      if (timeoutSeconds === void 0) {
        const { promise, resolver, rejecter } = createPromise();
        reconnectionPollingTimer = Time.getPeriodicTimer(
          "Controller reconnect",
          RECONNECTION_POLLING_INTERVAL,
          async () => {
            try {
              logger.debug(`Polling for device at ${serverAddressToString(operationalAddress)} ...`);
              const result = await this.reconnectLastKnownAddress(
                peerNodeId,
                operationalAddress,
                discoveryData
              );
              if (result !== void 0 && reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                resolver(result);
              }
            } catch (error) {
              if (reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                rejecter(error);
              }
            }
          }
        ).start();
        discoveryPromises.push(() => promise);
      }
    }
    discoveryPromises.push(async () => {
      const scanResult = await ControllerDiscovery.discoverOperationalDevice(
        this.fabric,
        peerNodeId,
        mdnsScanner,
        timeoutSeconds,
        timeoutSeconds === void 0
      );
      if (reconnectionPollingTimer?.isRunning) {
        reconnectionPollingTimer?.stop();
      }
      const { result } = await ControllerDiscovery.iterateServerAddresses(
        [scanResult],
        PairRetransmissionLimitReachedError,
        async () => {
          const device = mdnsScanner.getDiscoveredOperationalDevice(this.fabric, peerNodeId);
          return device !== void 0 ? [device] : [];
        },
        async (address, device) => {
          const result2 = await this.pair(peerNodeId, address, device);
          await this.setOperationalDeviceData(peerNodeId, address, {
            ...discoveryData,
            ...device
          });
          return result2;
        }
      );
      return result;
    });
    return await anyPromise(discoveryPromises);
  }
  /**
   * Resume a device connection and establish a CASE session that was previously paired with the controller. This
   * method will try to connect to the device using the previously used server address (if set). If that fails, the
   * device is discovered again using its operational instance details.
   * It returns the operational MessageChannel on success.
   */
  async resume(peerNodeId, timeoutSeconds, discoveryData) {
    const operationalAddress = this.getLastOperationalAddress(peerNodeId);
    try {
      return await this.connectOrDiscoverNode(peerNodeId, operationalAddress, timeoutSeconds, discoveryData);
    } catch (error) {
      if ((error instanceof DiscoveryError || error instanceof PairRetransmissionLimitReachedError) && this.commissionedNodes.has(peerNodeId)) {
        logger.info(`Resume failed, remove all sessions for node ${peerNodeId}`);
        await this.sessionManager.removeAllSessionsForNode(peerNodeId);
      }
      throw error;
    }
  }
  /** Pair with an operational device (already commissioned) and establish a CASE session. */
  async pair(peerNodeId, operationalServerAddress, discoveryData) {
    const { ip, port } = operationalServerAddress;
    const isIpv6Address = isIPv6(ip);
    const operationalInterface = isIpv6Address ? this.netInterfaceIpv6 : this.netInterfaceIpv4;
    if (operationalInterface === void 0) {
      throw new PairRetransmissionLimitReachedError(
        `IPv${isIpv6Address ? "6" : "4"} interface not initialized for port ${port}. Cannot use ${ip} for pairing.`
      );
    }
    const operationalChannel = await operationalInterface.openChannel(operationalServerAddress);
    const { sessionParameters } = this.findResumptionRecordByNodeId(peerNodeId) ?? {};
    const unsecureSession = this.sessionManager.createUnsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: discoveryData?.SII ?? sessionParameters?.idleIntervalMs,
        activeIntervalMs: discoveryData?.SAI ?? sessionParameters?.activeIntervalMs,
        activeThresholdMs: discoveryData?.SAT ?? sessionParameters?.activeThresholdMs
      },
      isInitiator: true
    });
    const operationalUnsecureMessageExchange = new MessageChannel(operationalChannel, unsecureSession);
    let operationalSecureSession;
    try {
      const exchange = this.exchangeManager.initiateExchangeWithChannel(
        operationalUnsecureMessageExchange,
        SECURE_CHANNEL_PROTOCOL_ID
      );
      try {
        operationalSecureSession = await this.caseClient.pair(this, exchange, this.fabric, peerNodeId);
      } catch (e) {
        await exchange.close();
        throw e;
      }
    } catch (e) {
      RetransmissionLimitReachedError.accept(e);
      throw new PairRetransmissionLimitReachedError(e.message);
    }
    await unsecureSession.destroy();
    const channel = new MessageChannel(operationalChannel, operationalSecureSession);
    await this.channelManager.setChannel(this.fabric, peerNodeId, channel);
    return channel;
  }
  isCommissioned() {
    return this.commissionedNodes.size > 0;
  }
  getCommissionedNodes() {
    return Array.from(this.commissionedNodes.keys());
  }
  getCommissionedNodesDetails() {
    return Array.from(this.commissionedNodes.entries()).map(
      ([nodeId, { operationalServerAddress, discoveryData, basicInformationData }]) => ({
        nodeId,
        operationalAddress: operationalServerAddress ? serverAddressToString(operationalServerAddress) : void 0,
        advertisedName: discoveryData?.DN,
        discoveryData,
        basicInformationData
      })
    );
  }
  async setOperationalDeviceData(nodeId, operationalServerAddress, discoveryData) {
    const nodeDetails = this.commissionedNodes.get(nodeId) ?? {};
    nodeDetails.operationalServerAddress = operationalServerAddress;
    if (discoveryData !== void 0) {
      nodeDetails.discoveryData = {
        ...nodeDetails.discoveryData,
        ...discoveryData
      };
    }
    this.commissionedNodes.set(nodeId, nodeDetails);
    await this.storeCommissionedNodes();
  }
  async enhanceCommissionedNodeDetails(nodeId, data) {
    const nodeDetails = this.commissionedNodes.get(nodeId);
    if (nodeDetails === void 0) {
      throw new Error(`Node ${nodeId} is not commissioned.`);
    }
    const { basicInformationData } = data;
    nodeDetails.basicInformationData = basicInformationData;
    this.commissionedNodes.set(nodeId, nodeDetails);
    await this.storeCommissionedNodes();
  }
  getLastOperationalAddress(nodeId) {
    return this.commissionedNodes.get(nodeId)?.operationalServerAddress;
  }
  async storeCommissionedNodes() {
    await this.nodesStorage.set("commissionedNodes", Array.from(this.commissionedNodes.entries()));
  }
  /**
   * Connect to the device by opening a channel and creating a new CASE session if necessary.
   * Returns a InteractionClient on success.
   */
  async connect(peerNodeId, timeoutSeconds, discoveryData) {
    if (discoveryData == void 0) {
      discoveryData = this.commissionedNodes.get(peerNodeId)?.discoveryData;
    }
    let channel;
    try {
      channel = this.channelManager.getChannel(this.fabric, peerNodeId);
    } catch (error) {
      NoChannelError.accept(error);
      channel = await this.resume(peerNodeId, timeoutSeconds, discoveryData);
    }
    return new InteractionClient(
      new ExchangeProvider(this.exchangeManager, channel, async () => {
        await this.channelManager.removeAllNodeChannels(this.fabric, peerNodeId);
        await this.resume(peerNodeId, 60);
        return this.channelManager.getChannel(this.fabric, peerNodeId);
      }),
      peerNodeId
    );
  }
  async getNextAvailableSessionId() {
    return this.sessionManager.getNextAvailableSessionId();
  }
  getResumptionRecord(resumptionId) {
    return this.sessionManager.findResumptionRecordById(resumptionId);
  }
  findResumptionRecordByNodeId(nodeId) {
    return this.sessionManager.findResumptionRecordByNodeId(nodeId);
  }
  async saveResumptionRecord(resumptionRecord) {
    return this.sessionManager.saveResumptionRecord(resumptionRecord);
  }
  announce() {
  }
  async close() {
    await this.exchangeManager.close();
    await this.sessionManager.close();
    await this.channelManager.close();
    await this.netInterfaceBle?.close();
    await this.netInterfaceIpv4?.close();
    await this.netInterfaceIpv6?.close();
  }
  getActiveSessionInformation() {
    return this.sessionManager.getActiveSessionInformation();
  }
}
export {
  MatterController,
  PairRetransmissionLimitReachedError
};
//# sourceMappingURL=MatterController.js.map
