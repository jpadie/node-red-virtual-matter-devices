{
  "version": 3,
  "sources": ["../../../src/tlv/TlvNumber.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { UnexpectedDataError } from \"../common/MatterError.js\";\nimport { ValidationDatatypeMismatchError, ValidationOutOfBoundsError } from \"../common/ValidationError.js\";\nimport { BitSchema, BitmapSchema, TypeFromPartialBitSchema } from \"../schema/BitmapSchema.js\";\nimport { Schema } from \"../schema/Schema.js\";\nimport {\n    FLOAT32_MAX,\n    FLOAT32_MIN,\n    INT16_MAX,\n    INT16_MIN,\n    INT32_MAX,\n    INT32_MIN,\n    INT64_MAX,\n    INT64_MIN,\n    INT8_MAX,\n    INT8_MIN,\n    UINT16_MAX,\n    UINT24_MAX,\n    UINT32_MAX,\n    UINT64_MAX,\n    UINT8_MAX,\n    maxValue,\n    minValue,\n} from \"../util/Number.js\";\nimport { TlvCodec, TlvLength, TlvTag, TlvType, TlvTypeLength } from \"./TlvCodec.js\";\nimport { TlvReader, TlvSchema, TlvWriter } from \"./TlvSchema.js\";\nimport { TlvWrapper } from \"./TlvWrapper.js\";\n\n/**\n * Schema to encode an unsigned integer in TLV.\n *\n * @see {@link MatterSpecification.v10.Core} \u00A7 A.11.1\n */\nexport class TlvNumericSchema<T extends bigint | number> extends TlvSchema<T> {\n    constructor(\n        protected readonly type: TlvType.UnsignedInt | TlvType.SignedInt | TlvType.Float,\n        protected readonly lengthProvider: (value: T) => TlvLength,\n        protected readonly min?: T,\n        protected readonly max?: T,\n    ) {\n        super();\n    }\n\n    override encodeTlvInternal(writer: TlvWriter, value: T, tag?: TlvTag): void {\n        const typeLength = { type: this.type, length: this.lengthProvider(value) } as TlvTypeLength;\n        writer.writeTag(typeLength, tag);\n        writer.writePrimitive(typeLength, value);\n    }\n\n    override decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): T {\n        if (typeLength.type !== this.type)\n            throw new UnexpectedDataError(`Unexpected type ${typeLength.type}, was expecting ${this.type}.`);\n        return reader.readPrimitive(typeLength);\n    }\n\n    override validate(value: T): void {\n        if (typeof value !== \"number\" && typeof value !== \"bigint\")\n            throw new ValidationDatatypeMismatchError(`Expected number, got ${typeof value}.`);\n        this.validateBoundaries(value);\n    }\n\n    validateBoundaries(value: T): void {\n        if (this.min !== undefined && value < this.min)\n            throw new ValidationOutOfBoundsError(`Invalid value: ${value} is below the minimum, ${this.min}.`);\n        if (this.max !== undefined && value > this.max)\n            throw new ValidationOutOfBoundsError(`Invalid value: ${value} is above the maximum, ${this.max}.`);\n    }\n\n    /** Restrict value range. */\n    bound({ min, max }: NumericConstraints<T>): TlvNumericSchema<T> {\n        return new TlvNumericSchema(\n            this.type,\n            this.lengthProvider,\n            maxValue(min, this.min) as T,\n            minValue(max, this.max) as T,\n        );\n    }\n}\n\nexport type NumericConstraints<T extends number | bigint = number | bigint> = {\n    min?: T;\n    max?: T;\n};\n\nexport class TlvNumberSchema extends TlvNumericSchema<number> {\n    constructor(\n        type: TlvType.UnsignedInt | TlvType.SignedInt | TlvType.Float,\n        lengthProvider: (value: number) => TlvLength,\n        min?: number,\n        max?: number,\n    ) {\n        super(type, lengthProvider, min, max);\n    }\n\n    override decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength) {\n        const value = super.decodeTlvInternalValue(reader, typeLength);\n        return typeof value === \"bigint\" ? Number(value) : value;\n    }\n\n    override bound({ min, max }: NumericConstraints<number>): TlvNumericSchema<number> {\n        return new TlvNumberSchema(this.type, this.lengthProvider, maxValue(min, this.min), minValue(max, this.max));\n    }\n\n    override validate(value: number): void {\n        if (typeof value !== \"number\")\n            throw new ValidationDatatypeMismatchError(`Expected number, got ${typeof value}.`);\n        this.validateBoundaries(value);\n    }\n}\n\nexport const TlvLongNumberSchema = TlvNumericSchema<number | bigint>;\n\n/** Unsigned integer TLV schema. */\nexport const TlvFloat = new TlvNumberSchema(TlvType.Float, _value => TlvLength.FourBytes, FLOAT32_MIN, FLOAT32_MAX);\nexport const TlvDouble = new TlvNumberSchema(TlvType.Float, _value => TlvLength.EightBytes);\nexport const TlvInt8 = new TlvNumberSchema(\n    TlvType.SignedInt,\n    value => TlvCodec.getIntTlvLength(value),\n    INT8_MIN,\n    INT8_MAX,\n);\nexport const TlvInt16 = new TlvNumberSchema(\n    TlvType.SignedInt,\n    value => TlvCodec.getIntTlvLength(value),\n    INT16_MIN,\n    INT16_MAX,\n);\nexport const TlvInt32 = new TlvNumberSchema(\n    TlvType.SignedInt,\n    value => TlvCodec.getIntTlvLength(value),\n    INT32_MIN,\n    INT32_MAX,\n);\nexport const TlvInt64 = new TlvLongNumberSchema(\n    TlvType.SignedInt,\n    value => TlvCodec.getIntTlvLength(value),\n    INT64_MIN,\n    INT64_MAX,\n);\nexport const TlvUInt8 = new TlvNumberSchema(\n    TlvType.UnsignedInt,\n    value => TlvCodec.getUIntTlvLength(value),\n    0,\n    UINT8_MAX,\n);\nexport const TlvUInt16 = new TlvNumberSchema(\n    TlvType.UnsignedInt,\n    value => TlvCodec.getUIntTlvLength(value),\n    0,\n    UINT16_MAX,\n);\nexport const TlvUInt24 = new TlvNumberSchema(\n    TlvType.UnsignedInt,\n    value => TlvCodec.getUIntTlvLength(value),\n    0,\n    UINT24_MAX,\n);\nexport const TlvUInt32 = new TlvNumberSchema(\n    TlvType.UnsignedInt,\n    value => TlvCodec.getUIntTlvLength(value),\n    0,\n    UINT32_MAX,\n);\nexport const TlvUInt64 = new TlvLongNumberSchema(\n    TlvType.UnsignedInt,\n    value => TlvCodec.getUIntTlvLength(value),\n    0,\n    UINT64_MAX,\n);\n\n// We use internally 32bit here - in fact encoding is done by real value length anyway\nexport const TlvEnum = <T>() => TlvUInt32 as TlvSchema<number> as TlvSchema<T>;\n\nexport const TlvBitmap = <T extends BitSchema>(underlyingSchema: TlvNumberSchema, bitSchema: T) => {\n    // BitmapSchema supports encoding partial bit schemas but specifies its\n    // type as TypeFromBitSchema.  Changing to TypeFromPartialBitSchema there\n    // probably the right thing to do but this would force us to treat all\n    // decoded values as potentially having missing fields.\n    //\n    // Best would probably be to support different types on decode and encode.\n    // In the meantime though we can just cast here as this utility function is\n    // only used in places where we want to support partial bitmaps.\n    const bitmapSchema = BitmapSchema(bitSchema) as Schema<TypeFromPartialBitSchema<T>, number>;\n\n    return new TlvWrapper(\n        underlyingSchema,\n        (bitmapData: TypeFromPartialBitSchema<T>) => bitmapSchema.encode(bitmapData),\n        value => bitmapSchema.decode(value),\n    );\n};\n\n// Relative Number types\nexport const TlvPercent = TlvUInt8.bound({ max: 100 });\nexport const TlvPercent100ths = TlvUInt16.bound({ max: 10000 });\n\n// Time Number types\nexport const TlvEpochUs = TlvUInt64;\nexport const TlvEpochS = TlvUInt32;\nexport const TlvPosixMs = TlvUInt64;\nexport const TlvSysTimeUs = TlvUInt64;\nexport const TlvSysTimeMS = TlvUInt64;\n"],
  "mappings": "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",
  "names": []
}
