{
  "version": 3,
  "sources": ["../../../src/tlv/TlvObject.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError, InternalError, UnexpectedDataError } from \"../common/MatterError.js\";\nimport {\n    ValidationDatatypeMismatchError,\n    ValidationError,\n    ValidationMandatoryFieldMissingError,\n    ValidationOutOfBoundsError,\n} from \"../common/ValidationError.js\";\nimport { FabricIndex } from \"../model/standard/elements/FabricIndex.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { Merge } from \"../util/Type.js\";\nimport { TlvAny } from \"./TlvAny.js\";\nimport { LengthConstraints } from \"./TlvArray.js\";\nimport { TlvTag, TlvType, TlvTypeLength } from \"./TlvCodec.js\";\nimport { TlvEncodingOptions, TlvReader, TlvSchema, TlvWriter } from \"./TlvSchema.js\";\n\nexport interface FieldType<T> {\n    id: number;\n    schema: TlvSchema<T>;\n    optional?: boolean;\n    repeated?: boolean;\n    fallback?: T;\n}\n\nexport interface RepeatedFieldType<T> extends FieldType<T> {\n    repeated: true;\n    minLength?: number;\n    maxLength?: number;\n}\n\nexport interface OptionalFieldType<T> extends FieldType<T> {\n    optional: true;\n}\n\nexport interface OptionalRepeatedFieldType<T> extends OptionalFieldType<T> {\n    repeated: true;\n    maxLength?: number;\n}\n\nexport type TlvFields = { [field: string]: FieldType<any> };\n\ntype MandatoryFieldNames<F extends TlvFields> = {\n    [K in keyof F]: F[K] extends OptionalFieldType<any> ? never : K;\n}[keyof F];\ntype OptionalFieldNames<F extends TlvFields> = {\n    [K in keyof F]: F[K] extends OptionalFieldType<any> ? K : never;\n}[keyof F];\ntype TypeFromField<F extends FieldType<any>> = F extends FieldType<infer T> ? T : never;\ntype TypeForMandatoryFields<F extends TlvFields, MF extends keyof F> = { [K in MF]: TypeFromField<F[K]> };\ntype TypeForOptionalFields<F extends TlvFields, MF extends keyof F> = { [K in MF]?: TypeFromField<F[K]> };\nexport type TypeFromFields<F extends TlvFields> = Merge<\n    TypeForMandatoryFields<F, MandatoryFieldNames<F>>,\n    TypeForOptionalFields<F, OptionalFieldNames<F>>\n>;\n\n/**\n * Schema to encode an object in TLV.\n *\n * @see {@link MatterSpecification.v10.Core} \u00A7 A.5.1 and \u00A7 A.11.4\n */\nexport class ObjectSchema<F extends TlvFields> extends TlvSchema<TypeFromFields<F>> {\n    private readonly fieldById = new Array<{ name: string; field: FieldType<any> }>();\n\n    constructor(\n        private readonly fieldDefinitions: F,\n        private readonly type: TlvType.Structure | TlvType.List = TlvType.Structure,\n        private readonly allowProtocolSpecificTags = false,\n    ) {\n        super();\n\n        // TODO Add sorting option to enforce order of fields in encoded TLV If Ty is Structure\n        //  Requirements @see {@link MatterSpecification.Core.v12} \u00A7 A.2.4\n        for (const name in this.fieldDefinitions) {\n            const field = this.fieldDefinitions[name];\n            if (field.repeated && type !== TlvType.List) {\n                throw new Error(\"Repeated fields are only allowed in TLV List.\");\n            }\n            this.fieldById[field.id] = { name, field };\n        }\n    }\n\n    #encodeEntryToTlv(writer: TlvWriter, name: string, value: TypeFromFields<F>, options?: TlvEncodingOptions) {\n        const { id, schema, optional: isOptional, repeated: isRepeated } = this.fieldDefinitions[name];\n        const { forWriteInteraction = false, allowMissingFieldsForNonFabricFilteredRead = false } = options ?? {};\n        if (forWriteInteraction && allowMissingFieldsForNonFabricFilteredRead) {\n            throw new InternalError(\n                \"Encode options cannot indicate a write interaction and a fabric filtered read interaction at the same time.\",\n            );\n        }\n        const fieldValue = (value as any)[name];\n        if (fieldValue === undefined) {\n            if (!isOptional && !allowMissingFieldsForNonFabricFilteredRead) {\n                if (forWriteInteraction && id === <number>FabricIndex.id) {\n                    // FabricIndex field should not be included in encoded data for write interactions\n                    return;\n                }\n                throw new ValidationMandatoryFieldMissingError(`Missing mandatory field ${name}`, name);\n            }\n            return;\n        }\n        if (isRepeated) {\n            if (!Array.isArray(fieldValue)) {\n                throw new ValidationDatatypeMismatchError(`Repeated field ${name} should be an array.`, name);\n            }\n            for (const element of fieldValue) {\n                schema.encodeTlvInternal(writer, element, { id }, options);\n            }\n        } else {\n            schema.encodeTlvInternal(writer, fieldValue, { id }, options);\n        }\n    }\n\n    /**\n     * Encode the object as Structure, by the order of field definitions.\n     */\n    #encodeStructure(writer: TlvWriter, value: TypeFromFields<F>, options?: TlvEncodingOptions) {\n        for (const name in this.fieldDefinitions) {\n            this.#encodeEntryToTlv(writer, name, value, options);\n        }\n    }\n\n    /**\n     * Encode the object as List, by the order of the fields in the object.\n     */\n    #encodeList(writer: TlvWriter, value: TypeFromFields<F>, options?: TlvEncodingOptions) {\n        const encodedFields = new Set<string>();\n        // Encode object fields\n        for (const name of Object.keys(value)) {\n            this.#encodeEntryToTlv(writer, name, value, options);\n            encodedFields.add(name);\n        }\n        // Verify the potentially missing fields\n        for (const name in this.fieldDefinitions) {\n            if (encodedFields.has(name)) continue;\n            this.#encodeEntryToTlv(writer, name, value, options);\n        }\n    }\n\n    override encodeTlvInternal(\n        writer: TlvWriter,\n        value: TypeFromFields<F>,\n        tag?: TlvTag,\n        options?: TlvEncodingOptions,\n    ): void {\n        writer.writeTag({ type: this.type }, tag);\n\n        if (this.type === TlvType.Structure) {\n            // Encode in order of field definitions\n            this.#encodeStructure(writer, value, options);\n        } else {\n            this.#encodeList(writer, value, options);\n        }\n\n        writer.writeTag({ type: TlvType.EndOfContainer });\n    }\n\n    override decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): TypeFromFields<F> {\n        if (typeLength.type !== this.type)\n            throw new UnexpectedDataError(`Unexpected type ${typeLength.type} (expected ${this.type}).`);\n        const result: any = {};\n        while (true) {\n            const { tag: { profile, id } = {}, typeLength: elementTypeLength } = reader.readTagType();\n            if (elementTypeLength.type === TlvType.EndOfContainer) break;\n            if (profile !== undefined && !this.allowProtocolSpecificTags)\n                throw new UnexpectedDataError(\"Structure element tags should be context-specific.\");\n            if (id === undefined) throw new UnexpectedDataError(\"Structure element tags should have an id.\");\n            const fieldName = this.fieldById[id];\n            if (fieldName === undefined) {\n                // Ignore unknown field by decoding it as raw TLV so we skip forward the proper length.\n                TlvAny.decodeTlvInternalValue(reader, elementTypeLength);\n                continue;\n            }\n            const { field, name } = fieldName;\n            const decoded = field.schema.decodeTlvInternalValue(reader, elementTypeLength);\n            if (field.repeated) {\n                if (result[name] === undefined) {\n                    result[name] = [decoded];\n                } else {\n                    result[name].push(decoded);\n                }\n            } else {\n                result[name] = decoded;\n            }\n        }\n        // Check mandatory fields and, if missing, populate with fallback value if defined.\n        for (const name in this.fieldDefinitions) {\n            const { optional, fallback, repeated } = this.fieldDefinitions[name];\n            if (optional) continue;\n            const value = result[name];\n            if (value !== undefined) continue;\n            if (fallback !== undefined) {\n                if (repeated) {\n                    result[name] = [fallback];\n                } else {\n                    result[name] = fallback;\n                }\n            }\n        }\n        return result as TypeFromFields<F>;\n    }\n\n    override validate(value: TypeFromFields<F>): void {\n        for (const name in this.fieldDefinitions) {\n            const { optional, schema, repeated: isRepeated } = this.fieldDefinitions[name];\n            const data = (value as any)[name];\n            if (data === undefined) {\n                if (optional) {\n                    continue;\n                }\n                throw new ValidationMandatoryFieldMissingError(`Missing mandatory field ${name}`, name);\n            }\n            if (isRepeated) {\n                const { minLength = 2, maxLength = 65535 } = this.fieldDefinitions[name] as RepeatedFieldType<any>;\n                if (!Array.isArray(data)) {\n                    throw new ValidationDatatypeMismatchError(`Repeated field ${name} should be an array.`, name);\n                }\n                if (data.length > maxLength)\n                    throw new ValidationOutOfBoundsError(\n                        `Repeated field list for ${name} is too long: ${data.length}, max ${maxLength}.`,\n                        name,\n                    );\n                if (data.length < minLength)\n                    throw new ValidationOutOfBoundsError(\n                        `Repeated field list for ${name} is too short: ${data.length}, min ${minLength}.`,\n                        name,\n                    );\n                for (const element of data) {\n                    try {\n                        schema.validate(element);\n                    } catch (e) {\n                        ValidationError.accept(e);\n                        e.fieldName = `${name}${e.fieldName !== undefined ? `.${e.fieldName}` : \"\"}`;\n                        throw e;\n                    }\n                }\n            } else {\n                try {\n                    schema.validate(data);\n                } catch (e) {\n                    ValidationError.accept(e);\n                    e.fieldName = `${name}${e.fieldName !== undefined ? `.${e.fieldName}` : \"\"}`;\n                    throw e;\n                }\n            }\n        }\n    }\n\n    override injectField(\n        value: TypeFromFields<F>,\n        fieldId: number,\n        fieldValue: any,\n        injectChecker: (fieldValue: any) => boolean,\n    ): TypeFromFields<F> {\n        for (const k in this.fieldDefinitions) {\n            const field = this.fieldDefinitions[k] as FieldType<any>;\n\n            if (field.id === fieldId) {\n                if (injectChecker((value as any)[k])) {\n                    field.schema.validate(fieldValue); // Make sure type matches\n                    (value as any)[k] = fieldValue;\n                }\n            } else {\n                (value as any)[k] = field.schema.injectField((value as any)[k], fieldId, fieldValue, injectChecker);\n            }\n        }\n        return value;\n    }\n\n    override removeField(\n        value: TypeFromFields<F>,\n        fieldId: number,\n        removeChecker: (fieldValue: any) => boolean,\n    ): TypeFromFields<F> {\n        for (const k in this.fieldDefinitions) {\n            const field = this.fieldDefinitions[k] as FieldType<any>;\n\n            if (field.id === fieldId) {\n                if ((value as any)[k] !== undefined && removeChecker((value as any)[k])) {\n                    delete (value as any)[k];\n                }\n            } else {\n                (value as any)[k] = field.schema.removeField((value as any)[k], fieldId, removeChecker);\n            }\n        }\n        return value;\n    }\n}\n\n/** Object TLV schema. */\nexport const TlvObject = <F extends TlvFields>(fields: F) => new ObjectSchema(fields, TlvType.Structure);\n\nexport class ObjectSchemaWithMaxSize<F extends TlvFields> extends ObjectSchema<F> {\n    constructor(\n        fieldDefinitions: F,\n        protected readonly maxSize: number,\n        type: TlvType.Structure | TlvType.List = TlvType.Structure,\n        allowProtocolSpecificTags = false,\n    ) {\n        super(fieldDefinitions, type, allowProtocolSpecificTags);\n    }\n\n    override encode(value: TypeFromFields<F>): ByteArray {\n        const encoded = super.encode(value);\n        if (encoded.length > this.maxSize) {\n            throw new ImplementationError(\n                `Encoded TLV object with ${encoded.length} bytes exceeds maximum size of ${this.maxSize} bytes.`,\n            );\n        }\n        return encoded;\n    }\n}\n\nexport const TlvObjectWithMaxSize = <F extends TlvFields>(fields: F, maxSize: number) =>\n    new ObjectSchemaWithMaxSize(fields, maxSize, TlvType.Structure);\n\n/**\n * List TLV schema with all tagged entries.\n * List entries that can appear multiple times can be defined using TlvRepeatedField/TlvOptionalRepeatedField and are\n * represented as Arrays.\n * TODO: We represent Tlv Lists right now as named object properties. This formally does not match the spec, which\n *      defines a list as a sequence of TLV elements with optional tag where the order matters. That's ok for now\n *      (also with the help of \"Repeated Fields\") because it not makes any real difference for now for the current\n *      existing data structures. We need to change once this changes.\n */\nexport const TlvTaggedList = <F extends TlvFields>(fields: F, allowProtocolSpecificTags = false) =>\n    new ObjectSchema(fields, TlvType.List, allowProtocolSpecificTags);\n\n// TODO Implement a real TlvList schema that matches the spec to represent a ordered list of TLV elements with optional\n//      tag.\n\n/**\n * Object TLV mandatory field. Optionally provide a fallback value to initialize the field value when devices omit\n * providing a value against the specifications or in special use cases. Make sure to use a value that is an equivalent\n * to the value being empty.\n */\nexport const TlvField = <T>(id: number, schema: TlvSchema<T>, fallback?: T) =>\n    ({ id, schema, fallback, optional: false }) as FieldType<T>;\n\n/** Object TLV optional field. */\nexport const TlvOptionalField = <T>(id: number, schema: TlvSchema<T>) =>\n    ({ id, schema, optional: true }) as OptionalFieldType<T>;\n\n/**\n * Object TLV mandatory field that can exist repeated in a TLV List structure. The order is preserved on encoding and\n * decoding.\n */\nexport const TlvRepeatedField = <T>(id: number, schema: TlvSchema<T>, lengthOptions?: LengthConstraints) => {\n    const { minLength, maxLength, length } = lengthOptions ?? {};\n    return {\n        id,\n        schema,\n        optional: false,\n        repeated: true,\n        minLength: length ?? minLength,\n        maxLength: length ?? maxLength,\n    } as RepeatedFieldType<T[]>;\n};\n\n/**\n * Object TLV optional field that can exist repeated in a TLV List structure. The order is preserved on encoding and\n * decoding.\n */\nexport const TlvOptionalRepeatedField = <T>(\n    id: number,\n    schema: TlvSchema<T>,\n    lengthOptions?: { maxLength: number },\n) => {\n    const { maxLength } = lengthOptions ?? {};\n    return {\n        id,\n        schema,\n        optional: true,\n        repeated: true,\n        minLength: 0,\n        maxLength,\n    } as OptionalRepeatedFieldType<T[]>;\n};\n"],
  "mappings": "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",
  "names": []
}
