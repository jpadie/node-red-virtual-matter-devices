{
  "version": 3,
  "sources": ["../../../src/tlv/TlvNullable.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ArraySchema } from \"./TlvArray.js\";\nimport { TlvTag, TlvType, TlvTypeLength } from \"./TlvCodec.js\";\nimport { TlvEncodingOptions, TlvReader, TlvSchema, TlvWriter } from \"./TlvSchema.js\";\nimport { StringSchema } from \"./TlvString.js\";\n\n/**\n * Schema to encode a nullable value in TLV.\n *\n * @see {@link MatterSpecification.v10.Core} \u00A7 A.11.6\n */\nexport class NullableSchema<T> extends TlvSchema<T | null> {\n    constructor(private readonly schema: TlvSchema<T>) {\n        super();\n    }\n\n    override encodeTlvInternal(writer: TlvWriter, value: T | null, tag?: TlvTag, options?: TlvEncodingOptions): void {\n        if (value === null) {\n            writer.writeTag({ type: TlvType.Null }, tag);\n        } else {\n            this.schema.encodeTlvInternal(writer, value, tag, options);\n        }\n    }\n\n    override decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): T | null {\n        if (typeLength.type === TlvType.Null) return null;\n        const value = this.schema.decodeTlvInternalValue(reader, typeLength);\n        // The Matter standard allows to send an empty string or Array for nullable elements that have a length.\n        // This should be handled like null, so make sure to convert that correctly when decoding.\n        // @see {@link MatterSpecification.v12.Core} \u00A7 7.17.1\n        if (\n            value !== null &&\n            (this.schema instanceof ArraySchema || this.schema instanceof StringSchema) &&\n            (value as any).length === 0\n        ) {\n            return null;\n        }\n        return value;\n    }\n\n    override validate(value: T | null): void {\n        if (value !== null) this.schema.validate(value);\n    }\n\n    override injectField(value: T, fieldId: number, fieldValue: any, injectChecker: (fieldValue: any) => boolean): T {\n        if (value !== null) {\n            return this.schema.injectField(value, fieldId, fieldValue, injectChecker);\n        }\n        return value;\n    }\n\n    override removeField(value: T, fieldId: number, removeChecker: (fieldValue: any) => boolean): T {\n        if (value !== null) {\n            return this.schema.removeField(value, fieldId, removeChecker);\n        }\n        return value;\n    }\n}\n\n/** Nullable TLV schema. */\nexport const TlvNullable = <T>(schema: TlvSchema<T>) => new NullableSchema(schema);\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,mBAAmB;AAC5B,SAAiB,eAA8B;AAC/C,SAAwC,iBAA4B;AACpE,SAAS,oBAAoB;AAOtB,MAAM,uBAA0B,UAAoB;AAAA,EACvD,YAA6B,QAAsB;AAC/C,UAAM;AADmB;AAAA,EAE7B;AAAA,EAES,kBAAkB,QAAmB,OAAiB,KAAc,SAAoC;AAC7G,QAAI,UAAU,MAAM;AAChB,aAAO,SAAS,EAAE,MAAM,QAAQ,KAAK,GAAG,GAAG;AAAA,IAC/C,OAAO;AACH,WAAK,OAAO,kBAAkB,QAAQ,OAAO,KAAK,OAAO;AAAA,IAC7D;AAAA,EACJ;AAAA,EAES,uBAAuB,QAAmB,YAAqC;AACpF,QAAI,WAAW,SAAS,QAAQ,KAAM,QAAO;AAC7C,UAAM,QAAQ,KAAK,OAAO,uBAAuB,QAAQ,UAAU;AAInE,QACI,UAAU,SACT,KAAK,kBAAkB,eAAe,KAAK,kBAAkB,iBAC7D,MAAc,WAAW,GAC5B;AACE,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAES,SAAS,OAAuB;AACrC,QAAI,UAAU,KAAM,MAAK,OAAO,SAAS,KAAK;AAAA,EAClD;AAAA,EAES,YAAY,OAAU,SAAiB,YAAiB,eAAgD;AAC7G,QAAI,UAAU,MAAM;AAChB,aAAO,KAAK,OAAO,YAAY,OAAO,SAAS,YAAY,aAAa;AAAA,IAC5E;AACA,WAAO;AAAA,EACX;AAAA,EAES,YAAY,OAAU,SAAiB,eAAgD;AAC5F,QAAI,UAAU,MAAM;AAChB,aAAO,KAAK,OAAO,YAAY,OAAO,SAAS,aAAa;AAAA,IAChE;AACA,WAAO;AAAA,EACX;AACJ;AAGO,MAAM,cAAc,CAAI,WAAyB,IAAI,eAAe,MAAM;",
  "names": []
}
