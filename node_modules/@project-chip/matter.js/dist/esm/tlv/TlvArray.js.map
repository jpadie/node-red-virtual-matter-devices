{
  "version": 3,
  "sources": ["../../../src/tlv/TlvArray.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { UnexpectedDataError } from \"../common/MatterError.js\";\nimport {\n    ValidationDatatypeMismatchError,\n    ValidationError,\n    ValidationOutOfBoundsError,\n} from \"../common/ValidationError.js\";\nimport { deepCopy } from \"../util/DeepCopy.js\";\nimport { serialize } from \"../util/String.js\";\nimport { TlvTag, TlvType, TlvTypeLength } from \"./TlvCodec.js\";\nimport { TlvEncodingOptions, TlvReader, TlvSchema, TlvStream, TlvWriter } from \"./TlvSchema.js\";\n\nexport type LengthConstraints = {\n    minLength?: number;\n    maxLength?: number;\n    length?: number;\n};\n\ntype ArrayChunkData = {\n    listIndex: number | null | undefined;\n    element: TlvStream;\n};\nexport type ArrayAsChunked = ArrayChunkData[];\n\n/**\n * Schema to encode an array or string in TLV.\n *\n * @see {@link MatterSpecification.v10.Core} \u00A7 A.11.2 and A.11.4\n */\nexport class ArraySchema<T> extends TlvSchema<T[]> {\n    constructor(\n        readonly elementSchema: TlvSchema<T>,\n        readonly minLength: number = 0,\n        readonly maxLength: number = 65535,\n    ) {\n        super();\n    }\n\n    override encodeTlvInternal(writer: TlvWriter, value: T[], tag?: TlvTag, options?: TlvEncodingOptions): void {\n        writer.writeTag({ type: TlvType.Array }, tag);\n        value.forEach(element => this.elementSchema.encodeTlvInternal(writer, element, undefined, options));\n        writer.writeTag({ type: TlvType.EndOfContainer });\n    }\n\n    override decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): T[] {\n        if (typeLength.type !== TlvType.Array)\n            throw new UnexpectedDataError(`Unexpected type ${typeLength.type}, expected Array (${TlvType.Array}).`);\n        const result = new Array<T>();\n        while (true) {\n            const { tag: elementTag, typeLength: elementTypeLength } = reader.readTagType();\n            if (elementTag !== undefined) throw new UnexpectedDataError(\"Array element tags should be anonymous.\");\n            if (elementTypeLength.type === TlvType.EndOfContainer) break;\n            result.push(this.elementSchema.decodeTlvInternalValue(reader, elementTypeLength));\n        }\n        return result;\n    }\n\n    override injectField(\n        value: T[],\n        fieldId: number,\n        fieldValue: any,\n        injectChecker: (fieldValue: any) => boolean,\n    ): T[] {\n        if (Array.isArray(value)) {\n            value.forEach(\n                (item, index) =>\n                    (value[index] = this.elementSchema.injectField(item, fieldId, fieldValue, injectChecker)),\n            );\n        }\n        return value;\n    }\n\n    override removeField(value: T[], fieldId: number, removeChecker: (fieldValue: any) => boolean): T[] {\n        if (Array.isArray(value)) {\n            value.forEach(\n                (item, index) => (value[index] = this.elementSchema.removeField(item, fieldId, removeChecker)),\n            );\n        }\n        return value;\n    }\n\n    override validate(data: T[]): void {\n        if (!Array.isArray(data)) throw new ValidationDatatypeMismatchError(`Expected array, got ${typeof data}.`);\n        if (data.length > this.maxLength)\n            throw new ValidationOutOfBoundsError(\n                `Array ${serialize(data)} is too long: ${data.length}, max ${this.maxLength}.`,\n            );\n        if (data.length < this.minLength)\n            throw new ValidationOutOfBoundsError(\n                `Array ${serialize(data)} is too short: ${data.length}, min ${this.minLength}.`,\n            );\n        data.forEach((element, index) => {\n            try {\n                this.elementSchema.validate(element);\n            } catch (e) {\n                ValidationError.accept(e);\n                e.fieldName = `[${index}]${e.fieldName !== undefined ? `.${e.fieldName}` : \"\"}`;\n                throw e;\n            }\n        });\n    }\n\n    decodeFromChunkedArray(chunks: ArrayAsChunked, currentValue?: T[]): T[] {\n        if (currentValue === undefined && chunks[0].listIndex !== undefined) {\n            throw new UnexpectedDataError(\n                `When no current value is supplied the first chunked element needs to have a list index of undefined, but received ${chunks[0].listIndex}.`,\n            );\n        }\n        currentValue = currentValue !== undefined ? deepCopy(currentValue) : []; // For the sake of typing; the above check makes sure it is an array\n        for (const { listIndex, element } of chunks) {\n            if (listIndex === undefined) {\n                // not set listIndex means \"Override the whole array\"\n                currentValue = this.decodeTlv(element);\n            } else if (listIndex === null) {\n                // null listIndex means \"Append to the array\"\n                const decodedElement = this.elementSchema.decodeTlv(element);\n                currentValue.push(decodedElement);\n            } else if (element[0].typeLength.type === TlvType.Null) {\n                // null element means \"Remove from the array\"\n                currentValue.splice(listIndex, 1);\n            } else {\n                // otherwise, set the element at the given index\n                currentValue[listIndex] = this.elementSchema.decodeTlv(element);\n            }\n        }\n        return currentValue;\n    }\n\n    encodeAsChunkedArray(value: T[]): ArrayAsChunked {\n        const result: ArrayAsChunked = [];\n        result.push({ listIndex: undefined, element: this.encodeTlv([]) });\n        value.forEach(element => {\n            const elementStream = this.elementSchema.encodeTlv(element);\n            result.push({ listIndex: null, element: elementStream });\n        });\n        return result;\n    }\n}\n\n/** Array TLV schema. */\nexport const TlvArray = <T>(elementSchema: TlvSchema<T>, { minLength, maxLength, length }: LengthConstraints = {}) =>\n    new ArraySchema(elementSchema, length ?? minLength, length ?? maxLength);\n"],
  "mappings": "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",
  "names": []
}
