{
  "version": 3,
  "sources": ["../../../src/tlv/TlvString.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError, UnexpectedDataError } from \"../common/MatterError.js\";\nimport { ValidationDatatypeMismatchError, ValidationOutOfBoundsError } from \"../common/ValidationError.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { maxValue, minValue } from \"../util/Number.js\";\nimport { serialize } from \"../util/String.js\";\nimport { TlvCodec, TlvTag, TlvToPrimitive, TlvType, TlvTypeLength } from \"./TlvCodec.js\";\nimport { TlvReader, TlvSchema, TlvWriter } from \"./TlvSchema.js\";\n\ntype LengthConstraints = {\n    minLength?: number;\n    maxLength?: number;\n    length?: number;\n};\n\n/**\n * Schema to encode an byte string or an Utf8 string in TLV.\n *\n * @see {@link MatterSpecification.v10.Core} \u00A7 A.11.2\n */\nexport class StringSchema<T extends TlvType.ByteString | TlvType.Utf8String> extends TlvSchema<TlvToPrimitive[T]> {\n    constructor(\n        private type: T,\n        readonly minLength: number = 0,\n        readonly maxLength: number = 1024,\n    ) {\n        super();\n\n        if (minLength < 0) throw new InternalError(\"Minimum length should be a positive number.\");\n    }\n\n    override encodeTlvInternal(writer: TlvWriter, value: TlvToPrimitive[T], tag?: TlvTag): void {\n        const typeLength: TlvTypeLength = { type: this.type, length: TlvCodec.getUIntTlvLength(value.length) };\n        writer.writeTag(typeLength, tag);\n        writer.writePrimitive(typeLength, value);\n    }\n\n    override decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): TlvToPrimitive[T] {\n        if (typeLength.type !== this.type) throw new UnexpectedDataError(`Unexpected type ${typeLength.type}.`);\n        return reader.readPrimitive(typeLength);\n    }\n\n    override validate(value: TlvToPrimitive[T]): void {\n        if (this.type === TlvType.Utf8String && typeof value !== \"string\")\n            throw new ValidationDatatypeMismatchError(`Expected string, got ${typeof value}.`);\n        if (this.type === TlvType.ByteString && !(value instanceof ByteArray))\n            throw new ValidationDatatypeMismatchError(`Expected ByteArray, got ${typeof value}.`);\n        if (value.length > this.maxLength)\n            throw new ValidationOutOfBoundsError(\n                `String ${serialize(value)} is too long: ${value.length}, max ${this.maxLength}.`,\n            );\n        if (value.length < this.minLength)\n            throw new ValidationOutOfBoundsError(\n                `String ${serialize(value)} is too short: ${value.length}, min ${this.minLength}.`,\n            );\n    }\n\n    bound({ minLength, maxLength, length }: LengthConstraints) {\n        return new StringSchema(\n            this.type,\n            length ?? maxValue(this.minLength, minLength),\n            length ?? minValue(this.maxLength, maxLength),\n        );\n    }\n}\n\n/** ByteString TLV schema. */\nexport const TlvByteString = new StringSchema(TlvType.ByteString);\n\n/** String TLV schema. */\nexport const TlvString = new StringSchema(TlvType.Utf8String);\n\n/** String TLV schema. */\nexport const TlvString32max = TlvString.bound({ maxLength: 32 });\n\n/** String TLV schema. */\nexport const TlvString64max = TlvString.bound({ maxLength: 64 });\n\n/** String TLV schema. */\nexport const TlvString256max = TlvString.bound({ maxLength: 256 });\n\nexport const TlvHardwareAddress = TlvByteString.bound({ minLength: 6, maxLength: 8 });\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,eAAe,2BAA2B;AACnD,SAAS,iCAAiC,kCAAkC;AAC5E,SAAS,iBAAiB;AAC1B,SAAS,UAAU,gBAAgB;AACnC,SAAS,iBAAiB;AAC1B,SAAS,UAAkC,eAA8B;AACzE,SAAoB,iBAA4B;AAazC,MAAM,qBAAwE,UAA6B;AAAA,EAC9G,YACY,MACC,YAAoB,GACpB,YAAoB,MAC/B;AACE,UAAM;AAJE;AACC;AACA;AAIT,QAAI,YAAY,EAAG,OAAM,IAAI,cAAc,6CAA6C;AAAA,EAC5F;AAAA,EAES,kBAAkB,QAAmB,OAA0B,KAAoB;AACxF,UAAM,aAA4B,EAAE,MAAM,KAAK,MAAM,QAAQ,SAAS,iBAAiB,MAAM,MAAM,EAAE;AACrG,WAAO,SAAS,YAAY,GAAG;AAC/B,WAAO,eAAe,YAAY,KAAK;AAAA,EAC3C;AAAA,EAES,uBAAuB,QAAmB,YAA8C;AAC7F,QAAI,WAAW,SAAS,KAAK,KAAM,OAAM,IAAI,oBAAoB,mBAAmB,WAAW,IAAI,GAAG;AACtG,WAAO,OAAO,cAAc,UAAU;AAAA,EAC1C;AAAA,EAES,SAAS,OAAgC;AAC9C,QAAI,KAAK,SAAS,QAAQ,cAAc,OAAO,UAAU;AACrD,YAAM,IAAI,gCAAgC,wBAAwB,OAAO,KAAK,GAAG;AACrF,QAAI,KAAK,SAAS,QAAQ,cAAc,EAAE,iBAAiB;AACvD,YAAM,IAAI,gCAAgC,2BAA2B,OAAO,KAAK,GAAG;AACxF,QAAI,MAAM,SAAS,KAAK;AACpB,YAAM,IAAI;AAAA,QACN,UAAU,UAAU,KAAK,CAAC,iBAAiB,MAAM,MAAM,SAAS,KAAK,SAAS;AAAA,MAClF;AACJ,QAAI,MAAM,SAAS,KAAK;AACpB,YAAM,IAAI;AAAA,QACN,UAAU,UAAU,KAAK,CAAC,kBAAkB,MAAM,MAAM,SAAS,KAAK,SAAS;AAAA,MACnF;AAAA,EACR;AAAA,EAEA,MAAM,EAAE,WAAW,WAAW,OAAO,GAAsB;AACvD,WAAO,IAAI;AAAA,MACP,KAAK;AAAA,MACL,UAAU,SAAS,KAAK,WAAW,SAAS;AAAA,MAC5C,UAAU,SAAS,KAAK,WAAW,SAAS;AAAA,IAChD;AAAA,EACJ;AACJ;AAGO,MAAM,gBAAgB,IAAI,aAAa,QAAQ,UAAU;AAGzD,MAAM,YAAY,IAAI,aAAa,QAAQ,UAAU;AAGrD,MAAM,iBAAiB,UAAU,MAAM,EAAE,WAAW,GAAG,CAAC;AAGxD,MAAM,iBAAiB,UAAU,MAAM,EAAE,WAAW,GAAG,CAAC;AAGxD,MAAM,kBAAkB,UAAU,MAAM,EAAE,WAAW,IAAI,CAAC;AAE1D,MAAM,qBAAqB,cAAc,MAAM,EAAE,WAAW,GAAG,WAAW,EAAE,CAAC;",
  "names": []
}
