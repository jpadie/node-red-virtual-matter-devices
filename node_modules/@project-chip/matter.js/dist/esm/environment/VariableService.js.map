{
  "version": 3,
  "sources": ["../../../src/environment/VariableService.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { isObject } from \"../util/Type.js\";\nimport type { Environment } from \"./Environment.js\";\nimport { Environmental } from \"./Environmental.js\";\n\n/**\n * Environmental configuration values.\n */\nexport class VariableService {\n    #vars = {} as VariableService.Map;\n    #usageCollectors = Array<Set<string>>();\n    #usages = new Set<VariableService.Usage>();\n\n    constructor(environment: Environment) {\n        environment.set(VariableService, this);\n    }\n\n    static [Environmental.create](environment: Environment) {\n        return new this(environment);\n    }\n\n    get [Diagnostic.value]() {\n        return \"Configuration\";\n    }\n\n    get vars() {\n        return this.#vars;\n    }\n\n    /**\n     * Configure a component.\n     *\n     * Runs the supplied {@link configurator} immediately and whenever variables reference by the {@link configurator}\n     * change.\n     *\n     * To terminate reconfiguration invoke {@link VariableService.Usage.close} on the return value.\n     */\n    use(configurator: () => void): VariableService.Usage {\n        const variables = new Set<string>();\n        try {\n            this.#usageCollectors.push(variables);\n            configurator();\n        } finally {\n            this.#usageCollectors.pop();\n        }\n\n        const usage = {\n            variables,\n            configurator,\n            close: () => {\n                this.#usages.delete(usage);\n            },\n        };\n        this.#usages.add(usage);\n\n        return usage;\n    }\n\n    get<T extends VariableService.Primitive>(name: string, fallback?: T): T;\n\n    get<T extends VariableService.Value>(name: string, fallback: T): T;\n\n    get<T extends VariableService.Value>(name: string): T | undefined;\n\n    get(name: string, fallback?: VariableService.Value) {\n        for (const collector of this.#usageCollectors) {\n            collector.add(name);\n        }\n\n        switch (typeof fallback) {\n            case \"string\":\n                return this.string(name) ?? fallback;\n\n            case \"number\":\n                return this.number(name) ?? fallback;\n\n            case \"boolean\":\n                return this.boolean(name) ?? fallback;\n        }\n\n        let value: VariableService.Value = this.#vars;\n        for (const segment of this.#parseName(name)) {\n            if (value === null || typeof value !== \"object\" || Array.isArray(value)) {\n                return fallback;\n            }\n            value = value[segment];\n        }\n        return value ?? fallback;\n    }\n\n    has(name: string) {\n        return this.get(name) !== undefined;\n    }\n\n    set(name: string, value: VariableService.Value) {\n        const segments = name.toLowerCase().split(\".\");\n        const key = segments.pop() as string;\n        let parent: VariableService.Map = this.#vars;\n        for (const segment of segments) {\n            let nextParent = parent[segment];\n            if (nextParent === undefined || nextParent === null) {\n                nextParent = parent[segment] = {};\n            } else if (typeof nextParent !== \"object\" || Array.isArray(nextParent)) {\n                throw new ImplementationError(`Can't set ${name} because segment ${segment} is not a map`);\n            }\n            parent = nextParent;\n        }\n\n        if (parent[key] === value) {\n            return;\n        }\n\n        parent[key] = value;\n\n        for (const usage of this.#usages) {\n            if (usage.variables.has(name)) {\n                usage.configurator();\n            }\n        }\n    }\n\n    string(name: string) {\n        const value = this.get(name);\n        if (value === undefined) {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            return value;\n        }\n        if (value === null) {\n            return \"null\";\n        }\n        return value.toString();\n    }\n\n    boolean(name: string) {\n        const value = this.get(name);\n        switch (value) {\n            case undefined:\n                return value;\n\n            case null:\n            case 0:\n            case false:\n            case \"false\":\n            case \"off\":\n                return false;\n\n            default:\n                return true;\n        }\n    }\n\n    number(name: string) {\n        let value = this.get(name);\n        if (typeof value === \"number\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            value = Number.parseFloat(value);\n            if (Number.isNaN(value)) {\n                return;\n            }\n            return value;\n        }\n    }\n\n    integer(name: string, fallback?: number) {\n        const number = this.number(name) ?? fallback;\n        if (typeof number === \"number\") {\n            return Math.floor(number);\n        }\n    }\n\n    increment(name: string) {\n        const value = this.integer(name) ?? 0;\n        this.set(name, value + 1);\n        return value;\n    }\n\n    addConfigStyle(vars: VariableService.Map) {\n        const path = Array<string>();\n\n        const add = (vars: VariableService.Map) => {\n            for (const name in vars) {\n                const val = vars[name];\n                if (isObject(val)) {\n                    path.push(name);\n                    add(val);\n                    path.pop();\n                } else {\n                    this.set([...path, name].join(\".\"), val);\n                }\n            }\n        };\n\n        add(vars);\n    }\n\n    addUnixEnvStyle(vars: Record<string, string | undefined>) {\n        this.addConfigStyle(parseUnixStyle(vars));\n    }\n\n    addArgvStyle(vars: string[]) {\n        this.addConfigStyle(parseArgvStyle(vars));\n    }\n\n    #parseName(name: string) {\n        return name\n            .toLowerCase()\n            .split(\".\")\n            .map(segment => {\n                segment = segment.trim();\n                if (segment === \"\") {\n                    throw new ImplementationError(`Variable name ${name} contains empty segments`);\n                }\n                return segment;\n            });\n    }\n}\n\nexport namespace VariableService {\n    export interface Options {\n        unixEnvStyle?: Record<string, string>;\n        argvStyle?: string[];\n        configStyle?: Map;\n    }\n\n    export interface Map extends Record<string, Value> {}\n    export type List = Value[];\n    export type Primitive = number | string | boolean;\n    export type Value = Primitive | Map | List;\n    export interface Usage {\n        variables: Set<string>;\n        configurator(): void;\n        close(): void;\n    }\n}\n\nfunction addVariable(into: Record<string, any>, path: string[], value: any) {\n    if (!path.length) {\n        return;\n    }\n\n    let current = into[path[0]];\n    if (path.length === 1) {\n        if (current === undefined) {\n            into[path[0]] = value;\n        }\n        return;\n    }\n\n    if (typeof current !== \"object\") {\n        current = into[path[0]] = {};\n    }\n    addVariable(current, path.slice(1), value);\n}\n\nfunction parseUnixStyle(values: Record<string, string | undefined>) {\n    const variables = {} as VariableService.Map;\n\n    for (const key in values) {\n        if (key.startsWith(\"MATTER_\")) {\n            if (values[key] === undefined || values[key] === \"\") {\n                continue;\n            }\n            addVariable(variables, key.slice(7).toLowerCase().split(\"_\"), values[key]);\n        }\n    }\n\n    return variables;\n}\n\nfunction parseArgvStyle(values: string[]) {\n    const variables = {} as VariableService.Map;\n\n    for (let arg of values) {\n        if (!arg.startsWith(\"--\")) {\n            continue;\n        }\n        arg = arg.slice(2);\n\n        const separatorPos = arg.indexOf(\"=\");\n        let key, value;\n\n        if (separatorPos === -1) {\n            key = arg;\n            value = true;\n        } else {\n            key = arg.slice(0, separatorPos);\n            value = arg.slice(separatorPos + 1);\n            if ((value.startsWith(\"'\") && value.endsWith(\"'\")) || (value.startsWith('\"') && value.endsWith('\"'))) {\n                value = value.slice(1, -1).replaceAll(\"\\\\'\", \"'\").replaceAll('\\\\\"', '\"');\n            }\n        }\n\n        addVariable(variables, key.toLowerCase().split(\"-\"), value);\n    }\n\n    return variables;\n}\n"],
  "mappings": "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",
  "names": ["vars"]
}
