{
  "version": 3,
  "sources": ["../../../src/device/ComposedDevice.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BridgedDeviceBasicInformationCluster } from \"../cluster/definitions/index.js\";\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport { Device } from \"./Device.js\";\nimport { DeviceTypeDefinition } from \"./DeviceTypes.js\";\nimport { Endpoint, EndpointOptions } from \"./Endpoint.js\";\n\n/**\n * A ComposedDevice is a special endpoint that allows to combine multiple sub devices and expose this as one device\n * (e.g. a fan and a light).\n */\nexport class ComposedDevice extends Endpoint {\n    /**\n     * Creates a new ComposedDevice.\n     *\n     * @param definition DeviceTypeDefinitions of the composed device\n     * @param devices Array with devices that should be combined into one device that are directly added.\n     * @param options Optional Endpoint options\n     */\n    constructor(definition: DeviceTypeDefinition, devices: Device[] = [], options: EndpointOptions = {}) {\n        super([definition], options);\n        devices.forEach(device => this.addDevice(device));\n    }\n\n    /**\n     * Add a sub-device to the composed device.\n     * @param device Device instance to add\n     */\n    addDevice(device: Device) {\n        this.addChildEndpoint(device);\n    }\n\n    /**\n     * Get all sub-devices of the composed device.\n     *\n     * @returns Array with all sub-devices\n     */\n    getDevices() {\n        return this.getChildEndpoints();\n    }\n\n    /**\n     * Verify that the required clusters exists on the device.\n     */\n    override verifyRequiredClusters() {\n        // TODO find out what to really check here and how ... most likely we need to verify that the added sub devices\n        //      somehow match with the device types of the composed device?!\n        //      For now we do not check this\n        return;\n    }\n\n    /**\n     * Set the reachability of the Composed device exposed via the bridge.\n     *\n     * @param reachable true if reachable, false otherwise\n     */\n    setBridgedDeviceReachability(reachable: boolean) {\n        const bridgedBasicInformationCluster = this.getClusterServer(BridgedDeviceBasicInformationCluster);\n        if (bridgedBasicInformationCluster === undefined) {\n            throw new ImplementationError(\n                \"The reachability flag can only be set for bridged devices this way. To set the reachability flag for a non-bridged device or for the bridget itself please set it on the CommissioningServer!\",\n            );\n        }\n        bridgedBasicInformationCluster.setReachableAttribute(reachable);\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,SAAS,4CAA4C;AACrD,SAAS,2BAA2B;AAGpC,SAAS,gBAAiC;AAMnC,MAAM,uBAAuB,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzC,YAAY,YAAkC,UAAoB,CAAC,GAAG,UAA2B,CAAC,GAAG;AACjG,UAAM,CAAC,UAAU,GAAG,OAAO;AAC3B,YAAQ,QAAQ,YAAU,KAAK,UAAU,MAAM,CAAC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,QAAgB;AACtB,SAAK,iBAAiB,MAAM;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa;AACT,WAAO,KAAK,kBAAkB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKS,yBAAyB;AAI9B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,6BAA6B,WAAoB;AAC7C,UAAM,iCAAiC,KAAK,iBAAiB,oCAAoC;AACjG,QAAI,mCAAmC,QAAW;AAC9C,YAAM,IAAI;AAAA,QACN;AAAA,MACJ;AAAA,IACJ;AACA,mCAA+B,sBAAsB,SAAS;AAAA,EAClE;AACJ;",
  "names": []
}
