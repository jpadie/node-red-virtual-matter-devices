/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { asClusterClientInternal, isClusterClient } from "../cluster/client/ClusterClientTypes.js";
import { getClusterById } from "../cluster/ClusterHelper.js";
import { ClusterClient } from "../cluster/client/ClusterClient.js";
import { DescriptorCluster } from "../cluster/definitions/DescriptorCluster.js";
import { OperationalCredentials } from "../cluster/definitions/OperationalCredentialsCluster.js";
import { ClusterServer } from "../cluster/server/ClusterServer.js";
import {
  isClusterServer
} from "../cluster/server/ClusterServerTypes.js";
import { ImplementationError, InternalError, MatterError } from "../common/MatterError.js";
import { EndpointNumber } from "../datatype/EndpointNumber.js";
import { Logger } from "../log/Logger.js";
import {
  structureReadAttributeDataToClusterObject
} from "../protocol/interaction/AttributeDataDecoder.js";
import { Aggregator } from "./Aggregator.js";
import { ComposedDevice } from "./ComposedDevice.js";
import { PairedDevice, RootEndpoint } from "./Device.js";
import { BasicInformation } from "../cluster/definitions/BasicInformationCluster.js";
import { AdministratorCommissioning } from "../cluster/definitions/index.js";
import { Crypto } from "../crypto/Crypto.js";
import { Diagnostic } from "../log/Diagnostic.js";
import { StatusCode, StatusResponseError } from "../protocol/interaction/StatusCode.js";
import {
  CommissioningFlowType,
  DiscoveryCapabilitiesSchema,
  ManualPairingCodeCodec,
  QrPairingCodeCodec
} from "../schema/PairingCodeSchema.js";
import { PaseClient } from "../session/pase/PaseClient.js";
import { Time } from "../time/Time.js";
import { DeviceTypes, UnknownDeviceType, getDeviceTypeDefinitionByCode } from "./DeviceTypes.js";
import { logEndpoint } from "./EndpointStructureLogger.js";
const logger = Logger.get("PairedNode");
const STRUCTURE_UPDATE_TIMEOUT_MS = 5e3;
var NodeStateInformation = /* @__PURE__ */ ((NodeStateInformation2) => {
  NodeStateInformation2[NodeStateInformation2["Connected"] = 0] = "Connected";
  NodeStateInformation2[NodeStateInformation2["Disconnected"] = 1] = "Disconnected";
  NodeStateInformation2[NodeStateInformation2["Reconnecting"] = 2] = "Reconnecting";
  NodeStateInformation2[NodeStateInformation2["WaitingForDeviceDiscovery"] = 3] = "WaitingForDeviceDiscovery";
  NodeStateInformation2[NodeStateInformation2["StructureChanged"] = 4] = "StructureChanged";
  NodeStateInformation2[NodeStateInformation2["Decommissioned"] = 5] = "Decommissioned";
  return NodeStateInformation2;
})(NodeStateInformation || {});
class PairedNode {
  constructor(nodeId, commissioningController, options = {}, reconnectInteractionClient, assignDisconnectedHandler) {
    this.nodeId = nodeId;
    this.commissioningController = commissioningController;
    this.options = options;
    this.reconnectInteractionClient = reconnectInteractionClient;
    assignDisconnectedHandler(async () => {
      logger.info(
        `Node ${this.nodeId}: Session disconnected${this.connectionState !== 1 /* Disconnected */ ? ", trying to reconnect ..." : ""}`
      );
      if (this.connectionState === 0 /* Connected */) {
        await this.reconnect();
      }
    });
  }
  endpoints = /* @__PURE__ */ new Map();
  interactionClient;
  reconnectDelayTimer = Time.getTimer(
    "Reconnect delay",
    STRUCTURE_UPDATE_TIMEOUT_MS,
    async () => await this.reconnect()
  );
  updateEndpointStructureTimer = Time.getTimer(
    "Endpoint structure update",
    STRUCTURE_UPDATE_TIMEOUT_MS,
    async () => await this.updateEndpointStructure()
  );
  connectionState = 1 /* Disconnected */;
  static async create(nodeId, commissioningController, options = {}, reconnectInteractionClient, assignDisconnectedHandler) {
    const node = new PairedNode(
      nodeId,
      commissioningController,
      options,
      reconnectInteractionClient,
      assignDisconnectedHandler
    );
    await node.initialize();
    return node;
  }
  get isConnected() {
    return this.connectionState === 0 /* Connected */;
  }
  setConnectionState(state) {
    if (this.connectionState === state || this.connectionState === 1 /* Disconnected */ && state === 2 /* Reconnecting */ || this.connectionState === 3 /* WaitingForDeviceDiscovery */ && state === 2 /* Reconnecting */)
      return;
    this.connectionState = state;
    this.options.stateInformationCallback?.(this.nodeId, state);
  }
  /**
   * Force a reconnection to the device. This method is mainly used internally to reconnect after the active session
   * was closed or the device went offline and was detected as being online again.
   */
  async reconnect() {
    this.setConnectionState(2 /* Reconnecting */);
    while (true) {
      if (this.interactionClient !== void 0) {
        this.interactionClient.close();
        this.interactionClient = void 0;
      }
      try {
        await this.initialize();
        return;
      } catch (error) {
        MatterError.accept(error);
        if (this.connectionState === 1 /* Disconnected */) {
          return;
        }
        logger.info(`Node ${this.nodeId}: Error waiting for device rediscovery`, error);
        this.setConnectionState(3 /* WaitingForDeviceDiscovery */);
      }
    }
  }
  /** Ensure that the node is connected by creating a new InteractionClient if needed. */
  async ensureConnection() {
    if (this.interactionClient !== void 0) return this.interactionClient;
    this.interactionClient = await this.reconnectInteractionClient();
    return this.interactionClient;
  }
  /**
   * Initialize the node after the InteractionClient was created and to subscribe attributes and events if requested.
   */
  async initialize() {
    const interactionClient = await this.ensureConnection();
    const { autoSubscribe, attributeChangedCallback, eventTriggeredCallback } = this.options;
    if (autoSubscribe !== false) {
      const initialSubscriptionData = await this.subscribeAllAttributesAndEvents({
        ignoreInitialTriggers: true,
        attributeChangedCallback: (data) => attributeChangedCallback?.(this.nodeId, data),
        eventTriggeredCallback: (data) => eventTriggeredCallback?.(this.nodeId, data)
      });
      if (initialSubscriptionData.attributeReports === void 0) {
        throw new InternalError("No attribute reports received when subscribing to all values!");
      }
      await this.initializeEndpointStructure(initialSubscriptionData.attributeReports ?? []);
      const rootDescriptorCluster = this.getRootClusterClient(DescriptorCluster);
      rootDescriptorCluster?.addPartsListAttributeListener(() => {
        logger.info(`Node ${this.nodeId}: PartsList changed, reinitializing endpoint structure ...`);
        this.updateEndpointStructureTimer.stop().start();
      });
    } else {
      const allClusterAttributes = await interactionClient.getAllAttributes();
      await this.initializeEndpointStructure(allClusterAttributes);
    }
    this.setConnectionState(0 /* Connected */);
  }
  /**
   * Request the current InteractionClient for custom special case interactions with the device. Usually the
   * ClusterClients of the Devices of the node should be used instead.
   */
  async getInteractionClient() {
    return await this.ensureConnection();
  }
  /** Method to log the structure of this node with all endpoint and clusters. */
  logStructure(options) {
    const rootEndpoint = this.endpoints.get(EndpointNumber(0));
    if (rootEndpoint === void 0) {
      logger.info(`Node ${this.nodeId} has not yet been initialized!`);
      return;
    }
    logEndpoint(rootEndpoint, options);
  }
  /**
   * Subscribe to all attributes and events of the device. Unless setting the Controller property autoSubscribe to
   * false this is executed automatically. Alternatively you can manually subscribe by calling this method.
   */
  async subscribeAllAttributesAndEvents(options) {
    options = options ?? {};
    const { attributeChangedCallback, eventTriggeredCallback } = options;
    let { ignoreInitialTriggers = false } = options;
    const interactionClient = await this.ensureConnection();
    const initialSubscriptionData = await interactionClient.subscribeAllAttributesAndEvents({
      isUrgent: true,
      minIntervalFloorSeconds: this.options.subscribeMinIntervalFloorSeconds ?? 0,
      maxIntervalCeilingSeconds: this.options.subscribeMaxIntervalCeilingSeconds ?? 60,
      attributeListener: (data) => {
        const {
          path: { endpointId, clusterId, attributeId },
          value
        } = data;
        if (ignoreInitialTriggers) return;
        const device = this.endpoints.get(endpointId);
        if (device === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received attribute update for unknown endpoint ${endpointId}!`
          );
          return;
        }
        const cluster = device.getClusterClientById(clusterId);
        if (cluster === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received attribute update for unknown cluster ${Diagnostic.hex(
              clusterId
            )} on endpoint ${endpointId}!`
          );
          return;
        }
        logger.debug(
          `Node ${this.nodeId} Trigger attribute update for ${endpointId}.${cluster.name}.${attributeId} to ${Logger.toJSON(
            value
          )}`
        );
        asClusterClientInternal(cluster)._triggerAttributeUpdate(attributeId, value);
        if (attributeChangedCallback !== void 0) {
          attributeChangedCallback(data);
        }
      },
      eventListener: (data) => {
        const {
          path: { endpointId, clusterId, eventId },
          events
        } = data;
        if (ignoreInitialTriggers) return;
        const device = this.endpoints.get(endpointId);
        if (device === void 0) {
          logger.info(`Node ${this.nodeId} Ignoring received event for unknown endpoint ${endpointId}!`);
          return;
        }
        const cluster = device.getClusterClientById(clusterId);
        if (cluster === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received event for unknown cluster ${Diagnostic.hex(
              clusterId
            )} on endpoint ${endpointId}!`
          );
          return;
        }
        logger.debug(
          `Node ${this.nodeId} Trigger event update for ${endpointId}.${cluster.name}.${eventId} for ${events.length} events`
        );
        asClusterClientInternal(cluster)._triggerEventUpdate(eventId, events);
        if (eventTriggeredCallback !== void 0) {
          eventTriggeredCallback(data);
        }
        if (clusterId === BasicInformation.Cluster.id && eventId === BasicInformation.Cluster.events.shutDown.id) {
          this.handleNodeShutdown().catch(
            (error) => logger.warn(`Node ${this.nodeId}: Error handling node shutdown`, error)
          );
        }
      },
      updateTimeoutHandler: async () => {
        logger.info(`Node ${this.nodeId}: Subscription update not received ...`);
        try {
          await this.subscribeAllAttributesAndEvents({ ...options, ignoreInitialTriggers: false });
        } catch (error) {
          logger.info(`Node ${this.nodeId}: Error resubscribing to all attributes and events`, error);
          this.interactionClient = void 0;
        }
      }
    });
    ignoreInitialTriggers = false;
    return initialSubscriptionData;
  }
  /** Handles a node shutDown event (if supported by the node and received). */
  async handleNodeShutdown() {
    logger.info(`Node ${this.nodeId}: Node shutdown detected, trying to reconnect ...`);
    if (!this.reconnectDelayTimer.isRunning) {
      this.reconnectDelayTimer.start();
    }
    this.setConnectionState(2 /* Reconnecting */);
  }
  async updateEndpointStructure() {
    const interactionClient = await this.ensureConnection();
    const allClusterAttributes = await interactionClient.getAllAttributes();
    await this.initializeEndpointStructure(allClusterAttributes, true);
    this.options.stateInformationCallback?.(this.nodeId, 4 /* StructureChanged */);
  }
  /** Reads all data from the device and create a device object structure out of it. */
  async initializeEndpointStructure(allClusterAttributes, updateStructure = false) {
    const interactionClient = await this.ensureConnection();
    const allData = structureReadAttributeDataToClusterObject(allClusterAttributes);
    if (updateStructure) {
      const endpointsToRemove = new Set(this.endpoints.keys());
      for (const [endpointId] of Object.entries(allData)) {
        const endpointIdNumber = EndpointNumber(parseInt(endpointId));
        if (this.endpoints.has(endpointIdNumber)) {
          logger.debug("Retaining device", endpointId);
          endpointsToRemove.delete(endpointIdNumber);
        }
      }
      for (const endpointId of endpointsToRemove.values()) {
        logger.debug("Removing device", endpointId);
        this.endpoints.get(endpointId)?.removeFromStructure();
        this.endpoints.delete(endpointId);
      }
    } else {
      this.endpoints.clear();
    }
    const partLists = /* @__PURE__ */ new Map();
    for (const [endpointId, clusters] of Object.entries(allData)) {
      const endpointIdNumber = EndpointNumber(parseInt(endpointId));
      const descriptorData = clusters[DescriptorCluster.id];
      partLists.set(endpointIdNumber, descriptorData.partsList);
      if (this.endpoints.has(endpointIdNumber)) {
        continue;
      }
      logger.debug("Creating device", endpointId, Logger.toJSON(clusters));
      this.endpoints.set(endpointIdNumber, this.createDevice(endpointIdNumber, clusters, interactionClient));
    }
    this.structureEndpoints(partLists);
  }
  /** Bring the endpoints in a structure based on their partsList attribute. */
  structureEndpoints(partLists) {
    logger.debug(`Node ${this.nodeId}: Endpoints from PartsLists`, Logger.toJSON(Array.from(partLists.entries())));
    const endpointUsages = {};
    Array.from(partLists.entries()).forEach(
      ([parent, partsList]) => partsList.forEach((endPoint) => {
        endpointUsages[endPoint] = endpointUsages[endPoint] || [];
        endpointUsages[endPoint].push(parent);
      })
    );
    logger.debug(`Node ${this.nodeId}: Endpoint usages`, Logger.toJSON(endpointUsages));
    while (true) {
      const singleUsageEndpoints = Object.entries(endpointUsages).filter(([_, usages]) => usages.length === 1);
      if (singleUsageEndpoints.length === 0) {
        if (Object.entries(endpointUsages).length)
          throw new InternalError(`Endpoint structure for Node ${this.nodeId} could not be parsed!`);
        break;
      }
      logger.debug(`Node ${this.nodeId}: Processing Endpoint ${Logger.toJSON(singleUsageEndpoints)}`);
      const idsToCleanup = {};
      singleUsageEndpoints.forEach(([childId, usages]) => {
        const childEndpointId = EndpointNumber(parseInt(childId));
        const childEndpoint = this.endpoints.get(childEndpointId);
        const parentEndpoint = this.endpoints.get(usages[0]);
        if (childEndpoint === void 0 || parentEndpoint === void 0) {
          throw new InternalError(`Node ${this.nodeId}: Endpoint not found!`);
        }
        if (parentEndpoint.getChildEndpoint(childEndpointId) === void 0) {
          logger.debug(
            `Node ${this.nodeId}: Endpoint structure: Child: ${childEndpointId} -> Parent: ${parentEndpoint.number}`
          );
          parentEndpoint.addChildEndpoint(childEndpoint);
        }
        delete endpointUsages[EndpointNumber(parseInt(childId))];
        idsToCleanup[usages[0]] = true;
      });
      logger.debug(`Node ${this.nodeId}: Endpoint data Cleanup`, Logger.toJSON(idsToCleanup));
      Object.keys(idsToCleanup).forEach((idToCleanup) => {
        Object.keys(endpointUsages).forEach((id) => {
          const usageId = EndpointNumber(parseInt(id));
          endpointUsages[usageId] = endpointUsages[usageId].filter(
            (endpointId) => endpointId !== parseInt(idToCleanup)
          );
          if (!endpointUsages[usageId].length) {
            delete endpointUsages[usageId];
          }
        });
      });
    }
  }
  /**
   * Create a device object from the data read from the device.
   *
   * @param endpointId Endpoint ID
   * @param data Data of all clusters read from the device
   * @param interactionClient InteractionClient to use for the device
   * @private
   */
  createDevice(endpointId, data, interactionClient) {
    const descriptorData = data[DescriptorCluster.id];
    const deviceTypes = descriptorData.deviceTypeList.flatMap(({ deviceType, revision }) => {
      const deviceTypeDefinition = getDeviceTypeDefinitionByCode(deviceType);
      if (deviceTypeDefinition === void 0) {
        logger.info(
          `NodeId ${this.nodeId}: Device type with code ${deviceType} not known, use generic replacement.`
        );
        return UnknownDeviceType(deviceType);
      }
      if (deviceTypeDefinition.revision < revision) {
        logger.debug(
          `NodeId ${this.nodeId}: Device type with code ${deviceType} and revision ${revision} not supported, some data might be unknown.`
        );
      }
      return deviceTypeDefinition;
    });
    if (deviceTypes.length === 0) {
      logger.info(`NodeId ${this.nodeId}: No device type found for endpoint ${endpointId}, ignore`);
      throw new MatterError(`NodeId ${this.nodeId}: No device type found for endpoint`);
    }
    const endpointClusters = Array();
    for (const clusterId of descriptorData.serverList) {
      const cluster = getClusterById(clusterId);
      const clusterClient = ClusterClient(cluster, endpointId, interactionClient, data[clusterId]);
      endpointClusters.push(clusterClient);
    }
    for (const clusterId of descriptorData.clientList) {
      const cluster = getClusterById(clusterId);
      const clusterData = data[clusterId] ?? {};
      endpointClusters.push(
        ClusterServer(
          cluster,
          /*clusterData.featureMap,*/
          clusterData,
          {},
          void 0,
          true
        )
      );
    }
    if (endpointId === 0) {
      const rootEndpoint = new RootEndpoint();
      rootEndpoint.setDeviceTypes(deviceTypes);
      endpointClusters.forEach((cluster) => {
        if (isClusterServer(cluster)) {
          rootEndpoint.addClusterServer(cluster);
        } else if (isClusterClient(cluster)) {
          rootEndpoint.addClusterClient(cluster);
        }
      });
      return rootEndpoint;
    } else if (deviceTypes.find((deviceType) => deviceType.code === DeviceTypes.AGGREGATOR.code) !== void 0) {
      const aggregator = new Aggregator([], { endpointId });
      aggregator.setDeviceTypes(deviceTypes);
      endpointClusters.forEach((cluster) => {
        if (isClusterServer(cluster)) {
          aggregator.addClusterServer(cluster);
        } else if (isClusterClient(cluster)) {
          aggregator.addClusterClient(cluster);
        }
      });
      return aggregator;
    } else {
      if (descriptorData.partsList.length > 0) {
        const composedDevice = new ComposedDevice(deviceTypes[0], [], { endpointId });
        composedDevice.setDeviceTypes(deviceTypes);
        endpointClusters.forEach((cluster) => {
          if (isClusterServer(cluster)) {
            composedDevice.addClusterServer(cluster);
          } else if (isClusterClient(cluster)) {
            composedDevice.addClusterClient(cluster);
          }
        });
        return composedDevice;
      } else {
        return new PairedDevice(deviceTypes, endpointClusters, endpointId);
      }
    }
  }
  /** Returns the functional devices/endpoints (those below the Root Endpoint) known for this node. */
  getDevices() {
    return this.endpoints.get(EndpointNumber(0))?.getChildEndpoints() ?? [];
  }
  /** Returns the device/endpoint with the given endpoint ID. */
  getDeviceById(endpointId) {
    return this.endpoints.get(EndpointNumber(endpointId));
  }
  getRootEndpoint() {
    return this.getDeviceById(0);
  }
  /** De-Commission (unpair) the device from this controller by removing the fabric from the device. */
  async decommission() {
    if (!this.commissioningController.isNodeCommissioned(this.nodeId)) {
      throw new ImplementationError(`This Node ${this.nodeId} is not commissioned.`);
    }
    const operationalCredentialsCluster = this.getRootClusterClient(OperationalCredentials.Cluster);
    if (operationalCredentialsCluster === void 0) {
      throw new ImplementationError(`OperationalCredentialsCluster for node ${this.nodeId} not found.`);
    }
    const fabricIndex = await operationalCredentialsCluster.getCurrentFabricIndexAttribute(true);
    logger.debug(`Removing node ${this.nodeId} by removing fabric ${fabricIndex} on the node.`);
    const result = await operationalCredentialsCluster.commands.removeFabric({ fabricIndex });
    if (result.statusCode !== OperationalCredentials.NodeOperationalCertStatus.Ok) {
      throw new MatterError(
        `Removing node ${this.nodeId} failed with status ${result.statusCode} "${result.debugText}".`
      );
    }
    this.setConnectionState(1 /* Disconnected */);
    this.options.stateInformationCallback?.(this.nodeId, 5 /* Decommissioned */);
    await this.commissioningController.removeNode(this.nodeId, false);
  }
  /** Opens a Basic Commissioning Window (uses the original Passcode printed on the device) with the device. */
  async openBasicCommissioningWindow(commissioningTimeout = 900) {
    const adminCommissioningCluster = this.getRootClusterClient(AdministratorCommissioning.Cluster.with("Basic"));
    if (adminCommissioningCluster === void 0) {
      throw new ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);
    }
    if (adminCommissioningCluster.supportedFeatures.basic === false) {
      throw new ImplementationError(
        `AdministratorCommissioningCluster for node ${this.nodeId} does not support basic commissioning.`
      );
    }
    try {
      await adminCommissioningCluster.commands.revokeCommissioning();
    } catch (error) {
      if (!StatusResponseError.is(error, StatusCode.Failure) || error.clusterCode !== AdministratorCommissioning.StatusCode.WindowNotOpen) {
        throw error;
      }
    }
    await adminCommissioningCluster.commands.openBasicCommissioningWindow({ commissioningTimeout });
  }
  /** Opens an Enhanced Commissioning Window (uses a generated random Passcode) with the device. */
  async openEnhancedCommissioningWindow(commissioningTimeout = 900) {
    const adminCommissioningCluster = this.getRootClusterClient(AdministratorCommissioning.Cluster);
    if (adminCommissioningCluster === void 0) {
      throw new ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);
    }
    try {
      await adminCommissioningCluster.commands.revokeCommissioning();
    } catch (error) {
      if (!StatusResponseError.is(error, StatusCode.Failure) || error.clusterCode !== AdministratorCommissioning.StatusCode.WindowNotOpen) {
        throw error;
      }
    }
    const basicInformationCluster = this.getRootClusterClient(BasicInformation.Cluster);
    if (basicInformationCluster == void 0) {
      throw new ImplementationError(`BasicInformationCluster for node ${this.nodeId} not found.`);
    }
    const vendorId = await basicInformationCluster.getVendorIdAttribute();
    const productId = await basicInformationCluster.getProductIdAttribute();
    const discriminator = PaseClient.generateRandomDiscriminator();
    const passcode = PaseClient.generateRandomPasscode();
    const salt = Crypto.get().getRandomData(32);
    const iterations = 1e3;
    const pakePasscodeVerifier = await PaseClient.generatePakePasscodeVerifier(passcode, {
      iterations,
      salt
    });
    await adminCommissioningCluster.commands.openCommissioningWindow({
      commissioningTimeout,
      pakePasscodeVerifier,
      salt,
      iterations,
      discriminator
    });
    const qrPairingCode = QrPairingCodeCodec.encode([
      {
        version: 0,
        vendorId,
        productId,
        flowType: CommissioningFlowType.Standard,
        discriminator,
        passcode,
        discoveryCapabilities: DiscoveryCapabilitiesSchema.encode({
          onIpNetwork: true
        })
      }
    ]);
    return {
      manualPairingCode: ManualPairingCodeCodec.encode({
        discriminator,
        passcode
      }),
      qrPairingCode
    };
  }
  async disconnect() {
    this.close();
    await this.commissioningController.disconnectNode(this.nodeId);
  }
  close() {
    this.interactionClient?.close();
    this.setConnectionState(1 /* Disconnected */);
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getRootClusterServer(cluster) {
    return this.endpoints.get(EndpointNumber(0))?.getClusterServer(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getRootClusterClient(cluster) {
    return this.endpoints.get(EndpointNumber(0))?.getClusterClient(cluster);
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId EndpointNumber to get the cluster from
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getClusterServerForDevice(endpointId, cluster) {
    return this.getDeviceById(endpointId)?.getClusterServer(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId EndpointNumber to get the cluster from
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getClusterClientForDevice(endpointId, cluster) {
    return this.getDeviceById(endpointId)?.getClusterClient(cluster);
  }
}
export {
  NodeStateInformation,
  PairedNode
};
//# sourceMappingURL=PairedNode.js.map
