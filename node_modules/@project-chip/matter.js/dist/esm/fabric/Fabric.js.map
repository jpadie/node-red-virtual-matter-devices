{
  "version": 3,
  "sources": ["../../../src/fabric/Fabric.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    CertificateManager,\n    TlvIntermediateCertificate,\n    TlvOperationalCertificate,\n    TlvRootCertificate,\n} from \"../certificate/CertificateManager.js\";\nimport { Cluster } from \"../cluster/Cluster.js\";\nimport { GroupKeyManagement } from \"../cluster/definitions/GroupKeyManagementCluster.js\";\nimport { InternalError, MatterError, MatterFlowError } from \"../common/MatterError.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { BinaryKeyPair, Key, PrivateKey } from \"../crypto/Key.js\";\nimport { CaseAuthenticatedTag } from \"../datatype/CaseAuthenticatedTag.js\";\nimport { FabricId } from \"../datatype/FabricId.js\";\nimport { FabricIndex } from \"../datatype/FabricIndex.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { VendorId } from \"../datatype/VendorId.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { SecureSession } from \"../session/SecureSession.js\";\nimport { SupportedStorageTypes } from \"../storage/StringifyTools.js\";\nimport { TypeFromSchema } from \"../tlv/TlvSchema.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataWriter } from \"../util/DataWriter.js\";\nimport { MaybePromise } from \"../util/Promises.js\";\n\nconst logger = Logger.get(\"Fabric\");\n\nconst COMPRESSED_FABRIC_ID_INFO = ByteArray.fromString(\"CompressedFabric\");\nconst GROUP_SECURITY_INFO = ByteArray.fromString(\"GroupKey v1.0\");\n\nexport class PublicKeyError extends MatterError {}\n\nexport type FabricJsonObject = {\n    fabricIndex: FabricIndex;\n    fabricId: FabricId;\n    nodeId: NodeId;\n    rootNodeId: NodeId;\n    operationalId: ByteArray;\n    rootPublicKey: ByteArray;\n    keyPair: BinaryKeyPair;\n    rootVendorId: VendorId;\n    rootCert: ByteArray;\n    identityProtectionKey: ByteArray;\n    operationalIdentityProtectionKey: ByteArray;\n    intermediateCACert: ByteArray | undefined;\n    operationalCert: ByteArray;\n    label: string;\n    scopedClusterData: Map<number, Map<string, SupportedStorageTypes>>;\n};\n\ntype OperationalGroupKeySet = TypeFromSchema<typeof GroupKeyManagement.TlvGroupKeySet> & {\n    operationalEpochKey0: ByteArray;\n    groupSessionId0: number | null;\n    operationalEpochKey1: ByteArray | null;\n    groupSessionId1: number | null;\n    operationalEpochKey2: ByteArray | null;\n    groupSessionId2: number | null;\n};\n\nnamespace OperationalGroupKeySet {\n    export const asTlvGroupSet = (\n        operationalGroupSet: OperationalGroupKeySet,\n    ): TypeFromSchema<typeof GroupKeyManagement.TlvGroupKeySet> => {\n        const {\n            groupKeySetId,\n            epochKey0,\n            epochStartTime0,\n            epochKey1,\n            epochStartTime1,\n            epochKey2,\n            epochStartTime2,\n            groupKeySecurityPolicy,\n            groupKeyMulticastPolicy,\n        } = operationalGroupSet;\n        return {\n            groupKeySetId,\n            epochKey0,\n            epochStartTime0,\n            epochKey1,\n            epochStartTime1,\n            epochKey2,\n            epochStartTime2,\n            groupKeySecurityPolicy,\n            groupKeyMulticastPolicy,\n        };\n    };\n}\n\nexport type ExposedFabricInformation = {\n    fabricIndex: FabricIndex;\n    fabricId: FabricId;\n    nodeId: NodeId;\n    rootNodeId: NodeId;\n    rootVendorId: VendorId;\n    label: string;\n};\n\nexport class Fabric {\n    readonly #sessions = new Array<SecureSession<any>>();\n    readonly #scopedClusterData: Map<number, any>;\n\n    readonly #keyPair: Key;\n\n    #removeCallbacks = new Array<() => MaybePromise<void>>();\n    #persistCallback: ((isUpdate?: boolean) => MaybePromise<void>) | undefined;\n\n    constructor(\n        readonly fabricIndex: FabricIndex,\n        readonly fabricId: FabricId,\n        readonly nodeId: NodeId,\n        readonly rootNodeId: NodeId,\n        readonly operationalId: ByteArray,\n        readonly rootPublicKey: ByteArray,\n        keyPair: Key,\n        readonly rootVendorId: VendorId,\n        readonly rootCert: ByteArray,\n        readonly identityProtectionKey: ByteArray,\n        readonly operationalIdentityProtectionKey: ByteArray,\n        readonly intermediateCACert: ByteArray | undefined,\n        readonly operationalCert: ByteArray,\n        public label: string,\n        scopedClusterData?: Map<number, Map<string, SupportedStorageTypes>>,\n    ) {\n        this.#keyPair = keyPair;\n        this.#scopedClusterData = scopedClusterData ?? new Map<number, Map<string, SupportedStorageTypes>>();\n    }\n\n    toStorageObject(): FabricJsonObject {\n        return {\n            fabricIndex: this.fabricIndex,\n            fabricId: this.fabricId,\n            nodeId: this.nodeId,\n            rootNodeId: this.rootNodeId,\n            operationalId: this.operationalId,\n            rootPublicKey: this.rootPublicKey,\n            keyPair: this.#keyPair.keyPair,\n            rootVendorId: this.rootVendorId,\n            rootCert: this.rootCert,\n            identityProtectionKey: this.identityProtectionKey,\n            operationalIdentityProtectionKey: this.operationalIdentityProtectionKey,\n            intermediateCACert: this.intermediateCACert,\n            operationalCert: this.operationalCert,\n            label: this.label,\n            scopedClusterData: this.#scopedClusterData,\n        };\n    }\n\n    static createFromStorageObject(fabricObject: FabricJsonObject): Fabric {\n        return new Fabric(\n            fabricObject.fabricIndex,\n            fabricObject.fabricId,\n            fabricObject.nodeId,\n            fabricObject.rootNodeId,\n            fabricObject.operationalId,\n            fabricObject.rootPublicKey,\n            PrivateKey(fabricObject.keyPair),\n            fabricObject.rootVendorId,\n            fabricObject.rootCert,\n            fabricObject.identityProtectionKey,\n            fabricObject.operationalIdentityProtectionKey,\n            fabricObject.intermediateCACert,\n            fabricObject.operationalCert,\n            fabricObject.label,\n            fabricObject.scopedClusterData,\n        );\n    }\n\n    async setLabel(label: string) {\n        this.label = label;\n        await this.persist();\n    }\n\n    get publicKey() {\n        return this.#keyPair.publicKey;\n    }\n\n    sign(data: ByteArray) {\n        return Crypto.sign(this.#keyPair, data);\n    }\n\n    verifyCredentials(operationalCert: ByteArray, intermediateCACert?: ByteArray) {\n        if (intermediateCACert === undefined) {\n            // Validate NOC Certificate against Root Certificate\n            CertificateManager.verifyNodeOperationalCertificate(\n                TlvRootCertificate.decode(this.rootCert),\n                TlvOperationalCertificate.decode(operationalCert),\n            );\n        } else {\n            const decodedIcaCert = TlvIntermediateCertificate.decode(intermediateCACert);\n            // Validate NOC Certificate against ICA Certificate\n            CertificateManager.verifyNodeOperationalCertificate(\n                decodedIcaCert,\n                TlvOperationalCertificate.decode(operationalCert),\n            );\n\n            // Validate ICACertificate against Root Certificate\n            CertificateManager.verifyIntermediateCaCertificate(\n                TlvRootCertificate.decode(this.rootCert),\n                decodedIcaCert,\n            );\n        }\n    }\n\n    matchesFabricIdAndRootPublicKey(fabricId: FabricId, rootPublicKey: ByteArray) {\n        return this.fabricId === fabricId && this.rootPublicKey?.equals(rootPublicKey);\n    }\n\n    matchesKeyPair(keyPair: Key) {\n        return this.#keyPair.publicKey.equals(keyPair.publicKey) && this.#keyPair.privateKey.equals(keyPair.privateKey);\n    }\n\n    getDestinationId(nodeId: NodeId, random: ByteArray) {\n        const writer = new DataWriter(Endian.Little);\n        writer.writeByteArray(random);\n        writer.writeByteArray(this.rootPublicKey);\n        writer.writeUInt64(this.fabricId);\n        writer.writeUInt64(nodeId);\n        return Crypto.hmac(this.operationalIdentityProtectionKey, writer.toByteArray());\n    }\n\n    addSession(session: SecureSession<any>) {\n        this.#sessions.push(session);\n    }\n\n    removeSession(session: SecureSession<any>) {\n        const index = this.#sessions.indexOf(session);\n        if (index >= 0) {\n            this.#sessions.splice(index, 1);\n        }\n    }\n\n    addRemoveCallback(callback: () => MaybePromise<void>) {\n        this.#removeCallbacks.push(callback);\n    }\n\n    deleteRemoveCallback(callback: () => MaybePromise<void>) {\n        const index = this.#removeCallbacks.indexOf(callback);\n        if (index >= 0) {\n            this.#removeCallbacks.splice(index, 1);\n        }\n    }\n\n    set persistCallback(callback: (isUpdate?: boolean) => MaybePromise<void>) {\n        // TODO Remove \"isUpdate\" parameter as soon as the fabric scoped data are removed from here/legacy API gets removed\n        this.#persistCallback = callback;\n    }\n\n    async remove(currentSessionId?: number) {\n        for (const callback of this.#removeCallbacks) {\n            await callback();\n        }\n        for (const session of [...this.#sessions]) {\n            await session.destroy(false, session.id === currentSessionId); // Delay Close for current session only\n        }\n    }\n\n    persist(isUpdate = true) {\n        return this.#persistCallback?.(isUpdate);\n    }\n\n    getScopedClusterDataValue<T>(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string): T | undefined {\n        const dataMap = this.#scopedClusterData.get(cluster.id);\n        if (dataMap === undefined) {\n            return undefined;\n        }\n        return dataMap.get(clusterDataKey);\n    }\n\n    setScopedClusterDataValue<T>(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string, value: T) {\n        if (!this.#scopedClusterData.has(cluster.id)) {\n            this.#scopedClusterData.set(cluster.id, new Map<string, SupportedStorageTypes>());\n        }\n        this.#scopedClusterData.get(cluster.id).set(clusterDataKey, value);\n        return this.persist(false);\n    }\n\n    deleteScopedClusterDataValue(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string) {\n        if (!this.#scopedClusterData.has(cluster.id)) {\n            return;\n        }\n        this.#scopedClusterData.get(cluster.id).delete(clusterDataKey);\n        return this.persist(false);\n    }\n\n    hasScopedClusterDataValue(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string) {\n        return this.#scopedClusterData.has(cluster.id) && this.#scopedClusterData.get(cluster.id).has(clusterDataKey);\n    }\n\n    deleteScopedClusterData(cluster: Cluster<any, any, any, any, any>) {\n        this.#scopedClusterData.delete(cluster.id);\n        return this.persist(false);\n    }\n\n    getScopedClusterDataKeys(cluster: Cluster<any, any, any, any, any>): string[] {\n        if (!this.#scopedClusterData.has(cluster.id)) {\n            return [];\n        }\n        return Array.from(this.#scopedClusterData.get(cluster.id).keys());\n    }\n\n    getGroupKeySet(groupKeySetId: number) {\n        if (groupKeySetId === 0) {\n            return OperationalGroupKeySet.asTlvGroupSet(this.getGroupSetForIpk());\n        }\n        // TODO add correct group handling later, right now only IPK exists\n        return undefined;\n    }\n\n    private getGroupSetForIpk(): OperationalGroupKeySet {\n        return {\n            groupKeySetId: 0,\n            epochKey0: this.identityProtectionKey,\n            operationalEpochKey0: this.operationalIdentityProtectionKey,\n            epochStartTime0: 0, // or do we need to track Fabric creation date?\n            groupSessionId0: null,\n            epochKey1: null,\n            operationalEpochKey1: null,\n            epochStartTime1: null,\n            groupSessionId1: null,\n            epochKey2: null,\n            operationalEpochKey2: null,\n            epochStartTime2: null,\n            groupSessionId2: null,\n            groupKeySecurityPolicy: GroupKeyManagement.GroupKeySecurityPolicy.TrustFirst,\n            groupKeyMulticastPolicy: GroupKeyManagement.GroupKeyMulticastPolicy.PerGroupId,\n        };\n    }\n\n    getAllGroupKeySets() {\n        // TODO add correct group handling later, right now only IPK exists\n        return [OperationalGroupKeySet.asTlvGroupSet(this.getGroupSetForIpk())];\n    }\n\n    get externalInformation(): ExposedFabricInformation {\n        return {\n            fabricIndex: this.fabricIndex,\n            fabricId: this.fabricId,\n            nodeId: this.nodeId,\n            rootNodeId: this.rootNodeId,\n            rootVendorId: this.rootVendorId,\n            label: this.label,\n        };\n    }\n}\n\nexport class FabricBuilder {\n    #keyPair = Crypto.createKeyPair();\n    #rootVendorId?: VendorId;\n    #rootCert?: ByteArray;\n    #intermediateCACert?: ByteArray;\n    #operationalCert?: ByteArray;\n    #fabricId?: FabricId;\n    #nodeId?: NodeId;\n    #rootNodeId?: NodeId;\n    #rootPublicKey?: ByteArray;\n    #identityProtectionKey?: ByteArray;\n    #fabricIndex?: FabricIndex;\n    #label = \"\";\n\n    get publicKey() {\n        return this.#keyPair.publicKey;\n    }\n\n    get fabricIndex() {\n        return this.#fabricIndex;\n    }\n\n    createCertificateSigningRequest() {\n        return CertificateManager.createCertificateSigningRequest(this.#keyPair);\n    }\n\n    setRootCert(rootCert: ByteArray) {\n        const decodedRootCertificate = TlvRootCertificate.decode(rootCert);\n        CertificateManager.verifyRootCertificate(decodedRootCertificate);\n        this.#rootCert = rootCert;\n        this.#rootPublicKey = decodedRootCertificate.ellipticCurvePublicKey;\n        return this;\n    }\n\n    // TODO Remove when legacy API gets removed because then no longer needed\n    get rootCert() {\n        return this.#rootCert;\n    }\n\n    hasRootCert() {\n        return this.#rootCert !== undefined;\n    }\n\n    setOperationalCert(operationalCert: ByteArray, intermediateCACert?: ByteArray) {\n        if (intermediateCACert !== undefined && intermediateCACert.length === 0) {\n            intermediateCACert = undefined;\n        }\n        const {\n            subject: { nodeId, fabricId, caseAuthenticatedTags },\n            ellipticCurvePublicKey,\n        } = TlvOperationalCertificate.decode(operationalCert);\n        logger.debug(\n            `FabricBuilder setOperationalCert: nodeId=${nodeId}, fabricId=${fabricId}, caseAuthenticatedTags=${caseAuthenticatedTags}`,\n        );\n        if (caseAuthenticatedTags !== undefined) {\n            CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);\n        }\n\n        if (!ellipticCurvePublicKey.equals(this.#keyPair.publicKey)) {\n            throw new PublicKeyError(\"Operational Certificate does not match public key.\");\n        }\n\n        if (this.#rootCert === undefined) {\n            throw new MatterFlowError(\"Root Certificate needs to be set first.\");\n        }\n\n        if (intermediateCACert !== undefined) {\n            const decodedIntermediateCACert = TlvIntermediateCertificate.decode(intermediateCACert);\n            CertificateManager.verifyIntermediateCaCertificate(\n                TlvRootCertificate.decode(this.#rootCert),\n                decodedIntermediateCACert,\n            );\n            CertificateManager.verifyNodeOperationalCertificate(\n                decodedIntermediateCACert,\n                TlvOperationalCertificate.decode(operationalCert),\n            );\n        } else {\n            CertificateManager.verifyNodeOperationalCertificate(\n                TlvRootCertificate.decode(this.#rootCert),\n                TlvOperationalCertificate.decode(operationalCert),\n            );\n        }\n\n        this.#operationalCert = operationalCert;\n        this.#intermediateCACert = intermediateCACert;\n        this.#fabricId = FabricId(fabricId);\n        this.#nodeId = nodeId;\n\n        return this;\n    }\n\n    setRootVendorId(rootVendorId: VendorId) {\n        this.#rootVendorId = rootVendorId;\n        return this;\n    }\n\n    setRootNodeId(rootNodeId: NodeId) {\n        this.#rootNodeId = rootNodeId;\n        return this;\n    }\n\n    setIdentityProtectionKey(key: ByteArray) {\n        this.#identityProtectionKey = key;\n        return this;\n    }\n\n    initializeFromFabricForUpdate(fabric: Fabric) {\n        this.#rootVendorId = fabric.rootVendorId;\n        this.#rootNodeId = fabric.rootNodeId;\n        this.#identityProtectionKey = fabric.identityProtectionKey;\n        this.#rootCert = fabric.rootCert;\n        this.#rootPublicKey = fabric.rootPublicKey;\n        this.#label = fabric.label;\n    }\n\n    matchesToFabric(fabric: Fabric) {\n        if (this.#fabricId === undefined || this.#rootPublicKey === undefined) {\n            throw new MatterFlowError(\"Node Operational Data needs to be set first.\");\n        }\n        return fabric.matchesFabricIdAndRootPublicKey(this.#fabricId, this.#rootPublicKey);\n    }\n\n    get nodeId() {\n        return this.#nodeId;\n    }\n\n    get fabricId() {\n        return this.#fabricId;\n    }\n\n    get keyPair() {\n        return this.#keyPair;\n    }\n\n    async build(fabricIndex: FabricIndex) {\n        if (this.#fabricIndex !== undefined) throw new InternalError(\"FabricBuilder can only be built once\");\n        if (this.#rootNodeId === undefined) throw new InternalError(\"rootNodeId needs to be set\");\n        if (this.#rootVendorId === undefined) throw new InternalError(\"vendorId needs to be set\");\n        if (this.#rootCert === undefined || this.#rootPublicKey === undefined)\n            throw new InternalError(\"rootCert needs to be set\");\n        if (this.#identityProtectionKey === undefined) throw new InternalError(\"identityProtectionKey needs to be set\");\n        if (this.#operationalCert === undefined || this.#fabricId === undefined || this.#nodeId === undefined)\n            throw new InternalError(\"operationalCert needs to be set\");\n\n        this.#fabricIndex = fabricIndex;\n        const saltWriter = new DataWriter(Endian.Big);\n        saltWriter.writeUInt64(this.#fabricId);\n        const operationalId = await Crypto.hkdf(\n            this.#rootPublicKey.slice(1),\n            saltWriter.toByteArray(),\n            COMPRESSED_FABRIC_ID_INFO,\n            8,\n        );\n\n        return new Fabric(\n            this.#fabricIndex,\n            this.#fabricId,\n            this.#nodeId,\n            this.#rootNodeId,\n            operationalId,\n            this.#rootPublicKey,\n            this.#keyPair,\n            this.#rootVendorId,\n            this.#rootCert,\n            this.#identityProtectionKey, // Epoch Key\n            await Crypto.hkdf(this.#identityProtectionKey, operationalId, GROUP_SECURITY_INFO),\n            this.#intermediateCACert,\n            this.#operationalCert,\n            this.#label,\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": ["OperationalGroupKeySet"]
}
