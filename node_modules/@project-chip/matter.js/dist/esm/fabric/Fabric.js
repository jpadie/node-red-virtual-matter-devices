/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  CertificateManager,
  TlvIntermediateCertificate,
  TlvOperationalCertificate,
  TlvRootCertificate
} from "../certificate/CertificateManager.js";
import { GroupKeyManagement } from "../cluster/definitions/GroupKeyManagementCluster.js";
import { InternalError, MatterError, MatterFlowError } from "../common/MatterError.js";
import { Crypto } from "../crypto/Crypto.js";
import { PrivateKey } from "../crypto/Key.js";
import { CaseAuthenticatedTag } from "../datatype/CaseAuthenticatedTag.js";
import { FabricId } from "../datatype/FabricId.js";
import { Logger } from "../log/Logger.js";
import { ByteArray, Endian } from "../util/ByteArray.js";
import { DataWriter } from "../util/DataWriter.js";
const logger = Logger.get("Fabric");
const COMPRESSED_FABRIC_ID_INFO = ByteArray.fromString("CompressedFabric");
const GROUP_SECURITY_INFO = ByteArray.fromString("GroupKey v1.0");
class PublicKeyError extends MatterError {
}
var OperationalGroupKeySet;
((OperationalGroupKeySet2) => {
  OperationalGroupKeySet2.asTlvGroupSet = (operationalGroupSet) => {
    const {
      groupKeySetId,
      epochKey0,
      epochStartTime0,
      epochKey1,
      epochStartTime1,
      epochKey2,
      epochStartTime2,
      groupKeySecurityPolicy,
      groupKeyMulticastPolicy
    } = operationalGroupSet;
    return {
      groupKeySetId,
      epochKey0,
      epochStartTime0,
      epochKey1,
      epochStartTime1,
      epochKey2,
      epochStartTime2,
      groupKeySecurityPolicy,
      groupKeyMulticastPolicy
    };
  };
})(OperationalGroupKeySet || (OperationalGroupKeySet = {}));
class Fabric {
  constructor(fabricIndex, fabricId, nodeId, rootNodeId, operationalId, rootPublicKey, keyPair, rootVendorId, rootCert, identityProtectionKey, operationalIdentityProtectionKey, intermediateCACert, operationalCert, label, scopedClusterData) {
    this.fabricIndex = fabricIndex;
    this.fabricId = fabricId;
    this.nodeId = nodeId;
    this.rootNodeId = rootNodeId;
    this.operationalId = operationalId;
    this.rootPublicKey = rootPublicKey;
    this.rootVendorId = rootVendorId;
    this.rootCert = rootCert;
    this.identityProtectionKey = identityProtectionKey;
    this.operationalIdentityProtectionKey = operationalIdentityProtectionKey;
    this.intermediateCACert = intermediateCACert;
    this.operationalCert = operationalCert;
    this.label = label;
    this.#keyPair = keyPair;
    this.#scopedClusterData = scopedClusterData ?? /* @__PURE__ */ new Map();
  }
  #sessions = new Array();
  #scopedClusterData;
  #keyPair;
  #removeCallbacks = new Array();
  #persistCallback;
  toStorageObject() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      operationalId: this.operationalId,
      rootPublicKey: this.rootPublicKey,
      keyPair: this.#keyPair.keyPair,
      rootVendorId: this.rootVendorId,
      rootCert: this.rootCert,
      identityProtectionKey: this.identityProtectionKey,
      operationalIdentityProtectionKey: this.operationalIdentityProtectionKey,
      intermediateCACert: this.intermediateCACert,
      operationalCert: this.operationalCert,
      label: this.label,
      scopedClusterData: this.#scopedClusterData
    };
  }
  static createFromStorageObject(fabricObject) {
    return new Fabric(
      fabricObject.fabricIndex,
      fabricObject.fabricId,
      fabricObject.nodeId,
      fabricObject.rootNodeId,
      fabricObject.operationalId,
      fabricObject.rootPublicKey,
      PrivateKey(fabricObject.keyPair),
      fabricObject.rootVendorId,
      fabricObject.rootCert,
      fabricObject.identityProtectionKey,
      fabricObject.operationalIdentityProtectionKey,
      fabricObject.intermediateCACert,
      fabricObject.operationalCert,
      fabricObject.label,
      fabricObject.scopedClusterData
    );
  }
  async setLabel(label) {
    this.label = label;
    await this.persist();
  }
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  sign(data) {
    return Crypto.sign(this.#keyPair, data);
  }
  verifyCredentials(operationalCert, intermediateCACert) {
    if (intermediateCACert === void 0) {
      CertificateManager.verifyNodeOperationalCertificate(
        TlvRootCertificate.decode(this.rootCert),
        TlvOperationalCertificate.decode(operationalCert)
      );
    } else {
      const decodedIcaCert = TlvIntermediateCertificate.decode(intermediateCACert);
      CertificateManager.verifyNodeOperationalCertificate(
        decodedIcaCert,
        TlvOperationalCertificate.decode(operationalCert)
      );
      CertificateManager.verifyIntermediateCaCertificate(
        TlvRootCertificate.decode(this.rootCert),
        decodedIcaCert
      );
    }
  }
  matchesFabricIdAndRootPublicKey(fabricId, rootPublicKey) {
    return this.fabricId === fabricId && this.rootPublicKey?.equals(rootPublicKey);
  }
  matchesKeyPair(keyPair) {
    return this.#keyPair.publicKey.equals(keyPair.publicKey) && this.#keyPair.privateKey.equals(keyPair.privateKey);
  }
  getDestinationId(nodeId, random) {
    const writer = new DataWriter(Endian.Little);
    writer.writeByteArray(random);
    writer.writeByteArray(this.rootPublicKey);
    writer.writeUInt64(this.fabricId);
    writer.writeUInt64(nodeId);
    return Crypto.hmac(this.operationalIdentityProtectionKey, writer.toByteArray());
  }
  addSession(session) {
    this.#sessions.push(session);
  }
  removeSession(session) {
    const index = this.#sessions.indexOf(session);
    if (index >= 0) {
      this.#sessions.splice(index, 1);
    }
  }
  addRemoveCallback(callback) {
    this.#removeCallbacks.push(callback);
  }
  deleteRemoveCallback(callback) {
    const index = this.#removeCallbacks.indexOf(callback);
    if (index >= 0) {
      this.#removeCallbacks.splice(index, 1);
    }
  }
  set persistCallback(callback) {
    this.#persistCallback = callback;
  }
  async remove(currentSessionId) {
    for (const callback of this.#removeCallbacks) {
      await callback();
    }
    for (const session of [...this.#sessions]) {
      await session.destroy(false, session.id === currentSessionId);
    }
  }
  persist(isUpdate = true) {
    return this.#persistCallback?.(isUpdate);
  }
  getScopedClusterDataValue(cluster, clusterDataKey) {
    const dataMap = this.#scopedClusterData.get(cluster.id);
    if (dataMap === void 0) {
      return void 0;
    }
    return dataMap.get(clusterDataKey);
  }
  setScopedClusterDataValue(cluster, clusterDataKey, value) {
    if (!this.#scopedClusterData.has(cluster.id)) {
      this.#scopedClusterData.set(cluster.id, /* @__PURE__ */ new Map());
    }
    this.#scopedClusterData.get(cluster.id).set(clusterDataKey, value);
    return this.persist(false);
  }
  deleteScopedClusterDataValue(cluster, clusterDataKey) {
    if (!this.#scopedClusterData.has(cluster.id)) {
      return;
    }
    this.#scopedClusterData.get(cluster.id).delete(clusterDataKey);
    return this.persist(false);
  }
  hasScopedClusterDataValue(cluster, clusterDataKey) {
    return this.#scopedClusterData.has(cluster.id) && this.#scopedClusterData.get(cluster.id).has(clusterDataKey);
  }
  deleteScopedClusterData(cluster) {
    this.#scopedClusterData.delete(cluster.id);
    return this.persist(false);
  }
  getScopedClusterDataKeys(cluster) {
    if (!this.#scopedClusterData.has(cluster.id)) {
      return [];
    }
    return Array.from(this.#scopedClusterData.get(cluster.id).keys());
  }
  getGroupKeySet(groupKeySetId) {
    if (groupKeySetId === 0) {
      return OperationalGroupKeySet.asTlvGroupSet(this.getGroupSetForIpk());
    }
    return void 0;
  }
  getGroupSetForIpk() {
    return {
      groupKeySetId: 0,
      epochKey0: this.identityProtectionKey,
      operationalEpochKey0: this.operationalIdentityProtectionKey,
      epochStartTime0: 0,
      // or do we need to track Fabric creation date?
      groupSessionId0: null,
      epochKey1: null,
      operationalEpochKey1: null,
      epochStartTime1: null,
      groupSessionId1: null,
      epochKey2: null,
      operationalEpochKey2: null,
      epochStartTime2: null,
      groupSessionId2: null,
      groupKeySecurityPolicy: GroupKeyManagement.GroupKeySecurityPolicy.TrustFirst,
      groupKeyMulticastPolicy: GroupKeyManagement.GroupKeyMulticastPolicy.PerGroupId
    };
  }
  getAllGroupKeySets() {
    return [OperationalGroupKeySet.asTlvGroupSet(this.getGroupSetForIpk())];
  }
  get externalInformation() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      rootVendorId: this.rootVendorId,
      label: this.label
    };
  }
}
class FabricBuilder {
  #keyPair = Crypto.createKeyPair();
  #rootVendorId;
  #rootCert;
  #intermediateCACert;
  #operationalCert;
  #fabricId;
  #nodeId;
  #rootNodeId;
  #rootPublicKey;
  #identityProtectionKey;
  #fabricIndex;
  #label = "";
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  get fabricIndex() {
    return this.#fabricIndex;
  }
  createCertificateSigningRequest() {
    return CertificateManager.createCertificateSigningRequest(this.#keyPair);
  }
  setRootCert(rootCert) {
    const decodedRootCertificate = TlvRootCertificate.decode(rootCert);
    CertificateManager.verifyRootCertificate(decodedRootCertificate);
    this.#rootCert = rootCert;
    this.#rootPublicKey = decodedRootCertificate.ellipticCurvePublicKey;
    return this;
  }
  // TODO Remove when legacy API gets removed because then no longer needed
  get rootCert() {
    return this.#rootCert;
  }
  hasRootCert() {
    return this.#rootCert !== void 0;
  }
  setOperationalCert(operationalCert, intermediateCACert) {
    if (intermediateCACert !== void 0 && intermediateCACert.length === 0) {
      intermediateCACert = void 0;
    }
    const {
      subject: { nodeId, fabricId, caseAuthenticatedTags },
      ellipticCurvePublicKey
    } = TlvOperationalCertificate.decode(operationalCert);
    logger.debug(
      `FabricBuilder setOperationalCert: nodeId=${nodeId}, fabricId=${fabricId}, caseAuthenticatedTags=${caseAuthenticatedTags}`
    );
    if (caseAuthenticatedTags !== void 0) {
      CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
    }
    if (!ellipticCurvePublicKey.equals(this.#keyPair.publicKey)) {
      throw new PublicKeyError("Operational Certificate does not match public key.");
    }
    if (this.#rootCert === void 0) {
      throw new MatterFlowError("Root Certificate needs to be set first.");
    }
    if (intermediateCACert !== void 0) {
      const decodedIntermediateCACert = TlvIntermediateCertificate.decode(intermediateCACert);
      CertificateManager.verifyIntermediateCaCertificate(
        TlvRootCertificate.decode(this.#rootCert),
        decodedIntermediateCACert
      );
      CertificateManager.verifyNodeOperationalCertificate(
        decodedIntermediateCACert,
        TlvOperationalCertificate.decode(operationalCert)
      );
    } else {
      CertificateManager.verifyNodeOperationalCertificate(
        TlvRootCertificate.decode(this.#rootCert),
        TlvOperationalCertificate.decode(operationalCert)
      );
    }
    this.#operationalCert = operationalCert;
    this.#intermediateCACert = intermediateCACert;
    this.#fabricId = FabricId(fabricId);
    this.#nodeId = nodeId;
    return this;
  }
  setRootVendorId(rootVendorId) {
    this.#rootVendorId = rootVendorId;
    return this;
  }
  setRootNodeId(rootNodeId) {
    this.#rootNodeId = rootNodeId;
    return this;
  }
  setIdentityProtectionKey(key) {
    this.#identityProtectionKey = key;
    return this;
  }
  initializeFromFabricForUpdate(fabric) {
    this.#rootVendorId = fabric.rootVendorId;
    this.#rootNodeId = fabric.rootNodeId;
    this.#identityProtectionKey = fabric.identityProtectionKey;
    this.#rootCert = fabric.rootCert;
    this.#rootPublicKey = fabric.rootPublicKey;
    this.#label = fabric.label;
  }
  matchesToFabric(fabric) {
    if (this.#fabricId === void 0 || this.#rootPublicKey === void 0) {
      throw new MatterFlowError("Node Operational Data needs to be set first.");
    }
    return fabric.matchesFabricIdAndRootPublicKey(this.#fabricId, this.#rootPublicKey);
  }
  get nodeId() {
    return this.#nodeId;
  }
  get fabricId() {
    return this.#fabricId;
  }
  get keyPair() {
    return this.#keyPair;
  }
  async build(fabricIndex) {
    if (this.#fabricIndex !== void 0) throw new InternalError("FabricBuilder can only be built once");
    if (this.#rootNodeId === void 0) throw new InternalError("rootNodeId needs to be set");
    if (this.#rootVendorId === void 0) throw new InternalError("vendorId needs to be set");
    if (this.#rootCert === void 0 || this.#rootPublicKey === void 0)
      throw new InternalError("rootCert needs to be set");
    if (this.#identityProtectionKey === void 0) throw new InternalError("identityProtectionKey needs to be set");
    if (this.#operationalCert === void 0 || this.#fabricId === void 0 || this.#nodeId === void 0)
      throw new InternalError("operationalCert needs to be set");
    this.#fabricIndex = fabricIndex;
    const saltWriter = new DataWriter(Endian.Big);
    saltWriter.writeUInt64(this.#fabricId);
    const operationalId = await Crypto.hkdf(
      this.#rootPublicKey.slice(1),
      saltWriter.toByteArray(),
      COMPRESSED_FABRIC_ID_INFO,
      8
    );
    return new Fabric(
      this.#fabricIndex,
      this.#fabricId,
      this.#nodeId,
      this.#rootNodeId,
      operationalId,
      this.#rootPublicKey,
      this.#keyPair,
      this.#rootVendorId,
      this.#rootCert,
      this.#identityProtectionKey,
      // Epoch Key
      await Crypto.hkdf(this.#identityProtectionKey, operationalId, GROUP_SECURITY_INFO),
      this.#intermediateCACert,
      this.#operationalCert,
      this.#label
    );
  }
}
export {
  Fabric,
  FabricBuilder,
  PublicKeyError
};
//# sourceMappingURL=Fabric.js.map
