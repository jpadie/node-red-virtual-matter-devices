/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError } from "../common/MatterError.js";
import { Key } from "../crypto/Key.js";
import { FabricIndex } from "../datatype/FabricIndex.js";
import { StorageContext } from "../storage/StorageContext.js";
import { ByteArray } from "../util/ByteArray.js";
import { Observable } from "../util/Observable.js";
import { MaybePromise } from "../util/Promises.js";
import { Fabric } from "./Fabric.js";
/** Specific Error for when a fabric is not found. */
export declare class FabricNotFoundError extends MatterError {
}
export declare class FabricTableFullError extends MatterError {
}
export declare enum FabricAction {
    Added = 0,
    Removed = 1,
    Updated = 2
}
export declare class FabricManager {
    #private;
    constructor(fabricStorage: StorageContext);
    initFromStorage(): Promise<void>;
    get events(): {
        added: Observable<[fabric: Fabric], void>;
        updated: Observable<[fabric: Fabric], void>;
        deleted: Observable<[fabric: Fabric], void>;
        failsafeClosed: Observable<[], void>;
    };
    getNextFabricIndex(): FabricIndex;
    persistFabrics(): MaybePromise<void>;
    addFabric(fabric: Fabric): void;
    removeFabric(fabricIndex: FabricIndex): Promise<void>;
    getFabrics(): Fabric[];
    findFabricFromDestinationId(destinationId: ByteArray, initiatorRandom: ByteArray): Fabric;
    findByKeypair(keypair: Key): Fabric | undefined;
    updateFabric(fabric: Fabric): Promise<void>;
    revokeFabric(fabricIndex: FabricIndex): Promise<void>;
}
//# sourceMappingURL=FabricManager.d.ts.map