/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { InternalError, MatterError, MatterFlowError } from "../common/MatterError.js";
import { FabricIndex } from "../datatype/FabricIndex.js";
import { Observable } from "../util/Observable.js";
import { MaybePromise } from "../util/Promises.js";
import { Fabric } from "./Fabric.js";
class FabricNotFoundError extends MatterError {
}
class FabricTableFullError extends MatterError {
}
var FabricAction = /* @__PURE__ */ ((FabricAction2) => {
  FabricAction2[FabricAction2["Added"] = 0] = "Added";
  FabricAction2[FabricAction2["Removed"] = 1] = "Removed";
  FabricAction2[FabricAction2["Updated"] = 2] = "Updated";
  return FabricAction2;
})(FabricAction || {});
class FabricManager {
  #nextFabricIndex = 1;
  #fabrics = /* @__PURE__ */ new Map();
  #initializationDone = false;
  #fabricStorage;
  #events = {
    added: Observable(),
    updated: Observable(),
    deleted: Observable(),
    failsafeClosed: Observable()
  };
  constructor(fabricStorage) {
    this.#fabricStorage = fabricStorage;
  }
  async initFromStorage() {
    const fabrics = await this.#fabricStorage.get("fabrics", []);
    fabrics.forEach((fabric) => this.addFabric(Fabric.createFromStorageObject(fabric)));
    this.#nextFabricIndex = await this.#fabricStorage.get("nextFabricIndex", this.#nextFabricIndex);
    this.#initializationDone = true;
  }
  get events() {
    return this.#events;
  }
  getNextFabricIndex() {
    for (let i = 0; i < 254; i++) {
      const fabricIndex = this.#nextFabricIndex++;
      if (this.#nextFabricIndex > 254) this.#nextFabricIndex = 1;
      if (!this.#fabrics.has(FabricIndex(fabricIndex))) {
        return FabricIndex(fabricIndex);
      }
    }
    throw new FabricTableFullError("No free fabric index available.");
  }
  persistFabrics() {
    const storeResult = this.#fabricStorage.set(
      "fabrics",
      Array.from(this.#fabrics.values()).map((fabric) => fabric.toStorageObject())
    );
    if (MaybePromise.is(storeResult)) {
      return storeResult.then(() => this.#fabricStorage.set("nextFabricIndex", this.#nextFabricIndex));
    }
    return this.#fabricStorage.set("nextFabricIndex", this.#nextFabricIndex);
  }
  addFabric(fabric) {
    const { fabricIndex } = fabric;
    if (this.#fabrics.has(fabricIndex)) {
      throw new MatterFlowError(`Fabric with index ${fabricIndex} already exists.`);
    }
    this.#fabrics.set(fabricIndex, fabric);
    fabric.addRemoveCallback(async () => this.removeFabric(fabricIndex));
    fabric.persistCallback = (isUpdate = true) => {
      const persistResult = this.persistFabrics();
      return MaybePromise.then(persistResult, () => {
        if (isUpdate) {
          this.#events.updated.emit(fabric);
        }
      });
    };
    if (this.#initializationDone) {
      this.#events.added.emit(fabric);
    }
  }
  async removeFabric(fabricIndex) {
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0)
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be removed because it does not exist.`
      );
    this.#fabrics.delete(fabricIndex);
    await this.persistFabrics();
    this.#events.deleted.emit(fabric);
  }
  getFabrics() {
    return Array.from(this.#fabrics.values());
  }
  findFabricFromDestinationId(destinationId, initiatorRandom) {
    for (const fabric of this.#fabrics.values()) {
      const candidateDestinationId = fabric.getDestinationId(fabric.nodeId, initiatorRandom);
      if (!candidateDestinationId.equals(destinationId)) continue;
      return fabric;
    }
    throw new InternalError("Fabric cannot be found from destinationId");
  }
  findByKeypair(keypair) {
    for (const fabric of this.#fabrics.values()) {
      if (fabric.matchesKeyPair(keypair)) {
        return fabric;
      }
    }
    return void 0;
  }
  async updateFabric(fabric) {
    const { fabricIndex } = fabric;
    if (!this.#fabrics.has(fabricIndex)) {
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be updated because it does not exist.`
      );
    }
    this.#fabrics.set(fabricIndex, fabric);
    await this.persistFabrics();
    this.#events.updated.emit(fabric);
  }
  async revokeFabric(fabricIndex) {
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0) {
      throw new MatterFlowError(`Fabric with index ${fabricIndex} does not exist to revoke.`);
    }
    await fabric.remove();
  }
}
export {
  FabricAction,
  FabricManager,
  FabricNotFoundError,
  FabricTableFullError
};
//# sourceMappingURL=FabricManager.js.map
