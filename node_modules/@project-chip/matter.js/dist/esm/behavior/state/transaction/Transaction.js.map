{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/transaction/Transaction.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { Participant } from \"./Participant.js\";\nimport type { Resource } from \"./Resource.js\";\nimport { Status } from \"./Status.js\";\nimport { ReadOnlyTransaction, act } from \"./Tx.js\";\n\n/**\n * By default, Matter.js state is transactional.\n *\n * Transactions are either shared (for reads) or exclusive (for writes). Exclusive transactions do not block shared\n * transactions but state updates will not be visible until the transaction completes.\n *\n * Writes do block other writes.  Transactions start automatically when a write occurs.  Since this usually happens\n * synchronously, the best Matter.js can do is throw an error if two write transactions would conflict.  However, you\n * can avoid this by using {@link begin} which will wait for other transactions to complete before acquiring resource\n * locks.\n *\n * Persistence is implemented by a list of participants.  Commits are two phase.  If an error is thrown in phase one all\n * participants roll back. An error in phase 2 could result in data inconsistency as we don't have any form of retry as\n * of yet.\n *\n * TODO - does prevent deadlock but we should probably add a timeout for resource locking\n */\nexport interface Transaction {\n    /**\n     * Diagnostic description of the transaction's source.\n     */\n    readonly via: string;\n\n    /**\n     * The status of the transaction.\n     */\n    readonly status: Status;\n\n    /**\n     * Transaction participants.\n     */\n    readonly participants: Set<Participant>;\n\n    /**\n     * Resources addressed by the participants.\n     */\n    readonly resources: Set<Resource>;\n\n    /**\n     * The transactions currently blocking this transaction, if any.\n     */\n    readonly waitingOn: Iterable<Transaction> | undefined;\n\n    /**\n     * Listen for transaction commit or roll back.  This may occur more than once for a given.\n     */\n    onShared(actor: () => void, once?: boolean): void;\n\n    /**\n     * Listen for {@link Transaction.status} close.\n     */\n    onClose(actor: () => void): void;\n\n    /**\n     * Add {@link Resources} to the transaction.\n     *\n     * If the transaction is exclusive (writing) the transaction will acquire the lock on each {@link ResourceType},\n     * waiting for other writers to finish if necessary.\n     */\n    addResources(...resources: Resource[]): Promise<void>;\n\n    /**\n     * Add {@link ResourceType}s to the transaction synchronously.\n     *\n     * Unlike {@link addResources}, this method will throw an error if the\n     * transaction is exclusive and the resources cannot be locked.\n     */\n    addResourcesSync(...resources: Resource[]): void;\n\n    /**\n     * Begin an exclusive transaction.\n     *\n     * Transactions begin automatically on write but there are a few reasons you may want to use this method to start an\n     * exclusive transaction explicitly:\n     *\n     *   1. Automatic transactions are started in a synchronous context so conflicting transactions will throw an error.\n     *      If you start a transaction, your code will await any transaction that would otherwise throw an error.\n     *\n     *   2. Transaction isolation means your view of data may become stale if a write occurs in another transaction.\n     *      Once you start a transaction you block other writers so can be assured you're dealing with newest state.\n     *\n     *   3. Say transaction A has an exclusive lock on resource 1 and awaits resource 2.  Transaction B has an exclusive\n     *      lock on resource 2. Transaction B cannot then await resource 1 without causing a deadlock.  Matter.js will\n     *      detect the deadlock and throw an error. One way to prevent this is to begin a transaction and acquire locks\n     *      in a specific order.\n     *\n     * None of the issues above are likely and are probably not a concern for your application.  If you do encounter\n     * these issues the error message will suggest solutions.\n     */\n    begin(): Promise<void>;\n\n    /**\n     * Begin an exclusive transaction in a synchronous context.\n     *\n     * Unlike {@link begin}, this method will throw an error if any participant has already joined an exclusive\n     * transaction.\n     */\n    beginSync(): void;\n\n    /**\n     * Add {@link ParticipantType}s to the transaction.\n     */\n    addParticipants(...participants: Participant[]): void;\n\n    /**\n     * Retrieve a participant with a specific role.\n     */\n    getParticipant(role: {}): Participant | undefined;\n\n    /**\n     * Commit the transaction.\n     *\n     * Matter.js commits automatically when an interaction completes.  You may commit manually to publish your changes\n     * mid-interaction.\n     *\n     * After commit an exclusive transaction becomes shared and data references refresh to the most recent value.\n     */\n    commit(): MaybePromise;\n\n    /**\n     * Roll back the transaction.\n     *\n     * Matter.js rolls back automatically when an interaction fails.  You may roll back manually to undo your changes\n     * mid-interaction.\n     *\n     * After rollback an exclusive transaction becomes shared and data references refresh to the most recent value.\n     */\n    rollback(): MaybePromise;\n\n    /**\n     * Wait for a set of transactions to complete.\n     *\n     * @param others the set of transactions to await; cleared on return\n     */\n    waitFor(others: Set<Transaction>): Promise<void>;\n}\n\ntype StatusType = Status;\nconst StatusEnum = Status;\ntype ResourceType = Resource;\ntype ParticipantType = Participant;\n\nexport const Transaction = {\n    /**\n     * Perform a transactional operation.  This is the only way to obtain a read/write transaction.\n     *\n     * The transaction will commit automatically if it is exclusive (write mode) after the actor returns.\n     *\n     * The transaction is destroyed when {@link act} returns.  You will receive an error if you access it after it is\n     * destroyed.\n     */\n    act<T>(via: string, actor: (transaction: Transaction) => MaybePromise<T>): MaybePromise<T> {\n        // This function is replaced below so do not edit\n        return act(via, actor);\n    },\n\n    /**\n     * A read-only transaction you may use without context.\n     */\n    ReadOnly: ReadOnlyTransaction,\n\n    Status: StatusEnum,\n\n    [Symbol.toStringTag]: \"Transaction\",\n};\n\n// This is functionally equivalent to the definition above but removes a stack frame\nTransaction.act = act;\n\nexport namespace Transaction {\n    export type Status = StatusType;\n\n    export type Resource = ResourceType;\n\n    export type Participant = ParticipantType;\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AASA,SAAS,cAAc;AACvB,SAAS,qBAAqB,WAAW;AA4IzC,MAAM,aAAa;AAIZ,MAAM,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASvB,IAAO,KAAa,OAAuE;AAEvF,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AAAA,EAEV,QAAQ;AAAA,EAER,CAAC,OAAO,WAAW,GAAG;AAC1B;AAGA,YAAY,MAAM;",
  "names": []
}
