{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/managed/ManagedReference.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AccessControl } from \"../../AccessControl.js\";\nimport { ExpiredReferenceError } from \"../../errors.js\";\nimport { Val } from \"../Val.js\";\n\ntype Container = Record<string | number, Val>;\n\n/**\n * ManagedReference manages a reference to a container property of another reference.\n *\n * The ManagedReference detects when the value changes and clones the container if it is the original copy.\n *\n * This serves the following purposes:\n *\n *   - We can change properties in a container (an array or object) without modifying the original container\n *\n *   - When nested, this effect bubbles so we make copies at all levels in the hierarchy as necessary\n *\n *   - Preserves metadata regarding the state of the value\n *\n * Change detection happens automatically if the value is replaced.  If a subvalue is replaced, the logic replacing the\n * subvalue must update \"changed\" manually before replacing the subvalue.  For managed structures this is handled by a\n * separate ManagedReference.\n *\n * @param parent a reference to the container we reference\n * @param index the key we reference\n * @param assertWriteOk enforces ACLs and read-only\n * @param clone clones the container prior to write; undefined if not transactional\n *\n * @returns a reference to the property\n */\nexport function ManagedReference(\n    parent: Val.Reference<Val.Collection>,\n    index: string | number,\n    assertWriteOk: (value: Val) => void,\n    clone: (container: Val) => Val,\n) {\n    let value = (parent.value as Container)[index];\n    let expired = false;\n    let location = {\n        ...parent.location,\n        path: parent.location.path.at(index),\n    };\n\n    const reference: Val.Reference = {\n        owner: parent,\n\n        get value() {\n            // Authorization is unnecessary here because the reference would not exist if access is unauthorized\n\n            // Note that we allow read from expired references\n            return value;\n        },\n\n        get expired() {\n            return expired;\n        },\n\n        get location() {\n            return location;\n        },\n\n        set location(loc: AccessControl.Location) {\n            location = loc;\n        },\n\n        get rootOwner() {\n            return parent.rootOwner;\n        },\n\n        set value(newValue: Val) {\n            if (value === newValue) {\n                return;\n            }\n\n            // Authorization and validation\n            assertWriteOk(newValue);\n\n            // Set the value directly before change() so change() doesn't create a useless clone\n            replaceValue(newValue);\n\n            // Now use change to complete the update\n            this.change(() => ((parent.value as Container)[index] = newValue));\n        },\n\n        get original() {\n            if (!parent.original) {\n                return undefined;\n            }\n            return (parent.original as Container)[index];\n        },\n\n        change(mutator: () => void) {\n            if (expired) {\n                throw new ExpiredReferenceError(this.location);\n            }\n\n            parent.change(() => {\n                // In transactions, clone the value if we haven't done so yet\n                if (clone && value === this.original) {\n                    const newValue = clone(value);\n                    (parent.value as Container)[index] = newValue;\n                    replaceValue(newValue);\n                }\n\n                // Apply changes\n                mutator();\n            });\n        },\n\n        refresh() {\n            if (parent.expired) {\n                expired = true;\n                return;\n            }\n            if (parent.value === undefined) {\n                expired = true;\n                replaceValue(undefined);\n                return;\n            }\n            replaceValue((parent.value as Container)[index]);\n        },\n    };\n\n    if (!parent.subrefs) {\n        parent.subrefs = {};\n    }\n    parent.subrefs[index] = reference;\n\n    return reference;\n\n    function replaceValue(newValue: Val) {\n        value = newValue;\n\n        const subrefs = reference.subrefs;\n        if (subrefs) {\n            for (const key in subrefs) {\n                subrefs[key].refresh();\n            }\n        }\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,SAAS,6BAA6B;AA6B/B,SAAS,iBACZ,QACA,OACA,eACA,OACF;AACE,MAAI,QAAS,OAAO,MAAoB,KAAK;AAC7C,MAAI,UAAU;AACd,MAAI,WAAW;AAAA,IACX,GAAG,OAAO;AAAA,IACV,MAAM,OAAO,SAAS,KAAK,GAAG,KAAK;AAAA,EACvC;AAEA,QAAM,YAA2B;AAAA,IAC7B,OAAO;AAAA,IAEP,IAAI,QAAQ;AAIR,aAAO;AAAA,IACX;AAAA,IAEA,IAAI,UAAU;AACV,aAAO;AAAA,IACX;AAAA,IAEA,IAAI,WAAW;AACX,aAAO;AAAA,IACX;AAAA,IAEA,IAAI,SAAS,KAA6B;AACtC,iBAAW;AAAA,IACf;AAAA,IAEA,IAAI,YAAY;AACZ,aAAO,OAAO;AAAA,IAClB;AAAA,IAEA,IAAI,MAAM,UAAe;AACrB,UAAI,UAAU,UAAU;AACpB;AAAA,MACJ;AAGA,oBAAc,QAAQ;AAGtB,mBAAa,QAAQ;AAGrB,WAAK,OAAO,MAAQ,OAAO,MAAoB,KAAK,IAAI,QAAS;AAAA,IACrE;AAAA,IAEA,IAAI,WAAW;AACX,UAAI,CAAC,OAAO,UAAU;AAClB,eAAO;AAAA,MACX;AACA,aAAQ,OAAO,SAAuB,KAAK;AAAA,IAC/C;AAAA,IAEA,OAAO,SAAqB;AACxB,UAAI,SAAS;AACT,cAAM,IAAI,sBAAsB,KAAK,QAAQ;AAAA,MACjD;AAEA,aAAO,OAAO,MAAM;AAEhB,YAAI,SAAS,UAAU,KAAK,UAAU;AAClC,gBAAM,WAAW,MAAM,KAAK;AAC5B,UAAC,OAAO,MAAoB,KAAK,IAAI;AACrC,uBAAa,QAAQ;AAAA,QACzB;AAGA,gBAAQ;AAAA,MACZ,CAAC;AAAA,IACL;AAAA,IAEA,UAAU;AACN,UAAI,OAAO,SAAS;AAChB,kBAAU;AACV;AAAA,MACJ;AACA,UAAI,OAAO,UAAU,QAAW;AAC5B,kBAAU;AACV,qBAAa,MAAS;AACtB;AAAA,MACJ;AACA,mBAAc,OAAO,MAAoB,KAAK,CAAC;AAAA,IACnD;AAAA,EACJ;AAEA,MAAI,CAAC,OAAO,SAAS;AACjB,WAAO,UAAU,CAAC;AAAA,EACtB;AACA,SAAO,QAAQ,KAAK,IAAI;AAExB,SAAO;AAEP,WAAS,aAAa,UAAe;AACjC,YAAQ;AAER,UAAM,UAAU,UAAU;AAC1B,QAAI,SAAS;AACT,iBAAW,OAAO,SAAS;AACvB,gBAAQ,GAAG,EAAE,QAAQ;AAAA,MACzB;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
