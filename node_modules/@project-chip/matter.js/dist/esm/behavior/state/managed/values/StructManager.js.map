{
  "version": 3,
  "sources": ["../../../../../../src/behavior/state/managed/values/StructManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"../../../../common/MatterError.js\";\nimport { FabricIndex } from \"../../../../datatype/FabricIndex.js\";\nimport { Access, ElementTag, Metatype, ValueModel } from \"../../../../model/index.js\";\nimport { GeneratedClass } from \"../../../../util/GeneratedClass.js\";\nimport { camelize } from \"../../../../util/String.js\";\nimport { isObject } from \"../../../../util/Type.js\";\nimport { AccessControl } from \"../../../AccessControl.js\";\nimport { PhantomReferenceError, SchemaImplementationError } from \"../../../errors.js\";\nimport type { RootSupervisor } from \"../../../supervision/RootSupervisor.js\";\nimport type { Schema } from \"../../../supervision/Schema.js\";\nimport type { ValueSupervisor } from \"../../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../../Val.js\";\nimport { Instrumentation } from \"../Instrumentation.js\";\nimport { Internal } from \"../Internal.js\";\nimport { ManagedReference } from \"../ManagedReference.js\";\nimport { PrimitiveManager } from \"./PrimitiveManager.js\";\n\nconst SESSION = Symbol(\"options\");\nconst AUTHORIZE_READ = Symbol(\"authorize-read\");\n\n/**\n * For structs we generate a class with accessors for each property in the schema.\n */\nexport function StructManager(owner: RootSupervisor, schema: Schema): ValueSupervisor.Manage {\n    const instanceDescriptors = {} as PropertyDescriptorMap;\n    const propertyAccessControls = {} as Record<string, AccessControl>;\n    let hasFabricIndex = false;\n\n    // Scan the schema and configure each member (field or attribute) as a property\n    for (const member of schema.activeMembers) {\n        const name = camelize(member.name);\n\n        const { access, descriptor } = configureProperty(owner, member);\n\n        instanceDescriptors[name] = descriptor;\n        propertyAccessControls[name] = access;\n\n        if (member.name === \"FabricIndex\") {\n            hasFabricIndex = true;\n        }\n    }\n\n    let name = schema.name;\n    if (schema.tag === ElementTag.Cluster && !name.endsWith(\"$State\")) {\n        name = `${name}$State`;\n    }\n\n    const Wrapper = GeneratedClass({\n        name,\n\n        initialize(this: Wrapper, ref: Val.Reference, session: ValueSupervisor.Session) {\n            // Only objects are acceptable\n            if (!isObject(ref.value)) {\n                throw new SchemaImplementationError(\n                    ref.location,\n                    `Cannot manage ${typeof ref.value} because it is not a struct`,\n                );\n            }\n\n            // If we have a fabric index, update the context\n            if (hasFabricIndex) {\n                const owningFabric = (ref as Val.Reference<Val.Struct>).value.fabricIndex as FabricIndex | undefined;\n                ref.location = { ...ref.location, owningFabric };\n            }\n\n            Object.defineProperties(this, {\n                [Internal.reference]: {\n                    value: ref as Val.Reference<Val.Struct>,\n                },\n                [SESSION]: {\n                    value: session,\n                },\n            });\n\n            // Sadly we can't place instance descriptors on our prototype because then simple JS patterns that rely on\n            // enumerating own properties (e.g. spread) won't work.  At least we can reuse the accessors so they should\n            // get JITed\n            Object.defineProperties(this, instanceDescriptors);\n        },\n\n        instanceDescriptors: {\n            // TODO - interferes with Chai deep equal.  Best fix would probably be a custom deep equal assertion but\n            // leaving out for now\n            // [Symbol.toStringTag]: {\n            //     value: name,\n            // },\n\n            // TODO - makes Mocha diffs pretty useless.  Best fix is probably customized diff but leaving out for now\n            // toString: {\n            //     value() {\n            //         return serialize(this);\n            //     }\n            // },\n\n            // AUTHORIZE_READ is effectively a protected method, see StructManager.assertDirectReadAuthorized below\n            [AUTHORIZE_READ]: {\n                value(this: Wrapper, index: string) {\n                    const access = propertyAccessControls[index];\n\n                    if (access === undefined) {\n                        throw new ImplementationError(`Direct read of unknown property ${index}`);\n                    }\n\n                    access.authorizeRead(this[SESSION], this[Internal.reference].location);\n                },\n            },\n        },\n    }) as new (value: Val, session: AccessControl.Session) => Val.Struct;\n\n    Instrumentation.instrumentStruct(Wrapper);\n\n    return (reference, session) => {\n        reference.owner = new Wrapper(reference, session);\n        return reference.owner;\n    };\n}\n\nexport namespace StructManager {\n    /**\n     * If a struct is referenced as a whole, fields for which the session are unauthorized are simply omitted.\n     *\n     * This function instead throws an error for unauthorized access.  It must be invoked before direct property reads.\n     *\n     * @param struct a managed struct\n     * @param index the field to read\n     */\n    export function assertDirectReadAuthorized(struct: Val.Struct, index: string) {\n        if (!(struct as Wrapper)?.[AUTHORIZE_READ]) {\n            throw new ImplementationError(\"Cannot authorize read of unmanaged value\");\n        }\n        return (struct as Wrapper)[AUTHORIZE_READ](index);\n    }\n}\n\ninterface Wrapper extends Val.Struct, Internal.Collection {\n    /**\n     * A reference to the raw value.\n     */\n    [Internal.reference]: Val.Reference<Val.Struct>;\n\n    /**\n     * Information regarding the current user session.\n     */\n    [SESSION]: ValueSupervisor.Session;\n\n    /**\n     * Direct read authorization.\n     */\n    [AUTHORIZE_READ]: (index: string) => void;\n}\n\nfunction configureProperty(manager: RootSupervisor, schema: ValueModel) {\n    const name = camelize(schema.name);\n\n    const { access, manage, validate } = manager.get(schema);\n\n    const fabricScopedList =\n        schema.effectiveAccess.fabric === Access.Fabric.Scoped && schema.effectiveMetatype === Metatype.array;\n\n    const descriptor: PropertyDescriptor = {\n        enumerable: true,\n\n        set(this: Wrapper, value: Val) {\n            access.authorizeWrite(this[SESSION], this[Internal.reference].location);\n\n            const oldValue = this[Internal.reference].value[name];\n\n            const self = this;\n\n            this[Internal.reference].change(() => {\n                const struct = this[Internal.reference].value;\n\n                // Identify the target.  Usually just \"struct\" except when struct supports Val.Dynamic\n                let target;\n                if ((struct as Val.Dynamic)[Val.properties]) {\n                    const properties = (struct as Val.Dynamic)[Val.properties](\n                        this[Internal.reference].rootOwner,\n                        this[SESSION],\n                    );\n                    if (name in properties) {\n                        target = properties;\n                    } else {\n                        target = struct;\n                    }\n                } else {\n                    target = struct;\n                }\n\n                // Unwrap if incoming value is managed\n                if (value && (value as Internal.Collection)[Internal.reference]) {\n                    value = (value as Internal.Collection)[Internal.reference].value;\n                }\n\n                // Modify the value\n                if (fabricScopedList && Array.isArray(value) && Array.isArray(target[name])) {\n                    // In the case of fabric-scoped write to established list we use the managed proxy to perform update\n                    // as it will sort through values and only modify those with correct fabricIndex\n                    const proxy = self[name] as Val.List;\n                    for (let i = 0; i < value.length; i++) {\n                        proxy[i] = value[i];\n                    }\n                    proxy.length = value.length;\n                } else {\n                    // Direct assignment\n                    target[name] = value;\n                }\n\n                if (!this[SESSION].acceptInvalid && validate) {\n                    // Note: We validate fully for nested structs but *not* for the current struct.  This is because\n                    // choice conformance may be violated temporarily as individual fields change.\n                    //\n                    // Also, validating fully would require us to validate across all properties for every property\n                    // write.\n                    //\n                    // I think this is OK for now.  If it becomes an issue we'll probably want to wire in a separate\n                    // validation step that is performed on commit when choice conformance is in play.\n                    try {\n                        validate(value, this[SESSION], {\n                            path: this[Internal.reference].location.path,\n                            siblings: struct,\n                        });\n                    } catch (e) {\n                        // Undo our change on error.  Rollback will take care of this when transactional but this\n                        // handles the cases of 1.) no transaction, and 2.) error is caught within transaction\n                        target[name] = oldValue;\n\n                        throw e;\n                    }\n                }\n            });\n        },\n    };\n\n    if (manage === PrimitiveManager) {\n        // For primitives we don't need a manager so just proxy reads directly\n        descriptor.get = function (this: Wrapper) {\n            if (access.mayRead(this[SESSION], this[Internal.reference].location)) {\n                const struct = this[Internal.reference].value as Val.Dynamic;\n                if (struct === undefined) {\n                    throw new PhantomReferenceError(this[Internal.reference].location);\n                }\n                if (struct[Val.properties]) {\n                    const properties = struct[Val.properties](this[Internal.reference].rootOwner, this[SESSION]);\n                    if (name in properties) {\n                        return properties[name];\n                    }\n                }\n\n                return struct[name];\n            }\n        };\n    } else {\n        // For collections we create a managed value\n        let cloneContainer: (container: Val) => Val;\n        switch (schema.effectiveMetatype) {\n            case Metatype.array:\n                cloneContainer = (container: Val) => [...(container as Val.List)];\n                break;\n\n            case Metatype.bitmap:\n                cloneContainer = (container: Val) => {\n                    // Special case for bitmaps -- this only occurs when the manager takes control and converts from\n                    // a number to an object\n                    if (typeof container === \"number\" || typeof container === \"bigint\") {\n                        return {};\n                    }\n\n                    // Already an object\n                    return { ...(container as Val.Struct) };\n                };\n                break;\n\n            default:\n                cloneContainer = (container: Val) => ({ ...(container as Val.Struct) });\n        }\n\n        descriptor.get = function (this: Wrapper) {\n            let value;\n\n            // Obtain the value.  Normally just struct[name] except in the case of Val.Dynamic\n            const struct = this[Internal.reference].value;\n            if ((struct as Val.Dynamic)[Val.properties]) {\n                const properties = (struct as Val.Dynamic)[Val.properties](\n                    this[Internal.reference].rootOwner,\n                    this[SESSION],\n                );\n                if (name in properties) {\n                    value = properties[name];\n                } else {\n                    value = struct[name];\n                }\n            } else {\n                value = struct[name];\n            }\n\n            if (value === undefined) {\n                return;\n            }\n\n            // Note that we only mask values that are unreadable.  This is appropriate when the parent object is\n            // visible.  For direct access to a property we should throw an error but that must be implemented at a\n            // higher level because we cannot differentiate here\n            if (!access.mayRead(this[SESSION], this[Internal.reference].location)) {\n                return undefined;\n            }\n\n            if (value === null) {\n                return value;\n            }\n\n            const managed = this[Internal.reference].subrefs?.[name];\n            if (managed) {\n                return managed.owner;\n            }\n\n            const assertWriteOk = (value: Val) => {\n                // Note - this needs to mirror behavior in the setter above\n                access.authorizeWrite(this[SESSION], this[Internal.reference].location);\n                if (validate) {\n                    validate(value, this[SESSION], {\n                        path: this[Internal.reference].location.path,\n                        siblings: this[Internal.reference].value,\n                    });\n                }\n            };\n\n            // Clone the container before write\n            const ref = ManagedReference(this[Internal.reference], name, assertWriteOk, cloneContainer);\n\n            ref.owner = manage(ref, this[SESSION]);\n\n            return ref.owner;\n        };\n    }\n\n    return { descriptor, access };\n}\n"],
  "mappings": "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",
  "names": ["name", "StructManager", "value"]
}
