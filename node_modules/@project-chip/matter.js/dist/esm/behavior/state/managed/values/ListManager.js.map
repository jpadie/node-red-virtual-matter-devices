{
  "version": 3,
  "sources": ["../../../../../../src/behavior/state/managed/values/ListManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DataModelPath } from \"../../../../model/definitions/DataModelPath.js\";\nimport { Access, ValueModel } from \"../../../../model/index.js\";\nimport { StatusCode } from \"../../../../protocol/interaction/StatusCode.js\";\nimport { serialize } from \"../../../../util/String.js\";\nimport { isObject } from \"../../../../util/Type.js\";\nimport { AccessControl } from \"../../../AccessControl.js\";\nimport { ExpiredReferenceError, ReadError, SchemaImplementationError, WriteError } from \"../../../errors.js\";\nimport type { RootSupervisor } from \"../../../supervision/RootSupervisor.js\";\nimport { Schema } from \"../../../supervision/Schema.js\";\nimport type { ValueSupervisor } from \"../../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../../Val.js\";\nimport { Instrumentation } from \"../Instrumentation.js\";\nimport { Internal } from \"../Internal.js\";\nimport { ManagedReference } from \"../ManagedReference.js\";\nimport { PrimitiveManager } from \"./PrimitiveManager.js\";\n\n/**\n * We must use a proxy to properly encapsulate array data.\n *\n * This is ideal from a security and data quality perspective but not from a performance perspective.\n *\n * This can be worked around by replacing an entire array rather than just a single field.  If that is insufficient we\n * may need some type of batch interface or provide a means for accessing the internal array directly.\n *\n * Note that there can be access controls both on the list and the list entries.  We do not use the controls on the\n * entry as it doesn't make sense for them to be more conservative than the list and the Matter spec makes no mention of\n * this.\n */\nexport function ListManager(owner: RootSupervisor, schema: Schema): ValueSupervisor.Manage {\n    const config = createConfig(owner, schema);\n\n    return (list, session) => {\n        // Sanity check\n        if (!Array.isArray(list.value)) {\n            throw new SchemaImplementationError(\n                list.location,\n                `Cannot manage ${typeof list.value} because it is not an array`,\n            );\n        }\n\n        return createProxy(config, list as Val.Reference<Val.List>, session);\n    };\n}\n\nfunction createConfig(owner: RootSupervisor, schema: Schema): ListConfig {\n    const entry = schema instanceof ValueModel ? schema.listEntry : undefined;\n    if (entry === undefined) {\n        throw new SchemaImplementationError(DataModelPath(schema.path), \"List schema has no entry definition\");\n    }\n\n    const entryManager = owner.get(entry);\n\n    const access = AccessControl(schema);\n\n    return {\n        schema,\n        fabricScoped: schema.effectiveAccess.fabric == Access.Fabric.Scoped,\n        fabricSensitive: schema.effectiveAccess.fabric == Access.Fabric.Sensitive,\n        manageEntries: entryManager.manage !== PrimitiveManager,\n        manageEntry: entryManager.manage,\n        validateEntry: entryManager.validate,\n        authorizeRead: access.authorizeRead,\n        authorizeWrite: access.authorizeWrite,\n    };\n}\n\ninterface ListConfig {\n    schema: Schema;\n    fabricScoped: boolean;\n    fabricSensitive: boolean;\n    manageEntries: boolean;\n    manageEntry: ValueSupervisor.Manage;\n    validateEntry?: ValueSupervisor.Validate;\n    authorizeRead: AccessControl[\"authorizeRead\"];\n    authorizeWrite: AccessControl[\"authorizeWrite\"];\n}\n\nfunction createProxy(config: ListConfig, reference: Val.Reference<Val.List>, session: ValueSupervisor.Session) {\n    const { manageEntry, validateEntry, authorizeRead, authorizeWrite } = config;\n\n    // On read we treat nullish as an empty array.  This prevents errors on expired references\n    const readVal = () => reference.value ?? [];\n\n    // On write we throw an error if the reference is expired\n    const writeVal = () => {\n        if (reference.expired) {\n            throw new ExpiredReferenceError(reference.location);\n        }\n\n        return reference.value;\n    };\n\n    let getListLength = () => readVal().length;\n    let setListLength = (length: number) => {\n        if (length > 65535) {\n            throw new WriteError(reference.location, `Index ${length} is greater than allowed maximum of 65535`);\n        }\n\n        reference.change(() => (writeVal().length = length));\n    };\n    let hasEntry = (index: number) => readVal()[index] !== undefined;\n\n    // Create the base entry reader.  The reader is different for containers vs. primitive values\n    let readEntry: (index: number, location: AccessControl.Location) => Val;\n\n    // Iteration is different for fabric-scoped read but otherwise\n    let getIteratorFn = () => readVal()[Symbol.iterator];\n\n    // These two are needed to support \"for in\" loops.  And good for completeness\n    let ownKeys = () => Reflect.ownKeys(readVal());\n    let getOwnPropertyDescriptor = (_target: object, key: PropertyKey) =>\n        Reflect.getOwnPropertyDescriptor(readVal(), key);\n\n    // Template used to convey sub-location information\n    const sublocation = {\n        ...reference.location,\n        path: reference.location.path.at(-1),\n    };\n\n    if (config.manageEntries) {\n        // Base reader produces managed containers\n        readEntry = index => {\n            authorizeRead(session, reference.location);\n\n            if (index < 0 || index >= readVal().length) {\n                throw new ReadError(reference.location, `Index ${index} is out of bounds`);\n            }\n\n            if (index > 65535) {\n                throw new ReadError(reference.location, `Index ${index} is greater than allowed maximum of 65535`);\n            }\n\n            // AFAICT spec doesn't contemplate sparse arrays but it's kind of assumed.  If the value is nullish then\n            // treat like a primitive and no management necessary\n            const value = readVal()[index];\n            if (value === undefined || value === null) {\n                return value;\n            }\n\n            let subref = reference.subrefs?.[index];\n\n            if (subref === undefined) {\n                subref = ManagedReference(\n                    reference,\n                    index,\n\n                    () => true,\n\n                    val => (Array.isArray(val) ? [...(val as Val.List)] : isObject(val) ? { ...val } : val),\n                );\n\n                manageEntry(subref, session);\n            }\n\n            return subref.owner;\n        };\n    } else {\n        // Primitive value -- no management necessary\n        readEntry = (index, location) => {\n            authorizeRead(session, location);\n            if (index < 0 || index > readVal().length) {\n                throw new WriteError(location, `Index ${index} is out of bounds`);\n            }\n\n            return readVal()[index];\n        };\n    }\n\n    // Create an entry writer\n    let writeEntry = (index: number, value: Val, location: AccessControl.Location) => {\n        authorizeWrite(session, location);\n\n        if (index < 0 || index > readVal().length + 1) {\n            throw new WriteError(location, `Index ${index} is out of bounds`);\n        }\n\n        if (index > 65535) {\n            throw new ReadError(location, `Index ${index} is greater than allowed maximum of 65535`);\n        }\n\n        // Unwrap incoming managed values\n        if (value && (value as Internal.Collection)[Internal.reference]) {\n            value = (value as Internal.Collection)[Internal.reference].value;\n        }\n\n        reference.change(() => (writeVal()[index] = value));\n    };\n\n    // If the list is fabric-scoped, wrap read and write to map indices\n    if (config.fabricScoped) {\n        function mapScopedToActual(index: number, reading: boolean) {\n            if (index < 0) {\n                throw new (reading ? ReadError : WriteError)(reference.location, `Negative index ${index} unsupported`);\n            }\n\n            let nextPos = 0;\n            for (let i = 0; i < readVal().length; i++) {\n                // Skip invalid data\n                const entry = readVal()[i] as undefined | { fabricIndex?: number };\n                if (typeof entry !== \"object\") {\n                    continue;\n                }\n\n                // If there's no fabric index or it's a match, consider \"in scope\"\n                if (session.offline || !entry.fabricIndex || entry.fabricIndex === session.fabric) {\n                    if (nextPos === index) {\n                        // Found our target\n                        return i;\n                    }\n\n                    // Next target will be the one\n                    nextPos++;\n                }\n            }\n\n            if (reading) {\n                throw new ReadError(reference.location, `Index ${index} extends beyond available entries`);\n            }\n\n            if (nextPos === index) {\n                // Adding to end of list\n                return readVal().length;\n            }\n\n            throw new WriteError(reference.location, `Index ${index} would leave gaps in fabric-filtered list`);\n        }\n\n        if (session.fabricFiltered || config.fabricSensitive) {\n            const nextReadEntry = readEntry;\n\n            hasEntry = (index: number) => {\n                try {\n                    return nextReadEntry(mapScopedToActual(index, true), reference.location) !== undefined;\n                } catch (e) {\n                    return false;\n                }\n            };\n\n            readEntry = (index: number, location: AccessControl.Location) => {\n                return nextReadEntry(mapScopedToActual(index, true), location);\n            };\n\n            const nextWriteEntry = writeEntry;\n            writeEntry = (index: number, value: Val, location: AccessControl.Location) => {\n                if (value === undefined) {\n                    const valueIndex = mapScopedToActual(index, false);\n                    writeVal().splice(valueIndex, 1);\n                } else {\n                    if (typeof value !== \"object\") {\n                        throw new WriteError(location, `Fabric scoped list value is not an object`, StatusCode.Failure);\n                    }\n                    (value as { fabricIndex?: number }).fabricIndex ??= session.fabric;\n                    nextWriteEntry(mapScopedToActual(index, false), value, location);\n                }\n            };\n\n            getListLength = () => {\n                let length = 0;\n                for (let i = 0; i < readVal().length; i++) {\n                    const entry = readVal()[i] as undefined | { fabricIndex?: number };\n                    if (\n                        isObject(entry) &&\n                        (session.offline || !entry.fabricIndex || entry.fabricIndex === session.fabric)\n                    ) {\n                        length++;\n                    }\n                }\n                return length;\n            };\n\n            setListLength = (length: number) => {\n                const formerLength = getListLength();\n\n                reference.change(() => {\n                    for (let i = formerLength - 1; i >= length; i--) {\n                        const entry = writeVal()[mapScopedToActual(i, true)] as undefined | { fabricIndex?: number };\n                        if (\n                            typeof entry === \"object\" &&\n                            (session.offline || !entry.fabricIndex || entry.fabricIndex === session.fabric)\n                        ) {\n                            writeVal().splice(mapScopedToActual(i, false), 1);\n                        } else if (entry !== undefined) {\n                            throw new WriteError(\n                                reference.location,\n                                `Fabric scoped list value is not an object`,\n                                StatusCode.Failure,\n                            );\n                        }\n                    }\n                });\n            };\n\n            // Create a function that returns an iterator that skips entries from non-associated fabrics.  The base\n            // Array[Symbol.iterator] does the right thing because it uses indices and length.  So this is only an\n            // optimization\n            getIteratorFn = () => () => {\n                // The iterator for the actual collection\n                const iterator = readVal()[Symbol.iterator]();\n\n                // An iterator that skips inapplicable entries\n                return {\n                    next() {\n                        while (true) {\n                            // Iterate through source\n                            const next = iterator.next();\n\n                            // Skip iteration if the result would have incorrect fabricIndex\n                            if (\n                                !next.done &&\n                                isObject(next.value) &&\n                                (next.value as { fabricIndex?: number }).fabricIndex !== session.fabric\n                            ) {\n                                continue;\n                            }\n\n                            // Entry applies or we're done\n                            return next;\n                        }\n                    },\n\n                    [Symbol.iterator]() {\n                        return this;\n                    },\n                };\n            };\n\n            ownKeys = () => {\n                const length = getListLength();\n\n                const keys = Reflect.ownKeys(readVal()).filter(k => {\n                    if (typeof k !== \"string\") {\n                        return true;\n                    }\n                    if (!k.match(/^[0-9]+$/)) {\n                        return true;\n                    }\n                    if (Number.parseInt(k) < length) {\n                        return true;\n                    }\n                    return false;\n                });\n\n                return keys;\n            };\n\n            getOwnPropertyDescriptor = (_target, key) => {\n                if (typeof key === \"string\" && key.match(/^[0-9]+$/)) {\n                    key = Number.parseInt(key);\n                }\n                if (typeof key !== \"number\") {\n                    return Reflect.getOwnPropertyDescriptor(readVal(), key);\n                }\n\n                return Reflect.getOwnPropertyDescriptor(readVal(), mapScopedToActual(key, true));\n            };\n        }\n    }\n\n    const target = [] as Val.List;\n    const handlers: ProxyHandler<Val.List> = {\n        get(_target, property, receiver) {\n            if (typeof property === \"string\" && property.match(/^[0-9]+/)) {\n                sublocation.path.id = property;\n                return readEntry(Number.parseInt(property), sublocation);\n            }\n\n            switch (property) {\n                case \"length\":\n                    return getListLength();\n\n                case Symbol.iterator:\n                    return getIteratorFn();\n\n                case Internal.reference:\n                    return reference;\n\n                case \"toString\":\n                    return function (this: Val.List) {\n                        return serialize(this);\n                    };\n\n                case Symbol.toStringTag:\n                    return undefined;\n            }\n\n            return Reflect.get(readVal(), property, receiver);\n        },\n\n        // On write we enter a transaction\n        set(_target, property, newValue, receiver) {\n            if (typeof property === \"string\" && property.match(/^[0-9]+/)) {\n                sublocation.path.id = property;\n                validateEntry?.(newValue, session, sublocation);\n                writeEntry(Number.parseInt(property), newValue, sublocation);\n                return true;\n            } else if (property === \"length\") {\n                setListLength(newValue);\n                return true;\n            }\n\n            return Reflect.set(writeVal(), property, newValue, receiver);\n        },\n\n        has(_target, property) {\n            if (typeof property === \"string\" && property.match(/^[0-9]+/)) {\n                return hasEntry(Number.parseInt(property));\n            }\n\n            return Reflect.has(readVal(), property);\n        },\n\n        deleteProperty: (_target, property) => {\n            if (typeof property === \"string\" && property.match(/^[0-9]+/)) {\n                sublocation.path.id = property;\n                writeEntry(Number.parseInt(property), undefined, sublocation);\n                return true;\n            }\n\n            return Reflect.deleteProperty(writeVal(), property);\n        },\n\n        ownKeys,\n        getOwnPropertyDescriptor,\n    };\n\n    const factory = Instrumentation.instrumentList((handlers, target) => new Proxy(target, handlers));\n\n    reference.owner = factory(handlers, target);\n\n    return reference.owner;\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,qBAAqB;AAC9B,SAAS,QAAQ,kBAAkB;AACnC,SAAS,kBAAkB;AAC3B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,qBAAqB;AAC9B,SAAS,uBAAuB,WAAW,2BAA2B,kBAAkB;AAKxF,SAAS,uBAAuB;AAChC,SAAS,gBAAgB;AACzB,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AAc1B,SAAS,YAAY,OAAuB,QAAwC;AACvF,QAAM,SAAS,aAAa,OAAO,MAAM;AAEzC,SAAO,CAAC,MAAM,YAAY;AAEtB,QAAI,CAAC,MAAM,QAAQ,KAAK,KAAK,GAAG;AAC5B,YAAM,IAAI;AAAA,QACN,KAAK;AAAA,QACL,iBAAiB,OAAO,KAAK,KAAK;AAAA,MACtC;AAAA,IACJ;AAEA,WAAO,YAAY,QAAQ,MAAiC,OAAO;AAAA,EACvE;AACJ;AAEA,SAAS,aAAa,OAAuB,QAA4B;AACrE,QAAM,QAAQ,kBAAkB,aAAa,OAAO,YAAY;AAChE,MAAI,UAAU,QAAW;AACrB,UAAM,IAAI,0BAA0B,cAAc,OAAO,IAAI,GAAG,qCAAqC;AAAA,EACzG;AAEA,QAAM,eAAe,MAAM,IAAI,KAAK;AAEpC,QAAM,SAAS,cAAc,MAAM;AAEnC,SAAO;AAAA,IACH;AAAA,IACA,cAAc,OAAO,gBAAgB,UAAU,OAAO,OAAO;AAAA,IAC7D,iBAAiB,OAAO,gBAAgB,UAAU,OAAO,OAAO;AAAA,IAChE,eAAe,aAAa,WAAW;AAAA,IACvC,aAAa,aAAa;AAAA,IAC1B,eAAe,aAAa;AAAA,IAC5B,eAAe,OAAO;AAAA,IACtB,gBAAgB,OAAO;AAAA,EAC3B;AACJ;AAaA,SAAS,YAAY,QAAoB,WAAoC,SAAkC;AAC3G,QAAM,EAAE,aAAa,eAAe,eAAe,eAAe,IAAI;AAGtE,QAAM,UAAU,MAAM,UAAU,SAAS,CAAC;AAG1C,QAAM,WAAW,MAAM;AACnB,QAAI,UAAU,SAAS;AACnB,YAAM,IAAI,sBAAsB,UAAU,QAAQ;AAAA,IACtD;AAEA,WAAO,UAAU;AAAA,EACrB;AAEA,MAAI,gBAAgB,MAAM,QAAQ,EAAE;AACpC,MAAI,gBAAgB,CAAC,WAAmB;AACpC,QAAI,SAAS,OAAO;AAChB,YAAM,IAAI,WAAW,UAAU,UAAU,SAAS,MAAM,2CAA2C;AAAA,IACvG;AAEA,cAAU,OAAO,MAAO,SAAS,EAAE,SAAS,MAAO;AAAA,EACvD;AACA,MAAI,WAAW,CAAC,UAAkB,QAAQ,EAAE,KAAK,MAAM;AAGvD,MAAI;AAGJ,MAAI,gBAAgB,MAAM,QAAQ,EAAE,OAAO,QAAQ;AAGnD,MAAI,UAAU,MAAM,QAAQ,QAAQ,QAAQ,CAAC;AAC7C,MAAI,2BAA2B,CAAC,SAAiB,QAC7C,QAAQ,yBAAyB,QAAQ,GAAG,GAAG;AAGnD,QAAM,cAAc;AAAA,IAChB,GAAG,UAAU;AAAA,IACb,MAAM,UAAU,SAAS,KAAK,GAAG,EAAE;AAAA,EACvC;AAEA,MAAI,OAAO,eAAe;AAEtB,gBAAY,WAAS;AACjB,oBAAc,SAAS,UAAU,QAAQ;AAEzC,UAAI,QAAQ,KAAK,SAAS,QAAQ,EAAE,QAAQ;AACxC,cAAM,IAAI,UAAU,UAAU,UAAU,SAAS,KAAK,mBAAmB;AAAA,MAC7E;AAEA,UAAI,QAAQ,OAAO;AACf,cAAM,IAAI,UAAU,UAAU,UAAU,SAAS,KAAK,2CAA2C;AAAA,MACrG;AAIA,YAAM,QAAQ,QAAQ,EAAE,KAAK;AAC7B,UAAI,UAAU,UAAa,UAAU,MAAM;AACvC,eAAO;AAAA,MACX;AAEA,UAAI,SAAS,UAAU,UAAU,KAAK;AAEtC,UAAI,WAAW,QAAW;AACtB,iBAAS;AAAA,UACL;AAAA,UACA;AAAA,UAEA,MAAM;AAAA,UAEN,SAAQ,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAI,GAAgB,IAAI,SAAS,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI;AAAA,QACvF;AAEA,oBAAY,QAAQ,OAAO;AAAA,MAC/B;AAEA,aAAO,OAAO;AAAA,IAClB;AAAA,EACJ,OAAO;AAEH,gBAAY,CAAC,OAAO,aAAa;AAC7B,oBAAc,SAAS,QAAQ;AAC/B,UAAI,QAAQ,KAAK,QAAQ,QAAQ,EAAE,QAAQ;AACvC,cAAM,IAAI,WAAW,UAAU,SAAS,KAAK,mBAAmB;AAAA,MACpE;AAEA,aAAO,QAAQ,EAAE,KAAK;AAAA,IAC1B;AAAA,EACJ;AAGA,MAAI,aAAa,CAAC,OAAe,OAAY,aAAqC;AAC9E,mBAAe,SAAS,QAAQ;AAEhC,QAAI,QAAQ,KAAK,QAAQ,QAAQ,EAAE,SAAS,GAAG;AAC3C,YAAM,IAAI,WAAW,UAAU,SAAS,KAAK,mBAAmB;AAAA,IACpE;AAEA,QAAI,QAAQ,OAAO;AACf,YAAM,IAAI,UAAU,UAAU,SAAS,KAAK,2CAA2C;AAAA,IAC3F;AAGA,QAAI,SAAU,MAA8B,SAAS,SAAS,GAAG;AAC7D,cAAS,MAA8B,SAAS,SAAS,EAAE;AAAA,IAC/D;AAEA,cAAU,OAAO,MAAO,SAAS,EAAE,KAAK,IAAI,KAAM;AAAA,EACtD;AAGA,MAAI,OAAO,cAAc;AACrB,QAASA,qBAAT,SAA2B,OAAe,SAAkB;AACxD,UAAI,QAAQ,GAAG;AACX,cAAM,KAAK,UAAU,YAAY,YAAY,UAAU,UAAU,kBAAkB,KAAK,cAAc;AAAA,MAC1G;AAEA,UAAI,UAAU;AACd,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,QAAQ,KAAK;AAEvC,cAAM,QAAQ,QAAQ,EAAE,CAAC;AACzB,YAAI,OAAO,UAAU,UAAU;AAC3B;AAAA,QACJ;AAGA,YAAI,QAAQ,WAAW,CAAC,MAAM,eAAe,MAAM,gBAAgB,QAAQ,QAAQ;AAC/E,cAAI,YAAY,OAAO;AAEnB,mBAAO;AAAA,UACX;AAGA;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,SAAS;AACT,cAAM,IAAI,UAAU,UAAU,UAAU,SAAS,KAAK,mCAAmC;AAAA,MAC7F;AAEA,UAAI,YAAY,OAAO;AAEnB,eAAO,QAAQ,EAAE;AAAA,MACrB;AAEA,YAAM,IAAI,WAAW,UAAU,UAAU,SAAS,KAAK,2CAA2C;AAAA,IACtG;AAnCS,4BAAAA;AAqCT,QAAI,QAAQ,kBAAkB,OAAO,iBAAiB;AAClD,YAAM,gBAAgB;AAEtB,iBAAW,CAAC,UAAkB;AAC1B,YAAI;AACA,iBAAO,cAAcA,mBAAkB,OAAO,IAAI,GAAG,UAAU,QAAQ,MAAM;AAAA,QACjF,SAAS,GAAG;AACR,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,kBAAY,CAAC,OAAe,aAAqC;AAC7D,eAAO,cAAcA,mBAAkB,OAAO,IAAI,GAAG,QAAQ;AAAA,MACjE;AAEA,YAAM,iBAAiB;AACvB,mBAAa,CAAC,OAAe,OAAY,aAAqC;AAC1E,YAAI,UAAU,QAAW;AACrB,gBAAM,aAAaA,mBAAkB,OAAO,KAAK;AACjD,mBAAS,EAAE,OAAO,YAAY,CAAC;AAAA,QACnC,OAAO;AACH,cAAI,OAAO,UAAU,UAAU;AAC3B,kBAAM,IAAI,WAAW,UAAU,6CAA6C,WAAW,OAAO;AAAA,UAClG;AACA,UAAC,MAAmC,gBAAgB,QAAQ;AAC5D,yBAAeA,mBAAkB,OAAO,KAAK,GAAG,OAAO,QAAQ;AAAA,QACnE;AAAA,MACJ;AAEA,sBAAgB,MAAM;AAClB,YAAI,SAAS;AACb,iBAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,QAAQ,KAAK;AACvC,gBAAM,QAAQ,QAAQ,EAAE,CAAC;AACzB,cACI,SAAS,KAAK,MACb,QAAQ,WAAW,CAAC,MAAM,eAAe,MAAM,gBAAgB,QAAQ,SAC1E;AACE;AAAA,UACJ;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAEA,sBAAgB,CAAC,WAAmB;AAChC,cAAM,eAAe,cAAc;AAEnC,kBAAU,OAAO,MAAM;AACnB,mBAAS,IAAI,eAAe,GAAG,KAAK,QAAQ,KAAK;AAC7C,kBAAM,QAAQ,SAAS,EAAEA,mBAAkB,GAAG,IAAI,CAAC;AACnD,gBACI,OAAO,UAAU,aAChB,QAAQ,WAAW,CAAC,MAAM,eAAe,MAAM,gBAAgB,QAAQ,SAC1E;AACE,uBAAS,EAAE,OAAOA,mBAAkB,GAAG,KAAK,GAAG,CAAC;AAAA,YACpD,WAAW,UAAU,QAAW;AAC5B,oBAAM,IAAI;AAAA,gBACN,UAAU;AAAA,gBACV;AAAA,gBACA,WAAW;AAAA,cACf;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAKA,sBAAgB,MAAM,MAAM;AAExB,cAAM,WAAW,QAAQ,EAAE,OAAO,QAAQ,EAAE;AAG5C,eAAO;AAAA,UACH,OAAO;AACH,mBAAO,MAAM;AAET,oBAAM,OAAO,SAAS,KAAK;AAG3B,kBACI,CAAC,KAAK,QACN,SAAS,KAAK,KAAK,KAClB,KAAK,MAAmC,gBAAgB,QAAQ,QACnE;AACE;AAAA,cACJ;AAGA,qBAAO;AAAA,YACX;AAAA,UACJ;AAAA,UAEA,CAAC,OAAO,QAAQ,IAAI;AAChB,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AAEA,gBAAU,MAAM;AACZ,cAAM,SAAS,cAAc;AAE7B,cAAM,OAAO,QAAQ,QAAQ,QAAQ,CAAC,EAAE,OAAO,OAAK;AAChD,cAAI,OAAO,MAAM,UAAU;AACvB,mBAAO;AAAA,UACX;AACA,cAAI,CAAC,EAAE,MAAM,UAAU,GAAG;AACtB,mBAAO;AAAA,UACX;AACA,cAAI,OAAO,SAAS,CAAC,IAAI,QAAQ;AAC7B,mBAAO;AAAA,UACX;AACA,iBAAO;AAAA,QACX,CAAC;AAED,eAAO;AAAA,MACX;AAEA,iCAA2B,CAAC,SAAS,QAAQ;AACzC,YAAI,OAAO,QAAQ,YAAY,IAAI,MAAM,UAAU,GAAG;AAClD,gBAAM,OAAO,SAAS,GAAG;AAAA,QAC7B;AACA,YAAI,OAAO,QAAQ,UAAU;AACzB,iBAAO,QAAQ,yBAAyB,QAAQ,GAAG,GAAG;AAAA,QAC1D;AAEA,eAAO,QAAQ,yBAAyB,QAAQ,GAAGA,mBAAkB,KAAK,IAAI,CAAC;AAAA,MACnF;AAAA,IACJ;AAAA,EACJ;AAEA,QAAM,SAAS,CAAC;AAChB,QAAM,WAAmC;AAAA,IACrC,IAAI,SAAS,UAAU,UAAU;AAC7B,UAAI,OAAO,aAAa,YAAY,SAAS,MAAM,SAAS,GAAG;AAC3D,oBAAY,KAAK,KAAK;AACtB,eAAO,UAAU,OAAO,SAAS,QAAQ,GAAG,WAAW;AAAA,MAC3D;AAEA,cAAQ,UAAU;AAAA,QACd,KAAK;AACD,iBAAO,cAAc;AAAA,QAEzB,KAAK,OAAO;AACR,iBAAO,cAAc;AAAA,QAEzB,KAAK,SAAS;AACV,iBAAO;AAAA,QAEX,KAAK;AACD,iBAAO,WAA0B;AAC7B,mBAAO,UAAU,IAAI;AAAA,UACzB;AAAA,QAEJ,KAAK,OAAO;AACR,iBAAO;AAAA,MACf;AAEA,aAAO,QAAQ,IAAI,QAAQ,GAAG,UAAU,QAAQ;AAAA,IACpD;AAAA;AAAA,IAGA,IAAI,SAAS,UAAU,UAAU,UAAU;AACvC,UAAI,OAAO,aAAa,YAAY,SAAS,MAAM,SAAS,GAAG;AAC3D,oBAAY,KAAK,KAAK;AACtB,wBAAgB,UAAU,SAAS,WAAW;AAC9C,mBAAW,OAAO,SAAS,QAAQ,GAAG,UAAU,WAAW;AAC3D,eAAO;AAAA,MACX,WAAW,aAAa,UAAU;AAC9B,sBAAc,QAAQ;AACtB,eAAO;AAAA,MACX;AAEA,aAAO,QAAQ,IAAI,SAAS,GAAG,UAAU,UAAU,QAAQ;AAAA,IAC/D;AAAA,IAEA,IAAI,SAAS,UAAU;AACnB,UAAI,OAAO,aAAa,YAAY,SAAS,MAAM,SAAS,GAAG;AAC3D,eAAO,SAAS,OAAO,SAAS,QAAQ,CAAC;AAAA,MAC7C;AAEA,aAAO,QAAQ,IAAI,QAAQ,GAAG,QAAQ;AAAA,IAC1C;AAAA,IAEA,gBAAgB,CAAC,SAAS,aAAa;AACnC,UAAI,OAAO,aAAa,YAAY,SAAS,MAAM,SAAS,GAAG;AAC3D,oBAAY,KAAK,KAAK;AACtB,mBAAW,OAAO,SAAS,QAAQ,GAAG,QAAW,WAAW;AAC5D,eAAO;AAAA,MACX;AAEA,aAAO,QAAQ,eAAe,SAAS,GAAG,QAAQ;AAAA,IACtD;AAAA,IAEA;AAAA,IACA;AAAA,EACJ;AAEA,QAAM,UAAU,gBAAgB,eAAe,CAACC,WAAUC,YAAW,IAAI,MAAMA,SAAQD,SAAQ,CAAC;AAEhG,YAAU,QAAQ,QAAQ,UAAU,MAAM;AAE1C,SAAO,UAAU;AACrB;",
  "names": ["mapScopedToActual", "handlers", "target"]
}
