{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/managed/Datasource.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AccessLevel } from \"../../../cluster/Cluster.js\";\nimport { ImplementationError, InternalError } from \"../../../common/MatterError.js\";\nimport { Crypto } from \"../../../crypto/Crypto.js\";\nimport { ClusterId } from \"../../../datatype/ClusterId.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { DataModelPath } from \"../../../model/definitions/DataModelPath.js\";\nimport { deepCopy } from \"../../../util/DeepCopy.js\";\nimport { isDeepEqual } from \"../../../util/DeepEqual.js\";\nimport { Observable } from \"../../../util/Observable.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { AccessControl } from \"../../AccessControl.js\";\nimport { ExpiredReferenceError } from \"../../errors.js\";\nimport { RootSupervisor } from \"../../supervision/RootSupervisor.js\";\nimport { ValueSupervisor } from \"../../supervision/ValueSupervisor.js\";\nimport { StateType } from \"../StateType.js\";\nimport type { Val } from \"../Val.js\";\nimport { Resource } from \"../transaction/Resource.js\";\nimport { Transaction } from \"../transaction/Transaction.js\";\nimport { ReadOnlyTransaction } from \"../transaction/Tx.js\";\n\nconst logger = Logger.get(\"Datasource\");\n\n/**\n * Datasource manages the canonical root of a state tree.  The \"state\" property of a Behavior is a reference to a\n * Datasource.\n *\n * Datasources maintain a version number and triggers change events.  If modified in a transaction they compute changes\n * and persist values as necessary.\n */\nexport interface Datasource<T extends StateType = StateType> extends Resource {\n    /**\n     * Create a managed version of the source data.\n     */\n    reference(session: ValueSupervisor.Session): InstanceType<T>;\n\n    /**\n     * The data's version.\n     */\n    readonly version: number;\n\n    /**\n     * Validate values against the schema.\n     */\n    validate(session: ValueSupervisor.Session, values?: Val.Struct): void;\n\n    /**\n     * Obtain a read-only view of values.\n     */\n    readonly view: InstanceType<T>;\n}\n\n/**\n * Create a new datasource.\n */\nexport function Datasource<const T extends StateType = StateType>(options: Datasource.Options<T>): Datasource<T> {\n    const internals = configure(options);\n\n    let readOnlyView: undefined | InstanceType<T>;\n\n    return {\n        toString() {\n            return internals.path.toString();\n        },\n\n        reference(session: ValueSupervisor.Session) {\n            let context = internals.sessions?.get(session);\n            if (!context) {\n                context = createSessionContext(this, internals, session);\n            }\n            return context.managed as InstanceType<T>;\n        },\n\n        get version() {\n            return internals.version;\n        },\n\n        validate(session: ValueSupervisor.Session, values?: Val.Struct) {\n            const validate = internals.supervisor.validate;\n            if (!validate) {\n                return;\n            }\n            validate(values ?? internals.values, session, { path: internals.path });\n        },\n\n        get view() {\n            if (!readOnlyView) {\n                const session: ValueSupervisor.Session = {\n                    offline: true,\n                    authorizedFor(desiredAccessLevel: AccessLevel) {\n                        return desiredAccessLevel === AccessLevel.View;\n                    },\n                    transaction: ReadOnlyTransaction,\n                };\n                readOnlyView = createSessionContext(this, internals, session).managed as InstanceType<T>;\n            }\n            return readOnlyView;\n        },\n    };\n}\n\nexport namespace Datasource {\n    /**\n     * Datasource events.\n     */\n    export type Events = {\n        interactionBegin?: Observable<[]>;\n        interactionEnd?: Observable<[], MaybePromise>;\n    } & {\n        [K in `${string}$Changing` | `${string}$Changed`]: Observable<Parameters<ValueObserver>, MaybePromise>;\n    };\n\n    /**\n     * Datasource configuration options.\n     */\n    export interface Options<T extends StateType = StateType> {\n        /**\n         * The JS class for the root value.\n         */\n        type: T;\n\n        /**\n         * The manager used to manage and validate values.\n         */\n        supervisor: RootSupervisor;\n\n        /**\n         * Path used in diagnostic messages.\n         */\n        path: DataModelPath;\n\n        /**\n         * Events triggered automatically.\n         *\n         * Events named \"fieldName$Changing\", if present, emit before changes commit.  Events named \"fieldName$Changed\",\n         * if present, emit after field changes commit.\n         */\n        events?: Events;\n\n        /**\n         * Default values.  These defaults override default properties in the state class but not values persisted in\n         * the store.\n         */\n        defaults?: Val.Struct;\n\n        /**\n         * Optional storage for non-volatile values.\n         */\n        store?: Store;\n\n        /**\n         * The cluster used for access control checks.\n         */\n        cluster?: ClusterId;\n\n        /**\n         * The object that owns the datasource.  This is passed as the \"owner\" parameter to {@link Val.Dynamic}.\n         */\n        owner?: any;\n    }\n\n    /**\n     * The interface {@link Datasource} uses to read and write non-volatile values.\n     */\n    export interface Store {\n        /**\n         * Initial values must be loaded beforehand.  That allows the behavior to initialize synchronously.\n         */\n        initialValues?: Val.Struct;\n\n        /**\n         * Updates the values.\n         *\n         * This is a patch operation.  Only properties present are modified. Properties that are present but set to\n         * undefined are deleted.\n         */\n        set(transaction: Transaction, values: Val.Struct): Promise<void>;\n    }\n\n    export interface ValueObserver {\n        (value: Val, oldValue: Val, context?: ValueSupervisor.Session): void;\n    }\n}\n\n/**\n * Detail on all active references associated with the datasource.\n */\ninterface SessionContext {\n    managed: Val.Struct;\n    onChange(oldValues: Val.Struct): void;\n}\n\n/**\n * Internal datasource state.\n */\ninterface Internals extends Datasource.Options {\n    path: DataModelPath;\n    cluster?: ClusterId;\n    values: Val.Struct;\n    version: number;\n    sessions?: Map<ValueSupervisor.Session, SessionContext>;\n    interactionObserver(): MaybePromise<void>;\n}\n\n/**\n * Changes that are applied during a commit (computed post-commit).\n */\ninterface CommitChanges {\n    persistent?: Val.Struct;\n    notifications: Array<{\n        event: Observable<any[], MaybePromise>;\n        params: Parameters<Datasource.ValueObserver>;\n    }>;\n}\n\nfunction configure(options: Datasource.Options): Internals {\n    const values = new options.type() as Val.Struct;\n\n    const initialValues = {\n        ...options.defaults,\n        ...options.store?.initialValues,\n    };\n\n    for (const key in initialValues) {\n        values[key] = initialValues[key];\n    }\n\n    return {\n        ...options,\n        version: Crypto.getRandomUInt32(),\n        values: values,\n\n        interactionObserver() {\n            function handleObserverError(error: any) {\n                logger.error(`Error in ${options.path} observer:`, error);\n            }\n\n            try {\n                const result = options.events?.interactionEnd?.emit();\n                if (MaybePromise.is(result)) {\n                    return result.then(handleObserverError);\n                }\n            } catch (e) {\n                handleObserverError(e);\n            }\n        },\n    };\n}\n\n/**\n * The bulk of {@link Datasource} logic resides with a specific {@link Val.Reference} created by this function.\n *\n * This reference provides external access to the {@link Val.Struct} in the context of a specific session.\n */\nfunction createSessionContext(resource: Resource, internals: Internals, session: ValueSupervisor.Session) {\n    let values = internals.values;\n    let precommitValues: Val.Struct | undefined;\n    let changes: CommitChanges | undefined;\n    let expired = false;\n\n    const participant = {\n        toString() {\n            return internals.path.toString();\n        },\n        preCommit,\n        commit1,\n        commit2,\n        postCommit,\n        rollback,\n    };\n\n    const transaction = session.transaction;\n\n    // Refresh to newest values whenever the transaction commits or rolls back\n    void transaction.onShared(() => {\n        if (values !== internals.values) {\n            try {\n                rollback();\n            } catch (e) {\n                logger.error(\n                    `Error resetting reference to ${internals.path} after reset of transaction ${transaction.via}:`,\n                    e,\n                );\n            }\n        }\n    });\n\n    const fields = internals.supervisor.memberNames;\n    const persistentFields = internals.supervisor.persistentNames;\n\n    // This is the actual reference\n    const reference: Val.Reference<Val.Struct> = {\n        get original() {\n            return internals.values;\n        },\n\n        get value() {\n            if (expired) {\n                throw new ExpiredReferenceError(this.location);\n            }\n\n            return values;\n        },\n\n        set value(_value) {\n            throw new InternalError(`Cannot set root reference for ${internals.supervisor.schema.name}`);\n        },\n\n        get expired() {\n            return expired;\n        },\n\n        get location() {\n            return { path: internals.path, cluster: internals.cluster };\n        },\n\n        set location(_loc: AccessControl.Location) {\n            throw new ImplementationError(\"Root reference location is immutable\");\n        },\n\n        get rootOwner() {\n            return internals.owner;\n        },\n\n        change(mutator) {\n            if (expired) {\n                throw new ExpiredReferenceError(this.location);\n            }\n\n            // Join the transaction\n            startWrite();\n\n            // Upgrade transaction if not already exclusive\n            transaction.beginSync();\n\n            // Clone values if we haven't already\n            if (values === internals.values) {\n                const old = values;\n                values = new internals.type();\n                for (const index of fields) {\n                    values[index] = old[index];\n                }\n\n                // Point subreferences to the clone\n                refreshSubrefs();\n            }\n\n            // Perform the mutation\n            mutator();\n\n            // Refresh subrefs referencing any mutated values\n            refreshSubrefs();\n        },\n\n        refresh() {\n            throw new InternalError(`Cannot refresh root reference for ${internals.supervisor.schema.name}`);\n        },\n    };\n\n    reference.toString = () => `ref<${resource}>`;\n\n    // Register a listener on the datasource so we can update our reference when the datasource changes\n    const context: SessionContext = {\n        managed: internals.supervisor.manage(reference, session) as Val.Struct,\n\n        onChange(oldValues: Val.Struct) {\n            if (values === oldValues) {\n                values = internals.values;\n                refreshSubrefs();\n            }\n        },\n    };\n    if (!internals.sessions) {\n        internals.sessions = new Map();\n    }\n    internals.sessions.set(session, context);\n\n    // When the transaction is destroyed, decouple from the datasource and expire\n    void transaction.onClose(() => {\n        try {\n            internals.sessions?.delete(session);\n            expired = true;\n            refreshSubrefs();\n        } catch (e) {\n            logger.error(\n                `Error detaching reference to ${internals.path} from closed transaction ${transaction.via}:`,\n                e,\n            );\n        }\n    });\n\n    return context;\n\n    function startWrite() {\n        // Add myself as a resource so I can be locked\n        transaction.addResourcesSync(resource);\n\n        // Add my participant that performs commit\n        transaction.addParticipants(participant);\n\n        // Enter exclusive mode.  This will throw if my lock is unavailable\n        transaction.beginSync();\n\n        if (session.interactionComplete && !session.interactionComplete.isObservedBy(internals.interactionObserver)) {\n            internals.events?.interactionBegin?.emit();\n            session.interactionComplete.on(internals.interactionObserver);\n        }\n    }\n\n    // Need to invoke this anytime we change values\n    function refreshSubrefs() {\n        const subrefs = reference.subrefs;\n        if (subrefs) {\n            for (const key in subrefs) {\n                subrefs[key].refresh();\n            }\n        }\n    }\n\n    // Increment data version\n    function incrementVersion() {\n        // Update version\n        internals.version++;\n        if (internals.version > 0xffff_ffff) {\n            internals.version = 0;\n        }\n    }\n\n    // On the first pre-commit cycle, any change is a \"pre-commit\" change.  On subsequent cycles we only consider\n    // changes since the previous cycle\n    function computePreCommitChange(name: string): undefined | { newValue: unknown; oldValue: unknown } {\n        let oldValue;\n        if (precommitValues && name in precommitValues) {\n            oldValue = precommitValues[name];\n        } else {\n            oldValue = internals.values[name];\n        }\n\n        const newValue = values[name];\n        if (isDeepEqual(oldValue, newValue)) {\n            return;\n        }\n\n        if (!precommitValues) {\n            precommitValues = {};\n        }\n        precommitValues[name] = deepCopy(newValue);\n\n        // Since we are notifying of data in flight, pass the managed value for \"newValue\" so that we validate changes\n        // and subsequent listeners are updated\n        return { newValue: context.managed[name], oldValue };\n    }\n\n    /**\n     * For pre-commit we trigger \"fieldName$Changing\" events for any fields that have changed since the previous\n     * pre-commit cycle.\n     *\n     * Tracking data here is relatively expensive so we limit to events with registered observers.\n     */\n    function preCommit() {\n        // We do nothing if there are not events registered\n        const { events } = internals;\n        if (!events) {\n            return false;\n        }\n\n        // Mutation is only possible if we emit a $Changing event\n        let mayHaveMutated = false;\n\n        // Emit is optionally async so we must iterate manually\n        const keyIterator = Object.keys(values)[Symbol.iterator]();\n\n        // Proceed with next key on first iteration or after async notification\n        function nextKey(): MaybePromise<boolean> {\n            while (true) {\n                const n = keyIterator.next();\n                if (n.done) {\n                    return mayHaveMutated;\n                }\n\n                const name = n.value;\n\n                // Eventing here is relatively expensive because we need deep clones and will trigger another pre-commit\n                // cycle across all participants.  So we only process properties that are observed\n                const event = events?.[`${name}$Changing`];\n                if (!event?.isObserved) {\n                    continue;\n                }\n\n                const change = computePreCommitChange(name);\n                if (change) {\n                    // The pre-commit cycle will need to re-run\n                    mayHaveMutated = true;\n\n                    // Notify observers\n                    const result = event.emit(change.newValue, change.oldValue, session);\n\n                    // For pre-commit we run observers serially.  If the observer is async then we continue the loop\n                    // after the observer completes\n                    if (MaybePromise.is(result)) {\n                        return result.then(nextKey);\n                    }\n                }\n            }\n        }\n\n        return nextKey();\n    }\n\n    // In \"changed\" state, values !== data.values, but here we identify logical changes on a per-property basis.  For\n    // each change we record the \"changed\" event to trigger and collect those we must persist\n    function computePostCommitChanges() {\n        changes = undefined;\n\n        if (internals.values === values) {\n            return changes;\n        }\n\n        for (const name in values) {\n            const newval = values[name];\n            const oldval = internals.values[name];\n            if (oldval !== newval && !isDeepEqual(newval, oldval)) {\n                if (!changes) {\n                    changes = { notifications: [] };\n                }\n\n                if (persistentFields.has(name)) {\n                    if (changes.persistent === undefined) {\n                        changes.persistent = {};\n                    }\n                    changes.persistent[name] = values[name];\n                }\n\n                const event = internals.events?.[`${name}$Changed`];\n                if (event?.isObserved) {\n                    changes.notifications.push({\n                        event,\n                        params: [values[name], internals.values[name], session],\n                    });\n                }\n            }\n        }\n\n        // Increment version if necessary\n        if (changes) {\n            // We don't revert the version number on rollback.  Should be OK\n            incrementVersion();\n        }\n    }\n\n    /**\n     * For commit phase one we pass values to the persistence layer if present.\n     */\n    function commit1() {\n        computePostCommitChanges();\n\n        // No phase one commit if there are no persistent changes\n        const persistent = changes?.persistent;\n        if (!persistent) {\n            return;\n        }\n\n        return internals.store?.set(session.transaction, persistent);\n    }\n\n    /**\n     * For commit phase two we make the working values canonical and notify listeners.\n     */\n    function commit2() {\n        if (!changes) {\n            return;\n        }\n\n        const oldValues = internals.values;\n        internals.values = values;\n        if (internals.sessions) {\n            for (const context of internals.sessions.values()) {\n                context.onChange(oldValues);\n            }\n        }\n\n        if (session.trace && changes.persistent) {\n            let mutations = session.trace.mutations;\n            if (!mutations) {\n                mutations = session.trace.mutations = [];\n            }\n            mutations.push({\n                path: internals.path,\n                values: changes.persistent,\n            });\n        }\n    }\n\n    /**\n     * Post-commit logic.  Emit \"changed\" events.  Observers may be synchronous or asynchronous.\n     */\n    function postCommit() {\n        if (!changes || !internals.events) {\n            return;\n        }\n\n        // Emit is optionally async so we must iterate manually\n        const iterator = changes.notifications[Symbol.iterator]();\n\n        function emitChanged(): MaybePromise<void> {\n            while (true) {\n                const n = iterator.next();\n                if (n.done) {\n                    return;\n                }\n\n                const { event, params } = n.value;\n                const result = event.emit(...params);\n                if (MaybePromise.is(result)) {\n                    return Promise.resolve(result).then(emitChanged);\n                }\n            }\n        }\n\n        return emitChanged();\n    }\n\n    /**\n     * On rollback with just replace values and version with the canonical versions.\n     */\n    function rollback() {\n        ({ values } = internals);\n        refreshSubrefs();\n    }\n}\n"],
  "mappings": "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",
  "names": ["context"]
}
