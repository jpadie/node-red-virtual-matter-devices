{
  "version": 3,
  "sources": ["../../../../../../src/behavior/state/managed/values/BitmapManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DataModelPath } from \"../../../../model/definitions/DataModelPath.js\";\nimport { ValueModel } from \"../../../../model/models/ValueModel.js\";\nimport { FeatureMap } from \"../../../../model/standard/elements/FeatureMap.js\";\nimport { GeneratedClass } from \"../../../../util/GeneratedClass.js\";\nimport { camelize } from \"../../../../util/String.js\";\nimport { isObject } from \"../../../../util/Type.js\";\nimport { ConstraintError, PhantomReferenceError, SchemaImplementationError } from \"../../../errors.js\";\nimport { RootSupervisor } from \"../../../supervision/RootSupervisor.js\";\nimport { Schema } from \"../../../supervision/Schema.js\";\nimport { ValueSupervisor } from \"../../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../../Val.js\";\nimport { assertBoolean, assertNumber } from \"../../validation/assertions.js\";\nimport { Instrumentation } from \"../Instrumentation.js\";\nimport { Internal } from \"../Internal.js\";\n\nconst SESSION = Symbol(\"options\");\n\ninterface Wrapper extends Val.Struct, Internal.Collection {\n    /**\n     * A reference to the raw value.\n     */\n    [Internal.reference]: Val.Reference<Val.Struct>;\n\n    /**\n     * Information regarding the current user session.\n     */\n    [SESSION]: ValueSupervisor.Session;\n}\n\n/**\n * For bitmaps we generate a class with accessors for each bitmap value or range.\n */\nexport function BitmapManager(_owner: RootSupervisor, schema: Schema): ValueSupervisor.Manage {\n    const instanceDescriptors = {} as PropertyDescriptorMap;\n\n    const byteSize = (schema as ValueModel).metabase?.byteSize;\n    if (byteSize === undefined) {\n        throw new SchemaImplementationError(DataModelPath(schema.path), `Base bitmap type has no byteSize defined`);\n    }\n    const maxBit = byteSize * 8;\n\n    for (const member of schema.activeMembers) {\n        if (member.isDeprecated) {\n            continue;\n        }\n\n        let name;\n        if (schema.id === FeatureMap.id) {\n            // We require special casing for feature maps because the spec code uses \"feature\" field from spec as name\n            // and model uses \"code\".  The model should probably be inverted but we just special case for now\n            name = camelize(member.description ?? member.name);\n        } else {\n            name = camelize(member.name);\n        }\n\n        const descriptor = configureProperty(name, maxBit, member);\n\n        instanceDescriptors[name] = descriptor;\n    }\n\n    const Wrapper = GeneratedClass({\n        name: schema.name,\n\n        initialize(this: Wrapper, ref: Val.Reference<Val.Struct>, session: ValueSupervisor.Session) {\n            // Only objects are acceptable\n            if (!isObject(ref.value)) {\n                throw new SchemaImplementationError(\n                    ref.location,\n                    `Cannot manage ${typeof ref.value} because it is not a bitmap object`,\n                );\n            }\n\n            Object.defineProperties(this, {\n                [Internal.reference]: {\n                    value: ref,\n                },\n                [SESSION]: {\n                    value: session,\n                },\n            });\n\n            Object.defineProperties(this, instanceDescriptors);\n        },\n    });\n\n    Instrumentation.instrumentStruct(Wrapper);\n\n    return (reference, session) => {\n        reference.owner = new Wrapper(reference, session);\n        return reference.owner;\n    };\n}\n\nfunction configureProperty(name: string, maxBit: number, schema: ValueModel) {\n    const constraint = schema.effectiveConstraint;\n\n    let startBit: number, stopBit: number;\n    if (typeof constraint.value === \"number\") {\n        startBit = constraint.value;\n        stopBit = startBit + 1;\n    } else if (typeof constraint.min === \"number\" && typeof constraint.max === \"number\") {\n        startBit = constraint.min;\n        stopBit = constraint.max;\n\n        if (startBit > stopBit) {\n            const temp = startBit;\n            startBit = stopBit;\n            stopBit = temp;\n        }\n    } else {\n        throw new SchemaImplementationError(DataModelPath(schema.path), `Bitfield is not properly constrained`);\n    }\n\n    if (stopBit > maxBit) {\n        throw new SchemaImplementationError(\n            DataModelPath(schema.path),\n            `Bitfield range end ${stopBit} is too large for a ${maxBit}-bit bitmap`,\n        );\n    }\n\n    const max = 1 << (stopBit - startBit);\n\n    if (max === 2) {\n        return {\n            enumerable: true,\n\n            get(this: Wrapper) {\n                const bits = this[Internal.reference].value;\n                if (bits === undefined) {\n                    throw new PhantomReferenceError(this[Internal.reference].location);\n                }\n                return !!bits[name];\n            },\n\n            set(this: Wrapper, value: Val) {\n                const ref = this[Internal.reference];\n\n                if (value !== undefined) {\n                    assertBoolean(value, ref.location.path);\n                }\n\n                ref.change(() => {\n                    const bits = ref.value;\n                    if (bits === undefined) {\n                        throw new PhantomReferenceError(this[Internal.reference].location);\n                    }\n                    bits[name] = !!value;\n                });\n            },\n        };\n    }\n\n    return {\n        enumerable: true,\n\n        get(this: Wrapper) {\n            const bits = this[Internal.reference].value;\n            if (bits === undefined) {\n                throw new PhantomReferenceError(this[Internal.reference].location);\n            }\n            return bits[name];\n        },\n\n        set(this: Wrapper, value: Val) {\n            const ref = this[Internal.reference];\n\n            if (value !== undefined) {\n                assertNumber(value, ref.location.path);\n\n                if (value >= max) {\n                    throw new ConstraintError(\n                        schema,\n                        this[Internal.reference].location,\n                        `Value ${value} is too large for bitfield`,\n                    );\n                } else if (value < 0) {\n                    throw new ConstraintError(\n                        schema,\n                        this[Internal.reference].location,\n                        `Illegal negative value ${value} for bitfield`,\n                    );\n                }\n            }\n\n            ref.change(() => {\n                const bits = ref.value;\n                if (bits === undefined) {\n                    throw new PhantomReferenceError(this[Internal.reference].location);\n                }\n                bits[name] = value ? value : 0;\n            });\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
