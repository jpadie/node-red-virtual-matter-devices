{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/validation/conformance-compiler.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DataModelPath } from \"../../../model/definitions/DataModelPath.js\";\nimport { Conformance, FeatureSet, FieldValue, Metatype, ValueModel } from \"../../../model/index.js\";\nimport { camelize } from \"../../../util/String.js\";\nimport { AccessControl } from \"../../AccessControl.js\";\nimport { ConformanceError, SchemaImplementationError } from \"../../errors.js\";\nimport { Schema } from \"../../supervision/Schema.js\";\nimport { ValueSupervisor } from \"../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../Val.js\";\nimport {\n    Code,\n    ConformantNode,\n    DynamicNode,\n    EnumMemberValidator,\n    NonconformantNode,\n    StaticNode,\n    UnsupportedConformanceNodeError,\n    asBoolean,\n    asConformance,\n    createBooleanTest,\n    createComparison,\n    createLogicalBinaryEvaluator,\n    createLogicalInversion,\n    evaluateNode,\n    isStatic,\n    type RuntimeNode,\n} from \"./conformance-util.js\";\nimport { ValidationLocation } from \"./location.js\";\n\n/**\n * Generates JS function equivalent of a conformance expression.\n *\n * We generate a function for each node in the AST.  In addition to the function, we track whether the function\n * evaluates pure-feature conformance (vs. an expression).\n *\n * In general the conformance AST jumbles set logic with expression evaluation so we need to track two types of state to\n * implement properly.\n *\n * Many of the comments reference \"static\" vs \"runtime\" evaluation.  This is an important distinction that we use to\n * heavily optimize the generated function:\n *\n *   - \"static\" means conformance is known at compile time and runtime evaluation is thus minimal.  These result in a\n *     {@link StaticNode}.\n *\n *   - \"runtime\" means conformance depends on sibling fields in an object. These result in a {@link RuntimeNode} with\n *     additional logic that applies to operational state.\n */\nexport function astToFunction(\n    schema: ValueModel,\n    featureMap: ValueModel,\n    supportedFeatures: FeatureSet,\n): ValueSupervisor.Validate | undefined {\n    const ast = schema.conformance.ast;\n    const { featuresAvailable, featuresSupported } = FeatureSet.normalize(featureMap, supportedFeatures);\n\n    // Compile the AST\n    const compiledNode = compile(ast);\n\n    let validator: ValueSupervisor.Validate | undefined;\n\n    // The compiled AST is a DynamicNode describing how to test a field for conformance.  Convert this into a validation\n    // function\n    switch (compiledNode.code) {\n        case Code.Conformant:\n            // Passes validation if the field is present\n            validator = requireValue;\n            break;\n\n        case Code.Nonconformant:\n        case Code.Disallowed:\n            // Passes validation if the field is not present\n            validator = disallowValue;\n            break;\n\n        case Code.Optional:\n            // No conformance validation required\n            break;\n\n        case Code.Evaluate:\n            // We must perform runtime evaluation to determine whether the field is conformant\n            const { evaluate } = compiledNode;\n\n            validator = (value, session, location) => {\n                const staticNode = evaluate(value, location);\n\n                switch (staticNode.code) {\n                    case Code.Conformant:\n                        requireValue(value, session, location);\n                        break;\n\n                    case Code.Nonconformant:\n                    case Code.Disallowed:\n                        disallowValue(value, session, location);\n                        break;\n\n                    case Code.Optional:\n                        break;\n\n                    case Code.Value:\n                        if (staticNode.value === undefined) {\n                            disallowValue(value, session, location);\n                        } else {\n                            requireValue(value, session, location);\n                        }\n                        break;\n\n                    default:\n                        throw new UnsupportedConformanceNodeError(schema, compiledNode);\n                }\n            };\n            break;\n\n        default:\n            throw new UnsupportedConformanceNodeError(schema, compiledNode);\n    }\n\n    if (validator !== disallowValue && schema.effectiveMetatype === Metatype.enum) {\n        validator = addEnumMemberValidation(validator);\n    }\n\n    return validator;\n\n    /**\n     * Convert an AST node into a DynamicNode.\n     *\n     * If the node requires runtime evaluation it will be a RuntimeNode, which is a proxy that creates a StaticNode for\n     * a specific record.\n     *\n     * Runtime evaluation is required if the conformance expression has a choice or cross-references other properties of\n     * the same object.\n     *\n     * Otherwise the node is a StaticNode.\n     */\n    function compile(ast: Conformance.Ast): DynamicNode {\n        switch (ast?.type) {\n            case Conformance.Special.Empty:\n            case Conformance.Special.Desc:\n            case Conformance.Flag.Provisional:\n            case Conformance.Flag.Deprecated:\n            case Conformance.Flag.Optional:\n                // Alone these all effectively map to \"optional\" and thus result in no test as all values are acceptable\n                return { code: Code.Optional };\n\n            case Conformance.Special.Choice:\n                return createChoice(ast.param);\n\n            case Conformance.Special.Group:\n                return createGroup(ast.param);\n\n            case Conformance.Special.Name:\n                return createName(ast.param);\n\n            case Conformance.Special.OptionalIf:\n                return createOptionalIf(ast.param);\n\n            case Conformance.Special.Value:\n                return createValue(ast.param);\n\n            case Conformance.Flag.Disallowed:\n                return createDisallowed();\n\n            case Conformance.Flag.Mandatory:\n                return createMandatory();\n\n            case Conformance.Operator.AND:\n            case Conformance.Operator.OR:\n            case Conformance.Operator.XOR:\n                return createLogicalBinaryOp(ast.type, ast.param);\n\n            case Conformance.Operator.EQ:\n            case Conformance.Operator.NE:\n            case Conformance.Operator.GT:\n            case Conformance.Operator.LT:\n            case Conformance.Operator.GTE:\n            case Conformance.Operator.LTE:\n                return createComparisonOp(ast.type, ast.param);\n\n            case Conformance.Operator.NOT:\n                return createNotOp(ast.param);\n\n            default:\n                // Fail at compile time if list is not exhaustive\n                ast satisfies never;\n\n                // Throw at runtime\n                throw new SchemaImplementationError(\n                    DataModelPath(schema.path),\n                    `Unsupported conformance AST node type ${(ast as any).type}`,\n                );\n        }\n    }\n\n    /**\n     * A \"choice\" is an AST node such as \"O.a\".\n     *\n     * Choice conformance is only relevant when validating multiple properties on the same cluster or struct.\n     *\n     * Compiling a choice always results in a RuntimeNode that updates the count in options.choice.  If a property is\n     * validated individually then choice is irrelevant and the node does not affect conformance.\n     */\n    function createChoice(param: Conformance.Ast.Choice): DynamicNode {\n        const compiled = compile(param.expr);\n\n        const name = param.name;\n        const template: ValidationLocation.Choice = {\n            count: 0,\n            target: param.num,\n            orMore: !!param.orMore,\n        };\n\n        return {\n            code: Code.Evaluate,\n\n            evaluate: (value, options) => {\n                // Update choice definitions.  This is supplied by the struct validator.  If we're only validating a\n                // single field then choices aren't available so the choice is ignored\n                const choices = options?.choices;\n                let choice;\n                if (choices) {\n                    choice = choices[name];\n                    if (!choice) {\n                        choice = choices[name] = { ...template };\n                    }\n                    if (value !== undefined) {\n                        choice.count++;\n                    }\n                }\n\n                // The status of the subexpression is not relevant for the choice.  If conformance fails then it doesn't\n                // matter if we count the choice or not\n                return evaluateNode(compiled, value, options);\n            },\n        };\n    }\n\n    /**\n     * A \"group\" node is a list or the entries in an optional ([ ... ]) clause. The resulting node is the value of the\n     * first list member that does not report as Code.Nonconformant.\n     */\n    function createGroup(param: Conformance.Ast.Group): DynamicNode {\n        if (!Array.isArray(param)) {\n            throw new SchemaImplementationError(\n                DataModelPath(schema.path),\n                \"Conformance AST group parameter is not an array\",\n            );\n        }\n\n        // A \"group\" is a list of conformances; any success passes the entire group and subsequent tests are not\n        // evaluated\n        const members = param.map(test => compile(test));\n\n        // Reduce tests that must be evaluated at runtime vs. compile time\n        const reduced = Array<DynamicNode>();\n        for (const member of members) {\n            // Nonconformant - ignore\n            if (member.code === Code.Nonconformant) {\n                continue;\n            }\n\n            // Optional & required - no need to evaluate subsequent nodes\n            if (member.code === Code.Optional || member.code === Code.Conformant) {\n                // Runtime evaluation; this will be the final result\n                if (reduced.length) {\n                    reduced.push(member);\n                    break;\n                }\n\n                // No need to runtime evaluation\n                return member;\n            }\n\n            // Evaluate - remains in list and requires evaluation at runtime\n            reduced.push(member);\n        }\n\n        // We must further reduce at runtime\n        return {\n            code: Code.Evaluate,\n\n            evaluate: (value, options) => {\n                for (const member of reduced) {\n                    const node = evaluateNode(member, value, options);\n                    if (node.code !== Code.Nonconformant) {\n                        return node;\n                    }\n                }\n                return NonconformantNode;\n            },\n        };\n    }\n\n    /**\n     * A name references a feature or the name of a sibling property on the containing object.  We treat the name as a\n     * feature if the name is present in featuresAvailable.\n     *\n     * For features, conformance is known at compile time so the resuling node is a StaticNode.\n     *\n     * For property names, we need to load the corresponding value at runtime. This results in a RuntimeNode that\n     * retrieves the value from options.siblings.\n     */\n    function createName(param: string): DynamicNode {\n        if (featuresAvailable.has(param)) {\n            // Name references a feature.  We know whether features are supported by a cluster at compile time so this\n            // results in a static node that is conformant iff the feature is supported\n            if (featuresSupported.has(param)) {\n                return ConformantNode;\n            } else {\n                return NonconformantNode;\n            }\n        } else {\n            // Name references a sibling property.  This results in a value node but must be evaluated at runtime\n            // against a specific struct\n            param = camelize(param);\n            return {\n                code: Code.Evaluate,\n\n                evaluate: (_value, options) => {\n                    return {\n                        code: Code.Value,\n                        value: options?.siblings?.[param],\n                    };\n                },\n            };\n        }\n    }\n\n    /**\n     * Compile an \"optional if\" node.  This converts conformant nodes into optional nodes and otherwise leaves the node\n     * unchanged.\n     *\n     * This represents a conformance expression surrounded by brackets such as [ FOO, BAR ].  We first evaluate the\n     * internal expression which may happen statically or at runtime.  Then we convert conformant nodes to optional.\n     */\n    function createOptionalIf(param: Conformance.Ast): DynamicNode {\n        let node = compile(param) ?? {};\n        node = asConformance(node);\n\n        switch (node.code) {\n            case Code.Conformant:\n                return { code: Code.Optional };\n\n            case Code.Evaluate:\n                const evaluate = node.evaluate;\n                return {\n                    code: Code.Evaluate,\n\n                    evaluate: (value, options) => {\n                        let staticNode = evaluate(value, options);\n                        staticNode = asConformance(staticNode);\n\n                        if (staticNode.code === Code.Conformant) {\n                            return { code: Code.Optional };\n                        }\n\n                        return staticNode;\n                    },\n                };\n\n            default:\n                return node;\n        }\n    }\n\n    /**\n     * A value node represents is static literal value.  This is how we encode numeric literals used in expressions.\n     */\n    function createValue(param: FieldValue): DynamicNode {\n        return {\n            code: Code.Value,\n            value: param,\n        };\n    }\n\n    /**\n     * \"Disallowed\" represents \"X\" in a conformance expression which explicitly disallows the property.\n     */\n    function createDisallowed(): StaticNode {\n        return {\n            code: Code.Disallowed,\n        };\n    }\n\n    /**\n     * \"Mandatory\" is a conformance \"M\" and maps explicitly to conformant.\n     *\n     * This means that we will convert [ M ] to optional but that's a pretty silly construct that the spec doesn't use.\n     * Otherwise the field will be required.\n     */\n    function createMandatory(): DynamicNode {\n        return ConformantNode;\n    }\n\n    /**\n     * A logical binary operator is an expression that compares two values using a logical operator.  So e.g. \"LF | TL\".\n     *\n     * These operators work on conformance values.  Effectively casts non-binary field values to booleans where\n     * undefined = false/nonconformant and defined = true/conformant.\n     *\n     * This code is rather long because we unroll each operator by hand depending on whether the operators may be\n     * evaluated statically or not. This makes sense because we can avoid most runtime computations for common cases\n     * such as the \"LF | TL\" example.\n     */\n    function createLogicalBinaryOp(\n        operator: Conformance.Operator,\n        { lhs, rhs }: Conformance.Ast.BinaryOperands,\n    ): DynamicNode {\n        const compiledLhs = createBooleanTest(compile(lhs));\n        const compiledRhs = createBooleanTest(compile(rhs));\n\n        switch (operator) {\n            case Conformance.Operator.AND:\n                // Static LHS\n                if (isStatic(compiledLhs)) {\n                    if (asBoolean(compiledLhs)) {\n                        return compiledRhs;\n                    } else {\n                        return NonconformantNode;\n                    }\n                }\n\n                // Dynamic LHS, static RHS\n                if (isStatic(compiledRhs)) {\n                    if (asBoolean(compiledRhs)) {\n                        return compiledLhs;\n                    } else {\n                        return NonconformantNode;\n                    }\n                }\n\n                // Both sides dynamic\n                return createLogicalBinaryEvaluator(compiledLhs, compiledRhs, (lhs, rhs) => lhs && rhs);\n\n            case Conformance.Operator.OR:\n                // Static LHS\n                if (isStatic(compiledLhs)) {\n                    if (asBoolean(compiledLhs)) {\n                        return ConformantNode;\n                    } else {\n                        return compiledRhs;\n                    }\n                }\n\n                // Dynamic LHS, static RHS\n                if (isStatic(compiledRhs)) {\n                    if (asBoolean(compiledRhs)) {\n                        return ConformantNode;\n                    } else {\n                        return compiledLhs;\n                    }\n                }\n\n                // Both sides dynamic\n                return createLogicalBinaryEvaluator(compiledLhs, compiledRhs, (lhs, rhs) => lhs || rhs);\n\n            case Conformance.Operator.XOR:\n                // Static LHS\n                if (isStatic(compiledLhs)) {\n                    if (asBoolean(compiledLhs)) {\n                        return createLogicalInversion(compiledRhs);\n                    } else {\n                        return compiledRhs;\n                    }\n                }\n\n                // Dynamic LHS, static RHS\n                if (isStatic(compiledRhs)) {\n                    if (asBoolean(compiledRhs)) {\n                        return createLogicalInversion(compiledLhs);\n                    } else {\n                        return compiledLhs;\n                    }\n                }\n\n                // Both sides dynamic\n                return createLogicalBinaryEvaluator(compiledLhs, compiledRhs, (lhs, rhs) => (lhs ? !rhs : rhs));\n\n            default:\n                throw new SchemaImplementationError(\n                    DataModelPath(schema.path),\n                    `Unknown logical binary operator ${operator}`,\n                );\n        }\n    }\n\n    /**\n     * A comparison operator compares two values.  So e.g. \"FieldName > 4\".\n     *\n     * Throws an error if the input AST nodes are not values.  We could convert conformance to a binary 0 or 1 but this\n     * does not have real-world applicability and would only occur for malformed conformance.\n     */\n    function createComparisonOp(\n        operator: Conformance.Operator,\n        { lhs, rhs }: Conformance.Ast.BinaryOperands,\n    ): DynamicNode {\n        return createComparison(operator, compile(lhs), compile(rhs), schema);\n    }\n\n    /**\n     * Inverts the meaning of conformance.  A conformant node becomes non-conformant and vice-versa.\n     */\n    function createNotOp(param: Conformance.Ast): DynamicNode {\n        const operand = compile(param);\n        return createLogicalInversion(operand);\n    }\n\n    function requireValue(value: Val, _session: AccessControl.Session, location: ValidationLocation) {\n        if (value === undefined) {\n            throw new ConformanceError(schema, location, \"Matter requires you to set this attribute\");\n        }\n    }\n\n    function disallowValue(value: Val, _session: AccessControl.Session, location: ValidationLocation) {\n        if (value !== undefined) {\n            throw new ConformanceError(schema, location, \"Matter does not allow you to set this attribute\");\n        }\n    }\n\n    function disallowEnumValue(schema: Schema): EnumMemberValidator {\n        return location => {\n            throw new ConformanceError(\n                schema,\n                location,\n                `Matter does not allow enum value ${schema.name} (ID ${schema.effectiveId}) here`,\n            );\n        };\n    }\n\n    /**\n     * Extends the \"main\" validator (conformance on the field itself) with member validation (validation of specific\n     * values).\n     */\n    function addEnumMemberValidation(\n        mainValidator: ValueSupervisor.Validate | undefined,\n    ): ValueSupervisor.Validate | undefined {\n        // If there are no members we can't enforce anything\n        const members = schema.activeMembers;\n        if (!members.length) {\n            return mainValidator;\n        }\n\n        // Create a validator for each member with conformance.  If the member is not constrained then we perform no\n        // special validation for it\n        let memberValidators: undefined | Record<number, EnumMemberValidator>;\n        for (const member of members) {\n            // If there's no ID the schema is invalid so just skip\n            const id = member.effectiveId;\n            if (id === undefined) {\n                continue;\n            }\n\n            const compiledNode = compile(member.conformance.ast);\n\n            let memberValidator: undefined | EnumMemberValidator;\n            switch (compiledNode.code) {\n                case Code.Conformant:\n                case Code.Optional:\n                    // There's nothing to enforce here\n                    continue;\n\n                case Code.Nonconformant:\n                case Code.Disallowed:\n                    // If this member is selected it's an error\n                    memberValidator = disallowEnumValue(member);\n                    break;\n\n                case Code.Evaluate:\n                    // Requires runtime evaluation\n                    const { evaluate } = compiledNode;\n\n                    const disallow = disallowEnumValue(member);\n\n                    memberValidator = location => {\n                        // Note that we don't need the value here as it is constant so just use \"true\" indicating the\n                        // value is present\n                        const staticNode = evaluate(true, location);\n\n                        switch (staticNode.code) {\n                            case Code.Conformant:\n                            case Code.Optional:\n                                // Acceptable\n                                break;\n\n                            case Code.Nonconformant:\n                            case Code.Disallowed:\n                                // Unacceptable; throw an error\n                                disallow(location);\n                                break;\n\n                            default:\n                                throw new UnsupportedConformanceNodeError(member, compiledNode);\n                        }\n                    };\n                    break;\n\n                default:\n                    throw new UnsupportedConformanceNodeError(member, compiledNode);\n            }\n\n            if (!memberValidators) {\n                memberValidators = {};\n            }\n\n            memberValidators[id] = memberValidator;\n        }\n\n        // If we did not find members with conformance that requires enforcement then just return the main validator\n        if (memberValidators === undefined) {\n            return mainValidator;\n        }\n\n        // Extend the main validator with member validation\n        return (value, session, location) => {\n            mainValidator?.(value, session, location);\n\n            if (typeof value === \"number\") {\n                // Invoke the member validator if one exists for the selected value\n                memberValidators[value]?.(location);\n            }\n        };\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,qBAAqB;AAC9B,SAAS,aAAa,YAAwB,gBAA4B;AAC1E,SAAS,gBAAgB;AAEzB,SAAS,kBAAkB,iCAAiC;AAI5D;AAAA,EACI;AAAA,EACA;AAAA,EAGA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OAEG;AAqBA,SAAS,cACZ,QACA,YACA,mBACoC;AACpC,QAAM,MAAM,OAAO,YAAY;AAC/B,QAAM,EAAE,mBAAmB,kBAAkB,IAAI,WAAW,UAAU,YAAY,iBAAiB;AAGnG,QAAM,eAAe,QAAQ,GAAG;AAEhC,MAAI;AAIJ,UAAQ,aAAa,MAAM;AAAA,IACvB,KAAK,KAAK;AAEN,kBAAY;AACZ;AAAA,IAEJ,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAEN,kBAAY;AACZ;AAAA,IAEJ,KAAK,KAAK;AAEN;AAAA,IAEJ,KAAK,KAAK;AAEN,YAAM,EAAE,SAAS,IAAI;AAErB,kBAAY,CAAC,OAAO,SAAS,aAAa;AACtC,cAAM,aAAa,SAAS,OAAO,QAAQ;AAE3C,gBAAQ,WAAW,MAAM;AAAA,UACrB,KAAK,KAAK;AACN,yBAAa,OAAO,SAAS,QAAQ;AACrC;AAAA,UAEJ,KAAK,KAAK;AAAA,UACV,KAAK,KAAK;AACN,0BAAc,OAAO,SAAS,QAAQ;AACtC;AAAA,UAEJ,KAAK,KAAK;AACN;AAAA,UAEJ,KAAK,KAAK;AACN,gBAAI,WAAW,UAAU,QAAW;AAChC,4BAAc,OAAO,SAAS,QAAQ;AAAA,YAC1C,OAAO;AACH,2BAAa,OAAO,SAAS,QAAQ;AAAA,YACzC;AACA;AAAA,UAEJ;AACI,kBAAM,IAAI,gCAAgC,QAAQ,YAAY;AAAA,QACtE;AAAA,MACJ;AACA;AAAA,IAEJ;AACI,YAAM,IAAI,gCAAgC,QAAQ,YAAY;AAAA,EACtE;AAEA,MAAI,cAAc,iBAAiB,OAAO,sBAAsB,SAAS,MAAM;AAC3E,gBAAY,wBAAwB,SAAS;AAAA,EACjD;AAEA,SAAO;AAaP,WAAS,QAAQA,MAAmC;AAChD,YAAQA,MAAK,MAAM;AAAA,MACf,KAAK,YAAY,QAAQ;AAAA,MACzB,KAAK,YAAY,QAAQ;AAAA,MACzB,KAAK,YAAY,KAAK;AAAA,MACtB,KAAK,YAAY,KAAK;AAAA,MACtB,KAAK,YAAY,KAAK;AAElB,eAAO,EAAE,MAAM,KAAK,SAAS;AAAA,MAEjC,KAAK,YAAY,QAAQ;AACrB,eAAO,aAAaA,KAAI,KAAK;AAAA,MAEjC,KAAK,YAAY,QAAQ;AACrB,eAAO,YAAYA,KAAI,KAAK;AAAA,MAEhC,KAAK,YAAY,QAAQ;AACrB,eAAO,WAAWA,KAAI,KAAK;AAAA,MAE/B,KAAK,YAAY,QAAQ;AACrB,eAAO,iBAAiBA,KAAI,KAAK;AAAA,MAErC,KAAK,YAAY,QAAQ;AACrB,eAAO,YAAYA,KAAI,KAAK;AAAA,MAEhC,KAAK,YAAY,KAAK;AAClB,eAAO,iBAAiB;AAAA,MAE5B,KAAK,YAAY,KAAK;AAClB,eAAO,gBAAgB;AAAA,MAE3B,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AACtB,eAAO,sBAAsBA,KAAI,MAAMA,KAAI,KAAK;AAAA,MAEpD,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AAAA,MAC1B,KAAK,YAAY,SAAS;AACtB,eAAO,mBAAmBA,KAAI,MAAMA,KAAI,KAAK;AAAA,MAEjD,KAAK,YAAY,SAAS;AACtB,eAAO,YAAYA,KAAI,KAAK;AAAA,MAEhC;AAEI,QAAAA;AAGA,cAAM,IAAI;AAAA,UACN,cAAc,OAAO,IAAI;AAAA,UACzB,yCAA0CA,KAAY,IAAI;AAAA,QAC9D;AAAA,IACR;AAAA,EACJ;AAUA,WAAS,aAAa,OAA4C;AAC9D,UAAM,WAAW,QAAQ,MAAM,IAAI;AAEnC,UAAM,OAAO,MAAM;AACnB,UAAM,WAAsC;AAAA,MACxC,OAAO;AAAA,MACP,QAAQ,MAAM;AAAA,MACd,QAAQ,CAAC,CAAC,MAAM;AAAA,IACpB;AAEA,WAAO;AAAA,MACH,MAAM,KAAK;AAAA,MAEX,UAAU,CAAC,OAAO,YAAY;AAG1B,cAAM,UAAU,SAAS;AACzB,YAAI;AACJ,YAAI,SAAS;AACT,mBAAS,QAAQ,IAAI;AACrB,cAAI,CAAC,QAAQ;AACT,qBAAS,QAAQ,IAAI,IAAI,EAAE,GAAG,SAAS;AAAA,UAC3C;AACA,cAAI,UAAU,QAAW;AACrB,mBAAO;AAAA,UACX;AAAA,QACJ;AAIA,eAAO,aAAa,UAAU,OAAO,OAAO;AAAA,MAChD;AAAA,IACJ;AAAA,EACJ;AAMA,WAAS,YAAY,OAA2C;AAC5D,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,YAAM,IAAI;AAAA,QACN,cAAc,OAAO,IAAI;AAAA,QACzB;AAAA,MACJ;AAAA,IACJ;AAIA,UAAM,UAAU,MAAM,IAAI,UAAQ,QAAQ,IAAI,CAAC;AAG/C,UAAM,UAAU,MAAmB;AACnC,eAAW,UAAU,SAAS;AAE1B,UAAI,OAAO,SAAS,KAAK,eAAe;AACpC;AAAA,MACJ;AAGA,UAAI,OAAO,SAAS,KAAK,YAAY,OAAO,SAAS,KAAK,YAAY;AAElE,YAAI,QAAQ,QAAQ;AAChB,kBAAQ,KAAK,MAAM;AACnB;AAAA,QACJ;AAGA,eAAO;AAAA,MACX;AAGA,cAAQ,KAAK,MAAM;AAAA,IACvB;AAGA,WAAO;AAAA,MACH,MAAM,KAAK;AAAA,MAEX,UAAU,CAAC,OAAO,YAAY;AAC1B,mBAAW,UAAU,SAAS;AAC1B,gBAAM,OAAO,aAAa,QAAQ,OAAO,OAAO;AAChD,cAAI,KAAK,SAAS,KAAK,eAAe;AAClC,mBAAO;AAAA,UACX;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAWA,WAAS,WAAW,OAA4B;AAC5C,QAAI,kBAAkB,IAAI,KAAK,GAAG;AAG9B,UAAI,kBAAkB,IAAI,KAAK,GAAG;AAC9B,eAAO;AAAA,MACX,OAAO;AACH,eAAO;AAAA,MACX;AAAA,IACJ,OAAO;AAGH,cAAQ,SAAS,KAAK;AACtB,aAAO;AAAA,QACH,MAAM,KAAK;AAAA,QAEX,UAAU,CAAC,QAAQ,YAAY;AAC3B,iBAAO;AAAA,YACH,MAAM,KAAK;AAAA,YACX,OAAO,SAAS,WAAW,KAAK;AAAA,UACpC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AASA,WAAS,iBAAiB,OAAqC;AAC3D,QAAI,OAAO,QAAQ,KAAK,KAAK,CAAC;AAC9B,WAAO,cAAc,IAAI;AAEzB,YAAQ,KAAK,MAAM;AAAA,MACf,KAAK,KAAK;AACN,eAAO,EAAE,MAAM,KAAK,SAAS;AAAA,MAEjC,KAAK,KAAK;AACN,cAAM,WAAW,KAAK;AACtB,eAAO;AAAA,UACH,MAAM,KAAK;AAAA,UAEX,UAAU,CAAC,OAAO,YAAY;AAC1B,gBAAI,aAAa,SAAS,OAAO,OAAO;AACxC,yBAAa,cAAc,UAAU;AAErC,gBAAI,WAAW,SAAS,KAAK,YAAY;AACrC,qBAAO,EAAE,MAAM,KAAK,SAAS;AAAA,YACjC;AAEA,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MAEJ;AACI,eAAO;AAAA,IACf;AAAA,EACJ;AAKA,WAAS,YAAY,OAAgC;AACjD,WAAO;AAAA,MACH,MAAM,KAAK;AAAA,MACX,OAAO;AAAA,IACX;AAAA,EACJ;AAKA,WAAS,mBAA+B;AACpC,WAAO;AAAA,MACH,MAAM,KAAK;AAAA,IACf;AAAA,EACJ;AAQA,WAAS,kBAA+B;AACpC,WAAO;AAAA,EACX;AAYA,WAAS,sBACL,UACA,EAAE,KAAK,IAAI,GACA;AACX,UAAM,cAAc,kBAAkB,QAAQ,GAAG,CAAC;AAClD,UAAM,cAAc,kBAAkB,QAAQ,GAAG,CAAC;AAElD,YAAQ,UAAU;AAAA,MACd,KAAK,YAAY,SAAS;AAEtB,YAAI,SAAS,WAAW,GAAG;AACvB,cAAI,UAAU,WAAW,GAAG;AACxB,mBAAO;AAAA,UACX,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,YAAI,SAAS,WAAW,GAAG;AACvB,cAAI,UAAU,WAAW,GAAG;AACxB,mBAAO;AAAA,UACX,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,eAAO,6BAA6B,aAAa,aAAa,CAACC,MAAKC,SAAQD,QAAOC,IAAG;AAAA,MAE1F,KAAK,YAAY,SAAS;AAEtB,YAAI,SAAS,WAAW,GAAG;AACvB,cAAI,UAAU,WAAW,GAAG;AACxB,mBAAO;AAAA,UACX,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,YAAI,SAAS,WAAW,GAAG;AACvB,cAAI,UAAU,WAAW,GAAG;AACxB,mBAAO;AAAA,UACX,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,eAAO,6BAA6B,aAAa,aAAa,CAACD,MAAKC,SAAQD,QAAOC,IAAG;AAAA,MAE1F,KAAK,YAAY,SAAS;AAEtB,YAAI,SAAS,WAAW,GAAG;AACvB,cAAI,UAAU,WAAW,GAAG;AACxB,mBAAO,uBAAuB,WAAW;AAAA,UAC7C,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,YAAI,SAAS,WAAW,GAAG;AACvB,cAAI,UAAU,WAAW,GAAG;AACxB,mBAAO,uBAAuB,WAAW;AAAA,UAC7C,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,eAAO,6BAA6B,aAAa,aAAa,CAACD,MAAKC,SAASD,OAAM,CAACC,OAAMA,IAAI;AAAA,MAElG;AACI,cAAM,IAAI;AAAA,UACN,cAAc,OAAO,IAAI;AAAA,UACzB,mCAAmC,QAAQ;AAAA,QAC/C;AAAA,IACR;AAAA,EACJ;AAQA,WAAS,mBACL,UACA,EAAE,KAAK,IAAI,GACA;AACX,WAAO,iBAAiB,UAAU,QAAQ,GAAG,GAAG,QAAQ,GAAG,GAAG,MAAM;AAAA,EACxE;AAKA,WAAS,YAAY,OAAqC;AACtD,UAAM,UAAU,QAAQ,KAAK;AAC7B,WAAO,uBAAuB,OAAO;AAAA,EACzC;AAEA,WAAS,aAAa,OAAY,UAAiC,UAA8B;AAC7F,QAAI,UAAU,QAAW;AACrB,YAAM,IAAI,iBAAiB,QAAQ,UAAU,2CAA2C;AAAA,IAC5F;AAAA,EACJ;AAEA,WAAS,cAAc,OAAY,UAAiC,UAA8B;AAC9F,QAAI,UAAU,QAAW;AACrB,YAAM,IAAI,iBAAiB,QAAQ,UAAU,iDAAiD;AAAA,IAClG;AAAA,EACJ;AAEA,WAAS,kBAAkBC,SAAqC;AAC5D,WAAO,cAAY;AACf,YAAM,IAAI;AAAA,QACNA;AAAA,QACA;AAAA,QACA,oCAAoCA,QAAO,IAAI,QAAQA,QAAO,WAAW;AAAA,MAC7E;AAAA,IACJ;AAAA,EACJ;AAMA,WAAS,wBACL,eACoC;AAEpC,UAAM,UAAU,OAAO;AACvB,QAAI,CAAC,QAAQ,QAAQ;AACjB,aAAO;AAAA,IACX;AAIA,QAAI;AACJ,eAAW,UAAU,SAAS;AAE1B,YAAM,KAAK,OAAO;AAClB,UAAI,OAAO,QAAW;AAClB;AAAA,MACJ;AAEA,YAAMC,gBAAe,QAAQ,OAAO,YAAY,GAAG;AAEnD,UAAI;AACJ,cAAQA,cAAa,MAAM;AAAA,QACvB,KAAK,KAAK;AAAA,QACV,KAAK,KAAK;AAEN;AAAA,QAEJ,KAAK,KAAK;AAAA,QACV,KAAK,KAAK;AAEN,4BAAkB,kBAAkB,MAAM;AAC1C;AAAA,QAEJ,KAAK,KAAK;AAEN,gBAAM,EAAE,SAAS,IAAIA;AAErB,gBAAM,WAAW,kBAAkB,MAAM;AAEzC,4BAAkB,cAAY;AAG1B,kBAAM,aAAa,SAAS,MAAM,QAAQ;AAE1C,oBAAQ,WAAW,MAAM;AAAA,cACrB,KAAK,KAAK;AAAA,cACV,KAAK,KAAK;AAEN;AAAA,cAEJ,KAAK,KAAK;AAAA,cACV,KAAK,KAAK;AAEN,yBAAS,QAAQ;AACjB;AAAA,cAEJ;AACI,sBAAM,IAAI,gCAAgC,QAAQA,aAAY;AAAA,YACtE;AAAA,UACJ;AACA;AAAA,QAEJ;AACI,gBAAM,IAAI,gCAAgC,QAAQA,aAAY;AAAA,MACtE;AAEA,UAAI,CAAC,kBAAkB;AACnB,2BAAmB,CAAC;AAAA,MACxB;AAEA,uBAAiB,EAAE,IAAI;AAAA,IAC3B;AAGA,QAAI,qBAAqB,QAAW;AAChC,aAAO;AAAA,IACX;AAGA,WAAO,CAAC,OAAO,SAAS,aAAa;AACjC,sBAAgB,OAAO,SAAS,QAAQ;AAExC,UAAI,OAAO,UAAU,UAAU;AAE3B,yBAAiB,KAAK,IAAI,QAAQ;AAAA,MACtC;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": ["ast", "lhs", "rhs", "schema", "compiledNode"]
}
