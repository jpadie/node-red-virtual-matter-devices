{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/general-commissioning/ServerNodeFailsafeContext.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FailsafeContext } from \"../../../common/FailsafeContext.js\";\nimport { Lifecycle, UnsupportedDependencyError } from \"../../../common/Lifecycle.js\";\nimport { Endpoint } from \"../../../endpoint/Endpoint.js\";\nimport { Fabric } from \"../../../fabric/Fabric.js\";\nimport { FabricManager } from \"../../../fabric/FabricManager.js\";\nimport { Node } from \"../../../node/Node.js\";\nimport { Immutable } from \"../../../util/Type.js\";\nimport { NetworkCommissioningBehavior } from \"../network-commissioning/NetworkCommissioningBehavior.js\";\n\n/**\n * {@link FailsafeContext} for {@link Node} API.\n */\nexport class ServerNodeFailsafeContext extends FailsafeContext {\n    #node: Node;\n    #storedState?: {\n        networks: Map<Endpoint, Immutable<NetworkCommissioningBehavior.State[\"networks\"]>>;\n        /*\n\n        When Fabrics are no longer managed centrally in FabricManager we need this. Maybe we change to this later,\n        but now it is just here for reference because these changes are realized by events that are triggered by Fabric\n        object changes. See also other commented out sections in this class.\n\n        nocs: OperationalCredentialsBehavior.State[\"nocs\"];\n        fabrics: OperationalCredentialsBehavior.State[\"fabrics\"];\n        trustedRootCertificates: OperationalCredentialsBehavior.State[\"trustedRootCertificates\"];\n\n         */\n    };\n\n    constructor(node: Node, options: FailsafeContext.Options) {\n        super(options);\n        this.#node = node;\n        this.#node.env.set(FailsafeContext, this);\n        this.construction.change.on(status => {\n            if (status === Lifecycle.Status.Destroyed) {\n                this.#node.env.delete(FailsafeContext, this);\n            }\n        });\n    }\n\n    /**\n     * Persist endpoint credentials and network configurations for restoration if commissioning does not complete.\n     *\n     * The Matter 1.2 specification makes it pretty clear that Matter supports configuration of multiple network\n     * interfaces (e.g. @see {@link MatterSpecification.v11.Core} \u00A7 11.8.8 and \u00A7 2.3.2).\n     * {@link NetworkCommissioningCluster} of the primary interface is on the root endpoint.  However it's not clear\n     * where {@link NetworkCommissioningCluster} instances for secondary interfaces reside.  To be on the safe side\n     * we just assume any endpoint may support {@link NetworkCommissioningCluster}.\n     *\n     * TODO - it's recommended to reset all state if commissioning bails; currently we perform mandatory restore\n     */\n    override async storeEndpointState() {\n        // const opcreds = this.#node.state.operationalCredentials;\n        this.#storedState = {\n            networks: new Map(),\n            /*\n            nocs: opcreds.nocs.map(noc => ({ ...noc })),\n            fabrics: opcreds.fabrics.map(fabric => ({ ...fabric })),\n            trustedRootCertificates: [...opcreds.trustedRootCertificates],\n             */\n        };\n\n        if (!this.#node.behaviors.has(NetworkCommissioningBehavior)) {\n            return;\n        }\n\n        this.#node.visit(endpoint => {\n            if (endpoint.behaviors.has(NetworkCommissioningBehavior)) {\n                this.#storedState?.networks.set(endpoint, endpoint.stateOf(NetworkCommissioningBehavior).networks);\n            }\n        });\n    }\n\n    override async restoreNetworkState() {\n        await this.#node.act(this.restoreNetworkState.name, async agent => {\n            const context = agent.context;\n\n            await this.#node.visit(async endpoint => {\n                const networks = this.#storedState?.networks.get(endpoint);\n                if (networks) {\n                    context.agentFor(endpoint).get(NetworkCommissioningBehavior).state.networks = [...networks];\n                }\n            });\n        });\n    }\n\n    override async revokeFabric(fabric: Fabric) {\n        await fabric.remove();\n\n        // await this.#restoreOperationalCredentials();\n    }\n\n    override async restoreBreadcrumb() {\n        await this.#node.act(this.restoreBreadcrumb.name, agent => {\n            agent.generalCommissioning.state.breadcrumb = 0;\n        });\n    }\n\n    override async rollback() {\n        if (!this.fabricIndex && this.hasRootCert) {\n            // Update the fabric details if needed (like Trusted Root certificates) Only if fabric was not added because\n            // else all data gets updated anyway\n            try {\n                const fabricManager = this.#node.env.get(FabricManager);\n                fabricManager.events.failsafeClosed.emit();\n            } catch (error) {\n                // UnsupportedDependencyError can happen when the node closes. Then data are refreshed on next start\n                // anyway, so ignore this case\n                UnsupportedDependencyError.accept(error);\n            }\n        }\n\n        return super.rollback();\n    }\n\n    /*\n    override async restoreFabric() {\n        await super.restoreFabric();\n        await this.#restoreOperationalCredentials();\n    }\n\n    async #restoreOperationalCredentials() {\n        if (this.#operationalCredentialsRestored) {\n            return;\n        }\n\n        const state = this.#storedState;\n        if (state) {\n            await this.#node.act(agent => {\n                const opcreds = agent.operationalCredentials.state;\n                opcreds.nocs = state.nocs;\n                opcreds.fabrics = state.fabrics;\n                opcreds.commissionedFabrics = opcreds.fabrics.length;\n                opcreds.trustedRootCertificates = state.trustedRootCertificates;\n            });\n        }\n\n        this.#operationalCredentialsRestored = true;\n    }\n    */\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,uBAAuB;AAChC,SAAS,WAAW,kCAAkC;AAGtD,SAAS,qBAAqB;AAG9B,SAAS,oCAAoC;AAKtC,MAAM,kCAAkC,gBAAgB;AAAA,EAC3D;AAAA,EACA;AAAA,EAeA,YAAY,MAAY,SAAkC;AACtD,UAAM,OAAO;AACb,SAAK,QAAQ;AACb,SAAK,MAAM,IAAI,IAAI,iBAAiB,IAAI;AACxC,SAAK,aAAa,OAAO,GAAG,YAAU;AAClC,UAAI,WAAW,UAAU,OAAO,WAAW;AACvC,aAAK,MAAM,IAAI,OAAO,iBAAiB,IAAI;AAAA,MAC/C;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAe,qBAAqB;AAEhC,SAAK,eAAe;AAAA,MAChB,UAAU,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMtB;AAEA,QAAI,CAAC,KAAK,MAAM,UAAU,IAAI,4BAA4B,GAAG;AACzD;AAAA,IACJ;AAEA,SAAK,MAAM,MAAM,cAAY;AACzB,UAAI,SAAS,UAAU,IAAI,4BAA4B,GAAG;AACtD,aAAK,cAAc,SAAS,IAAI,UAAU,SAAS,QAAQ,4BAA4B,EAAE,QAAQ;AAAA,MACrG;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAe,sBAAsB;AACjC,UAAM,KAAK,MAAM,IAAI,KAAK,oBAAoB,MAAM,OAAM,UAAS;AAC/D,YAAM,UAAU,MAAM;AAEtB,YAAM,KAAK,MAAM,MAAM,OAAM,aAAY;AACrC,cAAM,WAAW,KAAK,cAAc,SAAS,IAAI,QAAQ;AACzD,YAAI,UAAU;AACV,kBAAQ,SAAS,QAAQ,EAAE,IAAI,4BAA4B,EAAE,MAAM,WAAW,CAAC,GAAG,QAAQ;AAAA,QAC9F;AAAA,MACJ,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AAAA,EAEA,MAAe,aAAa,QAAgB;AACxC,UAAM,OAAO,OAAO;AAAA,EAGxB;AAAA,EAEA,MAAe,oBAAoB;AAC/B,UAAM,KAAK,MAAM,IAAI,KAAK,kBAAkB,MAAM,WAAS;AACvD,YAAM,qBAAqB,MAAM,aAAa;AAAA,IAClD,CAAC;AAAA,EACL;AAAA,EAEA,MAAe,WAAW;AACtB,QAAI,CAAC,KAAK,eAAe,KAAK,aAAa;AAGvC,UAAI;AACA,cAAM,gBAAgB,KAAK,MAAM,IAAI,IAAI,aAAa;AACtD,sBAAc,OAAO,eAAe,KAAK;AAAA,MAC7C,SAAS,OAAO;AAGZ,mCAA2B,OAAO,KAAK;AAAA,MAC3C;AAAA,IACJ;AAEA,WAAO,MAAM,SAAS;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BJ;",
  "names": []
}
