{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/descriptor/DescriptorServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Descriptor } from \"../../../cluster/definitions/DescriptorCluster.js\";\nimport { Semtag } from \"../../../cluster/globals/Semtag.js\";\nimport { ImplementationError } from \"../../../common/MatterError.js\";\nimport { ClusterId } from \"../../../datatype/ClusterId.js\";\nimport { DeviceTypeId } from \"../../../datatype/DeviceTypeId.js\";\nimport { EndpointNumber } from \"../../../datatype/EndpointNumber.js\";\nimport { Endpoint } from \"../../../endpoint/Endpoint.js\";\nimport { EndpointLifecycle } from \"../../../endpoint/properties/EndpointLifecycle.js\";\nimport { DeviceTypeModel, MatterModel } from \"../../../model/index.js\";\nimport { TypeFromSchema } from \"../../../tlv/TlvSchema.js\";\nimport { isDeepEqual } from \"../../../util/DeepEqual.js\";\nimport { IndexBehavior } from \"../../system/index/IndexBehavior.js\";\nimport { DescriptorBehavior } from \"./DescriptorBehavior.js\";\n\n/**\n * This is the default server implementation of DescriptorBehavior.\n */\nexport class DescriptorServer extends DescriptorBehavior {\n    static override dependencies = [IndexBehavior];\n\n    override async initialize() {\n        // We update PartsList differently if there's an index\n        if (this.endpoint.behaviors.has(IndexBehavior)) {\n            // Note - do not use lock here because this reactor triggers frequently so it pollutes the logs.  Instead\n            // lock manually as necessary\n            this.reactTo(this.agent.get(IndexBehavior).events.change, this.#updatePartsList);\n        } else if (this.endpoint.hasParts) {\n            for (const endpoint of this.endpoint.parts) {\n                this.#monitorDestruction(endpoint);\n            }\n        }\n        await this.#updatePartsList();\n\n        // Handle lifecycle changes\n        this.reactTo(this.endpoint.lifecycle.changed, this.#updateDescriptor);\n\n        // Initialize ServerList\n        this.state.serverList = this.#serverList;\n\n        // Initialize device type list\n        if (!this.state.deviceTypeList.length) {\n            const partType = this.endpoint.type;\n            this.state.deviceTypeList = [\n                {\n                    deviceType: partType.deviceType,\n                    revision: partType.deviceRevision,\n                },\n            ];\n\n            // For complete semantics it would be better to include all inherited device types.  However there is\n            // typical spec-level confusion that makes this of questionable practical utility so omitting for now\n            // for (\n            //     let base = MatterModel.standard.get(DeviceTypeModel, partType.deviceType)?.base;\n            //     base;\n            //     { base } = base\n            // ) {\n            //     if (!(base instanceof DeviceTypeModel) || base.id === undefined) {\n            //         continue;\n            //     }\n\n            //     this.state.deviceTypeList.push({\n            //         deviceType: DeviceTypeId(base.id),\n            //         revision: base.revision,\n            //     });\n            // }\n        }\n    }\n\n    /**\n     * Extend device type metadata.  This is a shortcut for deduped insert into the deviceTypeList cluster attribute.\n     *\n     * @param deviceTypes an array of objects or named device types as defined in {@link MatterModel.standard}\n     */\n    addDeviceTypes(...deviceTypes: (DescriptorServer.DeviceType | string)[]) {\n        const list = this.state.deviceTypeList;\n\n        nextInput: for (let newDeviceType of deviceTypes) {\n            if (typeof newDeviceType === \"string\") {\n                const dt = MatterModel.standard.get(DeviceTypeModel, newDeviceType);\n                if (dt === undefined) {\n                    throw new ImplementationError(`Device type ${newDeviceType} not found`);\n                }\n                newDeviceType = { deviceType: DeviceTypeId(dt.id), revision: dt.revision };\n            }\n\n            for (const existingDeviceType of list) {\n                if (isDeepEqual(newDeviceType, existingDeviceType)) {\n                    continue nextInput;\n                }\n            }\n            list.push(newDeviceType);\n        }\n    }\n\n    /**\n     * Add semantic tags.  This is a shortcut for deduped insert into the tagList cluster attribute.\n     *\n     * You must enable the \"TagList\" feature to use this method.\n     */\n    addTags(...tags: Semtag[]) {\n        // TODO - should automatically enable the feature if it's not enabled\n        if (!this.features.tagList) {\n            throw new ImplementationError('You must enable the descriptor \"TagList\" feature to set tags');\n        }\n\n        const list = (this.state as unknown as { tagList: Semtag[] }).tagList;\n\n        nextInput: for (const newTag of tags) {\n            for (const existingTag of list) {\n                if (\n                    existingTag.mfgCode === newTag.mfgCode &&\n                    existingTag.namespaceId === newTag.namespaceId &&\n                    existingTag.tag === newTag.tag\n                ) {\n                    if (existingTag.label !== newTag.label && newTag.label !== null && newTag.label !== undefined) {\n                        existingTag.label = newTag.label;\n                        continue nextInput;\n                    }\n                }\n            }\n\n            list.push(newTag);\n        }\n    }\n\n    /**\n     * Check for presence of a device type.\n     */\n    hasDeviceType(type: DeviceTypeId) {\n        return this.state.deviceTypeList.findIndex(dt => dt.deviceType === type) !== -1;\n    }\n\n    /**\n     * Process a structure change event and trigger state updates if necessary.\n     */\n    async #updateDescriptor(type: EndpointLifecycle.Change, endpoint: Endpoint) {\n        switch (type) {\n            case EndpointLifecycle.Change.Ready:\n                if (!this.endpoint.parts.has(endpoint)) {\n                    return;\n                }\n                await this.#updatePartsList();\n                this.#monitorDestruction(endpoint);\n                break;\n\n            case EndpointLifecycle.Change.ServersChanged:\n                if (endpoint !== this.endpoint) {\n                    return;\n                }\n\n                await this.context.transaction.addResources(this);\n                await this.context.transaction.begin();\n                this.state.serverList = this.#serverList;\n                break;\n        }\n    }\n\n    /**\n     * Monitor endpoint for removal.\n     */\n    #monitorDestruction(endpoint: Endpoint) {\n        this.reactTo(endpoint.lifecycle.destroyed, this.#updatePartsList);\n    }\n\n    /**\n     * Update the parts list.\n     */\n    async #updatePartsList() {\n        const endpoint = this.endpoint;\n\n        let numbers: number[];\n\n        // The presence of IndexBehavior indicates a flat namespace as required by Matter standard for root and\n        // aggregator endpoints\n        if (this.agent.has(IndexBehavior)) {\n            const index = this.agent.get(IndexBehavior);\n            numbers = Object.keys(index.partsByNumber).map(n => Number.parseInt(n));\n\n            // My endpoint should not appear in its own PartsList\n            const pos = numbers.indexOf(this.endpoint.number);\n            if (pos !== -1) {\n                numbers.splice(pos, 1);\n            }\n        } else if (endpoint.hasParts) {\n            // No IndexBehavior, just direct descendents\n            numbers = [...endpoint.parts]\n                .map(endpoint => (endpoint.lifecycle.hasNumber ? endpoint.number : undefined))\n                .filter(n => n !== undefined) as number[];\n        } else {\n            // No sub-parts\n            numbers = [];\n        }\n\n        numbers.sort();\n\n        // Do a quick deep equal so we can avoid updating state since the filtering on events that trigger this function\n        // is rather lazy\n        if (this.state.partsList.length === numbers.length) {\n            let i = numbers.length;\n            for (; i < numbers.length; i++) {\n                if (this.state.partsList[i] !== numbers[i]) {\n                    break;\n                }\n            }\n            if (i === numbers.length) {\n                return;\n            }\n        }\n\n        await this.context.transaction.addResources(this);\n        await this.context.transaction.begin();\n\n        this.state.partsList = numbers as EndpointNumber[];\n    }\n\n    /**\n     * Computed current server list.\n     */\n    get #serverList() {\n        const list = new Array<ClusterId>();\n        for (const type of Object.values(this.endpoint.behaviors.supported)) {\n            const clusterId = (type as { cluster?: { id?: ClusterId } }).cluster?.id;\n            if (clusterId) {\n                list.push(clusterId);\n            }\n        }\n        return list;\n    }\n}\n\nexport namespace DescriptorServer {\n    export type DeviceType = TypeFromSchema<typeof Descriptor.TlvDeviceType>;\n}\n"],
  "mappings": "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",
  "names": ["endpoint"]
}
