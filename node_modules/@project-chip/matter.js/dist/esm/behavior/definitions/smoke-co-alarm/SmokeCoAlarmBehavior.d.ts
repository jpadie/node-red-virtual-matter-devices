/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { SmokeCoAlarm } from "../../../cluster/definitions/SmokeCoAlarmCluster.js";
import { ClusterBehavior } from "../../cluster/ClusterBehavior.js";
import { SmokeCoAlarmInterface } from "./SmokeCoAlarmInterface.js";
import { ClusterType } from "../../../cluster/ClusterType.js";
/**
 * SmokeCoAlarmBehavior is the base class for objects that support interaction with {@link SmokeCoAlarm.Cluster}.
 *
 * SmokeCoAlarm.Cluster requires you to enable one or more optional features. You can do so using {@link
 * SmokeCoAlarmBehavior.with}.
 */
export declare const SmokeCoAlarmBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly coAlarm: import("../../../schema/BitmapSchema.js").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("../../../cluster/Cluster.js").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("../../../cluster/Cluster.js").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("../../../cluster/Cluster.js").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("../../../cluster/Cluster.js").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("../../../cluster/Cluster.js").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("../../../cluster/Cluster.js").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("../../../cluster/Cluster.js").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("../../../cluster/Cluster.js").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("../../../cluster/Cluster.js").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("../../../cluster/Cluster.js").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
            alarmSeverityLevel: import("../../../tlv/TlvObject.js").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("../../../cluster/Cluster.js").Event<void, any>;
        readonly endOfService: import("../../../cluster/Cluster.js").Event<void, any>;
        readonly selfTestComplete: import("../../../cluster/Cluster.js").Event<void, any>;
        readonly alarmMuted: import("../../../cluster/Cluster.js").OptionalEvent<void, any>;
        readonly muteEnded: import("../../../cluster/Cluster.js").OptionalEvent<void, any>;
        readonly allClear: import("../../../cluster/Cluster.js").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("../../../cluster/Cluster.js").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("../../../cluster/Cluster.js").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("../../../cluster/Cluster.js").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    alarmSeverityLevel: import("../../../tlv/TlvObject.js").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("../../../cluster/Cluster.js").OptionalEvent<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    alarmSeverityLevel: import("../../../tlv/TlvObject.js").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("../../../cluster/Cluster.js").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    alarmSeverityLevel: import("../../../tlv/TlvObject.js").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("../../../cluster/Cluster.js").OptionalEvent<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    alarmSeverityLevel: import("../../../tlv/TlvObject.js").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof ClusterBehavior, SmokeCoAlarmInterface>, SmokeCoAlarmInterface>;
type SmokeCoAlarmBehaviorType = InstanceType<typeof SmokeCoAlarmBehavior>;
export interface SmokeCoAlarmBehavior extends SmokeCoAlarmBehaviorType {
}
type StateType = InstanceType<typeof SmokeCoAlarmBehavior.State>;
export declare namespace SmokeCoAlarmBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=SmokeCoAlarmBehavior.d.ts.map