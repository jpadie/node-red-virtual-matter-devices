{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/color-control/ColorControlServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterType } from \"../../../cluster/ClusterType.js\";\nimport { ColorControl } from \"../../../cluster/definitions/ColorControlCluster.js\";\nimport { GeneralDiagnostics } from \"../../../cluster/definitions/index.js\";\nimport { ImplementationError } from \"../../../common/MatterError.js\";\nimport { RootEndpoint } from \"../../../endpoint/definitions/system/RootEndpoint.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { TypeFromPartialBitSchema } from \"../../../schema/BitmapSchema.js\";\nimport { Time, Timer } from \"../../../time/Time.js\";\nimport { addValueWithOverflow, cropValueRange } from \"../../../util/Number.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { GeneralDiagnosticsBehavior } from \"../general-diagnostics/GeneralDiagnosticsBehavior.js\";\nimport { OnOffServer } from \"../on-off/OnOffServer.js\";\nimport { ColorControlBehavior } from \"./ColorControlBehavior.js\";\nimport {\n    hsvToMireds,\n    hsvToXy,\n    kelvinToMireds,\n    miredsToHsv,\n    miredsToKelvin,\n    miredsToXy,\n    xyToMireds,\n} from \"./ColorConversionUtils.js\";\n\nconst logger = Logger.get(\"ColorControlServer\");\n\nconst ColorControlServerBase = ColorControlBehavior.with(\n    ColorControl.Feature.HueSaturation,\n    ColorControl.Feature.EnhancedHue,\n    ColorControl.Feature.ColorLoop,\n    ColorControl.Feature.Xy,\n    ColorControl.Feature.ColorTemperature,\n);\n\ntype ManagedTransitionType = \"hue\" | \"enhancedHue\" | \"saturation\" | \"colorTemperature\" | \"x\" | \"y\";\n\nconst MIN_CIE_XY_VALUE = 0;\nconst MAX_CIE_XY_VALUE = 0xfeff; // this value comes directly from the ZCL specification table 5.3\n\nconst MIN_TEMPERATURE_VALUE = 0;\nconst MAX_TEMPERATURE_VALUE = 0xfeff;\n\nconst MIN_HUE_VALUE = 0;\nconst MAX_HUE_VALUE = 0xfe;\nconst MAX_ENHANCED_HUE_VALUE = 0xffff;\n\nconst MIN_SATURATION_VALUE = 0;\nconst MAX_SATURATION_VALUE = 0xfe;\n\nconst MIN_CURRENT_LEVEL = 0x01;\nconst MAX_CURRENT_LEVEL = 0xfe;\n\n/**\n * This is the default server implementation of {@link ColorControlBehavior}.\n *\n * This implementation includes all features of {@link ColorControl.Cluster} and implements all mandatory commands. You\n * should use {@link ColorControlServer.with} to specialize the class for the features your implementation supports.\n *\n * This default implementation also handles together with the LevelControl cluster the currentLevel dependency as\n * defined by the Matter specification automatically.\n *\n * This implementation ignores by default all transition times and sets the new color immediately. Alternatively, you\n * can set the `managedTransitionTimeHandling` state attribute to true to have matter.js manage transition times by\n * changing the level value step-wise every second. This might be an intermediate solution if you develop independently\n * of defined hardware.\n *\n * If you develop for a specific hardware you should extend the {@link ColorControlServer} class and implement the\n * following methods to natively use device features to correctly support the transition times. For this the default\n * implementation uses special protected methods which are used by the real commands and are only responsible for the\n * actual value change logic. The benefit of this structure is that basic data validations and options checks are\n * already done and you can focus on the actual hardware interaction:\n *\n * * {@link ColorControlServerLogic.moveToHueLogic} Logic to move the hue to a defined value in a defined time\n * * {@link ColorControlServerLogic.moveHueLogic} Logic to move the hue by a defined rate/second\n * * {@link ColorControlServerLogic.stepHueLogic} Logic to move the hue one defined step in a defined time\n * * {@link ColorControlServerLogic.moveToSaturationLogic} Logic to move the saturation to a defined value in a defined\n *   time\n * * {@link ColorControlServerLogic.moveSaturationLogic} Logic to move the saturation by a defined rate/second\n * * {@link ColorControlServerLogic.stepSaturationLogic} Logic to move the saturation one defined step in a defined time\n * * {@link ColorControlServerLogic.moveToHueAndSaturationLogic} Logic to move the hue and saturation to a defined value\n *   in a defined time\n * * {@link ColorControlServerLogic.moveToColorLogic} Logic to move the x/y color to a defined value in a defined time\n * * {@link ColorControlServerLogic.moveColorLogic} Logic to move the x/y color by a defined rate/second\n * * {@link ColorControlServerLogic.stepColorLogic} Logic to move the x/y color one defined step in a defined time\n * * {@link ColorControlServerLogic.moveToColorTemperatureLogic} Logic to move the color temperature to a defined value\n *   in a defined time\n * * {@link ColorControlServerLogic.moveToEnhancedHueAndSaturationLogic} Logic to move the enhanced hue and saturation\n *   to a defined value in a defined time\n * * {@link ColorControlServerLogic.moveColorTemperatureLogic} Logic to move the color temperature by a defined\n *   rate/second\n * * {@link ColorControlServerLogic.stepColorTemperatureLogic} Logic to move the color temperature one defined step in a\n *   defined time\n * * {@link ColorControlServerLogic.stopHueAndSaturationMovement} Logic to stop any hue and saturation movements\n * * {@link ColorControlServerLogic.stopAllColorMovement} Logic to stop any color movements\n * * {@link ColorControlServerLogic.startColorLoopLogic} Logic to start the color loop (looping enhanced hue endlessly)\n * * {@link ColorControlServerLogic.stopColorLoopLogic} Logic to stop the color loop\n * * {@link ColorControlServerLogic.stopMoveStepLogic} Logic to stop all movements beside color loops\n * * {@link ColorControlServerLogic.switchColorMode} Logic to switch the color mode and to set the current attributes of\n *   the new mode\n *\n * All overridable methods can be implemented sync or async by returning a Promise.\n *\n * For own implementations you can use:\n *\n * * {@link ColorControlServerLogic#setColorMode} to set the color mode\n * * {@link ColorControlServerLogic#setEnhancedColorMode} to set the enhanced color mode\n *\n * The default implementation of {@link ColorControlServerLogic.switchColorMode} tries to convert the color values\n * between the different modi. When switching from color temperature mode to any other mode the value can be converted\n * when the color temperature was between 1000K and 20.000K. For other values no conversion takes place.\n *\n * The method {@link ColorControlServerLogic.syncColorTemperatureWithLevelLogic} is handling the sync between the\n * LevelControl and ColorControl cluster when the color temperature is used.\n *\n * Additionally there are some convenience properties to access the current attribute values for all relevant color\n * attributes (x,y, hue, saturation, mireds/kelvin, colorTemperatur, ...) in their CIE value format instead the matter\n * data ranges.\n */\nexport class ColorControlServerLogic extends ColorControlServerBase {\n    protected declare internal: ColorControlServerLogic.Internal;\n    declare state: ColorControlServerLogic.State;\n\n    /*\n     * The following block contains some convenience methods to allow to easily work with the CIE color space values\n     * as usual and hide the matter specific data model.\n     */\n\n    /** Returns the current X value as decimal number according to CIE in the range 0..1. */\n    get x() {\n        return this.#returnAsXyValue(this.state.currentX);\n    }\n\n    /**\n     * Sets the current X value as decimal number according to CIE in the range 0..1 and converts into Matter number\n     * range.\n     */\n    set x(value: number) {\n        this.#setFromXyValue(\"currentX\", value);\n    }\n\n    /** Returns the current Y value as decimal number according to CIE in the range 0..1. */\n    get y() {\n        return this.#returnAsXyValue(this.state.currentY);\n    }\n\n    /**\n     * Sets the current Y value as decimal number according to CIE in the range 0..1 and converts into Matter number\n     * range.\n     */\n    set y(value: number) {\n        this.#setFromXyValue(\"currentY\", value);\n    }\n\n    /**\n     * Returns the current hue value as decimal number in the range 0..360.\n     */\n    get hue() {\n        return (this.state.currentHue * 360) / 254;\n    }\n\n    /**\n     * Sets the current hue value as decimal number in the range 0..360 and converts into Matter number range.\n     */\n    set hue(value: number) {\n        this.state.currentHue = cropValueRange(Math.round((value * 254) / 360), MIN_HUE_VALUE, MAX_HUE_VALUE);\n    }\n\n    /** Returns the current enhanced hue value as decimal number in the range 0..0xFFFF. */\n    get enhancedHue() {\n        return this.state.enhancedCurrentHue;\n    }\n\n    /**\n     * Sets the current enhanced hue value as decimal number in the range 0..0xFFFF and converts into Matter number range.\n     */\n    set enhancedHue(value: number) {\n        this.state.enhancedCurrentHue = cropValueRange(value, MIN_HUE_VALUE, MAX_ENHANCED_HUE_VALUE);\n    }\n\n    /** Returns the current saturation value as decimal number in the range 0..1. */\n    get saturation() {\n        return this.state.currentSaturation / 254;\n    }\n\n    /**\n     * Sets the current saturation value as decimal number in the range 0..1 and converts into Matter number range.\n     */\n    set saturation(value: number) {\n        this.state.currentSaturation = cropValueRange(\n            Math.round(value * 254),\n            MIN_SATURATION_VALUE,\n            MAX_SATURATION_VALUE,\n        );\n    }\n\n    /** Returns the current color temperature value in Mireds (0..0xFFFF). */\n    get mireds() {\n        return this.state.colorTemperatureMireds;\n    }\n\n    /**\n     * Sets the current color temperature value in Mireds (0..0xFFFF) and converts into Matter number range.\n     */\n    set mireds(value: number) {\n        this.state.colorTemperatureMireds = cropValueRange(\n            value,\n            this.minimumColorTemperatureMireds,\n            this.maximumColorTemperatureMireds,\n        );\n    }\n\n    /** Returns the current color temperature value in Kelvin (from internal Mireds). */\n    get kelvin() {\n        return miredsToKelvin(this.mireds);\n    }\n\n    /** Sets the current color temperature value in Kelvin and updates the internal mireds value. */\n    set kelvin(value: number) {\n        this.mireds = kelvinToMireds(value);\n    }\n\n    /**\n     * Returns the minimum color temperature value in Mireds (0..0xFFFF). This automatically handled the case that no\n     * physical minimum value is defined.\n     */\n    get minimumColorTemperatureMireds() {\n        return this.state.colorTempPhysicalMinMireds === 0\n            ? MIN_TEMPERATURE_VALUE\n            : this.state.colorTempPhysicalMinMireds;\n    }\n\n    /**\n     * Returns the maximum color temperature value in Mireds (0..0xFFFF). This automatically handled the case that no\n     * physical maximum value is defined.\n     */\n    get maximumColorTemperatureMireds() {\n        return this.state.colorTempPhysicalMaxMireds === 0\n            ? MAX_TEMPERATURE_VALUE\n            : this.state.colorTempPhysicalMaxMireds;\n    }\n\n    /** Returns the current whitePoint X value as decimal number according to CIE in the range 0..1. */\n    get whitePointX() {\n        return this.#returnAsOptionalXyValue(this.state.whitePointX);\n    }\n\n    /**\n     * Sets the current whitePoint X value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set whitePointX(value: number | undefined) {\n        this.#setFromXyValue(\"whitePointX\", value);\n    }\n\n    /** Returns the current whitePoint Y value as decimal number according to CIE in the range 0..1. */\n    get whitePointY() {\n        return this.#returnAsOptionalXyValue(this.state.whitePointY);\n    }\n\n    /**\n     * Sets the current whitePoint Y value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set whitePointY(value: number | undefined) {\n        this.#setFromXyValue(\"whitePointY\", value);\n    }\n\n    /** Returns the current colorPoint Rx value as decimal number according to CIE in the range 0..1. */\n    get colorPointRx() {\n        return this.#returnAsOptionalXyValue(this.state.colorPointRx);\n    }\n\n    /**\n     * Sets the current colorPoint Rx value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set colorPointRx(value: number | undefined) {\n        this.#setFromXyValue(\"colorPointRx\", value);\n    }\n\n    /** Returns the current colorPoint Ry value as decimal number according to CIE in the range 0..1. */\n    get colorPointRy() {\n        return this.#returnAsOptionalXyValue(this.state.colorPointRy);\n    }\n\n    /**\n     * Sets the current colorPoint Ry value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set colorPointRy(value: number | undefined) {\n        this.#setFromXyValue(\"colorPointRy\", value);\n    }\n\n    /** Returns the current colorPoint Gx value as decimal number according to CIE in the range 0..1. */\n    get colorPointGx() {\n        return this.#returnAsOptionalXyValue(this.state.colorPointGx);\n    }\n\n    /**\n     * Sets the current colorPoint Gx value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set colorPointGx(value: number | undefined) {\n        this.#setFromXyValue(\"colorPointGx\", value);\n    }\n\n    /** Returns the current colorPoint Gy value as decimal number according to CIE in the range 0..1. */\n    get colorPointGy() {\n        return this.#returnAsOptionalXyValue(this.state.colorPointGy);\n    }\n\n    /**\n     * Sets the current colorPoint Gy value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set colorPointGy(value: number | undefined) {\n        this.#setFromXyValue(\"colorPointGy\", value);\n    }\n\n    /** Returns the current colorPoint Bx value as decimal number according to CIE in the range 0..1. */\n    get colorPointBx() {\n        return this.#returnAsOptionalXyValue(this.state.colorPointBx);\n    }\n\n    /**\n     * Sets the current colorPoint Bx value as decimal number according to CIE in the range 0..1 and converts into Matter\n     * number range.\n     */\n    set colorPointBx(value: number | undefined) {\n        this.#setFromXyValue(\"colorPointBx\", value);\n    }\n\n    override initialize() {\n        this.#initializeManagedTransitionTimers();\n\n        // Sync the colorCapabilities with the features for convenience\n        this.state.colorCapabilities = this.features;\n\n        // Handle startup color Temperature when the color Temperature feature is supported\n        if (\n            this.features.colorTemperature &&\n            this.#getBootReason() !== GeneralDiagnostics.BootReason.SoftwareUpdateCompleted\n        ) {\n            const startUpMiredsValue = this.state.startUpColorTemperatureMireds ?? null;\n            const currentMiredsValue = this.state.colorTemperatureMireds;\n            let targetMiredsValue: number | null;\n            switch (startUpMiredsValue) {\n                case null:\n                    targetMiredsValue = currentMiredsValue;\n                    break;\n                default:\n                    targetMiredsValue = startUpMiredsValue;\n                    break;\n            }\n            if (targetMiredsValue !== currentMiredsValue) {\n                this.state.colorMode = ColorControl.ColorMode.ColorTemperatureMireds;\n                this.state.enhancedColorMode = ColorControl.EnhancedColorMode.ColorTemperatureMireds;\n                this.state.colorTemperatureMireds = targetMiredsValue;\n            }\n        }\n    }\n\n    /**\n     * Default implementation notes:\n     * This method ignores the transition time provided by the command and just sets the hue value to the\n     * requested value. After the options and value checks and the potential color mode switch it uses the\n     * {@link moveToHueLogic} method to set the hue. If you want to implement own logic just override\n     * {@link moveToHueLogic} with is also used for {@link enhancedMoveToHue}, {@link moveToHueAndSaturation} and\n     * {@link enhancedMoveToHueAndSaturation}.\n     */\n    override moveToHue({\n        optionsMask,\n        optionsOverride,\n        hue,\n        direction,\n        transitionTime,\n    }: ColorControl.MoveToHueRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () =>\n            this.moveToHueLogic(hue, direction, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the moveToHue logic. When a transition time is specified the implementation uses a\n     * step based to manage the move. The method handled hue and enhanced-Hue changes depending on the last parameter.\n     *\n     * @param targetHue The target hue value to move to (in range of the matter hue or enhanced hue ranges)\n     * @param direction The direction to move to the target hue\n     * @param transitionTime The time in seconds to move to the target hue. 0 means \"as fast as possible\"\n     * @param isEnhancedHue If true the enhanced hue is handled, otherwise the normal hue\n     * @protected\n     */\n    protected moveToHueLogic(\n        targetHue: number,\n        direction: ColorControl.Direction,\n        transitionTime: number,\n        isEnhancedHue = false,\n    ): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopHueTransition();\n            if (isEnhancedHue) {\n                this.state.enhancedCurrentHue = targetHue;\n            } else {\n                this.state.currentHue = targetHue;\n            }\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        const currentHue = isEnhancedHue ? this.state.enhancedCurrentHue : this.state.currentHue;\n        const maxHue = isEnhancedHue ? MAX_ENHANCED_HUE_VALUE : MAX_HUE_VALUE;\n\n        const effectiveRate = Math.ceil(\n            (this.#getHueDistanceByDirection(currentHue, targetHue, direction, maxHue) / transitionTime) * 10,\n        );\n        this.#initiateTransition(\n            isEnhancedHue ? \"enhancedHue\" : \"hue\",\n            effectiveRate,\n            MIN_HUE_VALUE,\n            maxHue,\n            targetHue,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveHueLogic} method to set the hue.\n     * If you want to implement own logic just override {@link moveHueLogic} with is also used for {@link enhancedMoveHue}.\n     * If a currently running movement should be stopped {@link stopHueAndSaturationMovement} is used which can also be\n     * overridden.\n     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, but\n     * increase only one rate directly if the managed transition is not used. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second.\n     */\n    override moveHue({ optionsMask, optionsOverride, moveMode, rate }: ColorControl.MoveHueRequest) {\n        this.#assertRate(moveMode, rate);\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () => {\n            if (moveMode === ColorControl.MoveMode.Stop) {\n                return this.stopHueAndSaturationMovement();\n            }\n\n            return this.moveHueLogic(moveMode, rate);\n        });\n    }\n\n    /**\n     * Default implementation of the moveHue logic. The method handled hue and enhanced-Hue changes depending on the\n     * last parameter.\n     * If the managed transition time handling is disabled the method directly increases the hue value by one rate step.\n     * So without managed transition not too much happens.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param moveMode Move Mode to move the hue up or down (Stop should not be provided in here because already handled)\n     * @param rate The rate to move the hue up or down. 0 should never be provided her because handled here.\n     * @param isEnhancedHue If true the enhanced hue is handled, otherwise the normal hue\n     * @protected\n     */\n    protected moveHueLogic(moveMode: ColorControl.MoveMode, rate: number, isEnhancedHue = false): MaybePromise {\n        const maxHue = isEnhancedHue ? MAX_ENHANCED_HUE_VALUE : MAX_HUE_VALUE;\n\n        if (!this.state.managedTransitionTimeHandling) {\n            this.internal.stopHueTransition();\n            if (isEnhancedHue) {\n                this.state.enhancedCurrentHue = addValueWithOverflow(\n                    this.state.enhancedCurrentHue,\n                    rate,\n                    MIN_HUE_VALUE,\n                    maxHue,\n                );\n            } else {\n                this.state.currentHue = addValueWithOverflow(this.state.currentHue, rate, MIN_HUE_VALUE, maxHue);\n            }\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        this.#initiateTransition(\n            isEnhancedHue ? \"enhancedHue\" : \"hue\",\n            rate * (moveMode === ColorControl.MoveMode.Up ? 1 : -1),\n            MIN_HUE_VALUE,\n            maxHue,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * This method is called to stop any hue, enhanced hue and/or saturation movements potentially in progress. Override\n     * this method with hardware specific logic to implement this functionality.\n     * @protected\n     */\n    protected stopHueAndSaturationMovement(): MaybePromise {\n        this.internal.stopHueTransition();\n        this.internal.stopSaturationTransition();\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link stepHueLogic} method to set the hue.\n     * If you want to implement own logic just override {@link stepHueLogic} with is also used for {@link enhancedStepHue}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set to min/max directly. Else the step logic is applied and the hue is increased or decreased\n     * by the step size every transition time interval.\n     */\n    override stepHue({\n        optionsMask,\n        optionsOverride,\n        stepMode,\n        stepSize,\n        transitionTime,\n    }: ColorControl.StepHueRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () =>\n            this.stepHueLogic(stepMode, stepSize, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the stepHue logic. The method handled hue and enhanced-Hue changes depending on the\n     * last parameter.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set to current Hue +/- stepSize directly. Else the step logic is applied and the hue is increased\n     * or decreased by the step size every transition time interval.\n     * @param stepMode The step mode to move the hue up or down\n     * @param stepSize The step size to move the hue up or down\n     * @param transitionTime The time in seconds to move the hue. 0 means \"as fast as possible\"\n     * @param isEnhancedHue If true the enhanced hue is handled, otherwise the normal hue\n     * @protected\n     */\n    protected stepHueLogic(\n        stepMode: ColorControl.StepMode,\n        stepSize: number,\n        transitionTime: number,\n        isEnhancedHue = false,\n    ): MaybePromise {\n        const currentHue = isEnhancedHue ? this.state.enhancedCurrentHue : this.state.currentHue;\n        const maxHue = isEnhancedHue ? MAX_ENHANCED_HUE_VALUE : MAX_HUE_VALUE;\n\n        const targetValue = addValueWithOverflow(\n            currentHue,\n            stepMode === ColorControl.StepMode.Up ? stepSize : -stepSize,\n            MIN_HUE_VALUE,\n            maxHue,\n        );\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopHueTransition();\n            if (isEnhancedHue) {\n                this.state.enhancedCurrentHue = targetValue;\n            } else {\n                this.state.currentHue = targetValue;\n            }\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        const effectiveRate =\n            Math.ceil((stepSize / transitionTime) * 10) * (stepMode === ColorControl.StepMode.Up ? 1 : -1);\n        this.#initiateTransition(\n            isEnhancedHue ? \"enhancedHue\" : \"hue\",\n            effectiveRate,\n            MIN_HUE_VALUE,\n            maxHue,\n            targetValue,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks and potentially switching the color mode it uses the {@link moveToSaturationLogic}\n     * method to set the hue.\n     * If you want to implement own logic just override {@link moveToSaturationLogic} with is also used for\n     * {@link moveToHueAndSaturation}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the saturation is increased or\n     * decreased by the step size every transition time interval.\n     */\n    override moveToSaturation({\n        optionsMask,\n        optionsOverride,\n        saturation,\n        transitionTime,\n    }: ColorControl.MoveToSaturationRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () =>\n            this.moveToSaturationLogic(saturation, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the moveToSaturation logic.\n     * If the managed transition time handling is disabled the method directly sets the new saturation value.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param targetSaturation The target saturation value to move to\n     * @param transitionTime The time in seconds to move to the target saturation. 0 means \"as fast as possible\"\n     * @protected\n     */\n    protected moveToSaturationLogic(targetSaturation: number, transitionTime: number): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopSaturationTransition();\n            this.state.currentSaturation = targetSaturation;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        // Else calculate a rate by second and manage the transition\n        const effectiveRate = Math.ceil(((targetSaturation - this.state.currentSaturation) / transitionTime) * 10);\n        this.#initiateTransition(\n            \"saturation\",\n            effectiveRate,\n            MIN_SATURATION_VALUE,\n            MAX_SATURATION_VALUE,\n            targetSaturation,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveSaturationLogic} method to set the hue.\n     * If you want to implement own logic just override {@link moveSaturationLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set to min/max directly. Else the step logic is applied and the saturation is increased or\n     * decreased by the step size every transition time interval.\n     */\n    override moveSaturation({ optionsMask, optionsOverride, moveMode, rate }: ColorControl.MoveSaturationRequest) {\n        this.#assertRate(moveMode, rate);\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () => {\n            if (moveMode === ColorControl.MoveMode.Stop) {\n                return this.stopHueAndSaturationMovement();\n            }\n\n            return this.moveSaturationLogic(moveMode, rate);\n        });\n    }\n\n    /**\n     * Default implementation of the moveSaturation logic.\n     * If the managed transition time handling is disabled the method directly sets the new saturation value.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param moveMode Move Mode to move the saturation up or down\n     * @param rate The rate to move the saturation up or down\n     * @protected\n     */\n    protected moveSaturationLogic(moveMode: ColorControl.MoveMode, rate: number): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling) {\n            this.internal.stopSaturationTransition();\n            this.state.currentSaturation =\n                moveMode === ColorControl.MoveMode.Up ? MAX_SATURATION_VALUE : MIN_SATURATION_VALUE;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        this.#initiateTransition(\n            \"saturation\",\n            rate * (moveMode === ColorControl.MoveMode.Up ? 1 : -1),\n            MIN_SATURATION_VALUE,\n            MAX_SATURATION_VALUE,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks and potentially switching the color mode it uses the {@link stepSaturationLogic}\n     * method to set the hue.\n     * If you want to implement own logic just override {@link stepSaturationLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target values directly. Else the step logic is applied and the hue and saturation are\n     * increased or decreased by the step size every transition time interval.\n     */\n    override stepSaturation({\n        optionsMask,\n        optionsOverride,\n        stepMode,\n        stepSize,\n        transitionTime,\n    }: ColorControl.StepSaturationRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () =>\n            this.stepSaturationLogic(stepMode, stepSize, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the stepSaturation logic.\n     * If the managed transition time handling is disabled the method directly sets the new saturation value.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param stepMode The step mode to move the saturation up or down\n     * @param stepSize The step size to move the saturation up or down\n     * @param transitionTime The time in seconds to move the saturation. 0 means \"as fast as possible\"\n     * @protected\n     */\n    protected stepSaturationLogic(\n        stepMode: ColorControl.StepMode,\n        stepSize: number,\n        transitionTime: number,\n    ): MaybePromise {\n        const effectiveRate =\n            Math.ceil((stepSize / transitionTime) * 10) * (stepMode === ColorControl.StepMode.Up ? 1 : -1);\n        const targetValue = cropValueRange(\n            stepMode === ColorControl.StepMode.Up\n                ? this.state.currentSaturation + stepSize\n                : this.state.currentSaturation - stepSize,\n            MIN_SATURATION_VALUE,\n            MAX_SATURATION_VALUE,\n        );\n\n        if (\n            !this.state.managedTransitionTimeHandling ||\n            transitionTime === 0 ||\n            this.state.currentSaturation === targetValue\n        ) {\n            this.internal.stopSaturationTransition();\n            this.state.currentSaturation = targetValue;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        this.#initiateTransition(\"saturation\", effectiveRate, MIN_SATURATION_VALUE, MAX_SATURATION_VALUE, targetValue);\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks and potentially switching the color mode it uses the {@link moveToHueAndSaturationLogic}\n     * method to set the hue.\n     * If you want to implement own logic just override {@link moveToHueAndSaturationLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target values directly. Else the step logic is applied and the hue and saturation is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override moveToHueAndSaturation({\n        optionsOverride,\n        optionsMask,\n        saturation,\n        hue,\n        transitionTime,\n    }: ColorControl.MoveToHueAndSaturationRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation), () =>\n            this.moveToHueAndSaturationLogic(hue, saturation, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the moveToHueAndSaturation logic.\n     * If the managed transition time handling is disabled the method directly sets the new hue and saturation values.\n     * Otherwise the method initiates a transition with the given rate.\n     * This method internally uses {@link moveToHueLogic} and {@link moveToSaturationLogic} to handle the hue and\n     * saturation changes, so if you have implemented them already you might not need to override this method.\n     *\n     * @param targetHue The target hue value to move to\n     * @param targetSaturation The target saturation value to move to\n     * @param transitionTime The time in seconds to move to the target hue and saturation. 0 means \"as fast as possible\"\n     * @protected\n     */\n    protected moveToHueAndSaturationLogic(\n        targetHue: number,\n        targetSaturation: number,\n        transitionTime: number,\n    ): MaybePromise {\n        return MaybePromise.then(\n            this.moveToHueLogic(targetHue, ColorControl.Direction.ShortestDistance, transitionTime, false),\n            () => this.moveToSaturationLogic(targetSaturation, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveToColorLogic} method to set the x and y value.\n     * If you want to implement own logic just override {@link moveToColorLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target values directly. Else the step logic is applied and the x and y is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override moveToColor({\n        optionsMask,\n        optionsOverride,\n        colorX,\n        colorY,\n        transitionTime,\n    }: ColorControl.MoveToColorRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentXAndCurrentY), () =>\n            this.moveToColorLogic(colorX, colorY, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the moveToColor logic.\n     * If the managed transition time handling is disabled the method directly sets the new x and y values.\n     * Otherwise the method initiates a transition with the given rate.\n     * This method internally uses {@link moveToColorLogic} to handle the x and y changes, so if you have implemented it\n     * already you might not need to override this method.\n     *\n     * @param targetX The target x value to move to\n     * @param targetY The target y value to move to\n     * @param transitionTime The time in seconds to move to the target x and y. 0 means \"as fast as possible\"\n     * @protected\n     */\n    protected moveToColorLogic(targetX: number, targetY: number, transitionTime: number): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopXTransition();\n            this.internal.stopYTransition();\n            this.state.currentX = cropValueRange(targetX, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n            this.state.currentY = cropValueRange(targetY, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        // Else calculate a rate by second and manage the transition\n        const effectiveRateX = Math.floor(((targetX - this.state.currentX) / transitionTime) * 10);\n        const effectiveRateY = Math.floor(((targetY - this.state.currentY) / transitionTime) * 10);\n\n        this.#initiateTransition(\"x\", effectiveRateX, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE, targetX);\n        this.#initiateTransition(\"y\", effectiveRateY, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE, targetY);\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveColorLogic} method to set the x and y value.\n     * If you want to implement own logic just override {@link moveColorLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target values directly. Else the step logic is applied and the x and y is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override moveColor({ optionsOverride, optionsMask, rateX, rateY }: ColorControl.MoveColorRequest): MaybePromise {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n\n        if (rateX === 0 && rateY === 0) {\n            return this.stopAllColorMovement();\n        }\n\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentXAndCurrentY), () =>\n            this.moveColorLogic(rateX, rateY),\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * This method is called to stop any color movements potentially in progress, including any x/y, hue, saturation and\n     * color temperature transitions. Override this method with hardware specific logic to implement this functionality.\n     * @protected\n     */\n    protected stopAllColorMovement(): MaybePromise {\n        this.internal.stopXTransition();\n        this.internal.stopYTransition();\n        this.internal.stopHueTransition();\n        this.internal.stopSaturationTransition();\n        this.internal.stopColorTemperatureTransition();\n        this.state.remainingTime = 0;\n    }\n\n    /**\n     * Default implementation of the moveColor logic.\n     * If the managed transition time handling is disabled the method directly sets the new x and y values.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param rateX The rate to move the x value up or down (positive values mean up, negative down)\n     * @param rateY The rate to move the y value up or down (positive values mean up, negative down)\n     * @protected\n     */\n    protected moveColorLogic(rateX: number, rateY: number): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling) {\n            this.internal.stopXTransition();\n            this.internal.stopYTransition();\n            if (rateX !== 0) {\n                this.state.currentX = MAX_CIE_XY_VALUE;\n            }\n            if (rateY !== 0) {\n                this.state.currentY = MAX_CIE_XY_VALUE;\n            }\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        if (rateX !== 0) {\n            this.#initiateTransition(\"x\", rateX, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n        }\n        if (rateY !== 0) {\n            this.#initiateTransition(\"y\", rateY, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n        }\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link stepColorLogic} method to set the x and y value.\n     * If you want to implement own logic just override {@link stepColorLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target values directly. Else the step logic is applied and the x and y is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override stepColor({\n        optionsOverride,\n        optionsMask,\n        stepX,\n        stepY,\n        transitionTime,\n    }: ColorControl.StepColorRequest): MaybePromise {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.CurrentXAndCurrentY), () =>\n            this.stepColorLogic(stepX, stepY, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the stepColor logic.\n     * If the managed transition time handling is disabled the method directly sets the new x and y values.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param stepX The step size to move the x value up or down\n     * @param stepY The step size to move the y value up or down\n     * @param transitionTime The time in seconds to move the x and y. 0 means \"as fast as possible\"\n     * @protected\n     */\n    protected stepColorLogic(stepX: number, stepY: number, transitionTime: number): MaybePromise {\n        const targetValueX = cropValueRange(this.state.currentX + stepX, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n        const targetValueY = cropValueRange(this.state.currentY + stepY, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopXTransition();\n            this.internal.stopYTransition();\n            this.state.currentX = targetValueX;\n            this.state.currentY = targetValueY;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        // Else calculate a rate by second and manage the transition\n        if (stepX !== 0) {\n            const effectiveRateX = Math.floor((stepX / transitionTime) * 10);\n            this.#initiateTransition(\"x\", effectiveRateX, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE, targetValueX);\n        }\n        if (stepY !== 0) {\n            const effectiveRateY = Math.floor((stepY / transitionTime) * 10);\n            this.#initiateTransition(\"y\", effectiveRateY, MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE, targetValueY);\n        }\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveToColorTemperatureLogic} method to set the color temperature.\n     * If you want to implement own logic just override {@link moveToColorTemperatureLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override moveToColorTemperature({\n        optionsOverride,\n        optionsMask,\n        colorTemperatureMireds,\n        transitionTime,\n    }: ColorControl.MoveToColorTemperatureRequest): MaybePromise {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.ColorTemperatureMireds), () =>\n            this.moveToColorTemperatureLogic(colorTemperatureMireds, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation of the moveToColorTemperature logic.\n     * If the managed transition time handling is disabled the method directly sets the new color temperature value.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param targetMireds The target color temperature value to move to\n     * @param transitionTime The time in seconds to move to the target color temperature. 0 means \"as fast as possible\"\n     * @protected\n     */\n    protected moveToColorTemperatureLogic(targetMireds: number, transitionTime: number): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopColorTemperatureTransition();\n            this.state.colorTemperatureMireds = targetMireds;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        // Else calculate a rate by second and manage the transition\n        const effectiveRate = Math.ceil(((targetMireds - this.state.colorTemperatureMireds) / transitionTime) * 10);\n        this.#initiateTransition(\n            \"colorTemperature\",\n            effectiveRate,\n            this.minimumColorTemperatureMireds,\n            this.maximumColorTemperatureMireds,\n            targetMireds,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveToHueLogic} method to set the enhanced hue.\n     * If you want to implement own logic just override {@link moveToHueLogic} which is used together with\n     * {@link moveToHue}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override enhancedMoveToHue({\n        optionsMask,\n        optionsOverride,\n        enhancedHue,\n        direction,\n        transitionTime,\n    }: ColorControl.EnhancedMoveToHueRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(\n            this.setEnhancedColorMode(ColorControl.EnhancedColorMode.EnhancedCurrentHueAndCurrentSaturation),\n            () => this.moveToHueLogic(enhancedHue, direction, transitionTime, true),\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveHueLogic} method to set the enhanced hue.\n     * If you want to implement own logic just override {@link moveHueLogic} which is used together with\n     * {@link moveHue}.\n     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, but\n     * increase only one rate directly if the managed transition is not used. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second.\n     */\n    override enhancedMoveHue({ optionsMask, optionsOverride, moveMode, rate }: ColorControl.EnhancedMoveHueRequest) {\n        this.#assertRate(moveMode, rate);\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(\n            this.setEnhancedColorMode(ColorControl.EnhancedColorMode.EnhancedCurrentHueAndCurrentSaturation),\n            () => {\n                if (moveMode === ColorControl.MoveMode.Stop) {\n                    return this.stopHueAndSaturationMovement();\n                }\n\n                return this.moveHueLogic(moveMode, rate, true);\n            },\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link stepHueLogic} method to set the enhanced hue.\n     * If you want to implement own logic just override {@link stepHueLogic} which is used together with\n     * {@link stepHue}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the hue is increased or\n     * decreased by the step size every transition time interval.\n     */\n    override enhancedStepHue({\n        optionsMask,\n        optionsOverride,\n        stepMode,\n        stepSize,\n        transitionTime,\n    }: ColorControl.EnhancedStepHueRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(\n            this.setEnhancedColorMode(ColorControl.EnhancedColorMode.EnhancedCurrentHueAndCurrentSaturation),\n            () => this.stepHueLogic(stepMode, stepSize, transitionTime, true),\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveToEnhancedHueAndSaturationLogic} method to set the enhanced hue\n     * and saturation.\n     * If you want to implement own logic just override {@link moveToEnhancedHueAndSaturationLogic}.\n     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, so\n     * we set to min/max directly if the managed transition is not used. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second.\n     */\n    override enhancedMoveToHueAndSaturation({\n        optionsOverride,\n        optionsMask,\n        enhancedHue,\n        saturation,\n        transitionTime,\n    }: ColorControl.EnhancedMoveToHueAndSaturationRequest): MaybePromise {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(\n            this.setEnhancedColorMode(ColorControl.EnhancedColorMode.EnhancedCurrentHueAndCurrentSaturation),\n            () => this.moveToEnhancedHueAndSaturationLogic(enhancedHue, saturation, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveToHueLogic} and {@link moveToSaturationLogic} methods to set the\n     * hue and saturation.\n     * Both methods are also used for other commands, so it maybe is not needed to override this method.\n     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, so\n     * we set to min/max directly if the managed transition is not used. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second.\n     */\n    protected moveToEnhancedHueAndSaturationLogic(\n        targetEnhancedHue: number,\n        targetSaturation: number,\n        transitionTime: number,\n    ): MaybePromise {\n        return MaybePromise.then(\n            this.moveToHueLogic(targetEnhancedHue, ColorControl.Direction.ShortestDistance, transitionTime, true),\n            () => this.moveToSaturationLogic(targetSaturation, transitionTime),\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks and potentially switching the color mode it uses the {@link stopColorLoopLogic}\n     * method to stop color loops or {@link startColorLoopLogic} to start a color loop at a defined enhanced hue value.\n     * If you want to implement own logic just override these methods.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override colorLoopSet({\n        optionsMask,\n        optionsOverride,\n        updateFlags,\n        action,\n        direction,\n        time,\n        startHue,\n    }: ColorControl.ColorLoopSetRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n\n        if (updateFlags.updateDirection) {\n            this.state.colorLoopDirection = direction as unknown as ColorControl.ColorLoopDirection;\n        }\n        if (updateFlags.updateTime) {\n            this.state.colorLoopTime = time;\n        }\n        if (updateFlags.updateStartHue) {\n            this.state.colorLoopStartEnhancedHue = startHue;\n        }\n        if (updateFlags.updateAction) {\n            if (action === ColorControl.Action.DeActivateTheColorLoop) {\n                return this.#stopColorLoop();\n            } else {\n                return MaybePromise.then(\n                    this.setEnhancedColorMode(ColorControl.EnhancedColorMode.EnhancedCurrentHueAndCurrentSaturation),\n                    () => {\n                        this.state.colorLoopStoredEnhancedHue = this.state.enhancedCurrentHue;\n                        this.state.colorLoopActive = ColorControl.ColorLoopActive.Active;\n                        if (\n                            action ===\n                            ColorControl.Action.ActivateTheColorLoopFromTheValueInTheColorLoopStartEnhancedHueField\n                        ) {\n                            return this.startColorLoopLogic(this.state.colorLoopStartEnhancedHue);\n                        } else if (\n                            action ===\n                            ColorControl.Action.ActivateTheColorLoopFromTheValueOfTheEnhancedCurrentHueAttribute\n                        ) {\n                            return this.startColorLoopLogic(this.state.enhancedCurrentHue);\n                        }\n                    },\n                );\n            }\n        }\n    }\n\n    /**\n     * Internal method to step the color loop and sync the internal ColorLoopActive state and restore the stored\n     * enhanced hue. It uses {@link stopColorLoopLogic} to execute the stop.\n     */\n    #stopColorLoop() {\n        return MaybePromise.then(this.stopColorLoopLogic(), () => {\n            if (this.state.colorLoopActive === ColorControl.ColorLoopActive.Active) {\n                this.state.colorLoopActive = ColorControl.ColorLoopActive.Inactive;\n                this.state.enhancedCurrentHue = this.state.colorLoopStoredEnhancedHue;\n            }\n        });\n    }\n\n    /**\n     * Default implementation notes:\n     * Implement stopping the color loop here if any special hardware specific logic is needed.\n     * @protected\n     */\n    protected stopColorLoopLogic(): MaybePromise {\n        this.internal.stopHueTransition();\n    }\n\n    /**\n     * Default implementation notes:\n     * This method uses {@link moveHueLogic} to start a enhanced color loop and sets the required start hue beforehand.\n     * If this is sufficient for your implementation you might not need to override this method.\n     *\n     * @param startHue The hue to start the color loop at\n     * @protected\n     */\n    protected startColorLoopLogic(startHue: number): MaybePromise {\n        this.state.enhancedCurrentHue = startHue;\n\n        return this.moveHueLogic(\n            this.state.colorLoopDirection === ColorControl.ColorLoopDirection.Decrement\n                ? ColorControl.MoveMode.Down\n                : ColorControl.MoveMode.Up,\n            Math.floor(MAX_ENHANCED_HUE_VALUE / this.state.colorLoopTime),\n            true,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link stopMoveStepLogic} method to stop any ongoing color movement.\n     * If you want to implement own logic just override {@link stopMoveStepLogic}.\n     */\n    override stopMoveStep({ optionsOverride, optionsMask }: ColorControl.StopMoveStepRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return this.stopMoveStepLogic();\n    }\n\n    /**\n     * Default implementation notes:\n     * Implement stopping any ongoing color movement here if any special hardware specific logic is needed. In fact this\n     * needs to stop any ongoing saturation, color temperature, x or y movement. Hue transitions should only be stopped\n     * when they do not belong to a color loop.\n     * @protected\n     */\n    protected stopMoveStepLogic(): MaybePromise {\n        if (this.state.colorLoopActive === ColorControl.ColorLoopActive.Inactive) {\n            this.internal.stopHueTransition();\n        }\n        this.internal.stopSaturationTransition();\n        this.internal.stopColorTemperatureTransition();\n        this.internal.stopXTransition();\n        this.internal.stopYTransition();\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks and potentially changing the color mode it uses the {@link moveColorTemperatureLogic}\n     * method to set the color temperature.\n     * If the current movement should be stopped {@link stopHueAndSaturationMovement} is used.\n     * If you want to implement own logic just override {@link moveColorTemperatureLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override moveColorTemperature({\n        optionsOverride,\n        optionsMask,\n        moveMode,\n        colorTemperatureMinimumMireds,\n        colorTemperatureMaximumMireds,\n        rate,\n    }: ColorControl.MoveColorTemperatureRequest): MaybePromise {\n        this.#assertRate(moveMode, rate);\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.ColorTemperatureMireds), () => {\n            if (moveMode === ColorControl.MoveMode.Stop) {\n                return this.stopHueAndSaturationMovement();\n            }\n\n            // If no min/max values are provided, use the device limits\n            if (colorTemperatureMinimumMireds === 0) {\n                colorTemperatureMinimumMireds = this.minimumColorTemperatureMireds;\n            }\n            if (colorTemperatureMaximumMireds === 0) {\n                colorTemperatureMaximumMireds = this.maximumColorTemperatureMireds;\n            }\n            colorTemperatureMinimumMireds = cropValueRange(\n                colorTemperatureMinimumMireds,\n                this.minimumColorTemperatureMireds,\n                this.maximumColorTemperatureMireds,\n            );\n            colorTemperatureMaximumMireds = cropValueRange(\n                colorTemperatureMaximumMireds,\n                this.minimumColorTemperatureMireds,\n                this.maximumColorTemperatureMireds,\n            );\n\n            return this.moveColorTemperatureLogic(\n                moveMode,\n                rate,\n                colorTemperatureMinimumMireds,\n                colorTemperatureMaximumMireds,\n            );\n        });\n    }\n\n    /**\n     * Default implementation of the moveColorTemperature logic.\n     * If the managed transition time handling is disabled the method directly sets the min or max color temperature value.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param moveMode\n     * @param rate\n     * @param colorTemperatureMinimumMireds\n     * @param colorTemperatureMaximumMireds\n     * @protected\n     */\n    protected moveColorTemperatureLogic(\n        moveMode: ColorControl.MoveMode,\n        rate: number,\n        colorTemperatureMinimumMireds: number,\n        colorTemperatureMaximumMireds: number,\n    ): MaybePromise {\n        if (!this.state.managedTransitionTimeHandling) {\n            this.internal.stopColorTemperatureTransition();\n            this.state.colorTemperatureMireds =\n                moveMode === ColorControl.MoveMode.Up ? colorTemperatureMaximumMireds : colorTemperatureMinimumMireds;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        const effectiveRate = rate * (moveMode === ColorControl.MoveMode.Up ? 1 : -1);\n        this.#initiateTransition(\n            \"colorTemperature\",\n            effectiveRate,\n            colorTemperatureMinimumMireds,\n            colorTemperatureMaximumMireds,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks and potentially switching the color mode it uses the {@link stepColorTemperatureLogic}\n     * method to set the color temperature.\n     * If you want to implement own logic just override {@link stepColorTemperatureLogic}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override stepColorTemperature({\n        optionsOverride,\n        optionsMask,\n        stepMode,\n        stepSize,\n        transitionTime,\n        colorTemperatureMinimumMireds,\n        colorTemperatureMaximumMireds,\n    }: ColorControl.StepColorTemperatureRequest) {\n        if (!this.#optionsAllowExecution(optionsMask, optionsOverride)) {\n            return;\n        }\n        return MaybePromise.then(this.setColorMode(ColorControl.ColorMode.ColorTemperatureMireds), () => {\n            // If no min/max values are provided, use the device limits\n            if (colorTemperatureMinimumMireds === 0) {\n                colorTemperatureMinimumMireds = this.minimumColorTemperatureMireds;\n            }\n            if (colorTemperatureMaximumMireds === 0) {\n                colorTemperatureMaximumMireds = this.maximumColorTemperatureMireds;\n            }\n            colorTemperatureMinimumMireds = cropValueRange(\n                colorTemperatureMinimumMireds,\n                this.minimumColorTemperatureMireds,\n                this.maximumColorTemperatureMireds,\n            );\n            colorTemperatureMaximumMireds = cropValueRange(\n                colorTemperatureMaximumMireds,\n                this.minimumColorTemperatureMireds,\n                this.maximumColorTemperatureMireds,\n            );\n\n            return this.stepColorTemperatureLogic(\n                stepMode,\n                stepSize,\n                transitionTime,\n                colorTemperatureMinimumMireds,\n                colorTemperatureMaximumMireds,\n            );\n        });\n    }\n\n    /**\n     * Default implementation of the stepColorTemperature logic.\n     * If the managed transition time handling is disabled the method directly sets the new color temperature value.\n     * Otherwise the method initiates a transition with the given rate.\n     *\n     * @param stepMode Step Mode to move the color temperature up or down\n     * @param stepSize Step size to move the color temperature up or down\n     * @param transitionTime Time in seconds to move the color temperature. 0 means \"as fast as possible\"\n     * @param colorTemperatureMinimumMireds Minimum allowed color temperature value\n     * @param colorTemperatureMaximumMireds Maximum allowed color temperature value\n     * @protected\n     */\n    protected stepColorTemperatureLogic(\n        stepMode: ColorControl.StepMode,\n        stepSize: number,\n        transitionTime: number,\n        colorTemperatureMinimumMireds: number,\n        colorTemperatureMaximumMireds: number,\n    ): MaybePromise {\n        const targetValue = cropValueRange(\n            this.state.colorTemperatureMireds + (stepMode === ColorControl.StepMode.Up ? stepSize : -stepSize),\n            colorTemperatureMinimumMireds,\n            colorTemperatureMaximumMireds,\n        );\n        if (!this.state.managedTransitionTimeHandling || transitionTime === 0) {\n            this.internal.stopColorTemperatureTransition();\n            this.state.colorTemperatureMireds = targetValue;\n            this.state.remainingTime = 0;\n            return;\n        }\n\n        const effectiveRate =\n            Math.ceil((stepSize / transitionTime) * 10) * (stepMode === ColorControl.StepMode.Up ? 1 : -1);\n        this.#initiateTransition(\n            \"colorTemperature\",\n            effectiveRate,\n            colorTemperatureMinimumMireds,\n            colorTemperatureMaximumMireds,\n        );\n    }\n\n    /**\n     * Convenient method to change the color mode of the device. It uses {@link switchColorMode} to\n     * convert the current color attributes to the new mode. Override this method for device specific behavior.\n     * @private\n     */\n    protected setColorMode(mode: ColorControl.ColorMode): MaybePromise {\n        if (this.state.colorMode === mode) {\n            return;\n        }\n\n        return MaybePromise.then(this.switchColorMode(this.state.colorMode, mode), () => {\n            this.state.colorMode = mode;\n            this.state.enhancedColorMode = mode as unknown as ColorControl.EnhancedColorMode; // Enhanced just has additional values\n        });\n    }\n\n    /**\n     * Convenient method to change the enhanced color mode of the device. it uses {@link switchColorMode} to\n     * convert the current color attributes to the new mode. Override this method for device specific behavior.\n     * @private\n     */\n    protected setEnhancedColorMode(mode: ColorControl.EnhancedColorMode): MaybePromise {\n        if (this.state.enhancedColorMode === mode) {\n            return;\n        }\n\n        let colorModeSet;\n        if (mode === ColorControl.EnhancedColorMode.EnhancedCurrentHueAndCurrentSaturation) {\n            colorModeSet = this.setColorMode(ColorControl.ColorMode.CurrentHueAndCurrentSaturation);\n        } else {\n            colorModeSet = this.setColorMode(mode as unknown as ColorControl.ColorMode);\n        }\n        return MaybePromise.then(colorModeSet, () => {\n            this.state.enhancedColorMode = mode;\n        });\n    }\n\n    /**\n     * Default implementation notes:\n     * This method is used to switch the device color mode. It converts the current color attributes to the new mode on\n     * a best effort \"as close as possible\" basis. If the device hardware can do this better this method should be\n     * overridden to implement this switch logic and to update all state attributes for the new mode. The color mode\n     * attribute update itself is handled by the calling method, so is not needed to be done here.\n     *\n     * @param oldMode Old color Mode\n     * @param newMode New color Mode\n     * @protected\n     */\n    protected switchColorMode(oldMode: ColorControl.ColorMode, newMode: ColorControl.ColorMode): MaybePromise {\n        if (oldMode === newMode) {\n            return;\n        }\n        switch (oldMode) {\n            case ColorControl.ColorMode.CurrentHueAndCurrentSaturation:\n                switch (newMode) {\n                    case ColorControl.ColorMode.CurrentXAndCurrentY:\n                        // Convert hue/saturation to xy\n                        const [x, y] = hsvToXy(this.hue, this.saturation);\n                        this.x = x;\n                        this.y = y;\n                        break;\n                    case ColorControl.ColorMode.ColorTemperatureMireds:\n                        // Convert hue/saturation to color temperature\n                        const mireds = hsvToMireds(this.hue, this.saturation);\n                        if (mireds === undefined) {\n                            logger.warn(\n                                `Could not convert hue/saturation (${this.hue}/${this.saturation}) to color temperature`,\n                            );\n                        } else {\n                            this.mireds = mireds;\n                        }\n                        break;\n                }\n                break;\n            case ColorControl.ColorMode.CurrentXAndCurrentY:\n                switch (newMode) {\n                    case ColorControl.ColorMode.CurrentHueAndCurrentSaturation:\n                        // Convert xy to hue/saturation\n                        const [hue, saturation] = hsvToXy(this.x, this.y);\n                        this.hue = hue;\n                        this.saturation = saturation;\n                        break;\n                    case ColorControl.ColorMode.ColorTemperatureMireds:\n                        // Convert xy to color temperature\n                        const mireds = xyToMireds(this.x, this.y);\n                        if (mireds === undefined) {\n                            logger.warn(`Could not convert xy ${this.x / this.y} to color temperature`);\n                        } else {\n                            this.mireds = mireds;\n                        }\n                        break;\n                }\n                break;\n            case ColorControl.ColorMode.ColorTemperatureMireds:\n                switch (newMode) {\n                    case ColorControl.ColorMode.CurrentHueAndCurrentSaturation:\n                        // Convert color temperature to hue/saturation\n                        const hsvResult = miredsToHsv(this.mireds);\n                        if (hsvResult === undefined) {\n                            logger.warn(`Could not convert color temperature ${this.mireds} to hue/saturation`);\n                        } else {\n                            const [hue, saturation] = hsvResult;\n                            this.hue = hue;\n                            this.saturation = saturation;\n                        }\n                        break;\n                    case ColorControl.ColorMode.CurrentXAndCurrentY:\n                        // Convert color temperature to xy\n                        const xyResult = miredsToXy(this.mireds);\n                        if (xyResult === undefined) {\n                            logger.warn(\"Could not convert color temperature to xy\");\n                        } else {\n                            const [x, y] = xyResult;\n                            this.x = x;\n                            this.y = y;\n                        }\n                        break;\n                }\n                break;\n        }\n    }\n\n    /**\n     * This method is used to set the remaining Time by checking the current transition timers depending on the color mode.\n     */\n    #setRemainingTime() {\n        let remaining = 0;\n        switch (this.state.colorMode) {\n            case ColorControl.ColorMode.CurrentHueAndCurrentSaturation:\n                if (this.internal.hueTransitionIntervalTimer?.isRunning) {\n                    remaining = this.internal.currentHueTransitionData?.remainingTime ?? 0;\n                }\n                if (this.internal.saturationTransitionIntervalTimer?.isRunning) {\n                    remaining = Math.max(remaining, this.internal.currentSaturationTransitionData?.remainingTime ?? 0);\n                }\n                break;\n            case ColorControl.ColorMode.CurrentXAndCurrentY:\n                if (this.internal.xTransitionIntervalTimer?.isRunning) {\n                    remaining = this.internal.currentXTransitionData?.remainingTime ?? 0;\n                }\n                if (this.internal.yTransitionIntervalTimer?.isRunning) {\n                    remaining = Math.max(remaining, this.internal.currentYTransitionData?.remainingTime ?? 0);\n                }\n                break;\n            case ColorControl.ColorMode.ColorTemperatureMireds:\n                if (this.internal.colorTemperatureTransitionIntervalTimer?.isRunning) {\n                    remaining = this.internal.currentColorTemperatureTransitionData?.remainingTime ?? 0;\n                }\n                break;\n        }\n        this.state.remainingTime = remaining;\n    }\n\n    /**\n     * This method is used internally to potentially handle the dependency between the ColorControl and LevelControl\n     * cluster.\n     * Do not override this method! Please use the {@link syncColorTemperatureWithLevelLogic} method instead which is\n     * called by this method if a sync is needed.\n     */\n    syncColorTemperatureWithLevel(level: number): MaybePromise {\n        if (\n            this.state.colorMode === ColorControl.ColorMode.ColorTemperatureMireds ||\n            this.state.enhancedColorMode === ColorControl.EnhancedColorMode.ColorTemperatureMireds\n        ) {\n            return this.syncColorTemperatureWithLevelLogic(level);\n        }\n    }\n\n    /**\n     * This method is used internally to potentially handle the dependency between the ColorControl and LevelControl\n     * clusters as defined by the Matter specification. It uses {@link moveToColorTemperatureLogic} with a transition\n     * time of 0 (as fast as possible) to set the determined color temperature. Unless you have special requirements\n     * you do not need to override it.\n     *\n     * @param level The current level value from the LevelControl cluster\n     * @protected\n     */\n    protected syncColorTemperatureWithLevelLogic(level: number): MaybePromise {\n        if (\n            this.state.colorMode !== ColorControl.ColorMode.ColorTemperatureMireds &&\n            this.state.enhancedColorMode !== ColorControl.EnhancedColorMode.ColorTemperatureMireds\n        ) {\n            return;\n        }\n        // The CoupleColorTempToLevelMinMireds attribute specifies a lower bound on the value of the ColorTemperatureMireds\n        // attribute for the purposes of coupling the ColorTemperatureMireds attribute to the CurrentLevel attribute when\n        // the CoupleColorTempToLevel bit of the Options attribute of the Level Control cluster is equal to 1. When coupling\n        // the ColorTemperatureMireds attribute to the CurrentLevel attribute, this value SHALL correspond to a\n        // CurrentLevel value of 0xFE (100%).\n        // Note that since this attribute is stored as a micro reciprocal degree (mired) value (i.e. color temperature in\n        // kelvins = 1,000,000 / CoupleColorTempToLevelMinMireds), the CoupleColorTempToLevelMinMireds attribute\n        // corresponds to an upper bound on the value of the color temperature in kelvins supported by the device.\n\n        const tempCoupleMin = this.state.coupleColorTempToLevelMinMireds ?? this.minimumColorTemperatureMireds;\n        const tempPhysMax = this.maximumColorTemperatureMireds;\n\n        // Scale color temp setting between the coupling min and the physical max.\n        // Note that mireds varies inversely with level: low level -> high mireds.\n        // Peg min/MAX level to MAX/min mireds, otherwise interpolate.\n        let newColorTemp;\n        if (level <= MIN_CURRENT_LEVEL) {\n            newColorTemp = tempPhysMax;\n        } else if (level >= MAX_CURRENT_LEVEL) {\n            newColorTemp = tempCoupleMin;\n        } else {\n            const tempDelta = Math.floor(\n                ((tempPhysMax - tempCoupleMin) * level) / (MAX_CURRENT_LEVEL - MIN_CURRENT_LEVEL + 1),\n            );\n            newColorTemp = tempPhysMax - tempDelta;\n        }\n\n        logger.debug(`Synced color temperature with level: ${level}, new color temperature: ${newColorTemp}`);\n\n        return this.moveToColorTemperatureLogic(newColorTemp, 0);\n    }\n\n    #assertRate(mode: ColorControl.MoveMode, rate: number) {\n        if ((mode === ColorControl.MoveMode.Up || mode === ColorControl.MoveMode.Down) && rate === 0) {\n            throw new StatusResponseError(\"Rate must not be 0 when moving Up or Down\", StatusCode.InvalidCommand);\n        }\n    }\n\n    /** Calculate the hue distance depending on the direction and the current and target hue. */\n    #getHueDistanceByDirection(currentHue: number, targetHue: number, direction: ColorControl.Direction, max: number) {\n        const distance = (targetHue > currentHue ? targetHue : max + targetHue) - currentHue;\n        logger.info(\n            `Distance: ${distance}, direction: ${direction}, max/2: ${max / 2}, max-distance: ${max - distance}`,\n        );\n        if (distance === 0) {\n            return 0;\n        }\n        if (direction === ColorControl.Direction.Up) {\n            return distance;\n        } else if (direction === ColorControl.Direction.Down) {\n            return -(max - distance);\n        }\n        if (direction === ColorControl.Direction.ShortestDistance) {\n            if (Math.abs(distance) > max / 2) {\n                return -(max - distance);\n            }\n            return distance;\n        }\n        if (direction === ColorControl.Direction.LongestDistance) {\n            if (Math.abs(distance) > max / 2) {\n                return distance;\n            }\n            return -(max - distance);\n        }\n        throw new ImplementationError(`Unknown direction: ${direction}`);\n    }\n\n    /** Initialize the managed transition timers.. */\n    #initializeManagedTransitionTimers() {\n        if (!this.state.managedTransitionTimeHandling) {\n            return;\n        }\n        this.internal.hueTransitionIntervalTimer = Time.getPeriodicTimer(\n            \"ColorControl.hue.transition\",\n            1000,\n            this.callback(this.#hueStepIntervalTick),\n        );\n        this.internal.saturationTransitionIntervalTimer = Time.getPeriodicTimer(\n            \"ColorControl.saturation.transition\",\n            1000,\n            this.callback(this.#saturationStepIntervalTick),\n        );\n        this.internal.colorTemperatureTransitionIntervalTimer = Time.getPeriodicTimer(\n            \"ColorControl.colorTemperature.transition\",\n            1000,\n            this.callback(this.#colorTemperatureStepIntervalTick),\n        );\n        this.internal.xTransitionIntervalTimer = Time.getPeriodicTimer(\n            \"ColorControl.x.transition\",\n            1000,\n            this.callback(this.#xStepIntervalTick),\n        );\n        this.internal.yTransitionIntervalTimer = Time.getPeriodicTimer(\n            \"ColorControl.y.transition\",\n            1000,\n            this.callback(this.#yStepIntervalTick),\n        );\n    }\n\n    #getBootReason() {\n        const rootEndpoint = this.endpoint.ownerOfType(RootEndpoint);\n        if (rootEndpoint !== undefined && rootEndpoint.behaviors.has(GeneralDiagnosticsBehavior)) {\n            return rootEndpoint.stateOf(GeneralDiagnosticsBehavior).bootReason;\n        }\n    }\n\n    #calculateEffectiveOptions(\n        optionsMask: TypeFromPartialBitSchema<typeof ColorControl.Options>,\n        optionsOverride: TypeFromPartialBitSchema<typeof ColorControl.Options>,\n    ): TypeFromPartialBitSchema<typeof ColorControl.Options> {\n        const options = this.state.options ?? {};\n        return {\n            executeIfOff: optionsMask.executeIfOff ? optionsOverride.executeIfOff : options.executeIfOff,\n        };\n    }\n\n    #optionsAllowExecution(\n        optionsMask: TypeFromPartialBitSchema<typeof ColorControl.Options>,\n        optionsOverride: TypeFromPartialBitSchema<typeof ColorControl.Options>,\n    ) {\n        const options = this.#calculateEffectiveOptions(optionsMask, optionsOverride);\n        return options.executeIfOff || !this.agent.has(OnOffServer) || this.agent.get(OnOffServer).state.onOff;\n    }\n\n    #initiateTransition(\n        transitionType: ManagedTransitionType,\n        changeRate: number,\n        minValue: number,\n        maxValue: number,\n        targetValue?: number,\n    ) {\n        let currentValue: number;\n        switch (transitionType) {\n            case \"hue\":\n                currentValue = this.state.currentHue;\n                break;\n            case \"enhancedHue\":\n                currentValue = this.state.enhancedCurrentHue;\n                break;\n            case \"saturation\":\n                currentValue = this.state.currentSaturation;\n                break;\n            case \"colorTemperature\":\n                currentValue = this.state.colorTemperatureMireds;\n                break;\n            case \"x\":\n                currentValue = this.state.currentX;\n                break;\n            case \"y\":\n                currentValue = this.state.currentY;\n                break;\n        }\n\n        let hueDistanceLeft: number | undefined = undefined;\n        let remainingTime = 0xffff; // Assume a looping for now, we adjust later\n        if (transitionType === \"enhancedHue\" || transitionType === \"hue\") {\n            if (targetValue !== undefined) {\n                const direction = changeRate > 0 ? ColorControl.Direction.Up : ColorControl.Direction.Down;\n                hueDistanceLeft = this.#getHueDistanceByDirection(currentValue, targetValue, direction, maxValue);\n                remainingTime = Math.floor(Math.ceil(hueDistanceLeft / changeRate) * 10);\n            }\n        } else {\n            if (changeRate > 0) {\n                remainingTime = Math.floor(Math.ceil((maxValue - currentValue) / changeRate) * 10);\n            } else {\n                remainingTime = Math.floor(Math.ceil((currentValue - minValue) / -changeRate) * 10);\n            }\n        }\n\n        const transitionData: TransitionData = {\n            changeRate,\n            targetValue,\n            minValue,\n            maxValue,\n            remainingTime,\n        };\n\n        logger.debug(`Starting ${transitionType} transition interval with stepSize: ${changeRate}.`);\n        switch (transitionType) {\n            case \"hue\":\n                this.internal.hueTransitionIntervalTimer?.stop();\n                this.internal.currentHueTransitionData = {\n                    ...transitionData,\n                    isEnhancedHue: false,\n                    distanceLeft: hueDistanceLeft !== undefined ? Math.abs(hueDistanceLeft) : undefined,\n                };\n                this.internal.hueTransitionIntervalTimer?.start();\n                break;\n            case \"enhancedHue\":\n                this.internal.hueTransitionIntervalTimer?.stop();\n                this.internal.currentHueTransitionData = {\n                    ...transitionData,\n                    isEnhancedHue: true,\n                    distanceLeft: hueDistanceLeft !== undefined ? Math.abs(hueDistanceLeft) : undefined,\n                };\n                this.internal.hueTransitionIntervalTimer?.start();\n                break;\n            case \"saturation\":\n                this.internal.saturationTransitionIntervalTimer?.stop();\n                this.internal.currentSaturationTransitionData = transitionData;\n                this.internal.saturationTransitionIntervalTimer?.start();\n                break;\n            case \"colorTemperature\":\n                this.internal.colorTemperatureTransitionIntervalTimer?.stop();\n                this.internal.currentColorTemperatureTransitionData = transitionData;\n                this.internal.colorTemperatureTransitionIntervalTimer?.start();\n                break;\n            case \"x\":\n                this.internal.xTransitionIntervalTimer?.stop();\n                this.internal.currentXTransitionData = transitionData;\n                this.internal.xTransitionIntervalTimer?.start();\n                break;\n            case \"y\":\n                this.internal.yTransitionIntervalTimer?.stop();\n                this.internal.currentYTransitionData = transitionData;\n                this.internal.yTransitionIntervalTimer?.start();\n                break;\n        }\n    }\n\n    #hueStepIntervalTick() {\n        const transitionData = this.internal.currentHueTransitionData;\n        this.#stepIntervalTick(\n            transitionData?.isEnhancedHue ? \"enhancedHue\" : \"hue\",\n            this.internal.hueTransitionIntervalTimer,\n            transitionData,\n            transitionData?.isEnhancedHue ? this.state.enhancedCurrentHue : this.state.currentHue,\n        );\n    }\n\n    #saturationStepIntervalTick() {\n        this.#stepIntervalTick(\n            \"saturation\",\n            this.internal.saturationTransitionIntervalTimer,\n            this.internal.currentSaturationTransitionData,\n            this.state.currentSaturation,\n        );\n    }\n\n    #colorTemperatureStepIntervalTick() {\n        this.#stepIntervalTick(\n            \"colorTemperature\",\n            this.internal.colorTemperatureTransitionIntervalTimer,\n            this.internal.currentColorTemperatureTransitionData,\n            this.state.colorTemperatureMireds,\n        );\n    }\n\n    #xStepIntervalTick() {\n        this.#stepIntervalTick(\n            \"x\",\n            this.internal.xTransitionIntervalTimer,\n            this.internal.currentXTransitionData,\n            this.state.currentX,\n        );\n    }\n\n    #yStepIntervalTick() {\n        this.#stepIntervalTick(\n            \"y\",\n            this.internal.yTransitionIntervalTimer,\n            this.internal.currentYTransitionData,\n            this.state.currentY,\n        );\n    }\n\n    #stepIntervalTick(\n        transitionType: ManagedTransitionType,\n        transitionTimer: Timer | undefined,\n        transitionData: TransitionData | undefined,\n        currentValue: number,\n    ) {\n        // Do some sanity checks to make sure we have a valid state\n        if (transitionData === undefined) {\n            transitionTimer?.stop();\n            return;\n        }\n        if (transitionTimer === undefined) {\n            transitionData.remainingTime = 0;\n            return;\n        }\n        if (\"isEnhancedHue\" in transitionData && transitionData.isEnhancedHue && transitionType !== \"enhancedHue\") {\n            throw new ImplementationError(\n                \"Transition data is for enhanced hue, but transition type is not enhanced hue\",\n            );\n        }\n\n        const { changeRate, targetValue, minValue, maxValue } = transitionData;\n\n        let newValue: number;\n        switch (transitionType) {\n            case \"hue\":\n            case \"enhancedHue\":\n                const maxHueRange = transitionType === \"hue\" ? MAX_HUE_VALUE : MAX_ENHANCED_HUE_VALUE;\n                // Hue is a circle, so we need to handle the wrap around\n                newValue = addValueWithOverflow(\n                    currentValue,\n                    changeRate,\n                    minValue ?? MIN_HUE_VALUE,\n                    maxValue ?? maxHueRange,\n                );\n                break;\n            case \"saturation\":\n                newValue = cropValueRange(\n                    currentValue + changeRate,\n                    minValue ?? MIN_SATURATION_VALUE,\n                    maxValue ?? MAX_SATURATION_VALUE,\n                );\n                break;\n            case \"colorTemperature\":\n                newValue = cropValueRange(\n                    currentValue + changeRate,\n                    minValue ?? this.minimumColorTemperatureMireds,\n                    maxValue ?? this.maximumColorTemperatureMireds,\n                );\n                break;\n            case \"x\":\n            case \"y\":\n                newValue = cropValueRange(\n                    currentValue + changeRate,\n                    minValue ?? MIN_CIE_XY_VALUE,\n                    maxValue ?? MAX_CIE_XY_VALUE,\n                );\n                break;\n            default:\n                throw new ImplementationError(`Unknown transition type: ${transitionType}`);\n        }\n\n        const isHueTransition = transitionType === \"hue\" || transitionType === \"enhancedHue\"; // min/max irrelevant here\n        if (isHueTransition) {\n            logger.info(\n                `Setting new value in ${transitionType} transition interval: ${newValue}, target: ${targetValue}, changeRate: ${changeRate}`,\n            );\n            let distanceLeft = (transitionData as HueTransitionData).distanceLeft;\n            if (targetValue !== undefined && distanceLeft !== undefined) {\n                distanceLeft -= Math.abs(changeRate);\n                if (distanceLeft <= 0) {\n                    logger.debug(`Stopping ${transitionType} transition interval at targetLevel: ${targetValue}.`);\n                    transitionTimer?.stop();\n                    transitionData.remainingTime = 0;\n                    newValue = targetValue;\n                } else {\n                    (transitionData as HueTransitionData).distanceLeft = distanceLeft;\n                }\n            }\n            if (transitionTimer.isRunning) {\n                logger.debug(\n                    `Setting new value in ${transitionType} transition interval: ${newValue} (distance left ${distanceLeft})`,\n                );\n\n                // There is no definition on how often the remaining time should be updated, so we update it with every step\n                if (distanceLeft === undefined) {\n                    // We loop on hue\n                    transitionData.remainingTime = 0xffff;\n                } else {\n                    transitionData.remainingTime = Math.floor(Math.ceil(distanceLeft / Math.abs(changeRate)) * 10);\n                }\n            }\n        } else {\n            if (minValue !== undefined && newValue === minValue) {\n                logger.debug(`Stopping ${transitionType} transition interval at minValue: ${minValue}.`);\n                transitionTimer?.stop();\n                transitionData.remainingTime = 0;\n            } else if (maxValue !== undefined && newValue === maxValue) {\n                logger.debug(`Stopping ${transitionType} transition interval at maxLevel: ${maxValue}.`);\n                transitionTimer?.stop();\n                transitionData.remainingTime = 0;\n            } else {\n                logger.info(\n                    `Setting new value in ${transitionType} transition interval: ${newValue}, target: ${targetValue}, changeRate: ${changeRate}`,\n                );\n\n                // Check if we reached the targetLevel if there is one\n                if (targetValue !== undefined) {\n                    if (changeRate > 0 && newValue >= targetValue) {\n                        logger.debug(`Stopping ${transitionType} transition interval at targetLevel: ${targetValue}.`);\n                        transitionTimer?.stop();\n                        transitionData.remainingTime = 0;\n                        newValue = targetValue;\n                    } else if (changeRate < 0 && newValue <= targetValue) {\n                        logger.debug(`Stopping ${transitionType} transition interval at targetLevel: ${targetValue}.`);\n                        transitionTimer?.stop();\n                        transitionData.remainingTime = 0;\n                        newValue = targetValue;\n                    }\n                }\n                if (transitionTimer.isRunning) {\n                    logger.debug(`Setting new value in ${transitionType} transition interval: ${newValue}`);\n\n                    // There is no definition on how often the remaining time should be updated, so we update it with every step\n                    if (targetValue === undefined) {\n                        // We loop on hue\n                        transitionData.remainingTime = 0xffff;\n                    } else if (changeRate > 0) {\n                        transitionData.remainingTime = Math.floor(\n                            Math.ceil(((targetValue ?? maxValue) - newValue) / changeRate) * 10,\n                        );\n                    } else {\n                        transitionData.remainingTime = Math.floor(\n                            Math.ceil((newValue - (targetValue ?? minValue)) / -changeRate) * 10,\n                        );\n                    }\n                }\n            }\n        }\n\n        switch (transitionType) {\n            case \"hue\":\n                this.state.currentHue = newValue;\n                break;\n            case \"enhancedHue\":\n                this.state.enhancedCurrentHue = newValue;\n                break;\n            case \"saturation\":\n                this.state.currentSaturation = newValue;\n                break;\n            case \"colorTemperature\":\n                this.state.colorTemperatureMireds = newValue;\n                break;\n            case \"x\":\n                this.state.currentX = newValue;\n                break;\n            case \"y\":\n                this.state.currentY = newValue;\n                break;\n        }\n        this.#setRemainingTime();\n    }\n\n    #returnAsXyValue(value: number) {\n        return value / 65536;\n    }\n\n    #returnAsOptionalXyValue(value: number | undefined) {\n        if (value === undefined) {\n            return undefined;\n        }\n        return this.#returnAsXyValue(value);\n    }\n\n    #setFromXyValue(fieldName: string, value: number | undefined) {\n        if (value === undefined) {\n            if ((this.state as any)[fieldName] === undefined) {\n                return;\n            } else {\n                throw new ImplementationError(`${fieldName} cannot be set to undefined while being enabled.`);\n            }\n        }\n        (this.state as any)[fieldName] = cropValueRange(Math.round(value * 65536), MIN_CIE_XY_VALUE, MAX_CIE_XY_VALUE);\n    }\n\n    override async [Symbol.asyncDispose]() {\n        this.internal.stopHueTransition();\n        this.internal.stopSaturationTransition();\n        this.internal.stopColorTemperatureTransition();\n        this.internal.stopXTransition();\n        this.internal.stopYTransition();\n        await super[Symbol.asyncDispose]?.();\n    }\n}\n\ntype TransitionData = {\n    changeRate: number;\n    targetValue?: number;\n    minValue: number;\n    maxValue: number;\n    remainingTime?: number;\n};\n\ntype HueTransitionData = TransitionData & {\n    isEnhancedHue: boolean;\n    distanceLeft?: number;\n};\n\nexport namespace ColorControlServerLogic {\n    export class Internal {\n        /** Timer for the managed hue transition */\n        hueTransitionIntervalTimer?: Timer;\n\n        /** Timer for the managed saturation transition */\n        saturationTransitionIntervalTimer?: Timer;\n\n        /** Timer for the managed colorTemperature transition */\n        colorTemperatureTransitionIntervalTimer?: Timer;\n\n        /** Timer for the managed x transition */\n        xTransitionIntervalTimer?: Timer;\n\n        /** Timer for the managed y transition */\n        yTransitionIntervalTimer?: Timer;\n\n        /** Structure to store the data of the current managed hue transition */\n        currentHueTransitionData?: HueTransitionData;\n\n        /** Structure to store the data of the current managed saturation transition */\n        currentSaturationTransitionData?: TransitionData;\n\n        /** Structure to store the data of the current managed color Temperature transition */\n        currentColorTemperatureTransitionData?: TransitionData;\n\n        /** Structure to store the data of the current managed x transition */\n        currentXTransitionData?: TransitionData;\n\n        /** Structure to store the data of the current managed y transition */\n        currentYTransitionData?: TransitionData;\n\n        stopHueTransition() {\n            this.hueTransitionIntervalTimer?.stop();\n            if (this.currentHueTransitionData !== undefined) {\n                this.currentHueTransitionData.remainingTime = 0;\n            }\n        }\n\n        stopSaturationTransition() {\n            this.saturationTransitionIntervalTimer?.stop();\n            if (this.currentSaturationTransitionData !== undefined) {\n                this.currentSaturationTransitionData.remainingTime = 0;\n            }\n        }\n\n        stopColorTemperatureTransition() {\n            this.colorTemperatureTransitionIntervalTimer?.stop();\n            if (this.currentColorTemperatureTransitionData !== undefined) {\n                this.currentColorTemperatureTransitionData.remainingTime = 0;\n            }\n        }\n\n        stopXTransition() {\n            this.xTransitionIntervalTimer?.stop();\n            if (this.currentXTransitionData !== undefined) {\n                this.currentXTransitionData.remainingTime = 0;\n            }\n        }\n\n        stopYTransition() {\n            this.yTransitionIntervalTimer?.stop();\n            if (this.currentYTransitionData !== undefined) {\n                this.currentYTransitionData.remainingTime = 0;\n            }\n        }\n    }\n\n    export class State extends ColorControlServerBase.State {\n        /**\n         * The default implementation always set the target level immediately and so ignores all transition times\n         * requested or configured.\n         * Set this to true to manage transition times by changing the level value step wise every second. This is in\n         * most cases not the best way because hardware supporting levels usually have ways to specify the change rate\n         * or target value and transition time.\n         */\n        managedTransitionTimeHandling = false;\n    }\n\n    export declare const ExtensionInterface: {\n        moveToHueLogic(\n            targetHue: number,\n            direction: ColorControl.Direction,\n            transitionTime: number,\n            isEnhancedHue: boolean,\n        ): MaybePromise;\n        moveHueLogic(moveMode: ColorControl.MoveMode, rate: number, isEnhancedHue: boolean): MaybePromise;\n        stopHueAndSaturationMovement(): MaybePromise;\n        stepHueLogic(\n            stepMode: ColorControl.StepMode,\n            stepSize: number,\n            transitionTime: number,\n            isEnhancedHue: boolean,\n        ): MaybePromise;\n        moveToSaturationLogic(targetSaturation: number, transitionTime: number): MaybePromise;\n        moveSaturationLogic(moveMode: ColorControl.MoveMode, rate: number): MaybePromise;\n        stepSaturationLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number): MaybePromise;\n        moveToHueAndSaturationLogic(targetHue: number, targetSaturation: number, transitionTime: number): MaybePromise;\n        moveToColorLogic(targetX: number, targetY: number, transitionTime: number): MaybePromise;\n        stopAllColorMovement(): MaybePromise;\n        moveColorLogic(rateX: number, rateY: number): MaybePromise;\n        stepColorLogic(stepX: number, stepY: number, transitionTime: number): MaybePromise;\n        moveToColorTemperatureLogic(targetMireds: number, transitionTime: number): MaybePromise;\n        moveToEnhancedHueAndSaturationLogic(\n            targetEnhancedHue: number,\n            targetSaturation: number,\n            transitionTime: number,\n        ): MaybePromise;\n        stopColorLoopLogic(): MaybePromise;\n        startColorLoopLogic(startHue: number): MaybePromise;\n        stopMoveStepLogic(): MaybePromise;\n        moveColorTemperatureLogic(\n            moveMode: ColorControl.MoveMode,\n            rate: number,\n            colorTemperatureMinimumMireds: number,\n            colorTemperatureMaximumMireds: number,\n        ): MaybePromise;\n        stepColorTemperatureLogic(\n            stepMode: ColorControl.StepMode,\n            stepSize: number,\n            transitionTime: number,\n            colorTemperatureMinimumMireds: number,\n            colorTemperatureMaximumMireds: number,\n        ): MaybePromise;\n        switchColorMode(oldMode: ColorControl.ColorMode, newMode: ColorControl.ColorMode): MaybePromise;\n        setColorMode(mode: ColorControl.ColorMode): MaybePromise;\n        setEnhancedColorMode(mode: ColorControl.EnhancedColorMode): MaybePromise;\n        syncColorTemperatureWithLevelLogic(level: number): MaybePromise;\n    };\n}\n\n// We had turned on some more features to provide a default implementation, but export the cluster with default\n// Features again.\nexport class ColorControlServer extends ColorControlServerLogic.for(ClusterType(ColorControl.Base)) {}\n"],
  "mappings": "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",
  "names": ["ColorControlServerLogic"]
}
