{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/administrator-commissioning/AdministratorCommissioningServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterDevice } from \"../../../MatterDevice.js\";\nimport { AccessLevel, Command, TlvNoResponse } from \"../../../cluster/Cluster.js\";\nimport { AdministratorCommissioning } from \"../../../cluster/definitions/AdministratorCommissioningCluster.js\";\nimport { FailsafeContext } from \"../../../common/FailsafeContext.js\";\nimport { InternalError } from \"../../../common/MatterError.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { PaseServer } from \"../../../session/pase/PaseServer.js\";\nimport { Time, Timer } from \"../../../time/Time.js\";\nimport { TlvUInt16, TlvUInt32 } from \"../../../tlv/TlvNumber.js\";\nimport { TlvField, TlvObject } from \"../../../tlv/TlvObject.js\";\nimport { TlvByteString } from \"../../../tlv/TlvString.js\";\nimport { NetworkServer } from \"../../system/network/NetworkServer.js\";\nimport { AdministratorCommissioningBehavior } from \"./AdministratorCommissioningBehavior.js\";\nimport {\n    MAXIMUM_COMMISSIONING_TIMEOUT_S,\n    MINIMUM_COMMISSIONING_TIMEOUT_S,\n    PAKE_PASSCODE_VERIFIER_LENGTH,\n} from \"./AdministratorCommissioningConstants.js\";\n\n/**\n * Monkey patching Tlv Structure of openCommissioningWindow command to prevent data validation of the fields to be\n * handled as ConstraintError because we need to return a special error.\n * We do this to leave the model in fact for other validations and only apply the change for our Schema-aware Tlv parsing.\n */\nAdministratorCommissioning.Cluster.commands = {\n    ...AdministratorCommissioning.Cluster.commands,\n    openCommissioningWindow: Command(\n        0x0,\n        TlvObject({\n            commissioningTimeout: TlvField(0, TlvUInt16),\n            pakePasscodeVerifier: TlvField(1, TlvByteString),\n            discriminator: TlvField(2, TlvUInt16.bound({ max: 4095 })),\n            iterations: TlvField(3, TlvUInt32),\n            salt: TlvField(4, TlvByteString),\n        }),\n        0x0,\n        TlvNoResponse,\n        {\n            invokeAcl: AccessLevel.Administer,\n            timed: true,\n        },\n    ),\n};\n\nconst logger = Logger.get(\"AdministratorCommissioningServer\");\n\n/**\n * This is the default server implementation of AdministratorCommissioningBehavior.\n *\n * This implementation includes all features of AdministratorCommissioning.Cluster. You should use\n * AdministratorCommissioningServer.with to specialize the class for the features your implementation supports.\n */\nexport class AdministratorCommissioningServer extends AdministratorCommissioningBehavior {\n    declare internal: AdministratorCommissioningServer.Internal;\n    declare state: AdministratorCommissioningServer.State;\n\n    /**\n     * This method opens an Enhanced Commissioning Window (A dynamic passcode is used which was provided by the caller).\n     */\n    override async openCommissioningWindow({\n        pakePasscodeVerifier,\n        discriminator,\n        iterations,\n        salt,\n        commissioningTimeout,\n    }: AdministratorCommissioning.OpenCommissioningWindowRequest) {\n        // We monkey patched the Tlv definition above, so take care about correct error handling\n        if (pakePasscodeVerifier.length !== PAKE_PASSCODE_VERIFIER_LENGTH) {\n            throw new StatusResponseError(\n                \"PAKE Passcode verifier length is invalid.\",\n                StatusCode.Failure,\n                AdministratorCommissioning.StatusCode.PakeParameterError,\n            );\n        }\n        if (iterations < 1000 || iterations > 100_000) {\n            throw new StatusResponseError(\n                \"PAKE iterations invalid.\",\n                StatusCode.Failure,\n                AdministratorCommissioning.StatusCode.PakeParameterError,\n            );\n        }\n        if (salt.length < 16 || salt.length > 32) {\n            throw new StatusResponseError(\n                \"PAKE salt has invalid length.\",\n                StatusCode.Failure,\n                AdministratorCommissioning.StatusCode.PakeParameterError,\n            );\n        }\n\n        const device = this.session?.context;\n\n        this.#assertCommissioningWindowRequirements(commissioningTimeout, device);\n\n        this.#initializeCommissioningWindow(\n            commissioningTimeout,\n            AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen,\n        );\n\n        await device.allowEnhancedCommissioning(\n            discriminator,\n            PaseServer.fromVerificationValue(pakePasscodeVerifier, { iterations, salt }),\n            this.callback(this.#endCommissioning),\n        );\n    }\n\n    /** This method opens a Basic Commissioning Window. The default passcode is used. */\n    async openBasicCommissioningWindow({\n        commissioningTimeout,\n    }: AdministratorCommissioning.OpenBasicCommissioningWindowRequest) {\n        const device = this.session.context;\n\n        this.#assertCommissioningWindowRequirements(commissioningTimeout, device);\n\n        this.#initializeCommissioningWindow(\n            commissioningTimeout,\n            AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen,\n        );\n\n        await device.allowBasicCommissioning(this.callback(this.#endCommissioning));\n    }\n\n    /** This method is used to revoke a commissioning window. */\n    override async revokeCommissioning() {\n        if (this.internal.commissioningWindowTimeout === undefined) {\n            throw new StatusResponseError(\n                \"No commissioning window is opened that could be revoked.\",\n                StatusCode.Failure,\n                AdministratorCommissioning.StatusCode.WindowNotOpen,\n            );\n        }\n\n        logger.debug(\"Revoking commissioning window.\");\n\n        await this.#closeCommissioningWindow();\n\n        if (this.endpoint.env.has(FailsafeContext)) {\n            const failsafeContext = this.endpoint.env.get(FailsafeContext);\n            if (failsafeContext) {\n                await failsafeContext.close();\n            }\n        }\n    }\n\n    /**\n     * Called whenever a Commissioning/Announcement Window is opened by this cluster. This method starts the timer and\n     * adjusts the needed attributes.\n     */\n    #initializeCommissioningWindow(\n        commissioningTimeout: number,\n        windowStatus: AdministratorCommissioning.CommissioningWindowStatus,\n    ) {\n        if (this.internal.commissioningWindowTimeout !== undefined) {\n            // Should never happen, but let's make sure\n            throw new InternalError(\"Commissioning window already initialized.\");\n        }\n        logger.debug(\n            `Commissioning window timer started for ${commissioningTimeout} seconds for ${this.context.session?.name}.`,\n        );\n        this.internal.commissioningWindowTimeout = Time.getTimer(\n            \"Commissioning timeout\",\n            commissioningTimeout * 1000,\n            this.callback(this.#commissioningTimeout),\n        ).start();\n\n        const adminFabric = this.session.associatedFabric;\n\n        this.state.windowStatus = windowStatus;\n        this.state.adminFabricIndex = adminFabric.fabricIndex;\n        this.state.adminVendorId = adminFabric.rootVendorId;\n\n        const removeCallback = this.callback(this.#fabricRemovedCallback);\n\n        this.internal.stopMonitoringFabricForRemoval = () => {\n            adminFabric.deleteRemoveCallback(removeCallback);\n        };\n\n        this.session.associatedFabric.addRemoveCallback(removeCallback);\n    }\n\n    /**\n     * This method validates if a commissioning window can be opened and throws various exceptions in case of failures.\n     */\n    #assertCommissioningWindowRequirements(commissioningTimeout: number, device: MatterDevice) {\n        if (this.internal.commissioningWindowTimeout !== undefined) {\n            throw new StatusResponseError(\n                \"A commissioning window is already opened.\",\n                StatusCode.Failure,\n                AdministratorCommissioning.StatusCode.Busy,\n            );\n        }\n\n        if (commissioningTimeout > MAXIMUM_COMMISSIONING_TIMEOUT_S) {\n            throw new StatusResponseError(\n                `Commissioning timeout must not exceed ${MAXIMUM_COMMISSIONING_TIMEOUT_S} seconds.`,\n                StatusCode.InvalidCommand,\n            );\n        }\n\n        if (commissioningTimeout < MINIMUM_COMMISSIONING_TIMEOUT_S) {\n            throw new StatusResponseError(\n                `Commissioning timeout must not be lower then ${MINIMUM_COMMISSIONING_TIMEOUT_S} seconds.`,\n                StatusCode.InvalidCommand,\n            );\n        }\n\n        if (device.isFailsafeArmed()) {\n            throw new StatusResponseError(\n                \"Failsafe timer armed, assume commissioning in progress.\",\n                StatusCode.Failure,\n                AdministratorCommissioning.StatusCode.Busy,\n            );\n        }\n    }\n\n    /**\n     * This method is used internally when the commissioning window timer expires or the commissioning was completed.\n     */\n    #endCommissioning() {\n        logger.debug(\"End commissioning window.\");\n        if (this.internal.commissioningWindowTimeout !== undefined) {\n            this.internal.commissioningWindowTimeout.stop();\n            this.internal.commissioningWindowTimeout = undefined;\n        }\n\n        this.internal.stopMonitoringFabricForRemoval?.();\n        this.state.adminFabricIndex = null;\n\n        this.state.windowStatus = AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;\n        this.state.adminFabricIndex = null;\n        this.state.adminVendorId = null;\n    }\n\n    /**\n     * Closes the commissioning window per the matter specification.\n     */\n    async #closeCommissioningWindow() {\n        this.callback(this.#endCommissioning);\n        await this.agent.get(NetworkServer).endCommissioning();\n    }\n\n    /**\n     * Close commissioning window on timeout when there's nobody to await the resulting promise\n     * */\n    #commissioningTimeout() {\n        this.endpoint.env.runtime.add(this.#closeCommissioningWindow());\n    }\n\n    /**\n     * Invoked when fabric is removed.\n     */\n    #fabricRemovedCallback() {\n        this.state.adminFabricIndex = null;\n        this.internal.stopMonitoringFabricForRemoval?.();\n    }\n\n    /**\n     * Clean up resources and stop the timer when the behavior is destroyed.\n     */\n    override [Symbol.asyncDispose]() {\n        if (this.internal.commissioningWindowTimeout !== undefined) {\n            this.internal.commissioningWindowTimeout.stop();\n            this.internal.commissioningWindowTimeout = undefined;\n        }\n    }\n}\n\nexport namespace AdministratorCommissioningServer {\n    export class Internal {\n        commissioningWindowTimeout?: Timer;\n        stopMonitoringFabricForRemoval?: () => void;\n    }\n\n    export class State extends AdministratorCommissioningBehavior.State {\n        // Spec doesn't declare a default here so set manually\n        override windowStatus = AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;\n    }\n}\n"],
  "mappings": "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",
  "names": ["AdministratorCommissioningServer"]
}
