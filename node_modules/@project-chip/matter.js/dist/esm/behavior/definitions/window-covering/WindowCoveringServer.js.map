{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/window-covering/WindowCoveringServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterType } from \"../../../cluster/ClusterType.js\";\nimport { WindowCovering } from \"../../../cluster/definitions/WindowCoveringCluster.js\";\nimport { ImplementationError } from \"../../../common/MatterError.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { TypeFromPartialBitSchema } from \"../../../schema/BitmapSchema.js\";\nimport { isDeepEqual } from \"../../../util/DeepEqual.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { WindowCoveringBehavior } from \"./WindowCoveringBehavior.js\";\n\nconst logger = Logger.get(\"WindowCoveringServer\");\n\nconst WindowCoveringServerBase = WindowCoveringBehavior.with(\n    WindowCovering.Feature.Lift,\n    WindowCovering.Feature.Tilt,\n    WindowCovering.Feature.PositionAwareLift,\n    WindowCovering.Feature.PositionAwareTilt,\n    WindowCovering.Feature.AbsolutePosition,\n);\n\n/** What element should move? */\nexport enum MovementType {\n    Lift,\n    Tilt,\n}\n\n/** Status of the Calibration mode. */\nexport enum CalibrationMode {\n    Enabled,\n    Running,\n    Disabled,\n}\n\n/**\n * Direction the Window covering should move.\n * The special state \"DefinedByPosition\" is used to indicate that the direction should be determined by the target\n * position and the implementation needs to determine it himself.\n */\nexport enum MovementDirection {\n    Open,\n    Close,\n    DefinedByPosition,\n}\n\ntype AbsoluteLimits = {\n    open: number;\n    closed: number;\n};\n\nconst WC_PERCENT100THS_MIN_OPEN = 0;\nconst WC_PERCENT100THS_MAX_CLOSED = 10000;\nconst WC_PERCENT100THS_COEFFICIENT = 100;\n\n/**\n * This is the default server implementation of {@link WindowCoveringBehavior}.\n *\n * This implementation includes all features of {@link WindowCovering.Cluster} and implements all mandatory commands.\n * You should use {@link WindowCoveringServer.with} to specialize the class for the features your implementation\n * supports.\n *\n * If you enable position awareness (positionAware* features), the default logic automatically syncs current positions\n * and operational state when the currentPosition*Percent100ths attributes change. You should update\n * currentPosition*Percent100ths with the actual position from your device.  This updates other attributes\n * automatically.\n *\n * When targetPosition*Percent100ths attributes change, operational state updates bases on the current and target\n * values.\n *\n * If you do not override {@link handleMovement} the default implementation updates current position to the target\n * position immediately.\n *\n * In addition to Matter attributes, {@link WindowCoveringServerLogic.State} includes the following configuration\n * properties:\n *\n *   * supportsCalibration (default false): Set to true if the device supports calibration. You must implement\n *     {@link WindowCoveringServerLogic.executeCalibration} to perform actual calibration.\n *\n *   * supportsMaintenanceMode (default true): Set to false if the device has no maintenance mode\n *\n * When developing for specific hardware you should extend {@link WindowCoveringServer} and implement the following\n * methods to map movement to your device. The default implementation maps Matter commands to these methods. The benefit\n * of this structure is that basic data validations and option checks are already done and you can focus on the actual\n * hardware interaction:\n *\n *   * {@link WindowCoveringServerLogic.handleMovement} Logic to actually move the device. Via Parameters the movement\n *     type (Lift/Tilt), direction, target percentage and information if motor is configured reversed are provided. When\n *     the device moves the current Positions (if supported by the device) are updated with the movement. The\n *     operational state is automatically updated by the default implementation based on current and target values of\n *     the cluster state.\n *\n *   * {@link WindowCoveringServerLogic.handleStopMovement} Logic to stop any movement of the device. You can use the\n *     super.handleStopMovement() to set the target positions to the current positions or do this yourself.\n *\n *   * {@link WindowCoveringServerLogic.executeCalibration} If supported, override this method to implement the\n *     calibration process. The default implementation returns an error to indicate calibration is unsupported. If\n *     unsupported you should also add a Changing event handler to the mode attribute to ensure calibration mode is not\n *     set (needs to throw an ConstraintError).\n *\n * IMPORTANT NOTE:\n *\n * This default implementation could have pitfalls when the calibration process and/or movement is handled via long\n * running promises. There could be edge cases not correctly handled by the current implementation when it comes to long\n * running movements or calibration processes - especially when these processes are long running async JS operations.\n *\n * A movement coming in while another movement is still running is assumed to be handled by the device. It is not\n * handled here. If this causes you trouble please provide feedback and we can discuss how to improve the default\n * implementation.\n */\nexport class WindowCoveringServerLogic extends WindowCoveringServerBase {\n    protected declare internal: WindowCoveringServerLogic.Internal;\n    declare state: WindowCoveringServerLogic.State;\n\n    override initialize() {\n        // Initialize Internal state from the Mode attribute and keep in sync\n        this.internal.inMaintenanceMode = !!this.state.mode.maintenanceMode;\n        this.internal.calibrationMode =\n            this.state.mode.calibrationMode && !this.state.mode.maintenanceMode\n                ? CalibrationMode.Enabled\n                : CalibrationMode.Disabled;\n        this.reactTo(this.events.mode$Changing, this.#handleModeChanging);\n\n        // Sync ConfigStatus with features ans set mode to operational if not in maintenance or calibration\n        const configStatus = this.state.configStatus;\n        configStatus.operational = !this.internal.inMaintenanceMode && !this.state.mode.calibrationMode;\n        if (this.features.lift) {\n            if (this.features.positionAwareLift) {\n                configStatus.liftPositionAware = true;\n            }\n        }\n        if (this.features.tilt) {\n            if (this.features.positionAwareTilt) {\n                configStatus.tiltPositionAware = true;\n            }\n        }\n        if (!isDeepEqual(configStatus, this.state.configStatus)) {\n            this.state.configStatus = configStatus;\n        }\n\n        // Initially sync the target positions with the current positions, so we have no movement\n        if (this.features.tilt) {\n            this.state.targetPositionTiltPercent100ths = this.state.currentPositionTiltPercent100ths;\n        }\n        if (this.features.lift) {\n            this.state.targetPositionLiftPercent100ths = this.state.currentPositionLiftPercent100ths;\n        }\n\n        // Keep position attributes (percentage and also absolute position) and operational state in sync\n        this.reactTo(this.events.currentPositionLiftPercent100ths$Changing, this.#syncLiftCurrentPositions);\n        this.reactTo(this.events.currentPositionTiltPercent100ths$Changing, this.#syncTiltCurrentPositions);\n\n        // Update operational state when target position changes\n        this.reactTo(this.events.targetPositionLiftPercent100ths$Changing, this.#handleLiftTargetPositionChanging);\n        this.reactTo(this.events.targetPositionTiltPercent100ths$Changing, this.#handleTiltTargetPositionChanging);\n\n        // Update the global operational status when lift or tilt status changes\n        this.reactTo(this.events.operationalStatus$Changing, this.#handleOperationalStatusChanging);\n    }\n\n    /**\n     * Sync the mode attribute with the configStatus attribute and the internal state.\n     */\n    #handleModeChanging(mode: TypeFromPartialBitSchema<typeof WindowCovering.Mode>) {\n        // According to chip implementation maintenance mode has priority over calibration mode\n        if (mode.maintenanceMode && mode.calibrationMode) {\n            mode.calibrationMode = false;\n        }\n        if (mode.maintenanceMode && !this.state.supportsMaintenanceMode) {\n            throw new StatusResponseError(\"Maintenance mode not supported\", StatusCode.ConstraintError);\n        }\n        this.internal.inMaintenanceMode = !!mode.maintenanceMode;\n\n        if (mode.calibrationMode) {\n            if (!this.state.supportsCalibration) {\n                throw new StatusResponseError(\"Calibration not supported\", StatusCode.ConstraintError);\n            }\n            if (this.internal.calibrationMode === CalibrationMode.Running) {\n                // What to do here? For now lets leave unchanged\n            } else {\n                this.internal.calibrationMode = CalibrationMode.Enabled;\n            }\n        } else {\n            this.internal.calibrationMode = CalibrationMode.Disabled;\n        }\n\n        const configStatus = this.state.configStatus;\n        configStatus.operational = !mode.maintenanceMode || (mode.calibrationMode && !this.state.supportsCalibration);\n        configStatus.liftMovementReversed = !!mode.motorDirectionReversed;\n        if (isDeepEqual(configStatus, this.state.configStatus)) {\n            this.asAdmin(() => {\n                this.state.configStatus = configStatus;\n            });\n        }\n\n        logger.debug(\n            `Mode changed to ${Logger.toJSON(mode)} and config status to ${Logger.toJSON(configStatus)} and internal calibration mode to ${this.internal.calibrationMode}`,\n        );\n    }\n\n    /** Update the global operational status based on the lift or tilt status. */\n    #handleOperationalStatusChanging(\n        operationalStatus: TypeFromPartialBitSchema<typeof WindowCovering.OperationalStatus>,\n    ) {\n        // Global tracks lift if moving otherwise it follows tilt\n        const globalStatus =\n            operationalStatus.lift !== WindowCovering.MovementStatus.Stopped\n                ? operationalStatus.lift\n                : operationalStatus.tilt;\n        operationalStatus.global = globalStatus;\n        logger.debug(\n            `Operational status changed to ${Logger.toJSON(operationalStatus)} with new global status ${globalStatus}`,\n        );\n        this.state.operationalStatus = operationalStatus;\n    }\n\n    /** Update the operational state when the target lift position changes. */\n    #handleLiftTargetPositionChanging(percent100ths: number | null) {\n        if (this.features.positionAwareLift) {\n            this.state.operationalStatus.lift = this.#computeOperationalState(\n                percent100ths,\n                this.state.currentPositionLiftPercent100ths,\n            );\n        }\n    }\n\n    /** Update the operational state when the target tilt position changes. */\n    #handleTiltTargetPositionChanging(percent100ths: number | null) {\n        if (this.features.positionAwareTilt) {\n            this.state.operationalStatus.tilt = this.#computeOperationalState(\n                percent100ths,\n                this.state.currentPositionTiltPercent100ths,\n            );\n        }\n    }\n\n    /** Sync the current lift position attributes and the operational state. */\n    #syncLiftCurrentPositions(percent100ths: number | null) {\n        if (this.features.positionAwareLift) {\n            this.state.currentPositionLiftPercentage =\n                percent100ths === null ? percent100ths : Math.floor(percent100ths / WC_PERCENT100THS_COEFFICIENT);\n            if (\n                this.state.operationalStatus.lift !== WindowCovering.MovementStatus.Stopped &&\n                percent100ths === this.state.targetPositionLiftPercent100ths\n            ) {\n                this.state.operationalStatus.lift = WindowCovering.MovementStatus.Stopped;\n                logger.debug(\"Lift movement stopped, target value reached\");\n            }\n        }\n        if (this.features.absolutePosition) {\n            this.state.currentPositionLift = percent100ths === null ? null : this.#percent100thsToLift(percent100ths);\n        }\n        logger.debug(\n            `Syncing lift position ${this.state.currentPositionLiftPercent100ths === null ? null : (this.state.currentPositionLiftPercent100ths / 100).toFixed(2)} to ${this.state.currentPositionLiftPercentage}% (${this.state.currentPositionLift})`,\n        );\n    }\n\n    /** Sync the current tilt position attributes and the operational state. */\n    #syncTiltCurrentPositions(percent100ths: number | null) {\n        if (this.features.positionAwareTilt) {\n            this.state.currentPositionTiltPercentage =\n                percent100ths === null ? percent100ths : Math.floor(percent100ths / WC_PERCENT100THS_COEFFICIENT);\n            if (\n                this.state.operationalStatus.tilt !== WindowCovering.MovementStatus.Stopped &&\n                percent100ths === this.state.targetPositionTiltPercent100ths\n            ) {\n                this.state.operationalStatus.tilt = WindowCovering.MovementStatus.Stopped;\n                logger.debug(\"Tilt movement stopped, target value reached\");\n            }\n        }\n        if (this.features.absolutePosition) {\n            this.state.currentPositionTilt = percent100ths === null ? null : this.#percent100thsToTilt(percent100ths);\n        }\n        logger.debug(\n            `Syncing tilt position ${this.state.currentPositionTiltPercent100ths === null ? null : (this.state.currentPositionTiltPercent100ths / 100).toFixed(2)} to ${this.state.currentPositionTiltPercentage}% (${this.state.currentPositionTilt})`,\n        );\n    }\n\n    /** Compute the operational state based on the current and target position. */\n    #computeOperationalState(target: number | null, current: number | null) {\n        if (current === null || target === null) {\n            return WindowCovering.MovementStatus.Stopped;\n        } else if (current === target) {\n            return WindowCovering.MovementStatus.Stopped;\n        } else if (current < target) {\n            return WindowCovering.MovementStatus.Closing;\n        } else {\n            return WindowCovering.MovementStatus.Opening;\n        }\n    }\n\n    /**\n     * Asserts if the device can be controlled or not because of an active Maintenance mode or a calibration is\n     * required but not supported.\n     */\n    #assertMotionLockStatus() {\n        if (this.internal.inMaintenanceMode) {\n            throw new StatusResponseError(\"Device is in maintenance mode\", StatusCode.Busy);\n        }\n\n        switch (this.internal.calibrationMode) {\n            case CalibrationMode.Enabled:\n                if (!this.state.supportsCalibration) {\n                    // Should never happy normally because mode attribute should never be set\n                    throw new StatusResponseError(\"Calibration not implemented\", StatusCode.Failure);\n                }\n                break;\n            case CalibrationMode.Running:\n                // Calibration already in progress, not defined what to return here\n                break;\n            case CalibrationMode.Disabled:\n                break;\n        }\n\n        if (!this.state.configStatus.operational) {\n            throw new StatusResponseError(\"Device is not operational\", StatusCode.Failure);\n        }\n    }\n\n    /**\n     * Calibrate the device.  The default implementation takes no action. Override to implement calibration if\n     * necessary.\n     *\n     * @protected\n     */\n    protected executeCalibration(): MaybePromise {}\n\n    /**\n     * Perform actual \"movement\".  Override to initiate movement of your device.\n     *\n     * The default implementation logs and immediately updates current position to the target positions.  This is\n     * probably not desirable for a real device so do not invoke `super.handleMovement()` from your implementation.\n     *\n     * @param type Which element should move, Lift or Tilt\n     * @param reversed If the motor is configured reversed\n     * @param direction The direction of the movement (Open, Close, DefinedByPosition)\n     * @param targetPercent100ths Optionally the target position in percent 100ths. It depends on the used feature set\n     * of the cluster if this is provided or not.\n     *\n     * @protected\n     */\n    protected async handleMovement(\n        type: MovementType,\n        reversed: boolean,\n        direction: MovementDirection,\n        targetPercent100ths?: number,\n    ) {\n        switch (type) {\n            case MovementType.Lift:\n                if (this.features.positionAwareLift) {\n                    if (targetPercent100ths === undefined) {\n                        throw new ImplementationError(\"Target position must be defined for position aware lift\");\n                    }\n                    this.state.currentPositionLiftPercent100ths = targetPercent100ths;\n                }\n                break;\n\n            case MovementType.Tilt:\n                if (this.features.positionAwareTilt) {\n                    if (targetPercent100ths === undefined) {\n                        throw new ImplementationError(\"Target position must be defined for position aware lift\");\n                    }\n                    this.state.currentPositionTiltPercent100ths = targetPercent100ths;\n                }\n                break;\n        }\n        const directionInfo =\n            direction === MovementDirection.DefinedByPosition\n                ? ` in direction by position`\n                : ` in direction ${direction === MovementDirection.Close ? \"Close\" : \"Open\"}`;\n        const targetInfo =\n            targetPercent100ths === undefined ? \"\" : ` to target position ${(targetPercent100ths / 100).toFixed(2)}`;\n        logger.debug(\n            `Moving the device ${type === MovementType.Lift ? \"Lift\" : \"Tilt\"}${directionInfo} (reversed=${reversed})${targetInfo}`,\n        );\n    }\n\n    /**\n     * Handle a movement. If calibration is supported and needed then {@link executeCalibration} runs before the actual\n     * movement. The method increases the numberOfActuations* attribute and updates the operational status.\n     *\n     * Actual movement occurs in {@link handleMovement} as a worker. Thus this method returns before actual movement\n     * completes.\n     */\n    #prepareMovement(type: MovementType, direction: MovementDirection, targetPercent100ths?: number): void {\n        if (this.state.supportsCalibration && this.internal.calibrationMode === CalibrationMode.Enabled) {\n            return this.endpoint.env.runtime.add(this.#executeCalibrationAndMove(type, direction, targetPercent100ths));\n        }\n        if (type === MovementType.Lift && this.state.configStatus.liftMovementReversed) {\n            logger.debug(\"Lift movement is reversed\");\n        }\n\n        switch (type) {\n            case MovementType.Lift:\n                this.state.numberOfActuationsLift = (this.state.numberOfActuationsLift ?? 0) + 1;\n                if (\n                    this.features.positionAwareLift &&\n                    direction === MovementDirection.DefinedByPosition &&\n                    targetPercent100ths !== undefined &&\n                    this.state.currentPositionLiftPercent100ths !== null\n                ) {\n                    direction =\n                        targetPercent100ths > this.state.currentPositionLiftPercent100ths\n                            ? MovementDirection.Close\n                            : MovementDirection.Open;\n                }\n                if (direction !== MovementDirection.DefinedByPosition) {\n                    this.state.operationalStatus.lift =\n                        direction === MovementDirection.Close\n                            ? WindowCovering.MovementStatus.Closing\n                            : WindowCovering.MovementStatus.Opening;\n                }\n                break;\n\n            case MovementType.Tilt:\n                this.state.numberOfActuationsTilt = (this.state.numberOfActuationsTilt ?? 0) + 1;\n                if (\n                    this.features.positionAwareLift &&\n                    direction === MovementDirection.DefinedByPosition &&\n                    targetPercent100ths !== undefined &&\n                    this.state.currentPositionTiltPercent100ths !== null\n                ) {\n                    direction =\n                        targetPercent100ths > this.state.currentPositionTiltPercent100ths\n                            ? MovementDirection.Close\n                            : MovementDirection.Open;\n                }\n                if (direction !== MovementDirection.DefinedByPosition) {\n                    this.state.operationalStatus.tilt =\n                        direction === MovementDirection.Close\n                            ? WindowCovering.MovementStatus.Closing\n                            : WindowCovering.MovementStatus.Opening;\n                }\n                break;\n        }\n\n        this.endpoint.env.runtime.add(\n            this.handleMovement(\n                type,\n                type === MovementType.Lift && !!this.state.configStatus.liftMovementReversed,\n                direction,\n                targetPercent100ths,\n            ),\n        );\n    }\n\n    #executeCalibrationAndMove(type: MovementType, direction: MovementDirection, targetPercent100ths?: number) {\n        let calibration;\n        if (this.internal.calibrationMode === CalibrationMode.Enabled && this.state.supportsCalibration) {\n            this.internal.calibrationMode = CalibrationMode.Running;\n            calibration = this.executeCalibration();\n        }\n        return MaybePromise.then(calibration, () => {\n            this.internal.calibrationMode = CalibrationMode.Disabled;\n            return this.#prepareMovement(type, direction, targetPercent100ths);\n        });\n    }\n\n    /**\n     * Stop device movement.  Sets the target position to the current position and updates operational state. Override\n     * to implement the actual stop movement logic.\n     *\n     * If you update the current positions you can include the default logic via \"super.handleStopMovement()\".\n     *\n     * @protected\n     */\n    protected handleStopMovement(): MaybePromise {\n        if (this.features.positionAwareLift) {\n            this.state.targetPositionLiftPercent100ths = this.state.currentPositionLiftPercent100ths;\n        }\n        if (this.features.positionAwareTilt) {\n            this.state.targetPositionTiltPercent100ths = this.state.currentPositionTiltPercent100ths;\n        }\n        if (!this.features.positionAwareLift && !this.features.positionAwareTilt) {\n            this.state.operationalStatus = {\n                global: WindowCovering.MovementStatus.Stopped,\n                lift: WindowCovering.MovementStatus.Stopped,\n                tilt: WindowCovering.MovementStatus.Stopped,\n            };\n        }\n    }\n\n    #triggerLiftMotion(direction: MovementDirection, targetPercent100ths?: number) {\n        this.#prepareMovement(0 /* Lift */, direction, targetPercent100ths);\n    }\n\n    #triggerTiltMotion(direction: MovementDirection, targetPercent100ths?: number) {\n        this.#prepareMovement(1 /* Tilt */, direction, targetPercent100ths);\n    }\n\n    /**\n     * Move the WindowCovering up or open. For position aware devices the target position is set to 0%. The method calls\n     * the handleMovement method to actually move the device.\n     */\n    override upOrOpen() {\n        this.#assertMotionLockStatus();\n\n        let targetLiftPercent100ths;\n        let targetTiltPercent100ths;\n        if (this.features.positionAwareLift) {\n            this.state.targetPositionLiftPercent100ths = targetLiftPercent100ths = WC_PERCENT100THS_MIN_OPEN;\n        }\n        if (this.features.positionAwareTilt) {\n            this.state.targetPositionTiltPercent100ths = targetTiltPercent100ths = WC_PERCENT100THS_MIN_OPEN;\n        }\n\n        if (this.features.lift) {\n            this.#triggerLiftMotion(MovementDirection.Open, targetLiftPercent100ths);\n        }\n        if (this.features.tilt) {\n            this.#triggerTiltMotion(MovementDirection.Open, targetTiltPercent100ths);\n        }\n    }\n\n    /**\n     * Move the WindowCovering down or close. For position aware devices the target position is set to 100%. The method\n     * calls the handleMovement method to actually move the device.\n     */\n    override downOrClose() {\n        this.#assertMotionLockStatus();\n\n        let targetLiftPercent100ths;\n        let targetTiltPercent100ths;\n        if (this.features.positionAwareLift) {\n            this.state.targetPositionLiftPercent100ths = targetLiftPercent100ths = WC_PERCENT100THS_MAX_CLOSED;\n        }\n        if (this.features.positionAwareTilt) {\n            this.state.targetPositionTiltPercent100ths = targetTiltPercent100ths = WC_PERCENT100THS_MAX_CLOSED;\n        }\n\n        if (this.features.lift) {\n            this.#triggerLiftMotion(MovementDirection.Close, targetLiftPercent100ths);\n        }\n        if (this.features.tilt) {\n            this.#triggerTiltMotion(MovementDirection.Close, targetTiltPercent100ths);\n        }\n    }\n\n    /**\n     * Stop any movement of the WindowCovering. The method calls the handleStopMovement method to actually stop the\n     * movement of the device.\n     */\n    override stopMotion() {\n        this.#assertMotionLockStatus();\n\n        return this.handleStopMovement();\n    }\n\n    /**\n     * Move the WindowCovering to a specific lift value. The default implementation calculates the % value for the\n     * target position. The method calls the handleMovement method to actually move the device to the defined position.\n     */\n    override goToLiftValue({ liftValue }: WindowCovering.GoToLiftValueRequest) {\n        this.#assertMotionLockStatus();\n\n        this.state.targetPositionLiftPercent100ths = this.#liftToPercent100ths(liftValue);\n        this.#triggerLiftMotion(MovementDirection.DefinedByPosition, this.state.targetPositionLiftPercent100ths);\n    }\n\n    /**\n     * Move the WindowCovering to a specific tilt value. The method calls the handleMovement method to actually move the\n     * device to the defined position.\n     */\n    override goToLiftPercentage({ liftPercent100thsValue }: WindowCovering.GoToLiftPercentageRequest) {\n        this.#assertMotionLockStatus();\n\n        if (this.features.positionAwareLift) {\n            this.state.targetPositionLiftPercent100ths = liftPercent100thsValue;\n            this.#triggerLiftMotion(\n                MovementDirection.DefinedByPosition,\n                this.state.targetPositionLiftPercent100ths ?? undefined,\n            );\n        } else {\n            if (liftPercent100thsValue === 0) {\n                this.upOrOpen();\n            } else {\n                this.downOrClose();\n            }\n        }\n    }\n\n    /**\n     * Move the WindowCovering to a specific tilt value. The default implementation calculates the % value for the target\n     * position. The method calls the handleMovement method to actually move the device to the defined position.\n     */\n    override goToTiltValue({ tiltValue }: WindowCovering.GoToTiltValueRequest) {\n        this.#assertMotionLockStatus();\n\n        this.state.targetPositionTiltPercent100ths = this.#tiltToPercent100ths(tiltValue);\n        this.#triggerTiltMotion(MovementDirection.DefinedByPosition, this.state.targetPositionTiltPercent100ths);\n    }\n\n    /**\n     * Move the WindowCovering to a specific tilt value. The method calls the handleMovement method to actually move the\n     * device to the defined position.\n     */\n    override goToTiltPercentage({ tiltPercent100thsValue }: WindowCovering.GoToTiltPercentageRequest) {\n        this.#assertMotionLockStatus();\n\n        if (this.features.positionAwareTilt) {\n            this.state.targetPositionTiltPercent100ths = tiltPercent100thsValue ?? null;\n            this.#triggerTiltMotion(\n                MovementDirection.DefinedByPosition,\n                this.state.targetPositionTiltPercent100ths ?? undefined,\n            );\n        } else {\n            if (tiltPercent100thsValue === 0) {\n                this.upOrOpen();\n            } else {\n                this.downOrClose();\n            }\n        }\n    }\n\n    /**\n     * ConvertValue: Converts values from one range to another\n     * * Range In  -> from  inputLowValue to   inputHighValue\n     * * Range Out -> from outputLowValue to outputHighValue\n     */\n    #convertValue(\n        inputLowValue: number,\n        inputHighValue: number,\n        outputLowValue: number,\n        outputHighValue: number,\n        value: number,\n    ) {\n        let inputMin = inputLowValue;\n        let inputMax = inputHighValue;\n        let outputMin = outputLowValue;\n        let outputMax = outputHighValue;\n        if (inputLowValue > inputHighValue) {\n            inputMin = inputHighValue;\n            inputMax = inputLowValue;\n        }\n        if (outputLowValue > outputHighValue) {\n            outputMin = outputHighValue;\n            outputMax = outputLowValue;\n        }\n        const inputRange = inputMax - inputMin;\n        const outputRange = outputMax - outputMin;\n        if (value < inputMin) {\n            return outputMin;\n        }\n        if (value > inputMax) {\n            return outputMax;\n        }\n        if (inputRange > 0) {\n            return Math.round(outputMin + (outputRange * (value - inputMin)) / inputRange);\n        }\n        return outputMax;\n    }\n\n    #valueToPercent100ths(limits: AbsoluteLimits, absolute: number) {\n        return this.#convertValue(\n            limits.open,\n            limits.closed,\n            WC_PERCENT100THS_MIN_OPEN,\n            WC_PERCENT100THS_MAX_CLOSED,\n            absolute,\n        );\n    }\n\n    #percent100thsToValue(limits: AbsoluteLimits, relative: number) {\n        return this.#convertValue(\n            WC_PERCENT100THS_MIN_OPEN,\n            WC_PERCENT100THS_MAX_CLOSED,\n            limits.open,\n            limits.closed,\n            relative,\n        );\n    }\n\n    #liftToPercent100ths(lift: number) {\n        return this.#valueToPercent100ths(\n            { open: this.state.installedOpenLimitLift, closed: this.state.installedClosedLimitLift },\n            lift,\n        );\n    }\n\n    #percent100thsToLift(percent100ths: number) {\n        return this.#percent100thsToValue(\n            { open: this.state.installedOpenLimitLift, closed: this.state.installedClosedLimitLift },\n            percent100ths,\n        );\n    }\n\n    #tiltToPercent100ths(tilt: number) {\n        return this.#valueToPercent100ths(\n            { open: this.state.installedOpenLimitTilt, closed: this.state.installedClosedLimitTilt },\n            tilt,\n        );\n    }\n\n    #percent100thsToTilt(percent100ths: number) {\n        return this.#percent100thsToValue(\n            { open: this.state.installedOpenLimitTilt, closed: this.state.installedClosedLimitTilt },\n            percent100ths,\n        );\n    }\n}\n\nexport namespace WindowCoveringServerLogic {\n    export class Internal {\n        /** Status of the Device Calibration mode. */\n        calibrationMode: CalibrationMode = CalibrationMode.Disabled;\n\n        /** Status of the Device Maintenance mode. */\n        inMaintenanceMode: boolean = false;\n    }\n\n    export class State extends WindowCoveringServerBase.State {\n        /** Does the device supports calibration? */\n        supportsCalibration: boolean = false;\n\n        /** Does the device supports maintenance mode? */\n        supportsMaintenanceMode: boolean = true;\n    }\n\n    export declare const ExtensionInterface: {\n        handleMovement(\n            type: MovementType,\n            reversed: boolean,\n            direction: MovementDirection,\n            targetPercent100ths?: number,\n        ): Promise<void>;\n        handleStopMovement(): MaybePromise;\n        executeCalibration(): MaybePromise;\n    };\n}\n\nexport class WindowCoveringServer extends WindowCoveringServerLogic.for(ClusterType(WindowCovering.Base)) {}\n"],
  "mappings": "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",
  "names": ["MovementType", "CalibrationMode", "MovementDirection", "WindowCoveringServerLogic"]
}
