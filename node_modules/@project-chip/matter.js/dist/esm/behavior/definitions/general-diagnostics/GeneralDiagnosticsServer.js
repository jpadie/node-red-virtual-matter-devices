/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { GeneralDiagnostics } from "../../../cluster/definitions/GeneralDiagnosticsCluster.js";
import { ImplementationError } from "../../../common/MatterError.js";
import { CommandId } from "../../../datatype/CommandId.js";
import { MdnsService } from "../../../environment/MdnsService.js";
import { Logger } from "../../../log/Logger.js";
import { FieldElement } from "../../../model/elements/FieldElement.js";
import { TlvInvokeResponse } from "../../../protocol/interaction/InteractionProtocol.js";
import { INTERACTION_MODEL_REVISION } from "../../../protocol/interaction/InteractionServer.js";
import { StatusCode, StatusResponseError } from "../../../protocol/interaction/StatusCode.js";
import { Time } from "../../../time/Time.js";
import { ByteArray } from "../../../util/ByteArray.js";
import { iPv4ToByteArray, iPv6ToByteArray } from "../../../util/Ip.js";
import { Val } from "../../state/Val.js";
import { NetworkServer } from "../../system/network/NetworkServer.js";
import { NetworkCommissioningServer } from "../network-commissioning/NetworkCommissioningServer.js";
import { GeneralDiagnosticsBehavior } from "./GeneralDiagnosticsBehavior.js";
const logger = Logger.get("GeneralDiagnosticsServer");
const Base = GeneralDiagnosticsBehavior.with(GeneralDiagnostics.Feature.DataModelTest);
const schema = Base.schema?.clone();
schema.add(FieldElement({ name: "totalOperationalHoursCounter", type: "uint64", quality: "N" }));
class GeneralDiagnosticsServer extends Base {
  schema = schema;
  initialize() {
    if (this.state.testEventTriggersEnabled === void 0) {
      this.state.testEventTriggersEnabled = false;
    } else if (this.state.testEventTriggersEnabled) {
      if (this.state.deviceTestEnableKey.every((byte) => byte === 0)) {
        throw new ImplementationError("Test event triggers are enabled but no deviceTestEnableKey is set.");
      }
      logger.warn("Test event triggers are enabled. Make sure to disable them in production.");
    }
    if (this.state.rebootCount === void 0) {
      this.state.rebootCount = 0;
    } else {
      this.state.rebootCount++;
    }
    const lifecycle = this.endpoint.lifecycle;
    if (lifecycle.online !== void 0) {
      this.reactTo(lifecycle.online, this.#online, { lock: true });
    }
    if (this.events.activeHardwareFaults$Changed !== void 0) {
      this.reactTo(this.events.activeHardwareFaults$Changed, this.#triggerActiveHardwareFaultsChangedEvent);
    }
    if (this.events.activeRadioFaults$Changed !== void 0) {
      this.reactTo(this.events.activeRadioFaults$Changed, this.#triggerActiveRadioFaultsChangedEvent);
    }
    if (this.events.activeNetworkFaults$Changed !== void 0) {
      this.reactTo(this.events.activeNetworkFaults$Changed, this.#triggerActiveNetworkFaultsChangedEvent);
    }
  }
  #validateTestEnabledKey(enableKey) {
    if (enableKey.every((byte) => byte === 0)) {
      throw new StatusResponseError("Invalid test enable key, all zeros", StatusCode.ConstraintError);
    }
    enableKey.forEach((byte, index) => {
      if (byte !== this.state.deviceTestEnableKey[index]) {
        throw new StatusResponseError("Invalid test enable key", StatusCode.ConstraintError);
      }
    });
  }
  testEventTrigger({ eventTrigger, enableKey }) {
    this.#validateTestEnabledKey(enableKey);
    this.triggerTestEvent(eventTrigger);
  }
  triggerTestEvent(eventTrigger) {
    throw new StatusResponseError(`Unsupported test event trigger ${eventTrigger}`, StatusCode.InvalidCommand);
  }
  timeSnapshot() {
    const time = Time.nowMs();
    return {
      systemTimeMs: time - this.internal.bootUpTime,
      posixTimeMs: time
    };
  }
  payloadTestRequest({
    enableKey,
    value,
    count
  }) {
    this.#validateTestEnabledKey(enableKey);
    if (!this.state.testEventTriggersEnabled) {
      throw new StatusResponseError("Test event triggers are disabled", StatusCode.ConstraintError);
    }
    const payload = new ByteArray(count).fill(value);
    const responseSize = TlvInvokeResponse.encode({
      suppressResponse: false,
      interactionModelRevision: INTERACTION_MODEL_REVISION,
      moreChunkedMessages: true,
      invokeResponses: [
        {
          command: {
            commandPath: {
              endpointId: this.endpoint.number,
              clusterId: GeneralDiagnostics.Complete.id,
              commandId: CommandId(4)
              // Hardcode for now
            },
            commandRef: 0,
            commandFields: GeneralDiagnostics.TlvPayloadTestResponse.encodeTlv({
              payload
            })
          }
        }
      ]
    }).length;
    const exchange = this.context.exchange;
    if (exchange === void 0) {
      throw new ImplementationError(`Illegal operation outside exchange context`);
    }
    if (responseSize > exchange.maxPayloadSize) {
      throw new StatusResponseError("Response too large", StatusCode.ResourceExhausted);
    }
    return {
      payload
    };
  }
  /**
   * Register a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the
   * HardwareFaultChanged event. Make sure to clear the fault when it is resolved.
   * This method requires that the activeHardwareFaults attribute is activated when the cluster gets initialized.
   *
   * @param faultType The hardware fault to register.
   */
  registerHardwareFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeHardwareFaults");
    const list = currentFaults.filter((fault) => fault !== faultType);
    list.push(faultType);
    this.state.activeHardwareFaults = list;
  }
  /**
   * Clear a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the
   * HardwareFaultChanged event.
   *
   * @param faultType The hardware fault to clear.
   */
  clearHardwareFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeHardwareFaults");
    this.state.activeHardwareFaults = currentFaults.filter((fault) => fault !== faultType);
  }
  #triggerActiveHardwareFaultsChangedEvent(current, previous) {
    this.events.hardwareFaultChange?.emit(
      {
        current,
        previous
      },
      this.context
    );
  }
  /**
   * Register a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the
   * RadioFaultChanged event. Make sure to clear the fault when it is resolved.
   * This method requires that the activeRadioFaults attribute is activated when the cluster gets initialized.
   *
   * @param faultType The radio fault to register.
   */
  registerRadioFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeRadioFaults");
    const list = currentFaults.filter((fault) => fault !== faultType);
    list.push(faultType);
    this.state.activeRadioFaults = list;
  }
  /**
   * Clear a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the
   * RadioFaultChanged event.
   *
   * @param faultType The radio fault to clear.
   */
  clearRadioFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeRadioFaults");
    this.state.activeRadioFaults = currentFaults.filter((fault) => fault !== faultType);
  }
  #triggerActiveRadioFaultsChangedEvent(current, previous) {
    this.events.radioFaultChange?.emit(
      {
        current,
        previous
      },
      this.context
    );
  }
  /**
   * Register a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the
   * NetworkFaultChanged event. Make sure to clear the fault when it is resolved.
   * This method requires that the activeNetworkFaults attribute is activated when the cluster gets initialized.
   *
   * @param faultType The network fault to register.
   */
  registerNetworkFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeNetworkFaults");
    const list = currentFaults.filter((fault) => fault !== faultType);
    list.push(faultType);
    this.state.activeNetworkFaults = list;
  }
  /**
   * Clear a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the
   * NetworkFaultChanged event.
   *
   * @param faultType The network fault to clear.
   */
  clearNetworkFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeNetworkFaults");
    this.state.activeNetworkFaults = currentFaults.filter((fault) => fault !== faultType);
  }
  #triggerActiveNetworkFaultsChangedEvent(current, previous) {
    this.events.networkFaultChange?.emit(
      {
        current,
        previous
      },
      this.context
    );
  }
  async #online() {
    this.events.bootReason.emit(
      { bootReason: this.state.bootReason ?? GeneralDiagnostics.BootReason.Unspecified },
      this.context
    );
    this.internal.bootUpTime = Time.nowMs();
    this.internal.lastTotalOperationalHoursCounterUpdateTime = Time.nowMs();
    this.internal.lastTotalOperationalHoursTimer = Time.getPeriodicTimer(
      "GeneralDiagnostics.operationalHours",
      5 * 6e4,
      this.callback(this.#updateTotalOperationalHoursCounter)
    ).start();
    await this.#updateNetworkList();
  }
  #updateTotalOperationalHoursCounter() {
    const now = Time.nowMs();
    const elapsedTime = now - this.internal.lastTotalOperationalHoursCounterUpdateTime;
    this.state.totalOperationalHoursCounter = this.state.totalOperationalHoursCounter + elapsedTime;
    this.internal.lastTotalOperationalHoursCounterUpdateTime = now;
  }
  async #updateNetworkList() {
    const mdnsService = this.endpoint.env.get(MdnsService);
    const mdnsLimitedToNetworkInterfaces = mdnsService.limitedToNetInterface;
    const networkRuntime = this.endpoint.behaviors.internalsOf(NetworkServer).runtime;
    const systemNetworkInterfaces = await networkRuntime.getNetworkInterfaces();
    let networkType = GeneralDiagnostics.InterfaceType.Ethernet;
    if (this.endpoint.behaviors.has(NetworkCommissioningServer)) {
      const networkCommissioning = this.agent.get(NetworkCommissioningServer);
      if ("wiFiNetworkInterface" in networkCommissioning.features && networkCommissioning.features.wiFiNetworkInterface) {
        networkType = GeneralDiagnostics.InterfaceType.WiFi;
      } else if ("threadNetworkInterface" in networkCommissioning.features && networkCommissioning.features.threadNetworkInterface) {
        networkType = GeneralDiagnostics.InterfaceType.Thread;
      }
    }
    const isOperationalReachable = mdnsLimitedToNetworkInterfaces === void 0 ? () => true : (name) => {
      return name === mdnsLimitedToNetworkInterfaces;
    };
    this.state.networkInterfaces = systemNetworkInterfaces.filter(({ mac }) => mac !== "00:00:00:00:00:00").sort(({ name: nameA }, { name: nameB }) => {
      if (isOperationalReachable(nameA) && !isOperationalReachable(nameB)) {
        return -1;
      }
      if (!isOperationalReachable(nameA) && isOperationalReachable(nameB)) {
        return 1;
      }
      return 0;
    }).slice(0, 8).map(({ name, mac, ipV4, ipV6, type }) => ({
      name,
      isOperational: isOperationalReachable(name),
      offPremiseServicesReachableIPv4: null,
      // null means unknown or not supported
      offPremiseServicesReachableIPv6: null,
      // null means unknown or not supported
      hardwareAddress: ByteArray.fromHex(mac.replace(/[^\da-fA-F]/g, "")),
      iPv4Addresses: ipV4.slice(0, 4).map((ip) => iPv4ToByteArray(ip)),
      iPv6Addresses: ipV6.slice(0, 8).map((ip) => iPv6ToByteArray(ip)),
      type: type ?? networkType
    }));
  }
  async [Symbol.asyncDispose]() {
    this.internal.lastTotalOperationalHoursTimer?.stop();
    this.#updateTotalOperationalHoursCounter();
    await super[Symbol.asyncDispose]?.();
  }
}
((GeneralDiagnosticsServer2) => {
  class Internal {
    /** Remember the bootUp time for the device. */
    bootUpTime = Time.nowMs();
    /** Last time the total operational hours counter was updated. */
    lastTotalOperationalHoursCounterUpdateTime = Time.nowMs();
    /** Timer to update the total operational hours counter every 5 minutes. */
    lastTotalOperationalHoursTimer;
  }
  GeneralDiagnosticsServer2.Internal = Internal;
  class State extends Base.State {
    /** Internal counter of the total operational hours, counted in seconds, updated every 5 minutes. */
    totalOperationalHoursCounter = 0;
    /** The TestEnableKey set for this device for the test commands. Default means "not enabled"." */
    deviceTestEnableKey = new ByteArray(16).fill(0);
    [Val.properties](endpoint, _session) {
      return {
        /**
         * Dynamically calculate the upTime. This is ok because the attribute is not send out via subscriptions
         * anyway.
         */
        get upTime() {
          const bootUpTime = endpoint.behaviors.internalsOf(GeneralDiagnosticsServer2).bootUpTime;
          return Math.round((Time.nowMs() - bootUpTime) / 1e3);
        },
        /**
         * Dynamically calculate the operating Hours from our internal counter. This is ok because the attribute
         * is not send out via subscriptions anyway.
         */
        get totalOperationalHours() {
          const lastTotalOperationalHoursCounterUpdateTime = endpoint.behaviors.internalsOf(
            GeneralDiagnosticsServer2
          ).lastTotalOperationalHoursCounterUpdateTime;
          const totalOperationalHoursCounter = endpoint.stateOf(GeneralDiagnosticsServer2).totalOperationalHoursCounter;
          return Math.floor(
            (Time.nowMs() - lastTotalOperationalHoursCounterUpdateTime + totalOperationalHoursCounter) / (60 * 6e4)
          );
        }
      };
    }
  }
  GeneralDiagnosticsServer2.State = State;
})(GeneralDiagnosticsServer || (GeneralDiagnosticsServer = {}));
export {
  GeneralDiagnosticsServer
};
//# sourceMappingURL=GeneralDiagnosticsServer.js.map
