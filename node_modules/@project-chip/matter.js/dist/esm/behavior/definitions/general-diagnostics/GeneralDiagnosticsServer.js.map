{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/general-diagnostics/GeneralDiagnosticsServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeneralDiagnostics } from \"../../../cluster/definitions/GeneralDiagnosticsCluster.js\";\nimport { ImplementationError } from \"../../../common/MatterError.js\";\nimport { CommandId } from \"../../../datatype/CommandId.js\";\nimport { Endpoint } from \"../../../endpoint/Endpoint.js\";\nimport { MdnsService } from \"../../../environment/MdnsService.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { FieldElement } from \"../../../model/elements/FieldElement.js\";\nimport { ClusterModel } from \"../../../model/index.js\";\nimport { NodeLifecycle } from \"../../../node/NodeLifecycle.js\";\nimport { TlvInvokeResponse } from \"../../../protocol/interaction/InteractionProtocol.js\";\nimport { INTERACTION_MODEL_REVISION } from \"../../../protocol/interaction/InteractionServer.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { Time, Timer } from \"../../../time/Time.js\";\nimport { ByteArray } from \"../../../util/ByteArray.js\";\nimport { iPv4ToByteArray, iPv6ToByteArray } from \"../../../util/Ip.js\";\nimport { Val } from \"../../state/Val.js\";\nimport { ValueSupervisor } from \"../../supervision/ValueSupervisor.js\";\nimport { NetworkServer } from \"../../system/network/NetworkServer.js\";\nimport { NetworkCommissioningServer } from \"../network-commissioning/NetworkCommissioningServer.js\";\nimport { GeneralDiagnosticsBehavior } from \"./GeneralDiagnosticsBehavior.js\";\n\nconst logger = Logger.get(\"GeneralDiagnosticsServer\");\n\n// Enable DataModelTest feature by default because we use MaxPathsPerInvoke > 1 by default\nconst Base = GeneralDiagnosticsBehavior.with(GeneralDiagnostics.Feature.DataModelTest);\n\n// Enhance the Schema to store the real operational hours counter we internally use and persist this\nconst schema = Base.schema?.clone() as ClusterModel;\nschema.add(FieldElement({ name: \"totalOperationalHoursCounter\", type: \"uint64\", quality: \"N\" }));\n\n/**\n * This is the default server implementation of GeneralDiagnosticsBehavior.\n *\n * The implementation provides convenience methods to register and clear hardware, radio, and network faults and to\n * handle test Event triggers.\n *\n * To handle test Event triggers please override the triggerTestEvent method. If these test events are used in\n * certification please also set the EnableKey in the enhanced state as `deviceTestEnableKey`.\n *\n * To register or clear hardware, radio, and network faults, please use the provided convenience methods:\n * * registerHardwareFault and clearHardwareFault\n * * registerRadioFault and clearRadioFault\n * * registerNetworkFault and clearNetworkFault\n * If you want to send events when faults are registered or cleared you need to enable these events when the Root\n * Endpoint gets initialized.\n */\nexport class GeneralDiagnosticsServer extends Base {\n    protected declare internal: GeneralDiagnosticsServer.Internal;\n    declare state: GeneralDiagnosticsServer.State;\n    schema = schema;\n\n    override initialize() {\n        if (this.state.testEventTriggersEnabled === undefined) {\n            this.state.testEventTriggersEnabled = false;\n        } else if (this.state.testEventTriggersEnabled) {\n            if (this.state.deviceTestEnableKey.every(byte => byte === 0)) {\n                throw new ImplementationError(\"Test event triggers are enabled but no deviceTestEnableKey is set.\");\n            }\n            logger.warn(\"Test event triggers are enabled. Make sure to disable them in production.\");\n        }\n\n        if (this.state.rebootCount === undefined) {\n            this.state.rebootCount = 0;\n        } else {\n            this.state.rebootCount++;\n        }\n\n        const lifecycle = this.endpoint.lifecycle as NodeLifecycle;\n\n        if (lifecycle.online !== undefined) {\n            this.reactTo(lifecycle.online, this.#online, { lock: true });\n        }\n\n        if (this.events.activeHardwareFaults$Changed !== undefined) {\n            this.reactTo(this.events.activeHardwareFaults$Changed, this.#triggerActiveHardwareFaultsChangedEvent);\n        }\n        if (this.events.activeRadioFaults$Changed !== undefined) {\n            this.reactTo(this.events.activeRadioFaults$Changed, this.#triggerActiveRadioFaultsChangedEvent);\n        }\n        if (this.events.activeNetworkFaults$Changed !== undefined) {\n            this.reactTo(this.events.activeNetworkFaults$Changed, this.#triggerActiveNetworkFaultsChangedEvent);\n        }\n    }\n\n    #validateTestEnabledKey(enableKey: ByteArray) {\n        if (enableKey.every(byte => byte === 0)) {\n            throw new StatusResponseError(\"Invalid test enable key, all zeros\", StatusCode.ConstraintError);\n        }\n        enableKey.forEach((byte, index) => {\n            if (byte !== this.state.deviceTestEnableKey[index]) {\n                throw new StatusResponseError(\"Invalid test enable key\", StatusCode.ConstraintError);\n            }\n        });\n    }\n\n    override testEventTrigger({ eventTrigger, enableKey }: GeneralDiagnostics.TestEventTriggerRequest) {\n        this.#validateTestEnabledKey(enableKey);\n\n        this.triggerTestEvent(eventTrigger);\n    }\n\n    protected triggerTestEvent(eventTrigger: number | bigint) {\n        throw new StatusResponseError(`Unsupported test event trigger ${eventTrigger}`, StatusCode.InvalidCommand);\n    }\n\n    override timeSnapshot() {\n        const time = Time.nowMs();\n        return {\n            systemTimeMs: time - this.internal.bootUpTime,\n            posixTimeMs: time,\n        };\n    }\n\n    override payloadTestRequest({\n        enableKey,\n        value,\n        count,\n    }: GeneralDiagnostics.PayloadTestRequest): GeneralDiagnostics.PayloadTestResponse {\n        this.#validateTestEnabledKey(enableKey);\n\n        if (!this.state.testEventTriggersEnabled) {\n            throw new StatusResponseError(\"Test event triggers are disabled\", StatusCode.ConstraintError);\n        }\n\n        const payload = new ByteArray(count).fill(value);\n\n        // In our case encoding is done completely on an upper layer, so we need to build a dummy single response to get the size\n        // Formal note: This is not 100% accurate and we might be some bytes to huge (moreChunkedMessages, commandRef)\n        // but near enough\n        const responseSize = TlvInvokeResponse.encode({\n            suppressResponse: false,\n            interactionModelRevision: INTERACTION_MODEL_REVISION,\n            moreChunkedMessages: true,\n            invokeResponses: [\n                {\n                    command: {\n                        commandPath: {\n                            endpointId: this.endpoint.number,\n                            clusterId: GeneralDiagnostics.Complete.id,\n                            commandId: CommandId(0x04), // Hardcode for now\n                        },\n                        commandRef: 0,\n                        commandFields: GeneralDiagnostics.TlvPayloadTestResponse.encodeTlv({\n                            payload,\n                        }),\n                    },\n                },\n            ],\n        }).length;\n\n        const exchange = this.context.exchange;\n        if (exchange === undefined) {\n            throw new ImplementationError(`Illegal operation outside exchange context`);\n        }\n\n        if (responseSize > exchange.maxPayloadSize) {\n            throw new StatusResponseError(\"Response too large\", StatusCode.ResourceExhausted);\n        }\n\n        return {\n            payload,\n        };\n    }\n\n    /**\n     * Register a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the\n     * HardwareFaultChanged event. Make sure to clear the fault when it is resolved.\n     * This method requires that the activeHardwareFaults attribute is activated when the cluster gets initialized.\n     *\n     * @param faultType The hardware fault to register.\n     */\n    registerHardwareFault(faultType: GeneralDiagnostics.HardwareFault) {\n        const currentFaults = this.requireAttributeEnabled(\"activeHardwareFaults\");\n        const list = currentFaults.filter(fault => fault !== faultType);\n        list.push(faultType);\n        this.state.activeHardwareFaults = list;\n    }\n\n    /**\n     * Clear a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the\n     * HardwareFaultChanged event.\n     *\n     * @param faultType The hardware fault to clear.\n     */\n    clearHardwareFault(faultType: GeneralDiagnostics.HardwareFault) {\n        const currentFaults = this.requireAttributeEnabled(\"activeHardwareFaults\");\n        this.state.activeHardwareFaults = currentFaults.filter(fault => fault !== faultType);\n    }\n\n    #triggerActiveHardwareFaultsChangedEvent(\n        current: GeneralDiagnostics.HardwareFault[],\n        previous: GeneralDiagnostics.HardwareFault[],\n    ) {\n        this.events.hardwareFaultChange?.emit(\n            {\n                current,\n                previous,\n            },\n            this.context,\n        );\n    }\n\n    /**\n     * Register a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the\n     * RadioFaultChanged event. Make sure to clear the fault when it is resolved.\n     * This method requires that the activeRadioFaults attribute is activated when the cluster gets initialized.\n     *\n     * @param faultType The radio fault to register.\n     */\n    registerRadioFault(faultType: GeneralDiagnostics.RadioFault) {\n        const currentFaults = this.requireAttributeEnabled(\"activeRadioFaults\");\n        const list = currentFaults.filter(fault => fault !== faultType);\n        list.push(faultType);\n        this.state.activeRadioFaults = list;\n    }\n\n    /**\n     * Clear a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the\n     * RadioFaultChanged event.\n     *\n     * @param faultType The radio fault to clear.\n     */\n    clearRadioFault(faultType: GeneralDiagnostics.RadioFault) {\n        const currentFaults = this.requireAttributeEnabled(\"activeRadioFaults\");\n        this.state.activeRadioFaults = currentFaults.filter(fault => fault !== faultType);\n    }\n\n    #triggerActiveRadioFaultsChangedEvent(\n        current: GeneralDiagnostics.RadioFault[],\n        previous: GeneralDiagnostics.RadioFault[],\n    ) {\n        this.events.radioFaultChange?.emit(\n            {\n                current,\n                previous,\n            },\n            this.context,\n        );\n    }\n\n    /**\n     * Register a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the\n     * NetworkFaultChanged event. Make sure to clear the fault when it is resolved.\n     * This method requires that the activeNetworkFaults attribute is activated when the cluster gets initialized.\n     *\n     * @param faultType The network fault to register.\n     */\n    registerNetworkFault(faultType: GeneralDiagnostics.NetworkFault) {\n        const currentFaults = this.requireAttributeEnabled(\"activeNetworkFaults\");\n        const list = currentFaults.filter(fault => fault !== faultType);\n        list.push(faultType);\n        this.state.activeNetworkFaults = list;\n    }\n\n    /**\n     * Clear a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the\n     * NetworkFaultChanged event.\n     *\n     * @param faultType The network fault to clear.\n     */\n    clearNetworkFault(faultType: GeneralDiagnostics.NetworkFault) {\n        const currentFaults = this.requireAttributeEnabled(\"activeNetworkFaults\");\n        this.state.activeNetworkFaults = currentFaults.filter(fault => fault !== faultType);\n    }\n\n    #triggerActiveNetworkFaultsChangedEvent(\n        current: GeneralDiagnostics.NetworkFault[],\n        previous: GeneralDiagnostics.NetworkFault[],\n    ) {\n        this.events.networkFaultChange?.emit(\n            {\n                current,\n                previous,\n            },\n            this.context,\n        );\n    }\n\n    async #online() {\n        this.events.bootReason.emit(\n            { bootReason: this.state.bootReason ?? GeneralDiagnostics.BootReason.Unspecified },\n            this.context,\n        );\n\n        // Update the timestamps now that node is really online.\n        this.internal.bootUpTime = Time.nowMs();\n        this.internal.lastTotalOperationalHoursCounterUpdateTime = Time.nowMs();\n\n        this.internal.lastTotalOperationalHoursTimer = Time.getPeriodicTimer(\n            \"GeneralDiagnostics.operationalHours\",\n            5 * 60_000,\n            this.callback(this.#updateTotalOperationalHoursCounter),\n        ).start();\n\n        await this.#updateNetworkList();\n    }\n\n    #updateTotalOperationalHoursCounter() {\n        const now = Time.nowMs();\n        const elapsedTime = now - this.internal.lastTotalOperationalHoursCounterUpdateTime;\n        this.state.totalOperationalHoursCounter = this.state.totalOperationalHoursCounter + elapsedTime;\n        this.internal.lastTotalOperationalHoursCounterUpdateTime = now;\n    }\n\n    async #updateNetworkList() {\n        const mdnsService = this.endpoint.env.get(MdnsService);\n        const mdnsLimitedToNetworkInterfaces = mdnsService.limitedToNetInterface;\n\n        const networkRuntime = this.endpoint.behaviors.internalsOf(NetworkServer).runtime;\n        const systemNetworkInterfaces = await networkRuntime.getNetworkInterfaces();\n\n        // Determine the network type for all interfaces based on the Network Commissioning Server on the root endpoint\n        // TODO: Find a way if needed to handle devices connected with multiple technologies and report that correctly\n        //       but irrelevant for now because noone expects that (including chip)\n        let networkType = GeneralDiagnostics.InterfaceType.Ethernet;\n        if (this.endpoint.behaviors.has(NetworkCommissioningServer)) {\n            const networkCommissioning = this.agent.get(NetworkCommissioningServer);\n            if (\n                \"wiFiNetworkInterface\" in networkCommissioning.features &&\n                networkCommissioning.features.wiFiNetworkInterface\n            ) {\n                networkType = GeneralDiagnostics.InterfaceType.WiFi;\n            } else if (\n                \"threadNetworkInterface\" in networkCommissioning.features &&\n                networkCommissioning.features.threadNetworkInterface\n            ) {\n                networkType = GeneralDiagnostics.InterfaceType.Thread;\n            }\n        }\n\n        // If we only announce on one network interface, also consider this onw as only operational one (because noone\n        // else should connect to the others even if we listen\n        const isOperationalReachable =\n            mdnsLimitedToNetworkInterfaces === undefined\n                ? () => true\n                : (name: string) => {\n                      return name === mdnsLimitedToNetworkInterfaces;\n                  };\n\n        // Filter all unassigned MACs out, sort operational on top, limit to 8 entries and map to the required format.\n        this.state.networkInterfaces = systemNetworkInterfaces\n            .filter(({ mac }) => mac !== \"00:00:00:00:00:00\")\n            .sort(({ name: nameA }, { name: nameB }) => {\n                // sort operational entries on top, others to bottom\n                if (isOperationalReachable(nameA) && !isOperationalReachable(nameB)) {\n                    return -1;\n                }\n                if (!isOperationalReachable(nameA) && isOperationalReachable(nameB)) {\n                    return 1;\n                }\n                return 0;\n            })\n            .slice(0, 8)\n            .map(({ name, mac, ipV4, ipV6, type }) => ({\n                name,\n                isOperational: isOperationalReachable(name),\n                offPremiseServicesReachableIPv4: null, // null means unknown or not supported\n                offPremiseServicesReachableIPv6: null, // null means unknown or not supported\n                hardwareAddress: ByteArray.fromHex(mac.replace(/[^\\da-fA-F]/g, \"\")),\n                iPv4Addresses: ipV4.slice(0, 4).map(ip => iPv4ToByteArray(ip)),\n                iPv6Addresses: ipV6.slice(0, 8).map(ip => iPv6ToByteArray(ip)),\n                type: type ?? networkType,\n            }));\n    }\n\n    override async [Symbol.asyncDispose]() {\n        this.internal.lastTotalOperationalHoursTimer?.stop();\n        this.#updateTotalOperationalHoursCounter();\n        await super[Symbol.asyncDispose]?.();\n    }\n}\n\nexport namespace GeneralDiagnosticsServer {\n    export class Internal {\n        /** Remember the bootUp time for the device. */\n        bootUpTime: number = Time.nowMs();\n\n        /** Last time the total operational hours counter was updated. */\n        lastTotalOperationalHoursCounterUpdateTime: number = Time.nowMs();\n\n        /** Timer to update the total operational hours counter every 5 minutes. */\n        lastTotalOperationalHoursTimer: Timer | undefined;\n    }\n\n    export class State extends Base.State {\n        /** Internal counter of the total operational hours, counted in seconds, updated every 5 minutes. */\n        totalOperationalHoursCounter: number = 0;\n\n        /** The TestEnableKey set for this device for the test commands. Default means \"not enabled\".\" */\n        deviceTestEnableKey = new ByteArray(16).fill(0);\n\n        [Val.properties](endpoint: Endpoint, _session: ValueSupervisor.Session) {\n            return {\n                /**\n                 * Dynamically calculate the upTime. This is ok because the attribute is not send out via subscriptions\n                 * anyway.\n                 */\n                get upTime() {\n                    const bootUpTime = endpoint.behaviors.internalsOf(GeneralDiagnosticsServer).bootUpTime;\n                    return Math.round((Time.nowMs() - bootUpTime) / 1000);\n                },\n\n                /**\n                 * Dynamically calculate the operating Hours from our internal counter. This is ok because the attribute\n                 * is not send out via subscriptions anyway.\n                 */\n                get totalOperationalHours() {\n                    const lastTotalOperationalHoursCounterUpdateTime =\n                        endpoint.behaviors.internalsOf(\n                            GeneralDiagnosticsServer,\n                        ).lastTotalOperationalHoursCounterUpdateTime;\n                    const totalOperationalHoursCounter =\n                        endpoint.stateOf(GeneralDiagnosticsServer).totalOperationalHoursCounter;\n                    return Math.floor(\n                        (Time.nowMs() - lastTotalOperationalHoursCounterUpdateTime + totalOperationalHoursCounter) /\n                            (60 * 60_000),\n                    );\n                },\n            };\n        }\n    }\n\n    export declare const ExtensionInterface: {\n        triggerTestEvent: (eventTrigger: number | bigint) => void;\n        registerHardwareFault: (\n            current: GeneralDiagnostics.HardwareFault[],\n            previous: GeneralDiagnostics.HardwareFault[],\n        ) => void;\n        registerRadioFault: (\n            current: GeneralDiagnostics.RadioFault[],\n            previous: GeneralDiagnostics.RadioFault[],\n        ) => void;\n        registerNetworkFault: (\n            current: GeneralDiagnostics.NetworkFault[],\n            previous: GeneralDiagnostics.NetworkFault[],\n        ) => void;\n        clearHardwareFault: (faultType: GeneralDiagnostics.HardwareFault) => void;\n        clearRadioFault: (faultType: GeneralDiagnostics.RadioFault) => void;\n        clearNetworkFault: (faultType: GeneralDiagnostics.NetworkFault) => void;\n    };\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,0BAA0B;AACnC,SAAS,2BAA2B;AACpC,SAAS,iBAAiB;AAE1B,SAAS,mBAAmB;AAC5B,SAAS,cAAc;AACvB,SAAS,oBAAoB;AAG7B,SAAS,yBAAyB;AAClC,SAAS,kCAAkC;AAC3C,SAAS,YAAY,2BAA2B;AAChD,SAAS,YAAmB;AAC5B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB,uBAAuB;AACjD,SAAS,WAAW;AAEpB,SAAS,qBAAqB;AAC9B,SAAS,kCAAkC;AAC3C,SAAS,kCAAkC;AAE3C,MAAM,SAAS,OAAO,IAAI,0BAA0B;AAGpD,MAAM,OAAO,2BAA2B,KAAK,mBAAmB,QAAQ,aAAa;AAGrF,MAAM,SAAS,KAAK,QAAQ,MAAM;AAClC,OAAO,IAAI,aAAa,EAAE,MAAM,gCAAgC,MAAM,UAAU,SAAS,IAAI,CAAC,CAAC;AAkBxF,MAAM,iCAAiC,KAAK;AAAA,EAG/C,SAAS;AAAA,EAEA,aAAa;AAClB,QAAI,KAAK,MAAM,6BAA6B,QAAW;AACnD,WAAK,MAAM,2BAA2B;AAAA,IAC1C,WAAW,KAAK,MAAM,0BAA0B;AAC5C,UAAI,KAAK,MAAM,oBAAoB,MAAM,UAAQ,SAAS,CAAC,GAAG;AAC1D,cAAM,IAAI,oBAAoB,oEAAoE;AAAA,MACtG;AACA,aAAO,KAAK,2EAA2E;AAAA,IAC3F;AAEA,QAAI,KAAK,MAAM,gBAAgB,QAAW;AACtC,WAAK,MAAM,cAAc;AAAA,IAC7B,OAAO;AACH,WAAK,MAAM;AAAA,IACf;AAEA,UAAM,YAAY,KAAK,SAAS;AAEhC,QAAI,UAAU,WAAW,QAAW;AAChC,WAAK,QAAQ,UAAU,QAAQ,KAAK,SAAS,EAAE,MAAM,KAAK,CAAC;AAAA,IAC/D;AAEA,QAAI,KAAK,OAAO,iCAAiC,QAAW;AACxD,WAAK,QAAQ,KAAK,OAAO,8BAA8B,KAAK,wCAAwC;AAAA,IACxG;AACA,QAAI,KAAK,OAAO,8BAA8B,QAAW;AACrD,WAAK,QAAQ,KAAK,OAAO,2BAA2B,KAAK,qCAAqC;AAAA,IAClG;AACA,QAAI,KAAK,OAAO,gCAAgC,QAAW;AACvD,WAAK,QAAQ,KAAK,OAAO,6BAA6B,KAAK,uCAAuC;AAAA,IACtG;AAAA,EACJ;AAAA,EAEA,wBAAwB,WAAsB;AAC1C,QAAI,UAAU,MAAM,UAAQ,SAAS,CAAC,GAAG;AACrC,YAAM,IAAI,oBAAoB,sCAAsC,WAAW,eAAe;AAAA,IAClG;AACA,cAAU,QAAQ,CAAC,MAAM,UAAU;AAC/B,UAAI,SAAS,KAAK,MAAM,oBAAoB,KAAK,GAAG;AAChD,cAAM,IAAI,oBAAoB,2BAA2B,WAAW,eAAe;AAAA,MACvF;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAES,iBAAiB,EAAE,cAAc,UAAU,GAA+C;AAC/F,SAAK,wBAAwB,SAAS;AAEtC,SAAK,iBAAiB,YAAY;AAAA,EACtC;AAAA,EAEU,iBAAiB,cAA+B;AACtD,UAAM,IAAI,oBAAoB,kCAAkC,YAAY,IAAI,WAAW,cAAc;AAAA,EAC7G;AAAA,EAES,eAAe;AACpB,UAAM,OAAO,KAAK,MAAM;AACxB,WAAO;AAAA,MACH,cAAc,OAAO,KAAK,SAAS;AAAA,MACnC,aAAa;AAAA,IACjB;AAAA,EACJ;AAAA,EAES,mBAAmB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GAAkF;AAC9E,SAAK,wBAAwB,SAAS;AAEtC,QAAI,CAAC,KAAK,MAAM,0BAA0B;AACtC,YAAM,IAAI,oBAAoB,oCAAoC,WAAW,eAAe;AAAA,IAChG;AAEA,UAAM,UAAU,IAAI,UAAU,KAAK,EAAE,KAAK,KAAK;AAK/C,UAAM,eAAe,kBAAkB,OAAO;AAAA,MAC1C,kBAAkB;AAAA,MAClB,0BAA0B;AAAA,MAC1B,qBAAqB;AAAA,MACrB,iBAAiB;AAAA,QACb;AAAA,UACI,SAAS;AAAA,YACL,aAAa;AAAA,cACT,YAAY,KAAK,SAAS;AAAA,cAC1B,WAAW,mBAAmB,SAAS;AAAA,cACvC,WAAW,UAAU,CAAI;AAAA;AAAA,YAC7B;AAAA,YACA,YAAY;AAAA,YACZ,eAAe,mBAAmB,uBAAuB,UAAU;AAAA,cAC/D;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC,EAAE;AAEH,UAAM,WAAW,KAAK,QAAQ;AAC9B,QAAI,aAAa,QAAW;AACxB,YAAM,IAAI,oBAAoB,4CAA4C;AAAA,IAC9E;AAEA,QAAI,eAAe,SAAS,gBAAgB;AACxC,YAAM,IAAI,oBAAoB,sBAAsB,WAAW,iBAAiB;AAAA,IACpF;AAEA,WAAO;AAAA,MACH;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,sBAAsB,WAA6C;AAC/D,UAAM,gBAAgB,KAAK,wBAAwB,sBAAsB;AACzE,UAAM,OAAO,cAAc,OAAO,WAAS,UAAU,SAAS;AAC9D,SAAK,KAAK,SAAS;AACnB,SAAK,MAAM,uBAAuB;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,mBAAmB,WAA6C;AAC5D,UAAM,gBAAgB,KAAK,wBAAwB,sBAAsB;AACzE,SAAK,MAAM,uBAAuB,cAAc,OAAO,WAAS,UAAU,SAAS;AAAA,EACvF;AAAA,EAEA,yCACI,SACA,UACF;AACE,SAAK,OAAO,qBAAqB;AAAA,MAC7B;AAAA,QACI;AAAA,QACA;AAAA,MACJ;AAAA,MACA,KAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,mBAAmB,WAA0C;AACzD,UAAM,gBAAgB,KAAK,wBAAwB,mBAAmB;AACtE,UAAM,OAAO,cAAc,OAAO,WAAS,UAAU,SAAS;AAC9D,SAAK,KAAK,SAAS;AACnB,SAAK,MAAM,oBAAoB;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,gBAAgB,WAA0C;AACtD,UAAM,gBAAgB,KAAK,wBAAwB,mBAAmB;AACtE,SAAK,MAAM,oBAAoB,cAAc,OAAO,WAAS,UAAU,SAAS;AAAA,EACpF;AAAA,EAEA,sCACI,SACA,UACF;AACE,SAAK,OAAO,kBAAkB;AAAA,MAC1B;AAAA,QACI;AAAA,QACA;AAAA,MACJ;AAAA,MACA,KAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,qBAAqB,WAA4C;AAC7D,UAAM,gBAAgB,KAAK,wBAAwB,qBAAqB;AACxE,UAAM,OAAO,cAAc,OAAO,WAAS,UAAU,SAAS;AAC9D,SAAK,KAAK,SAAS;AACnB,SAAK,MAAM,sBAAsB;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,WAA4C;AAC1D,UAAM,gBAAgB,KAAK,wBAAwB,qBAAqB;AACxE,SAAK,MAAM,sBAAsB,cAAc,OAAO,WAAS,UAAU,SAAS;AAAA,EACtF;AAAA,EAEA,wCACI,SACA,UACF;AACE,SAAK,OAAO,oBAAoB;AAAA,MAC5B;AAAA,QACI;AAAA,QACA;AAAA,MACJ;AAAA,MACA,KAAK;AAAA,IACT;AAAA,EACJ;AAAA,EAEA,MAAM,UAAU;AACZ,SAAK,OAAO,WAAW;AAAA,MACnB,EAAE,YAAY,KAAK,MAAM,cAAc,mBAAmB,WAAW,YAAY;AAAA,MACjF,KAAK;AAAA,IACT;AAGA,SAAK,SAAS,aAAa,KAAK,MAAM;AACtC,SAAK,SAAS,6CAA6C,KAAK,MAAM;AAEtE,SAAK,SAAS,iCAAiC,KAAK;AAAA,MAChD;AAAA,MACA,IAAI;AAAA,MACJ,KAAK,SAAS,KAAK,mCAAmC;AAAA,IAC1D,EAAE,MAAM;AAER,UAAM,KAAK,mBAAmB;AAAA,EAClC;AAAA,EAEA,sCAAsC;AAClC,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,cAAc,MAAM,KAAK,SAAS;AACxC,SAAK,MAAM,+BAA+B,KAAK,MAAM,+BAA+B;AACpF,SAAK,SAAS,6CAA6C;AAAA,EAC/D;AAAA,EAEA,MAAM,qBAAqB;AACvB,UAAM,cAAc,KAAK,SAAS,IAAI,IAAI,WAAW;AACrD,UAAM,iCAAiC,YAAY;AAEnD,UAAM,iBAAiB,KAAK,SAAS,UAAU,YAAY,aAAa,EAAE;AAC1E,UAAM,0BAA0B,MAAM,eAAe,qBAAqB;AAK1E,QAAI,cAAc,mBAAmB,cAAc;AACnD,QAAI,KAAK,SAAS,UAAU,IAAI,0BAA0B,GAAG;AACzD,YAAM,uBAAuB,KAAK,MAAM,IAAI,0BAA0B;AACtE,UACI,0BAA0B,qBAAqB,YAC/C,qBAAqB,SAAS,sBAChC;AACE,sBAAc,mBAAmB,cAAc;AAAA,MACnD,WACI,4BAA4B,qBAAqB,YACjD,qBAAqB,SAAS,wBAChC;AACE,sBAAc,mBAAmB,cAAc;AAAA,MACnD;AAAA,IACJ;AAIA,UAAM,yBACF,mCAAmC,SAC7B,MAAM,OACN,CAAC,SAAiB;AACd,aAAO,SAAS;AAAA,IACpB;AAGV,SAAK,MAAM,oBAAoB,wBAC1B,OAAO,CAAC,EAAE,IAAI,MAAM,QAAQ,mBAAmB,EAC/C,KAAK,CAAC,EAAE,MAAM,MAAM,GAAG,EAAE,MAAM,MAAM,MAAM;AAExC,UAAI,uBAAuB,KAAK,KAAK,CAAC,uBAAuB,KAAK,GAAG;AACjE,eAAO;AAAA,MACX;AACA,UAAI,CAAC,uBAAuB,KAAK,KAAK,uBAAuB,KAAK,GAAG;AACjE,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX,CAAC,EACA,MAAM,GAAG,CAAC,EACV,IAAI,CAAC,EAAE,MAAM,KAAK,MAAM,MAAM,KAAK,OAAO;AAAA,MACvC;AAAA,MACA,eAAe,uBAAuB,IAAI;AAAA,MAC1C,iCAAiC;AAAA;AAAA,MACjC,iCAAiC;AAAA;AAAA,MACjC,iBAAiB,UAAU,QAAQ,IAAI,QAAQ,gBAAgB,EAAE,CAAC;AAAA,MAClE,eAAe,KAAK,MAAM,GAAG,CAAC,EAAE,IAAI,QAAM,gBAAgB,EAAE,CAAC;AAAA,MAC7D,eAAe,KAAK,MAAM,GAAG,CAAC,EAAE,IAAI,QAAM,gBAAgB,EAAE,CAAC;AAAA,MAC7D,MAAM,QAAQ;AAAA,IAClB,EAAE;AAAA,EACV;AAAA,EAEA,OAAgB,OAAO,YAAY,IAAI;AACnC,SAAK,SAAS,gCAAgC,KAAK;AACnD,SAAK,oCAAoC;AACzC,UAAM,MAAM,OAAO,YAAY,IAAI;AAAA,EACvC;AACJ;AAAA,CAEO,CAAUA,8BAAV;AAAA,EACI,MAAM,SAAS;AAAA;AAAA,IAElB,aAAqB,KAAK,MAAM;AAAA;AAAA,IAGhC,6CAAqD,KAAK,MAAM;AAAA;AAAA,IAGhE;AAAA,EACJ;AATO,EAAAA,0BAAM;AAAA,EAWN,MAAM,cAAc,KAAK,MAAM;AAAA;AAAA,IAElC,+BAAuC;AAAA;AAAA,IAGvC,sBAAsB,IAAI,UAAU,EAAE,EAAE,KAAK,CAAC;AAAA,IAE9C,CAAC,IAAI,UAAU,EAAE,UAAoB,UAAmC;AACpE,aAAO;AAAA;AAAA;AAAA;AAAA;AAAA,QAKH,IAAI,SAAS;AACT,gBAAM,aAAa,SAAS,UAAU,YAAYA,yBAAwB,EAAE;AAC5E,iBAAO,KAAK,OAAO,KAAK,MAAM,IAAI,cAAc,GAAI;AAAA,QACxD;AAAA;AAAA;AAAA;AAAA;AAAA,QAMA,IAAI,wBAAwB;AACxB,gBAAM,6CACF,SAAS,UAAU;AAAA,YACfA;AAAA,UACJ,EAAE;AACN,gBAAM,+BACF,SAAS,QAAQA,yBAAwB,EAAE;AAC/C,iBAAO,KAAK;AAAA,aACP,KAAK,MAAM,IAAI,6CAA6C,iCACxD,KAAK;AAAA,UACd;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AApCO,EAAAA,0BAAM;AAAA,GAZA;",
  "names": ["GeneralDiagnosticsServer"]
}
