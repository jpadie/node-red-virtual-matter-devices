{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/time-synchronization/TimeSynchronizationInterface.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { TimeSynchronization } from \"../../../cluster/definitions/TimeSynchronizationCluster.js\";\n\nexport namespace TimeSynchronizationInterface {\n    export interface Base {\n        /**\n         * This command may be issued by Administrator to set the time. If the Commissioner does not have a valid time\n         * source, it may send a Granularity of NoTimeGranularity.\n         *\n         * Upon receipt of this command, the node may update its UTCTime attribute to match the time specified in the\n         * command, if the stated Granularity and TimeSource are acceptable. The node shall update its UTCTime\n         * attribute if its current Granularity is NoTimeGranularity.\n         *\n         * If the time is updated, the node shall also update its Granularity attribute based on the granularity\n         * specified in the command and the expected clock drift of the node. This SHOULD normally be one level lower\n         * than the stated command Granularity. It shall also update its TimeSource attribute to Admin. It shall also\n         * update its Last Known Good UTC Time as defined in Section 3.5.6.1, \u201CLast Known Good UTC Time\u201D.\n         *\n         * If the node updates its UTCTime attribute, it shall accept the command with a status code of SUCCESS. If it\n         * opts to not update its time, it shall fail the command with a cluster specific Status Code of\n         * TimeNotAccepted.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1\n         */\n        setUtcTime(request: TimeSynchronization.SetUtcTimeRequest): MaybePromise;\n    }\n\n    export interface TimeSyncClient {\n        /**\n         * This command shall set the TrustedTimeSource attribute. Upon receipt of this command, * If the\n         * TrustedTimeSource field in the command is null, the node shall set the TrustedTimeSource attribute to null\n         * and shall generate a MissingTrustedTimeSource event. * Otherwise, the node shall set the TrustedTimeSource\n         * attribute to a struct which has NodeID and Endpoint fields matching those in the TrustedTimeSource field and\n         * has its FabricIndex field set to the command\u2019s accessing fabric index.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.2\n         */\n        setTrustedTimeSource(request: TimeSynchronization.SetTrustedTimeSourceRequest): MaybePromise;\n    }\n\n    export interface NtpClient {\n        /**\n         * This command is used to set the DefaultNTP attribute. If the DefaultNTP Address field does not conform to\n         * the requirements in the DefaultNTP attribute description, the command shall fail with a status code of\n         * INVALID_COMMAND. If the node does not support DNS resolution (as specified in SupportsDNSResolve) and the\n         * provided Address is a domain name, the command shall fail with a status code of INVALID_COMMAND. Otherwise,\n         * the node shall set the DefaultNTP attribute to match the DefaultNTP provided in this command.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.6\n         */\n        setDefaultNtp(request: TimeSynchronization.SetDefaultNtpRequest): MaybePromise;\n    }\n\n    export interface TimeZone {\n        /**\n         * This command is used to set the time zone of the node.\n         *\n         * If the given list is larger than the TimeZoneListMaxSize, the node shall respond with RESOURCE_EXHAUSTED and\n         * the TimeZone attribute shall NOT be updated.\n         *\n         * If the given list does not conform to the list requirements in TimeZone attribute the node shall respond\n         * with a CONSTRAINT_ERROR and the TimeZone attribute shall NOT be updated.\n         *\n         * If there are no errors in the list, the TimeZone field shall be copied to the TimeZone attribute. A\n         * TimeZoneStatus event shall be generated with the new time zone information.\n         *\n         * If the node supports a time zone database and it has information available for the time zone that will be\n         * applied, it may set its DSTOffset attribute, otherwise the DSTOffset attribute shall be set to an empty\n         * list. A DSTTableEmpty event shall be generated if the DSTOffset attribute is empty. A DSTStatus event shall\n         * be generated if the node was previously applying a DST offset.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.3\n         */\n        setTimeZone(request: TimeSynchronization.SetTimeZoneRequest): MaybePromise<TimeSynchronization.SetTimeZoneResponse>;\n\n        /**\n         * This command is used to set the DST offsets for a node.\n         *\n         *   \u2022 If the length of DSTOffset is larger than DSTOffsetListMaxSize, the node shall respond with\n         *     RESOURCE_EXHAUSTED.\n         *\n         *   \u2022 Else if the list entries do not conform to the list requirements for DSTOffset attribute, the node shall\n         *     respond with CONSTRAINT_ERROR.\n         *\n         * If there are no errors in the list, the DSTOffset field shall be copied to the DSTOffset attribute.\n         *\n         * If the DSTOffset attribute change causes a corresponding change to the DST state, a DSTStatus event shall be\n         * generated. If the list is empty, the node shall generate a DSTTableEmpty event.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.5\n         */\n        setDstOffset(request: TimeSynchronization.SetDstOffsetRequest): MaybePromise;\n    }\n}\n\nexport type TimeSynchronizationInterface = {\n    components: [\n        { flags: {}, methods: TimeSynchronizationInterface.Base },\n        { flags: { timeSyncClient: true }, methods: TimeSynchronizationInterface.TimeSyncClient },\n        { flags: { ntpClient: true }, methods: TimeSynchronizationInterface.NtpClient },\n        { flags: { timeZone: true }, methods: TimeSynchronizationInterface.TimeZone }\n    ]\n};\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
