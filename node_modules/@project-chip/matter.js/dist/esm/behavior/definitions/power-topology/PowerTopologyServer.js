/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterType } from "../../../cluster/ClusterType.js";
import { PowerTopology } from "../../../cluster/definitions/PowerTopologyCluster.js";
import { ImplementationError } from "../../../common/MatterError.js";
import { DescriptorServer } from "../descriptor/DescriptorServer.js";
import { ElectricalEnergyMeasurementBehavior } from "../electrical-energy-measurement/ElectricalEnergyMeasurementBehavior.js";
import { ElectricalPowerMeasurementBehavior } from "../electrical-power-measurement/ElectricalPowerMeasurementBehavior.js";
import { PowerTopologyBehavior } from "./PowerTopologyBehavior.js";
const PowerTopologyBase = PowerTopologyBehavior.with(
  PowerTopology.Feature.SetTopology,
  PowerTopology.Feature.DynamicPowerFlow
);
class PowerTopologyServerLogic extends PowerTopologyBase {
  initialize() {
    if (this.agent.has(ElectricalPowerMeasurementBehavior) || this.agent.has(ElectricalEnergyMeasurementBehavior)) {
      this.agent.get(DescriptorServer).addDeviceTypes("ElectricalSensor");
    }
    this.#assertActiveEndpointsAllowed(this.state.activeEndpoints);
    this.reactTo(this.events.activeEndpoints$Changing, this.#assertActiveEndpointsAllowed);
  }
  #assertActiveEndpointsAllowed(list) {
    const availableEndpoints = this.state.availableEndpoints;
    list.forEach((endpoint) => {
      if (!availableEndpoints.includes(endpoint)) {
        throw new ImplementationError(`Endpoint ${endpoint} is not in the list of available endpoints`);
      }
    });
  }
}
class PowerTopologyServer extends PowerTopologyServerLogic.for(ClusterType(PowerTopology.Base)) {
}
export {
  PowerTopologyServer,
  PowerTopologyServerLogic
};
//# sourceMappingURL=PowerTopologyServer.js.map
