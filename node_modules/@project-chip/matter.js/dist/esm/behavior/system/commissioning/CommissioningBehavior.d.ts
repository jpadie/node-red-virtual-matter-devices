/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { FabricIndex } from "../../../datatype/FabricIndex.js";
import { Endpoint } from "../../../endpoint/Endpoint.js";
import { ExposedFabricInformation } from "../../../fabric/Fabric.js";
import { FabricAction } from "../../../fabric/FabricManager.js";
import { DatatypeModel } from "../../../model/index.js";
import { CommissioningFlowType } from "../../../schema/PairingCodeSchema.js";
import { ByteArray } from "../../../util/ByteArray.js";
import { EventEmitter, Observable } from "../../../util/Observable.js";
import { Behavior } from "../../Behavior.js";
import { ActionContext } from "../../context/ActionContext.js";
import { Val } from "../../state/Val.js";
import { CommissioningOptions } from "./CommissioningOptions.js";
/**
 * Server functionality related to commissioning used by {@link EndpointServer}.
 *
 * Better name would be CommissioningServer but we already have one of those.
 */
export declare class CommissioningBehavior extends Behavior {
    #private;
    static readonly id = "commissioning";
    state: CommissioningBehavior.State;
    events: CommissioningBehavior.Events;
    internal: CommissioningBehavior.Internal;
    static early: boolean;
    initialize(): void;
    [Symbol.asyncDispose](): void;
    handleFabricChange(fabricIndex: FabricIndex, fabricAction: FabricAction): void;
    /**
     * The server invokes this method when the node is active but not yet commissioned.
     *
     * An uncommissioned node is not yet associated with fabrics.  It cannot be used until commissioned by a controller.
     *
     * The default implementation logs the QR code and credentials.
     */
    initiateCommissioning(): void;
    /**
     * Obtain pairing codes for a node.
     */
    static pairingCodesFor(node: Endpoint): {
        manualPairingCode: string;
        qrPairingCode: string;
    };
    /**
     * Define logical schema to make passcode and discriminator persistent.
     */
    static readonly schema: DatatypeModel;
}
export declare namespace CommissioningBehavior {
    interface PairingCodes {
        manualPairingCode: string;
        qrPairingCode: string;
    }
    class Internal {
        unregisterFailsafeListener?: () => void;
    }
    class State implements CommissioningOptions {
        commissioned: boolean;
        fabrics: Record<FabricIndex, ExposedFabricInformation>;
        passcode: number;
        discriminator: number;
        flowType: CommissioningFlowType;
        additionalBleAdvertisementData?: ByteArray;
        pairingCodes: PairingCodes;
        [Val.properties](endpoint: Endpoint): {
            readonly pairingCodes: {
                manualPairingCode: string;
                qrPairingCode: string;
            };
        };
    }
    class Events extends EventEmitter {
        commissioned: Observable<[session: ActionContext], void>;
        decommissioned: Observable<[session: ActionContext], void>;
        fabricsChanged: Observable<[fabricIndex: FabricIndex, action: FabricAction], void>;
    }
}
//# sourceMappingURL=CommissioningBehavior.d.ts.map