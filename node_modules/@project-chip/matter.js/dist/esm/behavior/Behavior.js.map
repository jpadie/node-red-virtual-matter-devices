{
  "version": 3,
  "sources": ["../../../src/behavior/Behavior.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type { ClusterType } from \"../cluster/ClusterType.js\";\nimport { ImplementationError, NotImplementedError } from \"../common/MatterError.js\";\nimport { Agent, INSTALL_BEHAVIOR } from \"../endpoint/Agent.js\";\nimport \"../polyfills/disposable.js\";\nimport { assertSecureSession } from \"../session/SecureSession.js\";\nimport { GeneratedClass } from \"../util/GeneratedClass.js\";\nimport { EventEmitter, Observable } from \"../util/Observable.js\";\nimport { MaybePromise } from \"../util/Promises.js\";\nimport { Reactor } from \"./Reactor.js\";\nimport type { BehaviorBacking } from \"./internal/BehaviorBacking.js\";\nimport { DerivedState, EmptyState } from \"./state/StateType.js\";\nimport { Resource } from \"./state/transaction/Resource.js\";\nimport { BehaviorSupervisor } from \"./supervision/BehaviorSupervisor.js\";\nimport { RootSupervisor } from \"./supervision/RootSupervisor.js\";\nimport { Schema } from \"./supervision/Schema.js\";\n\n// Internal fields\nconst BACKING = Symbol(\"endpoint-owner\");\nconst STATE = Symbol(\"state\");\nconst INTERNAL = Symbol(\"internal\");\nconst EVENTS = Symbol(\"events\");\n\ninterface Internal extends Behavior {\n    [BACKING]: BehaviorBacking;\n    [STATE]: {};\n    [INTERNAL]: {};\n    [EVENTS]: EventEmitter;\n}\n\nconst SUPERVISOR = Symbol(\"supervisor\");\n\ninterface StaticInternal {\n    [SUPERVISOR]?: RootSupervisor;\n}\n\n/**\n * Behavior implements functionality for an Endpoint.  Endpoint agents are implemented as a composition of behaviors.\n *\n * Most behaviors associated 1:1 with a Matter cluster type as implemented by ClusterBehavior.  But you can also extend\n * Behavior directly to add other types of composable logic to an endpoint.\n *\n * You probably want to build your behavior using one of the standard implementations offered by Matter.js.\n */\nexport abstract class Behavior {\n    #agent: Agent;\n\n    /**\n     * Each behavior implementation has an ID that uniquely identifies the type of behavior.  An Endpoint may only have\n     * one behavior with the specified ID.\n     *\n     * Endpoint instances store each behavior in a property with the same name as the behavior's ID.\n     *\n     * EndpointBuilder also uses the ID when replacing behaviors using the with() builder method.\n     */\n    static readonly id: string;\n\n    /**\n     * A behavior's schema controls access to data, commands and events.\n     *\n     * Schema is inferred from the methods and properties of the behavior but you can specify explicitly for additional\n     * control.\n     */\n    static readonly schema?: Schema;\n\n    /**\n     * By default behaviors load lazily as they are accessed.  You can set this flag to true to force behaviors to load\n     * immediately when the endpoint initializes.\n     */\n    static readonly early: boolean = false;\n\n    /**\n     * The agent that owns the behavior.\n     */\n    get agent() {\n        return this.#agent;\n    }\n\n    /**\n     * The endpoint that owns behavior's agent.\n     */\n    get endpoint() {\n        return this.#agent.endpoint;\n    }\n\n    /**\n     * The context in which the behavior operates.\n     */\n    get context() {\n        return this.#agent.context;\n    }\n\n    /**\n     * The session in which the behavior has been invoked.\n     */\n    get session() {\n        const session = this.#agent.context.session;\n        if (session === undefined) {\n            throw new ImplementationError(`Illegal operation outside session context`);\n        }\n\n        // TODO - would a behavior ever need access to an insecure session?\n        assertSecureSession(session);\n\n        return session;\n    }\n\n    /**\n     * Execute logic with elevated privileges.\n     *\n     * The provided function executes with privileges escalated to offline mode.  This is not commonly necessary.\n     *\n     * Elevated logic effectively ignores ACLs so should be used with care.\n     *\n     * Note that interactions with the behavior will remain elevated until the synchronous completion of this call.\n     * You should only elevate privileges for synchronous logic.\n     *\n     * @param fn the elevated logic\n     */\n    asAdmin(fn: () => void) {\n        const context = this.context;\n\n        const offline = context.offline;\n        try {\n            context.offline = true;\n            fn();\n        } finally {\n            context.offline = offline;\n        }\n    }\n\n    /**\n     * Access the behavior's state.\n     */\n    declare readonly state: {};\n\n    /**\n     * Access the behavior's events.\n     */\n    declare readonly events: EventEmitter;\n\n    constructor(agent: Agent, backing: BehaviorBacking) {\n        this.#agent = agent;\n        (this as unknown as Internal)[BACKING] = backing;\n\n        // Note - for introspection instance agent and backing will actually be undefined.  Not represented in types\n        // because it would require numerous assertions just to handle internal edge case\n        if (agent !== undefined) {\n            (agent as unknown as Agent.Internal)[INSTALL_BEHAVIOR](this);\n        }\n    }\n\n    /**\n     * The data supervisor for the behavior.  The supervisor controls validation and access to behavior data.\n     */\n    static get supervisor(): RootSupervisor {\n        if (Object.hasOwn(this, SUPERVISOR)) {\n            return (this as StaticInternal)[SUPERVISOR] as RootSupervisor;\n        }\n        return ((this as StaticInternal)[SUPERVISOR] = BehaviorSupervisor(this));\n    }\n\n    /**\n     * Implementation of endpoint-scoped state.  Subclasses may override to extend.\n     */\n    static State = EmptyState;\n\n    /**\n     * Implementation of internal state.  Subclasses may override to extend.\n     */\n    static Internal = EmptyState;\n\n    /**\n     * Implementation of the events property.  Subclasses may override to extend.\n     */\n    static Events = EventEmitter;\n\n    /**\n     * Behaviors are ephemeral and should not perform initialization in their constructor.  They can override this\n     * method instead.\n     *\n     * This method may be synchronous or asyncronous.  If asynchronous, the behavior will not be available for external\n     * use until initialization completes.\n     */\n    initialize(_options?: {}): MaybePromise {}\n\n    /**\n     * Release resources.  This is the public API for releasing application resources held by behaviors in internal\n     * state.\n     */\n    [Symbol.asyncDispose](): MaybePromise {}\n\n    /**\n     * Description used in diagnostic messages.\n     */\n    toString() {\n        return `${this.endpoint}.${(this.constructor as Behavior.Type).id}`;\n    }\n\n    /**\n     * Install a {@link Reactor}.\n     *\n     * Important: The reactor MUST be a real JS function - arrow functions will not work!\n     */\n    protected reactTo<O extends Observable<any[], any>>(\n        observable: O,\n        reactor: Reactor<Parameters<O[\"emit\"]>, ReturnType<O[\"emit\"]>>,\n        options?: Reactor.Options,\n    ) {\n        (this as unknown as Internal)[BACKING].reactTo(observable, reactor, options);\n    }\n\n    /**\n     * Create a generic callback function that has the same properties as a {@link Reactor}.\n     *\n     * Like a reactor, the callback's \"this\" will be bound to an active Behavior instance.\n     * Because of this: The reactor MUST be a real JS function - arrow functions will not work!\n     */\n    protected callback<A extends any[], R>(reactor: Reactor<A, R>, options?: Reactor.Options) {\n        const observable = Observable<A, R>();\n\n        this.reactTo(observable, reactor, options);\n\n        return (...args: A) => observable.emit(...args);\n    }\n\n    /**\n     * Does this behavior support functionality of a specific implementation?\n     */\n    static supports(other: Behavior.Type) {\n        return (this as any) === other || this.prototype instanceof other;\n    }\n\n    /**\n     * Default state values.\n     */\n    static get defaults(): Record<string, any> {\n        return new this.State();\n    }\n\n    /**\n     * Create a new behavior with different default state values.\n     */\n    static set<This extends Behavior.Type>(this: This, defaults: Behavior.InputStateOf<This>) {\n        return GeneratedClass({\n            name: this.name,\n            base: this,\n\n            staticProperties: {\n                State: DerivedState({\n                    name: `${this.name}$State`,\n                    base: this.State,\n                    values: defaults,\n                }),\n            },\n        }) as unknown as This;\n    }\n\n    /**\n     * Explicitly reference other {@link Behavior}s as dependencies, ensuring this behavior is destroyed first.\n     *\n     * This probably won't be commonly necessary.  If it is we can instrument Agent to collect dependencies\n     * automatically.\n     */\n    static dependencies?: Iterable<Behavior.Type>;\n\n    get [Resource.reference]() {\n        return (this as unknown as Internal)[BACKING].datasource;\n    }\n}\n\n// TS prevents us from declaring an override type if the base field is a getter in the class.  So we just declare in the\n// base class and manually install the getters here.\nObject.defineProperties(Behavior.prototype, {\n    state: {\n        get(this: Internal) {\n            if (!this[STATE]) {\n                this[STATE] = this[BACKING].datasource.reference(this.context);\n            }\n            return this[STATE];\n        },\n\n        enumerable: true,\n    },\n\n    internal: {\n        get(this: Internal) {\n            if (!this[INTERNAL]) {\n                this[INTERNAL] = this[BACKING].getInternal();\n            }\n            return this[INTERNAL];\n        },\n\n        enumerable: false,\n    },\n\n    events: {\n        get(this: Internal) {\n            if (!this[EVENTS]) {\n                this[EVENTS] = this[BACKING].events;\n            }\n            return this[EVENTS];\n        },\n\n        enumerable: true,\n    },\n});\n\nexport namespace Behavior {\n    /**\n     * Static properties supported by all behaviors.\n     */\n    export interface Type {\n        new (agent: Agent, backing: BehaviorBacking): Behavior;\n\n        readonly name: string;\n        readonly id: typeof Behavior.id;\n        readonly set: typeof Behavior.set;\n        readonly supports: typeof Behavior.supports;\n        readonly defaults: Record<string, any>;\n\n        readonly schema?: Schema;\n        readonly early: boolean;\n        readonly supervisor: RootSupervisor;\n        readonly dependencies?: Iterable<Behavior.Type>;\n        readonly State: new () => {};\n        readonly Internal: new () => {};\n        readonly Events: typeof EventEmitter;\n    }\n\n    /**\n     * This function simply throws NotImplementedError.  More importantly, its presence in any command implementation\n     * method informs the endpoint that the command is not implemented.\n     */\n    export function unimplemented(..._args: any[]): Promise<any> {\n        throw new NotImplementedError();\n    }\n\n    /**\n     * The state type of a behavior {@link Type}.\n     */\n    export type StateOf<B extends Type> = InstanceType<B[\"State\"]>;\n\n    /**\n     * Input variant of StateOf.\n     */\n    export type InputStateOf<B extends Type> = Partial<ClusterType.RelaxTypes<StateOf<B>>>;\n\n    /**\n     * Patch variant of StateOf.\n     */\n    export type PatchStateOf<B extends Type> = ClusterType.PatchType<StateOf<B>>;\n\n    /**\n     * The events type of a behavior {@link Type}.\n     */\n    export type EventsOf<B extends Type> = InstanceType<B[\"Events\"]>;\n\n    /**\n     * Initialization options.\n     */\n    export type InitializationOptionsOf<B extends Type> =\n        Parameters<InstanceType<B>[\"initialize\"]> extends [infer P extends object] ? P : {};\n\n    /**\n     * Configuration options you may set when adding a {@link Behavior} to an endpoint.\n     */\n    export type Options<T extends Behavior.Type = Behavior.Type> = Behavior.InputStateOf<T> &\n        Behavior.InitializationOptionsOf<T>;\n}\n"],
  "mappings": "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",
  "names": ["Behavior"]
}
