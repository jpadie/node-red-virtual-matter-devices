{
  "version": 3,
  "sources": ["../../../../../src/behavior/context/server/OfflineContext.ts"],
  "sourcesContent": ["import { AccessLevel } from \"../../../cluster/Cluster.js\";\nimport { Agent } from \"../../../endpoint/Agent.js\";\nimport { Endpoint } from \"../../../endpoint/Endpoint.js\";\nimport { EndpointType } from \"../../../endpoint/type/EndpointType.js\";\nimport { Diagnostic } from \"../../../log/Diagnostic.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { Transaction } from \"../../state/transaction/Transaction.js\";\nimport { ReadOnlyTransaction } from \"../../state/transaction/Tx.js\";\nimport { ActionContext } from \"../ActionContext.js\";\nimport { ActionTracer } from \"../ActionTracer.js\";\nimport { Contextual } from \"../Contextual.js\";\nimport { NodeActivity } from \"../NodeActivity.js\";\nimport { ContextAgents } from \"./ContextAgents.js\";\n\nexport let nextInternalId = 1;\n\n/**\n * {@link OfflineContext.act} gives you access to the {@link Agent} API outside of user interaction.\n *\n * You can also use {@link OfflineContext.ReadOnly} for read-only {@link Agent} access.\n */\nexport const OfflineContext = {\n    /**\n     * Operate in offline context.  Interactions with private Matter.js APIs happen in an offline context.\n     *\n     * {@link act} provides an {@link ActionContext} you can use to access agents for a {@link Endpoint}.\n     * State changes and change events occur once {@link actor} returns.\n     *\n     * The {@link Transaction} is destroyed with {@link act} exits so you should not keep a reference to any agents\n     * beyond the lifespan of {@link actor}.\n     *\n     * Offline context is very permissive.  You should use carefully.\n     */\n    act<T>(\n        purpose: string,\n        activity: NodeActivity | undefined,\n        actor: (context: ActionContext) => MaybePromise<T>,\n        options?: OfflineContext.Options,\n    ): MaybePromise<T> {\n        const id = nextInternalId;\n        nextInternalId = (nextInternalId + 1) % 65535;\n        const via = Diagnostic.via(`${purpose}#${id.toString(16)}`);\n\n        let context: ActionContext | undefined;\n        let frame: NodeActivity.Activity | undefined;\n\n        const actOffline = (transaction: Transaction) => {\n            context = createOfflineContext(transaction, frame, options);\n            return actor(context);\n        };\n\n        let isAsync = false;\n        try {\n            frame = activity?.begin(via);\n\n            const result = Transaction.act(via, actOffline);\n\n            if (MaybePromise.is(result)) {\n                isAsync = true;\n                return Promise.resolve(result).finally(() => {\n                    frame?.[Symbol.dispose]();\n                }) as T;\n            }\n\n            return result;\n        } finally {\n            if (!isAsync) {\n                frame?.[Symbol.dispose]();\n            }\n        }\n    },\n\n    /**\n     * Normally you need to use {@link OfflineContext.act} to work with behaviors, and you can only interact with the\n     * behaviors in the actor function.  This {@link ActionContext} allows you to create offline agents that remain\n     * functional for the lifespan of the node.\n     *\n     * Write operations will throw an error with this context.\n     */\n    ReadOnly: createOfflineContext(ReadOnlyTransaction),\n\n    [Symbol.toStringTag]: \"OfflineContext\",\n};\n\nexport namespace OfflineContext {\n    /**\n     * {@link OfflineContext} configuration options.\n     */\n    export interface Options {\n        trace?: ActionTracer.Action;\n    }\n}\n\nfunction createOfflineContext(\n    transaction: Transaction,\n    activity?: NodeActivity.Activity,\n    options?: OfflineContext.Options,\n) {\n    let agents: undefined | ContextAgents;\n\n    const context = Object.freeze({\n        ...options,\n\n        // Disable access level enforcement\n        offline: true,\n\n        transaction,\n        activity,\n\n        authorizedFor(desiredAccessLevel: AccessLevel) {\n            // Be as restrictive as possible.  The offline flag should make this irrelevant\n            return desiredAccessLevel === AccessLevel.View;\n        },\n\n        agentFor<const T extends EndpointType>(endpoint: Endpoint<T>): Agent.Instance<T> {\n            if (!agents) {\n                agents = ContextAgents(context);\n            }\n            return agents?.agentFor(endpoint);\n        },\n\n        get [Contextual.context]() {\n            return this;\n        },\n\n        [Symbol.toStringTag]: \"OfflineContext\",\n    });\n\n    return context;\n}\n"],
  "mappings": "AAAA,SAAS,mBAAmB;AAI5B,SAAS,kBAAkB;AAC3B,SAAS,oBAAoB;AAC7B,SAAS,mBAAmB;AAC5B,SAAS,2BAA2B;AAGpC,SAAS,kBAAkB;AAE3B,SAAS,qBAAqB;AAEvB,IAAI,iBAAiB;AAOrB,MAAM,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAY1B,IACI,SACA,UACA,OACA,SACe;AACf,UAAM,KAAK;AACX,sBAAkB,iBAAiB,KAAK;AACxC,UAAM,MAAM,WAAW,IAAI,GAAG,OAAO,IAAI,GAAG,SAAS,EAAE,CAAC,EAAE;AAE1D,QAAI;AACJ,QAAI;AAEJ,UAAM,aAAa,CAAC,gBAA6B;AAC7C,gBAAU,qBAAqB,aAAa,OAAO,OAAO;AAC1D,aAAO,MAAM,OAAO;AAAA,IACxB;AAEA,QAAI,UAAU;AACd,QAAI;AACA,cAAQ,UAAU,MAAM,GAAG;AAE3B,YAAM,SAAS,YAAY,IAAI,KAAK,UAAU;AAE9C,UAAI,aAAa,GAAG,MAAM,GAAG;AACzB,kBAAU;AACV,eAAO,QAAQ,QAAQ,MAAM,EAAE,QAAQ,MAAM;AACzC,kBAAQ,OAAO,OAAO,EAAE;AAAA,QAC5B,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,UAAE;AACE,UAAI,CAAC,SAAS;AACV,gBAAQ,OAAO,OAAO,EAAE;AAAA,MAC5B;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,qBAAqB,mBAAmB;AAAA,EAElD,CAAC,OAAO,WAAW,GAAG;AAC1B;AAWA,SAAS,qBACL,aACA,UACA,SACF;AACE,MAAI;AAEJ,QAAM,UAAU,OAAO,OAAO;AAAA,IAC1B,GAAG;AAAA;AAAA,IAGH,SAAS;AAAA,IAET;AAAA,IACA;AAAA,IAEA,cAAc,oBAAiC;AAE3C,aAAO,uBAAuB,YAAY;AAAA,IAC9C;AAAA,IAEA,SAAuC,UAA0C;AAC7E,UAAI,CAAC,QAAQ;AACT,iBAAS,cAAc,OAAO;AAAA,MAClC;AACA,aAAO,QAAQ,SAAS,QAAQ;AAAA,IACpC;AAAA,IAEA,KAAK,WAAW,OAAO,IAAI;AACvB,aAAO;AAAA,IACX;AAAA,IAEA,CAAC,OAAO,WAAW,GAAG;AAAA,EAC1B,CAAC;AAED,SAAO;AACX;",
  "names": []
}
