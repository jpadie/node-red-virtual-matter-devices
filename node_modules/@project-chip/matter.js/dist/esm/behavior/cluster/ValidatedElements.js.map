{
  "version": 3,
  "sources": ["../../../../src/behavior/cluster/ValidatedElements.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterType } from \"../../cluster/ClusterType.js\";\nimport { ImplementationError } from \"../../common/MatterError.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { Observable } from \"../../util/Observable.js\";\nimport { Behavior } from \"../Behavior.js\";\nimport { ClusterBehavior } from \"./ClusterBehavior.js\";\nimport { introspectionInstanceOf } from \"./ClusterBehaviorUtil.js\";\n\nconst logger = Logger.get(\"ValidatedElements\");\n\n/**\n * Analyzes a ClusterBehavior implementation to ensure it conforms to the Matter specification.\n *\n * As this API is accessible via vanilla JavaScript, validation includes tests for errors that TypeScript otherwise\n * prevents.\n *\n * Records elements supported and a list of errors if validation fails.\n */\nexport class ValidatedElements {\n    /**\n     * Supported attributes.\n     */\n    attributes = new Set<string>();\n\n    /**\n     * Supported commands.\n     */\n    commands = new Set<string>();\n\n    /**\n     * Supported events.\n     */\n    events = new Set<string>();\n\n    /**\n     * A list of implementation errors, if any.\n     */\n    errors?: { element: string; message: string; fatal: boolean }[];\n\n    #name: string;\n    #type: Behavior.Type;\n    #instance?: Behavior;\n    #cluster: ClusterType;\n\n    /**\n     * Obtain validation information.\n     *\n     * Validation may run against the type alone or with a specific instance of the behavior.  The latter option allows\n     * for per-instance specialization.\n     *\n     * @param type the behavior type to analyze\n     * @param instance optional concrete instance of the behavior\n     */\n    constructor(type: ClusterBehavior.Type, instance?: Behavior) {\n        this.#type = type;\n        this.#instance = instance;\n        this.#name = type.name;\n        this.#cluster = type.cluster;\n\n        if (typeof type !== \"function\") {\n            this.error(undefined, \"Is not a class\", true);\n        }\n        if (this.#cluster === undefined) {\n            this.error(\"cluster\", \"Property missing\", true);\n            return;\n        }\n        if (typeof this.#cluster !== \"object\") {\n            this.error(\"cluster\", \"Property is not an object\", true);\n            return;\n        }\n        if (instance !== undefined && (instance === null || typeof instance !== \"object\")) {\n            this.error(\"instance\", \"Is not an object\", true);\n        }\n\n        this.#validateAttributes();\n        this.#validateCommands();\n        this.#validateEvents();\n    }\n\n    /**\n     * If there are errors, log and throw an exception.\n     */\n    report() {\n        if (!this.errors) {\n            return;\n        }\n\n        let crashed = false;\n\n        for (const error of this.errors) {\n            const diagnostic = Diagnostic.squash(\"Error in \", Diagnostic.strong(error.element), \": \", error.message);\n\n            if (error.fatal) {\n                crashed = true;\n                logger.error(diagnostic);\n            } else {\n                logger.warn(diagnostic);\n            }\n        }\n\n        if (crashed) {\n            throw new ImplementationError(\n                `There ${\n                    this.errors.length > 1 ? `are ${this.errors.length} errors` : `is 1 error`\n                } in a ClusterBehavior implementation for property ${this.#name} (see log for details)`,\n            );\n        }\n    }\n\n    #validateAttributes() {\n        const attributes = this.#cluster.attributes;\n        if (!attributes) {\n            this.error(\"cluster.attributes\", \"Property missing\", true);\n            return;\n        }\n\n        let state;\n\n        if (this.#instance) {\n            state = this.#instance.state;\n        } else {\n            const constructor = this.#type.State;\n            if (!constructor) {\n                this.error(\"State\", \"Property missing\", true);\n                return;\n            }\n\n            try {\n                state = new constructor();\n            } catch (e) {\n                this.error(\"State\", \"Not constructable\", true);\n                return;\n            }\n        }\n\n        for (const name in attributes) {\n            const attr = attributes[name];\n            if (!attr) {\n                this.error(`cluster.attributes.${name}`, \"Undefined element in cluster definition\", true);\n                continue;\n            }\n\n            if ((state as Record<string, unknown>)[name] === undefined) {\n                if (!attr.optional) {\n                    this.error(`State.${name}`, \"Mandatory element unsupported\", false);\n                }\n                continue;\n            }\n\n            this.attributes.add(name);\n\n            // TODO - should we enforce presence of events.<attr>$Changed?\n\n            // TODO - validate \"optional but not nullable\" if attributes get proper metadata (or go to model for this)\n        }\n    }\n\n    #validateCommands() {\n        const commands = this.#cluster.commands;\n        if (!commands) {\n            this.error(\"cluster.commands\", \"Property missing\", true);\n            return;\n        }\n\n        let implementations;\n\n        if (this.#instance) {\n            implementations = this.#instance;\n        } else {\n            try {\n                implementations = introspectionInstanceOf(this.#type);\n            } catch (e) {\n                this.error(\"constructor\", \"Not constructable\", true);\n                return;\n            }\n        }\n\n        for (const name in commands) {\n            const command = commands[name];\n            if (!command) {\n                this.error(`cluster.commands.${name}`, \"Undefined element in cluster definition\", true);\n                continue;\n            }\n\n            const implementation = (implementations as Record<string, unknown>)[name];\n\n            if (!(name in implementations) || implementation === undefined) {\n                if (!command.optional) {\n                    this.error(name, `Implementation missing`, true);\n                }\n                continue;\n            }\n\n            if (typeof implementation !== \"function\") {\n                this.error(name, `Implementation is not a function`, true);\n                continue;\n            }\n\n            if (implementation === Behavior.unimplemented) {\n                if (!command.optional) {\n                    // TODO - do not pollute the logs with these as Matter spec is in flux (should this include groups\n                    // or just scenes?)\n                    if (this.#name.match(/^(?:Groups|Scenes|GroupKeyManagement)(?:Server|Behavior)/)) {\n                        continue;\n                    }\n\n                    // We treat this error as a warning\n                    this.error(name, `Throws unimplemented exception`, false);\n                }\n                continue;\n            }\n\n            this.commands.add(name);\n        }\n    }\n\n    #validateEvents() {\n        const expected = this.#cluster.events;\n        if (typeof expected !== \"object\" || expected === null) {\n            this.error(\"cluster.events\", \"Invalid definition\", true);\n            return;\n        }\n\n        const constructor = this.#type.Events;\n        if (!constructor) {\n            this.error(\"Events\", \"Implementation missing\", true);\n            return;\n        }\n\n        let emitters;\n\n        if (this.#instance) {\n            emitters = this.#instance.events;\n        } else {\n            try {\n                emitters = new constructor() as unknown as Record<string, Observable>;\n            } catch (e) {\n                this.error(\"Events\", \"Not constructable\", true);\n                return;\n            }\n        }\n\n        for (const name in expected) {\n            const event = expected[name];\n            if (!event) {\n                this.error(`cluster.events.${name}`, \"Undefined element in cluster definition\", true);\n                continue;\n            }\n\n            if (!(name in emitters)) {\n                if (!event.optional) {\n                    this.error(`cluster.events.${name}`, \"Implementation missing\", true);\n                }\n                continue;\n            }\n\n            this.events.add(name);\n        }\n    }\n\n    private error(element: string | undefined, message: string, fatal: boolean) {\n        if (!this.errors) {\n            this.errors = [];\n        }\n        const name = element === undefined ? this.#name : `${this.#name}.${element}`;\n\n        this.errors?.push({ element: name, message, fatal });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
