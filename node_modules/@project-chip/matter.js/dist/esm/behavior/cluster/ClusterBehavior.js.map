{
  "version": 3,
  "sources": ["../../../../src/behavior/cluster/ClusterBehavior.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterType } from \"../../cluster/ClusterType.js\";\nimport { ClusterComposer } from \"../../cluster/mutation/ClusterComposer.js\";\nimport { ElementModifier } from \"../../cluster/mutation/ElementModifier.js\";\nimport { ImplementationError } from \"../../common/MatterError.js\";\nimport type { Agent } from \"../../endpoint/Agent.js\";\nimport { TypeFromBitSchema } from \"../../schema/BitmapSchema.js\";\nimport { AsyncObservable, EventEmitter, Observable } from \"../../util/Observable.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { Behavior } from \"../Behavior.js\";\nimport type { BehaviorBacking } from \"../internal/BehaviorBacking.js\";\nimport type { RootSupervisor } from \"../supervision/RootSupervisor.js\";\nimport { Schema } from \"../supervision/Schema.js\";\nimport { NetworkBehavior } from \"../system/network/NetworkBehavior.js\";\nimport { ExtensionInterfaceOf, createType, type ClusterOf } from \"./ClusterBehaviorUtil.js\";\nimport type { ClusterEvents } from \"./ClusterEvents.js\";\nimport { ClusterInterface } from \"./ClusterInterface.js\";\nimport type { ClusterState } from \"./ClusterState.js\";\n\n/**\n * A {@link Behavior} with specialization for a specific cluster.\n *\n * To implement cluster functionality you should use a subclass provided by {@link ClusterBehavior.for} with the\n * {@link ClusterType} you are implementing.  Most commonly you would use one of the predefined implementations\n * matter.js includes.\n *\n * Subclasses can be modified using the static builder methods or extended like a normal class.\n *\n * Behaviors should store all mutable state in their {@link Behavior.state} property.  Other fields will be transient\n * and may not be retained across invocations.\n *\n * ClusterBehaviors may be instantiated with unsupported mandatory commands and attributes.  This is currently results\n * in a runtime error but it will not cause a type error during development.\n */\nexport class ClusterBehavior extends Behavior {\n    /**\n     * The ID of ClusterBehavior implementations is the uncapitalized cluster name.\n     */\n    static override id: Uncapitalize<string>;\n\n    /**\n     * The cluster implemented by this behavior.\n     */\n    get cluster() {\n        return (this.constructor as typeof ClusterBehavior).cluster;\n    }\n\n    /**\n     * Supported features as a flag object.\n     */\n    get features() {\n        return this.cluster.supportedFeatures;\n    }\n\n    /**\n     * Every cluster behavior has an associated ClusterType defined statically.\n     */\n    static readonly cluster = ClusterType.Unknown;\n\n    /**\n     * Method definitions.\n     */\n    static readonly Interface = ClusterInterface.Empty;\n\n    /**\n     * All ClusterBehavior initialization currently runs as part of {@link Endpoint} initialization.\n     */\n    static override readonly early = true;\n\n    /**\n     * Keep networking alive until I'm destroyed.\n     */\n    static override readonly dependencies = [NetworkBehavior];\n\n    constructor(agent: Agent, backing: BehaviorBacking) {\n        super(agent, backing);\n\n        const cluster = (this.constructor as typeof ClusterBehavior).cluster;\n        if (!cluster) {\n            throw new ImplementationError(\"ClusterBehavior class has no cluster defined\");\n        }\n    }\n\n    /**\n     * Create a new behavior for a specific {@link ClusterType}.\n     *\n     * If you invoke directly on {@link ClusterBehavior} you will receive a new implementation that reports all commands\n     * as unimplemented.\n     *\n     * If you invoke on an existing subclass, you will receive a new implementation with the cluster in the subclass\n     * replaced.  You should generally only do this with a {@link ClusterType} with the same ID.\n     */\n    static for<This extends ClusterBehavior.Type, const ClusterT extends ClusterType>(\n        this: This,\n        cluster: ClusterT,\n        schema?: Schema,\n    ) {\n        return createType(cluster, this, schema) as ClusterBehavior.Type<ClusterT, This>;\n    }\n\n    /**\n     * Create a new behavior with different cluster features.\n     */\n    static with<\n        This extends ClusterBehavior.Type,\n        const FeaturesT extends ClusterComposer.FeatureSelection<This[\"cluster\"]>,\n    >(this: This, ...features: FeaturesT) {\n        const newCluster = new ClusterComposer(this.cluster).compose(features) as ClusterComposer.WithFeatures<\n            This[\"cluster\"],\n            FeaturesT\n        >;\n        return this.for(newCluster);\n    }\n\n    /**\n     * Create a new behavior with modified cluster elements.\n     */\n    static alter<\n        This extends ClusterBehavior.Type,\n        const AlterationsT extends ElementModifier.Alterations<This[\"cluster\"]>,\n    >(this: This, alterations: AlterationsT) {\n        return this.for(new ElementModifier(this.cluster).alter(alterations));\n    }\n\n    /**\n     * Create a new behavior with additional cluster features marked \"mandatory\".\n     *\n     * This informs matter.js that an application supports these elements.\n     */\n    static enable<\n        This extends ClusterBehavior.Type,\n        const FlagsT extends ElementModifier.ElementFlags<This[\"cluster\"]>,\n    >(this: This, flags: FlagsT) {\n        return this.for(new ElementModifier(this.cluster).enable(flags));\n    }\n\n    /**\n     * Create a ClusterBehavior like this one with different interface methods.\n     *\n     * The Interface \"property\" is type-only.  We define a method however to keep the API consistent.  At runtime the\n     * method is a no-op.\n     */\n    static withInterface<const I extends ClusterInterface>() {\n        return this as unknown as ClusterBehavior.Type<typeof ClusterType.Unknown, typeof ClusterBehavior, I>;\n    }\n\n    static override supports(other: Behavior.Type) {\n        if (!Behavior.supports.call(this, other)) {\n            return false;\n        }\n\n        const otherCluster = (other as { cluster?: ClusterType }).cluster;\n        if (!otherCluster) {\n            return false;\n        }\n\n        const otherFeatures = otherCluster.supportedFeatures;\n        const myFeatures = this.cluster.supportedFeatures;\n        for (const name in otherFeatures) {\n            if (otherFeatures[name] && !(myFeatures as Record<string, boolean>)[name]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    requireAttributeEnabled<This extends Behavior, K extends keyof This[\"state\"]>(\n        this: This,\n        attributeName: K,\n    ): Exclude<This[\"state\"][K], undefined> {\n        if ((this.state as any)[attributeName] === undefined) {\n            throw new ImplementationError(\n                `To use this feature, please enable attribute ${String(attributeName)} by setting the value during initialization.`,\n            );\n        }\n        return (this.state as any)[attributeName];\n    }\n\n    assertAttributeEnabled<This extends Behavior, K extends keyof This[\"state\"]>(this: This, attributeName: K): void {\n        if ((this.state as any)[attributeName] === undefined) {\n            throw new ImplementationError(\n                `To use this feature, please enable attribute ${String(attributeName)} by setting the value during initialization.`,\n            );\n        }\n    }\n}\n\nexport namespace ClusterBehavior {\n    /**\n     * A ClusterBehavior specialized for a specific Cluster.\n     */\n    export interface Type<\n        C extends ClusterType = ClusterType,\n        B extends Behavior.Type = Behavior.Type,\n        I extends ClusterInterface = ClusterInterface.InterfaceOf<B>,\n    > {\n        new (agent: Agent, backing: BehaviorBacking): Instance<C, B, I>;\n\n        readonly name: string;\n\n        /**\n         * The behavior ID for ClusterBehaviors is the name of the cluster.\n         */\n        readonly id: Uncapitalize<C[\"name\"]>;\n\n        /**\n         * Base cluster state include all attribute values but may be extended by subclasses.\n         */\n        readonly cluster: C;\n\n        readonly Events: ClusterEvents.Type<C, B>;\n        readonly State: new () => ClusterState.Type<C, B>;\n        readonly Internal: B[\"Internal\"];\n        readonly Interface: I;\n\n        readonly schema?: Schema;\n        readonly early: boolean;\n        readonly defaults: ClusterState.Type<C, B>;\n        readonly supervisor: RootSupervisor;\n        readonly dependencies?: Iterable<Behavior.Type>;\n        supports: typeof ClusterBehavior.supports;\n        readonly ExtensionInterface: ExtensionInterfaceOf<B>;\n\n        // Prior to TS 5.4 could do this.  Sadly typing no longer carries through on these...  This[\"cluster\"] reverts\n        // to ClusterType).  So we have to define the long way.\n        //\n        // This also means intellisense doesn't work unless we copy comments here (or move here and cast ClusterBehavior\n        // to ClusterBehavior.Type).\n        //\n        // - for: typeof ClusterBehavior.for;\n        // - with: typeof ClusterBehavior.with;\n        // - alter: typeof ClusterBehavior.alter;\n        // - set: typeof ClusterBehavior.set;\n        // - enable: typeof ClusterBehavior.enable;\n\n        for<This extends ClusterBehavior.Type, const ClusterT extends ClusterType>(\n            this: This,\n            cluster: ClusterT,\n            schema?: Schema,\n        ): ClusterBehavior.Type<ClusterT, This>;\n\n        with<\n            This extends ClusterBehavior.Type,\n            const FeaturesT extends ClusterComposer.FeatureSelection<This[\"cluster\"]>,\n        >(\n            this: This,\n            ...features: FeaturesT\n        ): ClusterBehavior.Type<ClusterComposer.WithFeatures<This[\"cluster\"], FeaturesT>, This>;\n\n        alter<\n            This extends ClusterBehavior.Type,\n            const AlterationsT extends ElementModifier.Alterations<This[\"cluster\"]>,\n        >(\n            this: This,\n            alterations: AlterationsT,\n        ): ClusterBehavior.Type<ElementModifier.WithAlterations<This[\"cluster\"], AlterationsT>, This>;\n\n        set<This extends Behavior.Type>(this: This, defaults: Behavior.InputStateOf<This>): This;\n\n        enable<This extends ClusterBehavior.Type, const FlagsT extends ElementModifier.ElementFlags<This[\"cluster\"]>>(\n            this: This,\n            flags: FlagsT,\n        ): ClusterBehavior.Type<\n            ElementModifier.WithAlterations<This[\"cluster\"], ElementModifier.ElementFlagAlterations<FlagsT>>,\n            This\n        >;\n    }\n\n    /**\n     * A fully-typed ClusterBehavior.  This type is derived by combining properties of the base type with properties\n     * contributed by the cluster.\n     */\n    export type Instance<C extends ClusterType, B extends Behavior.Type, I extends ClusterInterface> =\n        // Base class\n        ClusterBehavior &\n            // Bring extensions of old class forward\n            Omit<\n                InstanceType<B>,\n                | \"cluster\"\n                | \"state\"\n                | \"events\"\n                | \"initialize\"\n\n                // Typescript 5.3 gets confused and thinks this is an instance property if we don't omit and then add\n                // (as we do below)\n                | typeof Symbol.asyncDispose\n\n                // Omit command methods of old cluster\n                | keyof ClusterInterface.MethodsOf<ClusterInterface.InterfaceOf<B>, ClusterOf<B>>\n\n                // Omit methods defined in ExtensionInterface\n                | keyof ExtensionInterfaceOf<B>\n            > &\n            // Add command methods\n            ClusterInterface.MethodsOf<I, C> &\n            // Add methods defined manually in ExtensionInterface\n            ExtensionInterfaceOf<B> & {\n                // Cluster-specific members\n                /**\n                 * The implemented cluster.\n                 */\n                cluster: C;\n\n                /**\n                 * State values for the behavior.\n                 */\n                state: ClusterState<C, B>;\n\n                /**\n                 * Observables for cluster events and attribute changes.\n                 */\n                events: ClusterEvents<C, B>;\n\n                /**\n                 * Supported features as a flag object.\n                 */\n                features: TypeFromBitSchema<C[\"features\"]>;\n\n                [Symbol.asyncDispose](): MaybePromise<void>;\n            };\n\n    /**\n     * All cluster behaviors support interaction events in addition to cluster-specific attribute mutation events.\n     */\n    export class Events extends EventEmitter {\n        /**\n         * Emitted when state associated with this behavior is first mutated by a specific interaction.\n         */\n        interactionBegin = Observable<[]>();\n\n        /**\n         * Emitted when a mutating interaction completes.\n         */\n        interactionEnd = AsyncObservable<[]>();\n    }\n\n    /**\n     * This is an unfortunate kludge required to work around https://github.com/microsoft/TypeScript/issues/27965.  It\n     * allows you to designate extension methods available on behavior instances.\n     *\n     * Methods designated in this way make it so you can override methods using the syntax:\n     *\n     *     override foo() {}\n     *\n     * rather than:\n     *\n     *     override foo: () => {}\n     *\n     * See {@link ClusterInterface} for more details.\n     */\n    export declare const ExtensionInterface: {};\n}\n"],
  "mappings": "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",
  "names": ["ClusterBehavior"]
}
