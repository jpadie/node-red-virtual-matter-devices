{
  "version": 3,
  "sources": ["../../../src/schema/PairingCodeSchema.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError, UnexpectedDataError } from \"../common/MatterError.js\";\nimport { VendorId } from \"../datatype/VendorId.js\";\nimport { Verhoeff } from \"../math/Verhoeff.js\";\nimport { TlvAny } from \"../tlv/TlvAny.js\";\nimport { TlvType } from \"../tlv/TlvCodec.js\";\nimport { TlvUInt16, TlvUInt32, TlvUInt8 } from \"../tlv/TlvNumber.js\";\nimport { TlvObject, TlvOptionalField } from \"../tlv/TlvObject.js\";\nimport { TlvSchema } from \"../tlv/TlvSchema.js\";\nimport { TlvByteString, TlvString } from \"../tlv/TlvString.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { deepCopy } from \"../util/DeepCopy.js\";\nimport { Base38 } from \"./Base38Schema.js\";\nimport {\n    BitField,\n    BitFieldEnum,\n    BitFlag,\n    BitmapSchema,\n    ByteArrayBitmapSchema,\n    TypeFromBitmapSchema,\n} from \"./BitmapSchema.js\";\nimport { Schema } from \"./Schema.js\";\n\n/** See {@link MatterSpecification.v13.Core} \u00A7 5.1.3.1 Table 38 */\nexport enum CommissioningFlowType {\n    /** When not commissioned, the device always enters commissioning mode upon power-up. */\n    Standard = 0,\n\n    /** User action required to enter commissioning mode. */\n    UserIntent = 1,\n\n    /** Interaction with a vendor-specified means is needed before commissioning. */\n    Custom = 2,\n}\n\n/** See {@link MatterSpecification.v13.Core} \u00A7 5.1.3.1 Table 39 */\nexport const DiscoveryCapabilitiesBitmap = {\n    /** Device supports BLE for discovery when not commissioned. */\n    ble: BitFlag(1),\n\n    /** Device is already on the IP network. */\n    onIpNetwork: BitFlag(2),\n};\nexport const DiscoveryCapabilitiesSchema = BitmapSchema(DiscoveryCapabilitiesBitmap);\n\n/** See {@link MatterSpecification.v13.Core} \u00A7 5.1.3.1 Table 38 */\nconst QrCodeDataSchema = ByteArrayBitmapSchema({\n    version: BitField(0, 3),\n    vendorId: BitField(3, 16),\n    productId: BitField(19, 16),\n    flowType: BitFieldEnum<CommissioningFlowType>(35, 2),\n    discoveryCapabilities: BitField(37, 8),\n    discriminator: BitField(45, 12),\n    passcode: BitField(57, 27),\n});\n\nexport type QrCodeData = TypeFromBitmapSchema<typeof QrCodeDataSchema> & {\n    /**\n     * See {@link MatterSpecification.v13.Core} \u00A7 5.1.5\n     * Variable length TLV data. Zero length if TLV is not included. This data is byte-aligned.\n     * All elements SHALL be housed within an anonymous top-level structure container.\n     */\n    tlvData?: ByteArray;\n};\n\n/**\n * Default field definition that can be enhanced with manufacturer specific Fields for the TlvSchema to use.\n * See {@link MatterSpecification.v13.Core} \u00A7 5.1.5\n */\nexport const QrCodeTlvDataDefaultFields = {\n    /** Device Serial # */\n    serialNumber: TlvOptionalField(0x00, TlvAny), // can be TlvString with up to 32 bytes or Unsigned Int up to 8 bytes\n    pbkdfIterations: TlvOptionalField(0x01, TlvUInt32.bound({ min: 1000, max: 100_000 })), // Or could also be UInt 16?\n    pbkdfSalt: TlvOptionalField(0x02, TlvByteString.bound({ minLength: 16, maxLength: 32 })),\n\n    /**\n     * Number of devices that are expected to be onboarded using this payload when using the Enhanced Commissioning\n     * Method\n     */\n    numberOfDevices: TlvOptionalField(0x03, TlvUInt8.bound({ min: 1 })),\n\n    /**\n     * Time, in seconds, during which the device(s) are expected to be commissionable using the Enhanced Commissioning\n     * Method\n     */\n    commissioningTimeout: TlvOptionalField(0x04, TlvUInt16),\n};\n\nconst PREFIX = \"MT:\";\n\nclass QrPairingCodeSchema extends Schema<QrCodeData[], string> {\n    protected encodeInternal(payloadData: QrCodeData[]): string {\n        if (payloadData.length === 0) throw new ImplementationError(\"Provided Payload data is empty\");\n        return (\n            PREFIX +\n            payloadData\n                .map(payloadData => {\n                    const { tlvData } = payloadData;\n                    const data =\n                        tlvData !== undefined && tlvData.length > 0\n                            ? ByteArray.concat(QrCodeDataSchema.encode(payloadData), tlvData)\n                            : QrCodeDataSchema.encode(payloadData);\n                    return Base38.encode(data);\n                })\n                .join(\"*\")\n        );\n    }\n\n    protected decodeInternal(encoded: string): QrCodeData[] {\n        if (!encoded.startsWith(PREFIX)) throw new UnexpectedDataError(\"The pairing code should start with MT:\");\n        return encoded\n            .slice(PREFIX.length)\n            .split(\"*\")\n            .map(encodedData => {\n                const data = Base38.decode(encodedData);\n                return {\n                    ...QrCodeDataSchema.decode(data.slice(0, 11)),\n                    tlvData: data.length > 11 ? data.slice(11) : undefined, // TlvData (if any) is after the fixed-length data\n                };\n            });\n    }\n\n    /**\n     * Decodes the TLV data from the QR code payload.\n     * This method especially also handles that an encoded serialNumber can be UTF-8-String or a Unsigned Integer.\n     *\n     * @param data Encoded TLV data\n     * @param schema The schema to use for decoding the TLV data, by default a schema with the QrCodeTlvDataDefaultFields is used\n     */\n    decodeTlvData(data: ByteArray, schema: TlvSchema<any> = TlvObject(QrCodeTlvDataDefaultFields)) {\n        const decoded = schema.decode(data);\n        if (decoded.serialNumber !== undefined) {\n            if (\n                !Array.isArray(decoded.serialNumber) ||\n                decoded.serialNumber.length !== 1 ||\n                decoded.serialNumber[0].typeLength === undefined ||\n                decoded.serialNumber[0].value === undefined\n            ) {\n                throw new UnexpectedDataError(\"Invalid serial number TLV data\");\n            }\n            switch (decoded.serialNumber[0].typeLength.type) {\n                case TlvType.Utf8String:\n                case TlvType.UnsignedInt:\n                    decoded.serialNumber = decoded.serialNumber[0].value;\n                    break;\n                default:\n                    throw new UnexpectedDataError(\"Invalid serial number TLV data\");\n            }\n        }\n        return decoded;\n    }\n\n    /**\n     * Encodes the TLV data for the QR code payload.\n     * This method especially also handles that an encoded serialNumber can be UTF-8-String or a Unsigned Integer.\n     *\n     * @param data Data object to encode\n     * @param schema The schema to use for encoding the TLV data, by default a schema with the QrCodeTlvDataDefaultFields is used\n     */\n    encodeTlvData(data: Record<string, any>, schema: TlvSchema<any> = TlvObject(QrCodeTlvDataDefaultFields)) {\n        const dataToEncode = deepCopy(data);\n        if (\"serialNumber\" in dataToEncode && dataToEncode.serialNumber !== undefined) {\n            switch (typeof dataToEncode.serialNumber) {\n                case \"string\":\n                    dataToEncode.serialNumber = TlvString.encodeTlv(dataToEncode.serialNumber);\n                    break;\n                case \"number\":\n                    dataToEncode.serialNumber = TlvUInt8.encodeTlv(dataToEncode.serialNumber);\n                    break;\n                default:\n                    throw new ImplementationError(\"Invalid serial number data\");\n            }\n        }\n        return schema.encode(dataToEncode);\n    }\n}\n\nexport const QrPairingCodeCodec = new QrPairingCodeSchema();\n\nexport type ManualPairingData = {\n    discriminator?: number;\n    shortDiscriminator?: number;\n    passcode: number;\n    vendorId?: VendorId;\n    productId?: number;\n};\n\n/** See {@link MatterSpecification.v10.Core} \u00A7 5.1.4.1 Table 38/39/40 */\nclass ManualPairingCodeSchema extends Schema<ManualPairingData, string> {\n    protected encodeInternal({ discriminator, passcode, vendorId, productId }: ManualPairingData): string {\n        if (discriminator === undefined) throw new UnexpectedDataError(\"discriminator is required\");\n        if (discriminator > 4095) throw new UnexpectedDataError(\"discriminator value must be less than 4096\");\n        let result = \"\";\n        const hasVendorProductIds = vendorId !== undefined && productId !== undefined;\n        result += (discriminator >> 10) | (hasVendorProductIds ? 1 << 2 : 0);\n        result += (((discriminator & 0x300) << 6) | (passcode & 0x3fff)).toString().padStart(5, \"0\");\n        result += (passcode >> 14).toString().padStart(4, \"0\");\n        if (hasVendorProductIds) {\n            result += vendorId.toString().padStart(5, \"0\");\n            result += productId.toString().padStart(5, \"0\");\n        }\n        result += new Verhoeff().computeChecksum(result);\n        return result;\n    }\n\n    protected decodeInternal(encoded: string): ManualPairingData {\n        encoded = encoded.replace(/[^0-9]/g, \"\"); // we SHALL be robust against other characters\n        if (encoded.length !== 11 && encoded.length != 21) {\n            throw new UnexpectedDataError(\"Invalid pairing code\");\n        }\n        if (new Verhoeff().computeChecksum(encoded.slice(0, -1)) !== parseInt(encoded.slice(-1))) {\n            throw new UnexpectedDataError(\"Invalid checksum\");\n        }\n        const hasVendorProductIds = !!(parseInt(encoded[0]) & (1 << 2));\n        const shortDiscriminator = ((parseInt(encoded[0]) & 0x03) << 2) | ((parseInt(encoded.slice(1, 6)) >> 14) & 0x3);\n        const passcode = (parseInt(encoded.slice(1, 6)) & 0x3fff) | (parseInt(encoded.slice(6, 10)) << 14);\n        let vendorId: VendorId | undefined;\n        let productId: number | undefined;\n        if (hasVendorProductIds) {\n            vendorId = VendorId(parseInt(encoded.slice(10, 15)));\n            productId = parseInt(encoded.slice(15, 20));\n        }\n        return { shortDiscriminator, passcode, vendorId, productId };\n    }\n}\n\nexport const ManualPairingCodeCodec = new ManualPairingCodeSchema();\n"],
  "mappings": "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",
  "names": ["CommissioningFlowType", "payloadData"]
}
