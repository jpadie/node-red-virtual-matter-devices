{
  "version": 3,
  "sources": ["../../../src/protocol/MessageExchange.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Message, MessageCodec, SessionType } from \"../codec/MessageCodec.js\";\nimport { InternalError, MatterError, MatterFlowError } from \"../common/MatterError.js\";\nimport { CRYPTO_AEAD_MIC_LENGTH_BYTES } from \"../crypto/CryptoConstants.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport {\n    SESSION_ACTIVE_INTERVAL_MS,\n    SESSION_ACTIVE_THRESHOLD_MS,\n    SESSION_IDLE_INTERVAL_MS,\n    Session,\n} from \"../session/Session.js\";\nimport { Time, Timer } from \"../time/Time.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { AsyncObservable } from \"../util/Observable.js\";\nimport { createPromise } from \"../util/Promises.js\";\nimport { Queue } from \"../util/Queue.js\";\nimport { ChannelNotConnectedError, MessageChannel } from \"./ExchangeManager.js\";\nimport { StatusCode, StatusResponseError } from \"./interaction/StatusCode.js\";\nimport { MessageType, SECURE_CHANNEL_PROTOCOL_ID } from \"./securechannel/SecureChannelMessages.js\";\nimport { SecureChannelProtocol } from \"./securechannel/SecureChannelProtocol.js\";\n\nconst logger = Logger.get(\"MessageExchange\");\n\nexport class RetransmissionLimitReachedError extends MatterError {}\n\nexport class UnexpectedMessageError extends MatterError {\n    public constructor(\n        message: string,\n        public readonly receivedMessage: Message,\n    ) {\n        super(`(${MessageCodec.messageDiagnostics(receivedMessage)}) ${message}`);\n    }\n}\n\nexport type ExchangeSendOptions = {\n    /**\n     * The response to this send should be an ack only and no StatusResponse or such. If a StatusResponse is returned\n     * then this is handled as error.\n     */\n    expectAckOnly?: boolean;\n\n    /**\n     * Define a minimum Response Timeout. This setting only increases the response timeout! The minimum four\n     * resubmissions are always done regardless of what is specified here. The logic will check if the timeout is\n     * reached after each resubmission, so it is not checked exact at the given timeout.\n     */\n    minimumResponseTimeoutMs?: number;\n\n    /** Allows to specify if the send message requires to be acknowledged by the receiver or not. */\n    requiresAck?: boolean;\n\n    /** Use the provided acknowledge MessageId instead checking the latest to send one */\n    includeAcknowledgeMessageId?: number;\n};\n\n/**\n * The maximum number of transmission attempts for a given reliable message. The sender MAY choose this value as it\n * sees fit.\n */\nconst MRP_MAX_TRANSMISSIONS = 5;\n\n/** The base number for the exponential backoff equation. */\nconst MRP_BACKOFF_BASE = 1.6;\n\n/** The scaler for random jitter in the backoff equation. */\nconst MRP_BACKOFF_JITTER = 0.25;\n\n/** The scaler margin increase to backoff over the peer sleepy interval. */\nconst MRP_BACKOFF_MARGIN = 1.1;\n\n/** The number of retransmissions before transitioning from linear to exponential backoff. */\nconst MRP_BACKOFF_THRESHOLD = 1;\n\n/** @see {@link MatterSpecification.v12.Core}, section 4.11.8 */\nconst MRP_STANDALONE_ACK_TIMEOUT_MS = 200;\n\n/**\n * Message size overhead of a Matter message:\n * 26 (Matter Message Header) + 12 (Matter Payload Header) taken from https://github.com/project-chip/connectedhomeip/blob/2d97cda23024e72f36216900ca667bf1a0d9499f/src/system/SystemConfig.h#L327\n * 16 byte MIC is then also needed to be excluded from the max payload size\n * Secure Extensions and Message Extensions need to be handled by exchange additionally!\n */\nexport const MATTER_MESSAGE_OVERHEAD = 26 + 12 + CRYPTO_AEAD_MIC_LENGTH_BYTES;\n\nexport class MessageExchange<ContextT> {\n    static fromInitialMessage<ContextT>(channel: MessageChannel<ContextT>, initialMessage: Message) {\n        const { session } = channel;\n        return new MessageExchange<ContextT>(\n            session,\n            channel,\n            false,\n            session.id,\n            initialMessage.packetHeader.destNodeId,\n            initialMessage.packetHeader.sourceNodeId,\n            initialMessage.payloadHeader.exchangeId,\n            initialMessage.payloadHeader.protocolId,\n        );\n    }\n\n    static initiate<ContextT>(channel: MessageChannel<ContextT>, exchangeId: number, protocolId: number) {\n        const { session } = channel;\n        return new MessageExchange(\n            session,\n            channel,\n            true,\n            session.peerSessionId,\n            session.nodeId,\n            session.peerNodeId,\n            exchangeId,\n            protocolId,\n        );\n    }\n\n    readonly #activeIntervalMs: number;\n    readonly #idleIntervalMs: number;\n    readonly #activeThresholdMs: number;\n    readonly #maxTransmissions: number;\n    readonly #messagesQueue = new Queue<Message>();\n    #receivedMessageToAck: Message | undefined;\n    #receivedMessageAckTimer = Time.getTimer(\"Ack receipt timeout\", MRP_STANDALONE_ACK_TIMEOUT_MS, () => {\n        if (this.#receivedMessageToAck !== undefined) {\n            const messageToAck = this.#receivedMessageToAck;\n            this.#receivedMessageToAck = undefined;\n            // TODO: We need to track this promise later\n            this.sendStandaloneAckForMessage(messageToAck).catch(error =>\n                logger.error(\"An error happened when sending a standalone ack\", error),\n            );\n        }\n    });\n    #sentMessageToAck: Message | undefined;\n    #sentMessageAckSuccess: ((...args: any[]) => void) | undefined;\n    #sentMessageAckFailure: ((error?: Error) => void) | undefined;\n    #retransmissionTimer: Timer | undefined;\n    #retransmissionCounter = 0;\n    #closeTimer: Timer | undefined;\n    #timedInteractionTimer: Timer | undefined;\n\n    readonly #peerSessionId: number;\n    readonly #nodeId: NodeId | undefined;\n    readonly #peerNodeId: NodeId | undefined;\n    readonly #exchangeId: number;\n    readonly #protocolId: number;\n    readonly #closed = AsyncObservable<[]>();\n    readonly #useMRP: boolean;\n\n    constructor(\n        readonly session: Session<ContextT>,\n        readonly channel: MessageChannel<ContextT>,\n        readonly isInitiator: boolean,\n        peerSessionId: number,\n        nodeId: NodeId | undefined,\n        peerNodeId: NodeId | undefined,\n        exchangeId: number,\n        protocolId: number,\n    ) {\n        this.#peerSessionId = peerSessionId;\n        this.#nodeId = nodeId;\n        this.#peerNodeId = peerNodeId;\n        this.#exchangeId = exchangeId;\n        this.#protocolId = protocolId;\n\n        const { activeIntervalMs, idleIntervalMs, activeThresholdMs } = session.parameters;\n        this.#activeIntervalMs = activeIntervalMs ?? SESSION_ACTIVE_INTERVAL_MS;\n        this.#idleIntervalMs = idleIntervalMs ?? SESSION_IDLE_INTERVAL_MS;\n        this.#activeThresholdMs = activeThresholdMs ?? SESSION_ACTIVE_THRESHOLD_MS;\n        this.#maxTransmissions = MRP_MAX_TRANSMISSIONS;\n\n        // When the session is supporting MRP and the channel is not reliable, use MRP handling\n        this.#useMRP = session.supportsMRP && !channel.isReliable;\n\n        logger.debug(\n            \"New exchange\",\n            Diagnostic.dict({\n                channel: channel.name,\n                protocol: this.#protocolId,\n                id: this.#exchangeId,\n                session: session.name,\n                peerSessionId: this.#peerSessionId,\n                \"active threshold ms\": this.#activeThresholdMs,\n                \"active interval ms\": this.#activeIntervalMs,\n                \"idle interval ms\": this.#idleIntervalMs,\n                maxTransmissions: this.#maxTransmissions,\n                useMrp: this.#useMRP,\n            }),\n        );\n    }\n\n    get closed() {\n        return this.#closed;\n    }\n\n    /**\n     * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter\n     * protocol overhead.\n     */\n    get maxPayloadSize() {\n        // TODO: Whenever we add support for MessageExtensions or Secured Message extensions then these need to be also\n        //  considered here and their size needs to be subtracted from the maxPayloadSize of the channel.\n        return this.channel.maxPayloadSize - MATTER_MESSAGE_OVERHEAD;\n    }\n\n    async sendStandaloneAckForMessage(message: Message) {\n        const {\n            packetHeader: { messageId },\n            payloadHeader: { requiresAck },\n        } = message;\n        if (!requiresAck || !this.#useMRP) return;\n\n        await this.send(MessageType.StandaloneAck, new ByteArray(0), { includeAcknowledgeMessageId: messageId });\n    }\n\n    async onMessageReceived(message: Message, isDuplicate = false) {\n        logger.debug(\"Message \u00AB\", MessageCodec.messageDiagnostics(message, isDuplicate));\n\n        // Adjust the incoming message when ack was required but this exchange do not use it to skip all relevant logic\n        if (message.payloadHeader.requiresAck && !this.#useMRP) {\n            logger.debug(\"Ignoring ack-required flag because MRP is not used for this exchange\");\n            message.payloadHeader.requiresAck = false;\n        }\n\n        const {\n            packetHeader: { messageId },\n            payloadHeader: { requiresAck, ackedMessageId, protocolId, messageType },\n        } = message;\n\n        const isStandaloneAck = SecureChannelProtocol.isStandaloneAck(protocolId, messageType);\n        if (protocolId !== this.#protocolId && !isStandaloneAck) {\n            throw new MatterFlowError(\n                `Drop received a message for an unexpected protocol. Expected: ${this.#protocolId}, received: ${protocolId}`,\n            );\n        }\n\n        this.session.notifyActivity(true);\n\n        if (isDuplicate) {\n            // Received a message retransmission but the reply is not ready yet, ignoring\n            if (requiresAck) {\n                await this.sendStandaloneAckForMessage(message);\n            }\n            return;\n        }\n        if (messageId === this.#sentMessageToAck?.payloadHeader.ackedMessageId) {\n            // Received a message retransmission, this means that the other side didn't get our ack\n            // Resending the previous reply message which contains the ack\n            await this.channel.send(this.#sentMessageToAck);\n            return;\n        }\n        const sentMessageIdToAck = this.#sentMessageToAck?.packetHeader.messageId;\n        if (sentMessageIdToAck !== undefined) {\n            if (ackedMessageId === undefined) {\n                // The message has no ack, but one previous message sent still needs to be acked.\n                throw new MatterFlowError(\"Previous message ack is missing\");\n            } else if (ackedMessageId !== sentMessageIdToAck) {\n                // The message has an ack for another message.\n                if (isStandaloneAck) {\n                    // Ignore if this is a standalone ack, probably this was a retransmission.\n                } else {\n                    throw new MatterFlowError(\n                        `Incorrect ack received. Expected ${sentMessageIdToAck}, received: ${ackedMessageId}`,\n                    );\n                }\n            } else {\n                // The other side has received our previous message\n                this.#retransmissionTimer?.stop();\n                this.#retransmissionCounter = 0;\n                this.#sentMessageAckSuccess?.(message);\n                this.#sentMessageAckSuccess = undefined;\n                this.#sentMessageAckFailure = undefined;\n                this.#sentMessageToAck = undefined;\n                if (isStandaloneAck && this.#closeTimer !== undefined) {\n                    // All resubmissions done and in closing, no need to wait further\n                    return this.closeInternal();\n                }\n            }\n        }\n        if (isStandaloneAck) {\n            // Don't include standalone acks in the message stream\n            return;\n        }\n        if (requiresAck) {\n            // We still have a message to ack, so ack this one as standalone ack directly\n            if (this.#receivedMessageToAck !== undefined) {\n                this.#receivedMessageAckTimer.stop();\n                await this.sendStandaloneAckForMessage(this.#receivedMessageToAck);\n                return;\n            }\n            this.#receivedMessageToAck = message;\n            this.#receivedMessageAckTimer.start();\n        }\n        await this.#messagesQueue.write(message);\n    }\n\n    async send(messageType: number, payload: ByteArray, options?: ExchangeSendOptions) {\n        if (options?.requiresAck && !this.#useMRP) {\n            options.requiresAck = false;\n        }\n\n        const {\n            expectAckOnly = false,\n            minimumResponseTimeoutMs,\n            requiresAck,\n            includeAcknowledgeMessageId,\n        } = options ?? {};\n        if (!this.#useMRP && includeAcknowledgeMessageId !== undefined) {\n            throw new InternalError(\"Cannot include an acknowledge message ID when MRP is not used\");\n        }\n        if (messageType === MessageType.StandaloneAck) {\n            if (!this.#useMRP) {\n                return;\n            }\n            if (requiresAck) {\n                throw new MatterFlowError(\"A standalone ack may not require acknowledgement.\");\n            }\n        }\n        if (this.#sentMessageToAck !== undefined && messageType !== MessageType.StandaloneAck)\n            throw new MatterFlowError(\"The previous message has not been acked yet, cannot send a new message.\");\n\n        this.session.notifyActivity(false);\n\n        let ackedMessageId = includeAcknowledgeMessageId;\n        if (ackedMessageId === undefined && this.#useMRP) {\n            ackedMessageId = this.#receivedMessageToAck?.packetHeader.messageId;\n            if (ackedMessageId !== undefined) {\n                this.#receivedMessageAckTimer.stop();\n                this.#receivedMessageToAck = undefined;\n            }\n        }\n\n        // TODO Add support to also send controlMessages for Group messages, use different messagecounter!\n        const message: Message = {\n            packetHeader: {\n                sessionId: this.#peerSessionId,\n                sessionType: SessionType.Unicast, // TODO: support multicast/groups\n                messageId: await this.session.getIncrementedMessageCounter(),\n                destNodeId: this.#peerNodeId,\n                sourceNodeId: this.#nodeId,\n                hasPrivacyEnhancements: false,\n                isControlMessage: false,\n                hasMessageExtensions: false,\n            },\n            payloadHeader: {\n                exchangeId: this.#exchangeId,\n                protocolId: messageType === MessageType.StandaloneAck ? SECURE_CHANNEL_PROTOCOL_ID : this.#protocolId,\n                messageType,\n                isInitiatorMessage: this.isInitiator,\n                requiresAck: requiresAck ?? (this.#useMRP && messageType !== MessageType.StandaloneAck),\n                ackedMessageId,\n                hasSecuredExtension: false,\n            },\n            payload,\n        };\n\n        let ackPromise: Promise<Message> | undefined;\n        if (this.#useMRP && message.payloadHeader.requiresAck) {\n            this.#sentMessageToAck = message;\n            this.#retransmissionTimer = Time.getTimer(\n                \"Message retransmission\",\n                this.getResubmissionBackOffTime(0),\n                () =>\n                    this.retransmitMessage(\n                        message,\n                        minimumResponseTimeoutMs !== undefined ? Time.nowMs() + minimumResponseTimeoutMs : undefined,\n                    ),\n            );\n            const { promise, resolver, rejecter } = createPromise<Message>();\n            ackPromise = promise;\n            this.#sentMessageAckSuccess = resolver;\n            this.#sentMessageAckFailure = rejecter;\n        }\n\n        await this.channel.send(message);\n\n        if (ackPromise !== undefined) {\n            this.#retransmissionCounter = 0;\n            this.#retransmissionTimer?.start();\n            // Await Response to be received (or Message retransmit limit reached which rejects the promise)\n            const responseMessage = await ackPromise;\n            this.#sentMessageAckSuccess = undefined;\n            this.#sentMessageAckFailure = undefined;\n            // If we only expect an Ack without data but got data, throw an error\n            const {\n                payloadHeader: { protocolId, messageType },\n            } = responseMessage;\n            if (expectAckOnly && !SecureChannelProtocol.isStandaloneAck(protocolId, messageType)) {\n                throw new UnexpectedMessageError(\"Expected ack only\", responseMessage);\n            }\n        }\n    }\n\n    nextMessage() {\n        return this.#messagesQueue.read();\n    }\n\n    async waitFor(messageType: number, timeoutMs = 180_000) {\n        const message = await this.#messagesQueue.read(timeoutMs);\n        const {\n            payloadHeader: { messageType: receivedMessageType },\n        } = message;\n        if (receivedMessageType !== messageType)\n            throw new MatterFlowError(\n                `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(\n                    16,\n                )}`,\n            );\n        return message;\n    }\n\n    /** @see {@link MatterSpecification.v10.Core}, section 4.11.2.1 */\n    private getResubmissionBackOffTime(retransmissionCount: number) {\n        const baseInterval = this.session.isPeerActive() ? this.#activeIntervalMs : this.#idleIntervalMs;\n        return Math.floor(\n            MRP_BACKOFF_MARGIN *\n                baseInterval *\n                Math.pow(MRP_BACKOFF_BASE, Math.max(0, retransmissionCount - MRP_BACKOFF_THRESHOLD)) *\n                (1 + Math.random() * MRP_BACKOFF_JITTER),\n        );\n    }\n\n    private retransmitMessage(message: Message, notTimeoutBeforeTimeMs?: number) {\n        this.#retransmissionCounter++;\n        if (\n            this.#retransmissionCounter >= this.#maxTransmissions &&\n            (notTimeoutBeforeTimeMs === undefined || Time.nowMs() > notTimeoutBeforeTimeMs)\n        ) {\n            if (this.#sentMessageToAck !== undefined && this.#sentMessageAckFailure !== undefined) {\n                this.#receivedMessageToAck = undefined;\n                this.#sentMessageAckFailure(new RetransmissionLimitReachedError());\n                this.#sentMessageAckFailure = undefined;\n                this.#sentMessageAckSuccess = undefined;\n            }\n            if (this.#closeTimer !== undefined) {\n                // All resubmissions done and in closing, no need to wait further\n                this.closeInternal().catch(error => logger.error(\"An error happened when closing the exchange\", error));\n            }\n            return;\n        }\n\n        this.session.notifyActivity(false);\n\n        if (this.#retransmissionCounter === 1) {\n            // this.session.context.announce(); // TODO: announce\n        }\n        const resubmissionBackoffTime = this.getResubmissionBackOffTime(this.#retransmissionCounter);\n        logger.debug(\n            `Resubmit message ${message.packetHeader.messageId} (retransmission attempt ${this.#retransmissionCounter}, backoff time ${resubmissionBackoffTime}ms))`,\n        );\n\n        this.channel\n            .send(message)\n            .then(() => {\n                this.#retransmissionTimer = Time.getTimer(\"Message retransmission\", resubmissionBackoffTime, () =>\n                    this.retransmitMessage(message, notTimeoutBeforeTimeMs),\n                ).start();\n            })\n            .catch(error => {\n                logger.error(\"An error happened when retransmitting a message\", error);\n                if (error instanceof ChannelNotConnectedError) {\n                    this.closeInternal().catch(error =>\n                        logger.error(\"An error happened when closing the exchange\", error),\n                    );\n                }\n            });\n    }\n\n    async destroy() {\n        if (this.#closeTimer === undefined && this.#receivedMessageToAck !== undefined) {\n            this.#receivedMessageAckTimer.stop();\n            const messageToAck = this.#receivedMessageToAck;\n            this.#receivedMessageToAck = undefined;\n            try {\n                await this.sendStandaloneAckForMessage(messageToAck);\n            } catch (error) {\n                logger.error(\"An error happened when closing the exchange\", error);\n            }\n        }\n        await this.closeInternal();\n    }\n\n    startTimedInteraction(timeoutMs: number) {\n        if (this.#timedInteractionTimer !== undefined && this.#timedInteractionTimer.isRunning) {\n            this.#timedInteractionTimer.stop();\n            throw new StatusResponseError(\n                \"Timed interaction already running for this exchange\",\n                StatusCode.InvalidAction,\n            );\n        }\n        logger.debug(\n            `Starting timed interaction with Transaction ID ${this.#exchangeId} for ${timeoutMs}ms from ${this.channel.name}`,\n        );\n        this.#timedInteractionTimer = Time.getTimer(\"Timed interaction\", timeoutMs, () => {\n            logger.debug(\n                `Timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name} timed out`,\n            );\n        }).start();\n    }\n\n    clearTimedInteraction() {\n        if (this.#timedInteractionTimer !== undefined) {\n            logger.debug(\n                `Clearing timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name}`,\n            );\n            this.#timedInteractionTimer.stop();\n            this.#timedInteractionTimer = undefined;\n        }\n    }\n\n    hasTimedInteraction() {\n        return this.#timedInteractionTimer !== undefined;\n    }\n\n    hasActiveTimedInteraction() {\n        return this.#timedInteractionTimer !== undefined && this.#timedInteractionTimer.isRunning;\n    }\n\n    hasExpiredTimedInteraction() {\n        return this.#timedInteractionTimer !== undefined && !this.#timedInteractionTimer.isRunning;\n    }\n\n    async close() {\n        if (this.#closeTimer !== undefined) return; // close was already called\n\n        if (this.#receivedMessageToAck !== undefined) {\n            this.#receivedMessageAckTimer.stop();\n            const messageToAck = this.#receivedMessageToAck;\n            this.#receivedMessageToAck = undefined;\n            try {\n                await this.sendStandaloneAckForMessage(messageToAck);\n            } catch (error) {\n                logger.error(\"An error happened when closing the exchange\", error);\n            }\n        } else if (this.#sentMessageToAck === undefined) {\n            // No message left that we need to ack and no sent message left that waits for an ack, close directly\n            return this.closeInternal();\n        }\n\n        // Wait until all potential Resubmissions are done, also for Standalone-Acks.\n        // We might wait a bit longer then needed but because this is mainly a failsafe mechanism it is acceptable.\n        // in normal case this timer is cancelled before it triggers when all retries are done.\n        let maxResubmissionTime = 0;\n        for (let i = this.#retransmissionCounter; i <= this.#maxTransmissions; i++) {\n            maxResubmissionTime += this.getResubmissionBackOffTime(i);\n        }\n        this.#closeTimer = Time.getTimer(\n            \"Message exchange cleanup\",\n            maxResubmissionTime,\n            async () => await this.closeInternal(),\n        ).start();\n    }\n\n    private async closeInternal() {\n        this.#retransmissionTimer?.stop();\n        this.#closeTimer?.stop();\n        this.#timedInteractionTimer?.stop();\n        this.#messagesQueue.close();\n        await this.#closed.emit();\n    }\n}\n"],
  "mappings": "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",
  "names": ["messageType", "error"]
}
