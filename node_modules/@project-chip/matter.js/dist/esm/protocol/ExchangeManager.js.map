{
  "version": 3,
  "sources": ["../../../src/protocol/ExchangeManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterController } from \"../MatterController.js\";\nimport { Message, MessageCodec, SessionType } from \"../codec/MessageCodec.js\";\nimport { Channel } from \"../common/Channel.js\";\nimport { ImplementationError, MatterError, MatterFlowError, NotImplementedError } from \"../common/MatterError.js\";\nimport { Listener, TransportInterface } from \"../common/TransportInterface.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { UdpInterface } from \"../net/UdpInterface.js\";\nimport { INTERACTION_PROTOCOL_ID } from \"../protocol/interaction/InteractionServer.js\";\nimport { SecureSession } from \"../session/SecureSession.js\";\nimport { Session } from \"../session/Session.js\";\nimport { SessionManager, UNICAST_UNSECURE_SESSION_ID } from \"../session/SessionManager.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { ChannelManager } from \"./ChannelManager.js\";\nimport { MessageExchange } from \"./MessageExchange.js\";\nimport { DuplicateMessageError } from \"./MessageReceptionState.js\";\nimport { ProtocolHandler } from \"./ProtocolHandler.js\";\nimport { MessageType, SECURE_CHANNEL_PROTOCOL_ID } from \"./securechannel/SecureChannelMessages.js\";\nimport { SecureChannelMessenger } from \"./securechannel/SecureChannelMessenger.js\";\n\nconst logger = Logger.get(\"ExchangeManager\");\n\nexport class ChannelNotConnectedError extends MatterError {}\n\nexport class MessageChannel<ContextT> implements Channel<Message> {\n    public closed = false;\n    #closeCallback?: () => Promise<void>;\n\n    constructor(\n        readonly channel: Channel<ByteArray>,\n        readonly session: Session<ContextT>,\n        closeCallback?: () => Promise<void>,\n    ) {\n        this.#closeCallback = closeCallback;\n    }\n\n    set closeCallback(callback: () => Promise<void>) {\n        this.#closeCallback = callback;\n    }\n\n    /** Is the underlying transport reliable? */\n    get isReliable() {\n        return this.channel.isReliable;\n    }\n\n    get type() {\n        return this.channel.type;\n    }\n\n    /**\n     * Max Payload size of the exchange which bases on the maximum payload size of the channel. The full encoded matter\n     * message payload sent here can be as huge as allowed by the channel.\n     */\n    get maxPayloadSize() {\n        return this.channel.maxPayloadSize;\n    }\n\n    send(message: Message): Promise<void> {\n        logger.debug(\"Message \u00BB\", MessageCodec.messageDiagnostics(message));\n        const packet = this.session.encode(message);\n        const bytes = MessageCodec.encodePacket(packet);\n        if (bytes.length > this.maxPayloadSize) {\n            logger.warn(\n                `Matter message to send to ${this.name} is ${bytes.length}bytes long, which is larger than the maximum allowed size of ${this.maxPayloadSize}. This only works if both nodes support it.`,\n            );\n        }\n\n        return this.channel.send(bytes);\n    }\n\n    get name() {\n        return `${this.channel.name} on session ${this.session.name}`;\n    }\n\n    async close() {\n        const wasAlreadyClosed = this.closed;\n        this.closed = true;\n        await this.channel.close();\n        if (!wasAlreadyClosed) {\n            await this.#closeCallback?.();\n        }\n    }\n}\n\nexport class ExchangeManager<ContextT> {\n    private readonly exchangeCounter = new ExchangeCounter();\n    private readonly exchanges = new Map<number, MessageExchange<ContextT>>();\n    private readonly protocols = new Map<number, ProtocolHandler<ContextT>>();\n    private readonly transportListeners = new Array<Listener>();\n    private readonly closingSessions = new Set<number>();\n\n    constructor(\n        private readonly sessionManager: SessionManager<ContextT>,\n        private readonly channelManager: ChannelManager,\n    ) {}\n\n    addTransportInterface(netInterface: TransportInterface) {\n        const udpInterface = netInterface instanceof UdpInterface;\n        this.transportListeners.push(\n            netInterface.onData((socket, data) => {\n                if (udpInterface && data.length > socket.maxPayloadSize) {\n                    logger.warn(\n                        `Ignoring UDP message with size ${data.length} from ${socket.name}, which is larger than the maximum allowed size of ${socket.maxPayloadSize}.`,\n                    );\n                    return;\n                }\n\n                try {\n                    this.onMessage(socket, data).catch(error => logger.error(error));\n                } catch (error) {\n                    logger.warn(\"Ignoring UDP message with error\", error);\n                }\n            }),\n        );\n    }\n\n    hasProtocolHandler(protocolId: number) {\n        return this.protocols.has(protocolId);\n    }\n\n    getProtocolHandler(protocolId: number) {\n        return this.protocols.get(protocolId);\n    }\n\n    addProtocolHandler(protocol: ProtocolHandler<ContextT>) {\n        if (this.hasProtocolHandler(protocol.getId())) {\n            throw new ImplementationError(`Handler for protocol ${protocol.getId()} already registered.`);\n        }\n        this.protocols.set(protocol.getId(), protocol);\n    }\n\n    initiateExchange(fabric: Fabric, nodeId: NodeId, protocolId: number) {\n        return this.initiateExchangeWithChannel(this.channelManager.getChannel(fabric, nodeId), protocolId);\n    }\n\n    initiateExchangeWithChannel(channel: MessageChannel<ContextT>, protocolId: number) {\n        const exchangeId = this.exchangeCounter.getIncrementedCounter();\n        const exchangeIndex = exchangeId | 0x10000; // Ensure initiated and received exchange index are different, since the exchangeID can be the same\n        const exchange = MessageExchange.initiate(channel, exchangeId, protocolId);\n        this.#addExchange(exchangeIndex, exchange);\n        return exchange;\n    }\n\n    async close() {\n        for (const protocol of this.protocols.values()) {\n            await protocol.close();\n        }\n        for (const netListener of this.transportListeners) {\n            await netListener.close();\n        }\n        this.transportListeners.length = 0;\n        for (const exchange of this.exchanges.values()) {\n            await exchange.destroy();\n        }\n        this.exchanges.clear();\n    }\n\n    private async onMessage(channel: Channel<ByteArray>, messageBytes: ByteArray) {\n        const packet = MessageCodec.decodePacket(messageBytes);\n\n        if (packet.header.sessionType === SessionType.Group)\n            throw new NotImplementedError(\"Group messages are not supported\");\n\n        let session: Session<ContextT> | undefined;\n        if (packet.header.sessionType === SessionType.Unicast) {\n            if (packet.header.sessionId === UNICAST_UNSECURE_SESSION_ID) {\n                const initiatorNodeId = packet.header.sourceNodeId ?? NodeId.UNSPECIFIED_NODE_ID;\n                session =\n                    this.sessionManager.getUnsecureSession(initiatorNodeId) ??\n                    this.sessionManager.createUnsecureSession({\n                        initiatorNodeId,\n                    });\n            } else {\n                session = this.sessionManager.getSession(packet.header.sessionId);\n            }\n        } else if (packet.header.sessionType === SessionType.Group) {\n            if (packet.header.sourceNodeId !== undefined) {\n                //session = this.sessionManager.findGroupSession(packet.header.destGroupId, packet.header.sessionId);\n            }\n            // if (packet.header.destGroupId !== undefined) { ???\n        }\n\n        if (session === undefined) {\n            throw new MatterFlowError(\n                `Cannot find a session for ID ${packet.header.sessionId}${\n                    packet.header.sourceNodeId !== undefined ? ` and source NodeId ${packet.header.sourceNodeId}` : \"\"\n                }`,\n            );\n        }\n\n        const messageId = packet.header.messageId;\n\n        let isDuplicate;\n        try {\n            session?.updateMessageCounter(packet.header.messageId, packet.header.sourceNodeId);\n            isDuplicate = false;\n        } catch (e) {\n            DuplicateMessageError.accept(e);\n            isDuplicate = true;\n        }\n\n        const aad = messageBytes.slice(0, messageBytes.length - packet.applicationPayload.length); // Header+Extensions\n        const message = session.decode(packet, aad);\n        const exchangeIndex = message.payloadHeader.isInitiatorMessage\n            ? message.payloadHeader.exchangeId\n            : message.payloadHeader.exchangeId | 0x10000;\n        let exchange = this.exchanges.get(exchangeIndex);\n\n        if (\n            exchange !== undefined &&\n            (exchange.session.id !== session.id || exchange.isInitiator === message.payloadHeader.isInitiatorMessage) // Should always be ok, but just in case\n        ) {\n            exchange = undefined;\n        }\n\n        if (exchange !== undefined) {\n            await exchange.onMessageReceived(message, isDuplicate);\n        } else {\n            if (session.closingAfterExchangeFinished) {\n                throw new MatterFlowError(\n                    `Session with ID ${packet.header.sessionId} marked for closure, decline new exchange creation.`,\n                );\n            }\n\n            const protocolHandler = this.protocols.get(message.payloadHeader.protocolId);\n\n            if (protocolHandler !== undefined && message.payloadHeader.isInitiatorMessage && !isDuplicate) {\n                const exchange = MessageExchange.fromInitialMessage(\n                    await this.channelManager.getOrCreateChannel(channel, session),\n                    message,\n                );\n                this.#addExchange(exchangeIndex, exchange);\n                await exchange.onMessageReceived(message);\n                await protocolHandler.onNewExchange(exchange, message);\n            } else if (message.payloadHeader.requiresAck) {\n                const exchange = MessageExchange.fromInitialMessage(\n                    await this.channelManager.getOrCreateChannel(channel, session),\n                    message,\n                );\n                this.#addExchange(exchangeIndex, exchange);\n                await exchange.send(MessageType.StandaloneAck, new ByteArray(0), {\n                    includeAcknowledgeMessageId: message.packetHeader.messageId,\n                });\n                await exchange.close();\n                logger.debug(\n                    `Ignoring unsolicited message ${messageId} for protocol ${message.payloadHeader.protocolId}.`,\n                );\n            } else {\n                if (protocolHandler === undefined) {\n                    throw new MatterFlowError(`Unsupported protocol ${message.payloadHeader.protocolId}`);\n                }\n                if (isDuplicate) {\n                    logger.info(\n                        `Ignoring duplicate message ${messageId} (requires no ack) for protocol ${message.payloadHeader.protocolId}.`,\n                    );\n                    return;\n                } else {\n                    logger.info(\n                        `Discarding unexpected message ${messageId} for protocol ${\n                            message.payloadHeader.protocolId\n                        }, exchangeIndex ${exchangeIndex} and sessionId ${session.id} : ${Logger.toJSON(message)}`,\n                    );\n                }\n            }\n\n            // TODO A node SHOULD limit itself to a maximum of 5 concurrent exchanges over a unicast session. This is\n            //  to prevent a node from exhausting the message counter window of the peer node.\n        }\n    }\n\n    async deleteExchange(exchangeIndex: number) {\n        const exchange = this.exchanges.get(exchangeIndex);\n        if (exchange === undefined) {\n            logger.info(`Exchange with index ${exchangeIndex} to delete not found or already deleted.`);\n            return;\n        }\n        const { session } = exchange;\n        if (session.isSecure && session.closingAfterExchangeFinished) {\n            logger.debug(\n                `Exchange index ${exchangeIndex} Session ${session.name} is already marked for closure. Close session now.`,\n            );\n            try {\n                await this.closeSession(session as SecureSession<any>);\n            } catch (error) {\n                logger.error(`Error closing session ${session.name}. Ignoring.`, error);\n            }\n        }\n        this.exchanges.delete(exchangeIndex);\n    }\n\n    async closeSession(session: SecureSession<any>) {\n        const sessionId = session.id;\n        const sessionName = session.name;\n        if (this.sessionManager.getSession(sessionId) === undefined) {\n            // Session already removed, so we do not need to close again\n            return;\n        }\n        if (this.closingSessions.has(sessionId)) {\n            return;\n        }\n        this.closingSessions.add(sessionId);\n        for (const [_exchangeIndex, exchange] of this.exchanges.entries()) {\n            if (exchange.session.id === sessionId) {\n                await exchange.destroy();\n            }\n        }\n        if (session.sendCloseMessageWhenClosing) {\n            const channel = this.channelManager.getChannelForSession(session);\n            logger.debug(`Channel for session ${session.name} is ${channel?.name}`);\n            if (channel !== undefined) {\n                const exchange = this.initiateExchangeWithChannel(channel, SECURE_CHANNEL_PROTOCOL_ID);\n                logger.debug(`Initiated exchange ${!!exchange} to close session ${sessionName}`);\n                if (exchange !== undefined) {\n                    try {\n                        const messenger = new SecureChannelMessenger(exchange);\n                        await messenger.sendCloseSession();\n                        await messenger.close();\n                    } catch (error) {\n                        if (error instanceof ChannelNotConnectedError) {\n                            logger.debug(\"Session already closed because channel is disconnected.\");\n                        } else {\n                            logger.error(\"Error closing session\", error);\n                        }\n                    }\n                }\n                await exchange.destroy();\n            }\n        }\n        if (session.closingAfterExchangeFinished) {\n            await session.destroy(false, false);\n        }\n        this.sessionManager.removeSession(sessionId);\n        this.closingSessions.delete(sessionId);\n    }\n\n    #addExchange(exchangeIndex: number, exchange: MessageExchange<ContextT>) {\n        exchange.closed.on(() => this.deleteExchange(exchangeIndex));\n        this.exchanges.set(exchangeIndex, exchange);\n    }\n}\n\nexport class ExchangeCounter {\n    private exchangeCounter = Crypto.getRandomUInt16();\n\n    getIncrementedCounter() {\n        this.exchangeCounter++;\n        if (this.exchangeCounter > 0xffff) {\n            this.exchangeCounter = 0;\n        }\n        return this.exchangeCounter;\n    }\n}\n\nexport class ExchangeProvider {\n    constructor(\n        private readonly exchangeManager: ExchangeManager<MatterController>,\n        private channel: MessageChannel<MatterController>,\n        private readonly reconnectChannelFunc?: () => Promise<MessageChannel<MatterController>>,\n    ) {}\n\n    hasProtocolHandler(protocolId: number) {\n        return this.exchangeManager.hasProtocolHandler(protocolId);\n    }\n\n    getProtocolHandler(protocolId: number) {\n        return this.exchangeManager.getProtocolHandler(protocolId);\n    }\n\n    addProtocolHandler(handler: ProtocolHandler<MatterController>) {\n        this.exchangeManager.addProtocolHandler(handler);\n    }\n\n    initiateExchange(): MessageExchange<MatterController> {\n        return this.exchangeManager.initiateExchangeWithChannel(this.channel, INTERACTION_PROTOCOL_ID);\n    }\n\n    async reconnectChannel() {\n        if (this.reconnectChannelFunc === undefined) return false;\n        this.channel = await this.reconnectChannelFunc();\n        return true;\n    }\n\n    get session() {\n        return this.channel.session;\n    }\n\n    get channelType() {\n        return this.channel.type;\n    }\n}\n"],
  "mappings": "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",
  "names": ["exchange"]
}
