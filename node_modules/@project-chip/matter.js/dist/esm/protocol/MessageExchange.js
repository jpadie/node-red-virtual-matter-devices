/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MessageCodec, SessionType } from "../codec/MessageCodec.js";
import { InternalError, MatterError, MatterFlowError } from "../common/MatterError.js";
import { CRYPTO_AEAD_MIC_LENGTH_BYTES } from "../crypto/CryptoConstants.js";
import { Diagnostic } from "../log/Diagnostic.js";
import { Logger } from "../log/Logger.js";
import {
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "../session/Session.js";
import { Time } from "../time/Time.js";
import { ByteArray } from "../util/ByteArray.js";
import { AsyncObservable } from "../util/Observable.js";
import { createPromise } from "../util/Promises.js";
import { Queue } from "../util/Queue.js";
import { ChannelNotConnectedError } from "./ExchangeManager.js";
import { StatusCode, StatusResponseError } from "./interaction/StatusCode.js";
import { MessageType, SECURE_CHANNEL_PROTOCOL_ID } from "./securechannel/SecureChannelMessages.js";
import { SecureChannelProtocol } from "./securechannel/SecureChannelProtocol.js";
const logger = Logger.get("MessageExchange");
class RetransmissionLimitReachedError extends MatterError {
}
class UnexpectedMessageError extends MatterError {
  constructor(message, receivedMessage) {
    super(`(${MessageCodec.messageDiagnostics(receivedMessage)}) ${message}`);
    this.receivedMessage = receivedMessage;
  }
}
const MRP_MAX_TRANSMISSIONS = 5;
const MRP_BACKOFF_BASE = 1.6;
const MRP_BACKOFF_JITTER = 0.25;
const MRP_BACKOFF_MARGIN = 1.1;
const MRP_BACKOFF_THRESHOLD = 1;
const MRP_STANDALONE_ACK_TIMEOUT_MS = 200;
const MATTER_MESSAGE_OVERHEAD = 26 + 12 + CRYPTO_AEAD_MIC_LENGTH_BYTES;
class MessageExchange {
  constructor(session, channel, isInitiator, peerSessionId, nodeId, peerNodeId, exchangeId, protocolId) {
    this.session = session;
    this.channel = channel;
    this.isInitiator = isInitiator;
    this.#peerSessionId = peerSessionId;
    this.#nodeId = nodeId;
    this.#peerNodeId = peerNodeId;
    this.#exchangeId = exchangeId;
    this.#protocolId = protocolId;
    const { activeIntervalMs, idleIntervalMs, activeThresholdMs } = session.parameters;
    this.#activeIntervalMs = activeIntervalMs ?? SESSION_ACTIVE_INTERVAL_MS;
    this.#idleIntervalMs = idleIntervalMs ?? SESSION_IDLE_INTERVAL_MS;
    this.#activeThresholdMs = activeThresholdMs ?? SESSION_ACTIVE_THRESHOLD_MS;
    this.#maxTransmissions = MRP_MAX_TRANSMISSIONS;
    this.#useMRP = session.supportsMRP && !channel.isReliable;
    logger.debug(
      "New exchange",
      Diagnostic.dict({
        channel: channel.name,
        protocol: this.#protocolId,
        id: this.#exchangeId,
        session: session.name,
        peerSessionId: this.#peerSessionId,
        "active threshold ms": this.#activeThresholdMs,
        "active interval ms": this.#activeIntervalMs,
        "idle interval ms": this.#idleIntervalMs,
        maxTransmissions: this.#maxTransmissions,
        useMrp: this.#useMRP
      })
    );
  }
  static fromInitialMessage(channel, initialMessage) {
    const { session } = channel;
    return new MessageExchange(
      session,
      channel,
      false,
      session.id,
      initialMessage.packetHeader.destNodeId,
      initialMessage.packetHeader.sourceNodeId,
      initialMessage.payloadHeader.exchangeId,
      initialMessage.payloadHeader.protocolId
    );
  }
  static initiate(channel, exchangeId, protocolId) {
    const { session } = channel;
    return new MessageExchange(
      session,
      channel,
      true,
      session.peerSessionId,
      session.nodeId,
      session.peerNodeId,
      exchangeId,
      protocolId
    );
  }
  #activeIntervalMs;
  #idleIntervalMs;
  #activeThresholdMs;
  #maxTransmissions;
  #messagesQueue = new Queue();
  #receivedMessageToAck;
  #receivedMessageAckTimer = Time.getTimer("Ack receipt timeout", MRP_STANDALONE_ACK_TIMEOUT_MS, () => {
    if (this.#receivedMessageToAck !== void 0) {
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      this.sendStandaloneAckForMessage(messageToAck).catch(
        (error) => logger.error("An error happened when sending a standalone ack", error)
      );
    }
  });
  #sentMessageToAck;
  #sentMessageAckSuccess;
  #sentMessageAckFailure;
  #retransmissionTimer;
  #retransmissionCounter = 0;
  #closeTimer;
  #timedInteractionTimer;
  #peerSessionId;
  #nodeId;
  #peerNodeId;
  #exchangeId;
  #protocolId;
  #closed = AsyncObservable();
  #useMRP;
  get closed() {
    return this.#closed;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter
   * protocol overhead.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize - MATTER_MESSAGE_OVERHEAD;
  }
  async sendStandaloneAckForMessage(message) {
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck }
    } = message;
    if (!requiresAck || !this.#useMRP) return;
    await this.send(MessageType.StandaloneAck, new ByteArray(0), { includeAcknowledgeMessageId: messageId });
  }
  async onMessageReceived(message, isDuplicate = false) {
    logger.debug("Message \xAB", MessageCodec.messageDiagnostics(message, isDuplicate));
    if (message.payloadHeader.requiresAck && !this.#useMRP) {
      logger.debug("Ignoring ack-required flag because MRP is not used for this exchange");
      message.payloadHeader.requiresAck = false;
    }
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck, ackedMessageId, protocolId, messageType }
    } = message;
    const isStandaloneAck = SecureChannelProtocol.isStandaloneAck(protocolId, messageType);
    if (protocolId !== this.#protocolId && !isStandaloneAck) {
      throw new MatterFlowError(
        `Drop received a message for an unexpected protocol. Expected: ${this.#protocolId}, received: ${protocolId}`
      );
    }
    this.session.notifyActivity(true);
    if (isDuplicate) {
      if (requiresAck) {
        await this.sendStandaloneAckForMessage(message);
      }
      return;
    }
    if (messageId === this.#sentMessageToAck?.payloadHeader.ackedMessageId) {
      await this.channel.send(this.#sentMessageToAck);
      return;
    }
    const sentMessageIdToAck = this.#sentMessageToAck?.packetHeader.messageId;
    if (sentMessageIdToAck !== void 0) {
      if (ackedMessageId === void 0) {
        throw new MatterFlowError("Previous message ack is missing");
      } else if (ackedMessageId !== sentMessageIdToAck) {
        if (isStandaloneAck) {
        } else {
          throw new MatterFlowError(
            `Incorrect ack received. Expected ${sentMessageIdToAck}, received: ${ackedMessageId}`
          );
        }
      } else {
        this.#retransmissionTimer?.stop();
        this.#retransmissionCounter = 0;
        this.#sentMessageAckSuccess?.(message);
        this.#sentMessageAckSuccess = void 0;
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageToAck = void 0;
        if (isStandaloneAck && this.#closeTimer !== void 0) {
          return this.closeInternal();
        }
      }
    }
    if (isStandaloneAck) {
      return;
    }
    if (requiresAck) {
      if (this.#receivedMessageToAck !== void 0) {
        this.#receivedMessageAckTimer.stop();
        await this.sendStandaloneAckForMessage(this.#receivedMessageToAck);
        return;
      }
      this.#receivedMessageToAck = message;
      this.#receivedMessageAckTimer.start();
    }
    await this.#messagesQueue.write(message);
  }
  async send(messageType, payload, options) {
    if (options?.requiresAck && !this.#useMRP) {
      options.requiresAck = false;
    }
    const {
      expectAckOnly = false,
      minimumResponseTimeoutMs,
      requiresAck,
      includeAcknowledgeMessageId
    } = options ?? {};
    if (!this.#useMRP && includeAcknowledgeMessageId !== void 0) {
      throw new InternalError("Cannot include an acknowledge message ID when MRP is not used");
    }
    if (messageType === MessageType.StandaloneAck) {
      if (!this.#useMRP) {
        return;
      }
      if (requiresAck) {
        throw new MatterFlowError("A standalone ack may not require acknowledgement.");
      }
    }
    if (this.#sentMessageToAck !== void 0 && messageType !== MessageType.StandaloneAck)
      throw new MatterFlowError("The previous message has not been acked yet, cannot send a new message.");
    this.session.notifyActivity(false);
    let ackedMessageId = includeAcknowledgeMessageId;
    if (ackedMessageId === void 0 && this.#useMRP) {
      ackedMessageId = this.#receivedMessageToAck?.packetHeader.messageId;
      if (ackedMessageId !== void 0) {
        this.#receivedMessageAckTimer.stop();
        this.#receivedMessageToAck = void 0;
      }
    }
    const message = {
      packetHeader: {
        sessionId: this.#peerSessionId,
        sessionType: SessionType.Unicast,
        // TODO: support multicast/groups
        messageId: await this.session.getIncrementedMessageCounter(),
        destNodeId: this.#peerNodeId,
        sourceNodeId: this.#nodeId,
        hasPrivacyEnhancements: false,
        isControlMessage: false,
        hasMessageExtensions: false
      },
      payloadHeader: {
        exchangeId: this.#exchangeId,
        protocolId: messageType === MessageType.StandaloneAck ? SECURE_CHANNEL_PROTOCOL_ID : this.#protocolId,
        messageType,
        isInitiatorMessage: this.isInitiator,
        requiresAck: requiresAck ?? (this.#useMRP && messageType !== MessageType.StandaloneAck),
        ackedMessageId,
        hasSecuredExtension: false
      },
      payload
    };
    let ackPromise;
    if (this.#useMRP && message.payloadHeader.requiresAck) {
      this.#sentMessageToAck = message;
      this.#retransmissionTimer = Time.getTimer(
        "Message retransmission",
        this.getResubmissionBackOffTime(0),
        () => this.retransmitMessage(
          message,
          minimumResponseTimeoutMs !== void 0 ? Time.nowMs() + minimumResponseTimeoutMs : void 0
        )
      );
      const { promise, resolver, rejecter } = createPromise();
      ackPromise = promise;
      this.#sentMessageAckSuccess = resolver;
      this.#sentMessageAckFailure = rejecter;
    }
    await this.channel.send(message);
    if (ackPromise !== void 0) {
      this.#retransmissionCounter = 0;
      this.#retransmissionTimer?.start();
      const responseMessage = await ackPromise;
      this.#sentMessageAckSuccess = void 0;
      this.#sentMessageAckFailure = void 0;
      const {
        payloadHeader: { protocolId, messageType: messageType2 }
      } = responseMessage;
      if (expectAckOnly && !SecureChannelProtocol.isStandaloneAck(protocolId, messageType2)) {
        throw new UnexpectedMessageError("Expected ack only", responseMessage);
      }
    }
  }
  nextMessage() {
    return this.#messagesQueue.read();
  }
  async waitFor(messageType, timeoutMs = 18e4) {
    const message = await this.#messagesQueue.read(timeoutMs);
    const {
      payloadHeader: { messageType: receivedMessageType }
    } = message;
    if (receivedMessageType !== messageType)
      throw new MatterFlowError(
        `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(
          16
        )}`
      );
    return message;
  }
  /** @see {@link MatterSpecification.v10.Core}, section 4.11.2.1 */
  getResubmissionBackOffTime(retransmissionCount) {
    const baseInterval = this.session.isPeerActive() ? this.#activeIntervalMs : this.#idleIntervalMs;
    return Math.floor(
      MRP_BACKOFF_MARGIN * baseInterval * Math.pow(MRP_BACKOFF_BASE, Math.max(0, retransmissionCount - MRP_BACKOFF_THRESHOLD)) * (1 + Math.random() * MRP_BACKOFF_JITTER)
    );
  }
  retransmitMessage(message, notTimeoutBeforeTimeMs) {
    this.#retransmissionCounter++;
    if (this.#retransmissionCounter >= this.#maxTransmissions && (notTimeoutBeforeTimeMs === void 0 || Time.nowMs() > notTimeoutBeforeTimeMs)) {
      if (this.#sentMessageToAck !== void 0 && this.#sentMessageAckFailure !== void 0) {
        this.#receivedMessageToAck = void 0;
        this.#sentMessageAckFailure(new RetransmissionLimitReachedError());
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageAckSuccess = void 0;
      }
      if (this.#closeTimer !== void 0) {
        this.closeInternal().catch((error) => logger.error("An error happened when closing the exchange", error));
      }
      return;
    }
    this.session.notifyActivity(false);
    if (this.#retransmissionCounter === 1) {
    }
    const resubmissionBackoffTime = this.getResubmissionBackOffTime(this.#retransmissionCounter);
    logger.debug(
      `Resubmit message ${message.packetHeader.messageId} (retransmission attempt ${this.#retransmissionCounter}, backoff time ${resubmissionBackoffTime}ms))`
    );
    this.channel.send(message).then(() => {
      this.#retransmissionTimer = Time.getTimer(
        "Message retransmission",
        resubmissionBackoffTime,
        () => this.retransmitMessage(message, notTimeoutBeforeTimeMs)
      ).start();
    }).catch((error) => {
      logger.error("An error happened when retransmitting a message", error);
      if (error instanceof ChannelNotConnectedError) {
        this.closeInternal().catch(
          (error2) => logger.error("An error happened when closing the exchange", error2)
        );
      }
    });
  }
  async destroy() {
    if (this.#closeTimer === void 0 && this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
    }
    await this.closeInternal();
  }
  startTimedInteraction(timeoutMs) {
    if (this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning) {
      this.#timedInteractionTimer.stop();
      throw new StatusResponseError(
        "Timed interaction already running for this exchange",
        StatusCode.InvalidAction
      );
    }
    logger.debug(
      `Starting timed interaction with Transaction ID ${this.#exchangeId} for ${timeoutMs}ms from ${this.channel.name}`
    );
    this.#timedInteractionTimer = Time.getTimer("Timed interaction", timeoutMs, () => {
      logger.debug(
        `Timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name} timed out`
      );
    }).start();
  }
  clearTimedInteraction() {
    if (this.#timedInteractionTimer !== void 0) {
      logger.debug(
        `Clearing timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name}`
      );
      this.#timedInteractionTimer.stop();
      this.#timedInteractionTimer = void 0;
    }
  }
  hasTimedInteraction() {
    return this.#timedInteractionTimer !== void 0;
  }
  hasActiveTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning;
  }
  hasExpiredTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && !this.#timedInteractionTimer.isRunning;
  }
  async close() {
    if (this.#closeTimer !== void 0) return;
    if (this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
    } else if (this.#sentMessageToAck === void 0) {
      return this.closeInternal();
    }
    let maxResubmissionTime = 0;
    for (let i = this.#retransmissionCounter; i <= this.#maxTransmissions; i++) {
      maxResubmissionTime += this.getResubmissionBackOffTime(i);
    }
    this.#closeTimer = Time.getTimer(
      "Message exchange cleanup",
      maxResubmissionTime,
      async () => await this.closeInternal()
    ).start();
  }
  async closeInternal() {
    this.#retransmissionTimer?.stop();
    this.#closeTimer?.stop();
    this.#timedInteractionTimer?.stop();
    this.#messagesQueue.close();
    await this.#closed.emit();
  }
}
export {
  MATTER_MESSAGE_OVERHEAD,
  MessageExchange,
  RetransmissionLimitReachedError,
  UnexpectedMessageError
};
//# sourceMappingURL=MessageExchange.js.map
