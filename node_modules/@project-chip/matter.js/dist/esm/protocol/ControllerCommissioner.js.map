{
  "version": 3,
  "sources": ["../../../src/protocol/ControllerCommissioner.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TlvCertSigningRequest } from \"../behavior/definitions/operational-credentials/OperationalCredentialsTypes.js\";\nimport { CertificateManager } from \"../certificate/CertificateManager.js\";\nimport { RootCertificateManager } from \"../certificate/RootCertificateManager.js\";\nimport { ClusterType } from \"../cluster/ClusterType.js\";\nimport { ClusterClient } from \"../cluster/client/ClusterClient.js\";\nimport { ClusterClientObj } from \"../cluster/client/ClusterClientTypes.js\";\nimport { BasicInformation } from \"../cluster/definitions/BasicInformationCluster.js\";\nimport { Descriptor } from \"../cluster/definitions/DescriptorCluster.js\";\nimport { GeneralCommissioning } from \"../cluster/definitions/GeneralCommissioningCluster.js\";\nimport { NetworkCommissioning } from \"../cluster/definitions/NetworkCommissioningCluster.js\";\nimport { OperationalCredentials } from \"../cluster/definitions/OperationalCredentialsCluster.js\";\nimport { TimeSynchronizationCluster } from \"../cluster/definitions/TimeSynchronizationCluster.js\";\nimport { ChannelType } from \"../common/Channel.js\";\nimport { MatterError, UnexpectedDataError } from \"../common/MatterError.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { VendorId } from \"../datatype/VendorId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { TypeFromPartialBitSchema } from \"../schema/BitmapSchema.js\";\nimport { Time } from \"../time/Time.js\";\nimport { TypeFromSchema } from \"../tlv/TlvSchema.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { InteractionClient } from \"./interaction/InteractionClient.js\";\nimport { StatusResponseError } from \"./interaction/StatusCode.js\";\n\nconst logger = Logger.get(\"ControllerCommissioner\");\n\n/**\n * User specific options for the Commissioning process\n */\nexport type CommissioningOptions = {\n    /** Regulatory Location (Indoor/Outdoor) where the device is used. */\n    regulatoryLocation: GeneralCommissioning.RegulatoryLocationType;\n\n    /** Country Code where the device is used. */\n    regulatoryCountryCode: string;\n\n    /** Wifi network credentials to commission the device to. */\n    wifiNetwork?: {\n        wifiSsid: string;\n        wifiCredentials: string;\n    };\n\n    /** Thread network credentials to commission the device to. */\n    threadNetwork?: {\n        networkName: string;\n        operationalDataset: string;\n    };\n    nodeId?: NodeId;\n};\n\n/** Types representation of a general commissioning response. */\ntype CommissioningSuccessFailureResponse = {\n    errorCode: number;\n    debugText?: string;\n};\n\n/** Result code of a single commissioning step. */\nenum CommissioningStepResultCode {\n    Success,\n    Failure,\n    Skipped,\n}\n\n/**\n * Result of a single commissioning step\n * Breadcrump value is stored for each step for transparency\n */\ntype CommissioningStepResult = {\n    code: CommissioningStepResultCode;\n    breadcrumb: number;\n};\n\n/**\n * Definition of one commissioning step\n * All steps are for execution sorted by stepNumber and subStepNumber\n */\ntype CommissioningStep = {\n    /** Step Number according to the specs */\n    stepNumber: number;\n\n    /** Order of actions within a step */\n    subStepNumber: number;\n\n    /** Name of the action or step */\n    name: string;\n\n    /** Logic function to execute */\n    stepLogic: () => Promise<CommissioningStepResult>;\n};\n\n/** Data that are collected initially or through the commissioning process and can be used also by other steps. */\ntype CollectedCommissioningData = {\n    basicCommissioningInfo?: TypeFromSchema<typeof GeneralCommissioning.TlvBasicCommissioningInfo>;\n    productName?: string;\n    networkFeatures?: {\n        endpointId: number;\n        value: TypeFromPartialBitSchema<typeof NetworkCommissioning.Complete.features>;\n    }[];\n    networkStatus?: { endpointId: number; value: TypeFromSchema<typeof NetworkCommissioning.TlvNetworkInfo>[] }[];\n    rootPartsList?: EndpointNumber[];\n    rootServerList?: ClusterId[];\n    vendorId?: VendorId;\n    productId?: number;\n    supportsConcurrentConnection?: boolean;\n    successfullyConnectedToNetwork?: boolean;\n};\n\n/** Error that throws when Commissioning fails and process cannot be continued. */\nexport class CommissioningError extends MatterError {}\n\n/** Error that throws when Commissioning fails but process can be continued. */\nclass RecoverableCommissioningError extends CommissioningError {}\n\n/**\n * Special Error instance used to detect if the commissioning was successfully finished externally and the device is\n * now operational.\n */\nexport class CommissioningSuccessfullyFinished extends MatterError {}\n\nconst DEFAULT_FAILSAFE_TIME_MS = 60_000; // 60 seconds\n\n/**\n * Class to abstract the Device commission flow in a step wise way as defined in Specs. The specs are not 100%\n */\nexport class ControllerCommissioner {\n    private readonly commissioningSteps = new Array<CommissioningStep>();\n    private readonly commissioningStepResults = new Map<string, CommissioningStepResult>();\n    private readonly clusterClients = new Map<ClusterId, ClusterClientObj>();\n    private commissioningStartedTime: number | undefined;\n    private commissioningExpiryTime: number | undefined;\n    private lastFailSafeTime: number | undefined;\n    private lastBreadcrumb = 1;\n    private collectedCommissioningData: CollectedCommissioningData = {};\n    private failSafeTimeMs = DEFAULT_FAILSAFE_TIME_MS;\n\n    constructor(\n        /** InteractionClient for the initiated PASE session */\n        private interactionClient: InteractionClient,\n\n        /** CertificateManager of the controller. */\n        private readonly certificateManager: RootCertificateManager,\n\n        /** Fabric of the controller. */\n        private readonly fabric: Fabric,\n\n        /** Commissioning options for the commissioning process. */\n        private readonly commissioningOptions: CommissioningOptions,\n\n        /** NodeId to assign to the device to commission. */\n        private readonly nodeId: NodeId,\n\n        /** Administrator/Controller VendorId */\n        private readonly adminVendorId: VendorId,\n\n        /**\n         * Callback to operative discover and connect to the device and establish a CASE session with the device.\n         * The callback should return an InteractionClient to use to finish the commissioning process, or throw one of the following errors:\n         * * CommissioningSuccessfullyFinished: This special error can be used to notify that the commissioning completion was done by own logic and the device is now operational. The commissioner will not do any further steps.\n         * * CommissioningError: This error will stop the commissioning process in an error state.\n         * * other errors: Any other error will be logged and the commissioning process should be restarted.\n         */\n        private readonly doOperativeDeviceConnectionCallback: () => Promise<InteractionClient>,\n    ) {\n        logger.debug(`Commissioning options: ${Logger.toJSON(commissioningOptions)}`);\n        this.initializeCommissioningSteps();\n    }\n\n    /**\n     * Helper method to create ClusterClients. If not feature specific and for the Root Endpoint they are also reused.\n     */\n    private getClusterClient<const T extends ClusterType>(\n        cluster: T,\n        endpointId = EndpointNumber(0),\n        isFeatureSpecific = false,\n    ): ClusterClientObj<T> {\n        if (!isFeatureSpecific && endpointId === 0) {\n            const clusterClient = this.clusterClients.get(cluster.id);\n            if (clusterClient !== undefined) {\n                logger.debug(\n                    `Returning existing cluster client for cluster ${cluster.name} (endpoint ${endpointId}, isFeatureSpecific ${isFeatureSpecific})`,\n                );\n                return clusterClient as ClusterClientObj<T>;\n            }\n        }\n        logger.debug(\n            `Creating new cluster client for cluster ${cluster.name} (endpoint ${endpointId}, isFeatureSpecific ${isFeatureSpecific})`,\n        );\n        const client = ClusterClient(cluster, endpointId, this.interactionClient);\n        this.clusterClients.set(cluster.id, client);\n        return client;\n    }\n\n    /**\n     * Initialize commissioning steps and add them in the default order\n     */\n    private initializeCommissioningSteps() {\n        this.commissioningSteps.push({\n            stepNumber: 0,\n            subStepNumber: 1,\n            name: \"GetInitialData\",\n            stepLogic: () => this.getInitialData(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 3,\n            subStepNumber: 1,\n            name: \"GeneralCommissioning.ArmFailsafe\",\n            stepLogic: () => this.armFailsafe(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 5,\n            subStepNumber: 1,\n            name: \"GeneralCommissioning.ConfigureRegulatoryInformation\",\n            stepLogic: () => this.configureRegulatoryInformation(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 5,\n            subStepNumber: 2,\n            name: \"TimeSynchronization.SynchronizeTime\",\n            stepLogic: () => this.synchronizeTime(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 6,\n            subStepNumber: 1,\n            name: \"OperationalCredentials.DeviceAttestation\",\n            stepLogic: () => this.deviceAttestation(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 7,\n            subStepNumber: 1,\n            name: \"OperationalCredentials.Certificates\",\n            stepLogic: () => this.certificates(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 10,\n            subStepNumber: 1,\n            name: \"AccessControl\",\n            stepLogic: () => this.configureAccessControlLists(),\n        });\n\n        // Care about Network commissioning only when we are on BLE, because else we are already on IP network\n        if (this.interactionClient.channelType === ChannelType.BLE) {\n            this.commissioningSteps.push({\n                stepNumber: 11,\n                subStepNumber: 1,\n                name: \"NetworkCommissioning.Validate\",\n                stepLogic: () => this.validateNetwork(),\n            });\n            if (this.commissioningOptions.wifiNetwork !== undefined) {\n                this.commissioningSteps.push({\n                    stepNumber: 11,\n                    subStepNumber: 2,\n                    name: \"NetworkCommissioning.Wifi\",\n                    stepLogic: () => this.configureNetworkWifi(),\n                });\n            }\n            if (this.commissioningOptions.threadNetwork !== undefined) {\n                this.commissioningSteps.push({\n                    stepNumber: 11,\n                    subStepNumber: 3,\n                    name: \"NetworkCommissioning.Thread\",\n                    stepLogic: () => this.configureNetworkThread(),\n                });\n            }\n        } else {\n            logger.info(\n                `Skipping NetworkCommissioning steps because the device is already on IP network (${this.interactionClient.channelType})`,\n            );\n        }\n\n        this.commissioningSteps.push({\n            stepNumber: 12,\n            subStepNumber: 1,\n            name: \"Reconnect\",\n            stepLogic: () => this.reconnectWithDevice(),\n        });\n\n        this.commissioningSteps.push({\n            stepNumber: 15,\n            subStepNumber: 1,\n            name: \"GeneralCommissioning.Complete\",\n            stepLogic: () => this.completeCommissioning(),\n        });\n    }\n\n    /**\n     * Execute the commissioning process in the defined order. The steps are sorted before execution based on the step\n     * number and sub step number.\n     * If >50% of the failsafe time has passed, the failsafe timer is re-armed (50% of 60s default are 30s and each\n     * action is allowed to take 30s at minimum based on specs).\n     */\n    async executeCommissioning() {\n        this.sortSteps();\n\n        for (const step of this.commissioningSteps) {\n            logger.info(`Executing commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name}`);\n            try {\n                const result = await step.stepLogic();\n                this.setCommissioningStepResult(step, result);\n                if (this.lastFailSafeTime !== undefined) {\n                    const timeSinceLastArmFailsafe = Time.nowMs() - this.lastFailSafeTime;\n                    if (this.commissioningExpiryTime !== undefined && Time.nowMs() > this.commissioningExpiryTime) {\n                        logger.error(\n                            `Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} succeeded, but commissioning took too long in general!`,\n                        );\n                        throw new CommissioningError(`Commissioning took too long!`);\n                    }\n                    /**\n                     * Commissioner SHALL re-arm the Fail-safe timer on the Commissionee to the desired commissioning\n                     * timeout within 60 seconds of the completion of PASE session establishment, using the ArmFailSafe\n                     * command (see Section 11.9.6.2, \u201CArmFailSafe Command\u201D)\n                     */\n                    if (timeSinceLastArmFailsafe > this.failSafeTimeMs / 2) {\n                        logger.info(\n                            `After Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${\n                                step.name\n                            } succeeded, ${Math.floor(\n                                timeSinceLastArmFailsafe / 1000,\n                            )}s elapsed since last arm failsafe, re-arming failsafe`,\n                        );\n                        await this.armFailsafe();\n                    }\n                }\n            } catch (error) {\n                if (error instanceof RecoverableCommissioningError) {\n                    logger.error(\n                        `Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} failed with recoverable error: ${error.message} ... Continuing with process`,\n                    );\n                } else if (error instanceof CommissioningError || error instanceof StatusResponseError) {\n                    logger.error(\n                        `Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} failed with error: ${error.message} ... Aborting commissioning`,\n                    );\n                    // TODO In concurrent connection commissioning flow, the failure of any of the steps 2 through 10\n                    //  SHALL result in the Commissioner and Commissionee returning to step 2 (device discovery and\n                    //  commissioning channel establishment) and repeating each step. The failure of any of the steps\n                    //  11 through 15 in concurrent connection commissioning flow SHALL result in the Commissioner and\n                    //  Commissionee returning to step 11 (configuration of operational network information). In the\n                    //  case of failure of any of the steps 11 through 15 in concurrent connection commissioning flow,\n                    //  the Commissioner and Commissionee SHALL reuse the existing PASE-derived encryption keys over\n                    //  the commissioning channel and all steps up to and including step 10 are considered to have\n                    //  been successfully completed.\n\n                    // Commissioners that need to restart from step 2 MAY immediately expire the fail-safe by invoking\n                    // the ArmFailSafe command with an ExpiryLengthSeconds field set to 0. Otherwise, Commissioners\n                    // will need to wait until the current fail-safe timer has expired for the Commissionee to begin\n                    // accepting PASE again.\n                    await this.resetFailsafeTimer();\n\n                    StatusResponseError.accept(error);\n\n                    // Convert error\n                    const commError = new CommissioningError(error.message);\n                    commError.stack = error.stack;\n                    throw commError;\n                }\n\n                CommissioningSuccessfullyFinished.accept(error);\n                break;\n            }\n        }\n    }\n\n    private sortSteps() {\n        this.commissioningSteps.sort((a, b) => {\n            if (a.stepNumber !== b.stepNumber) return a.stepNumber - b.stepNumber;\n            return a.subStepNumber - b.subStepNumber;\n        });\n    }\n\n    private setCommissioningStepResult(step: CommissioningStep, result: CommissioningStepResult) {\n        this.commissioningStepResults.set(`${step.stepNumber}-${step.subStepNumber}`, result);\n    }\n\n    getCommissioningStepResult(stepNumber: number, subStepNumber: number) {\n        return this.commissioningStepResults.get(`${stepNumber}-${subStepNumber}`);\n    }\n\n    /** Helper method to check for errorCode/debugTest responses and throw error on failure */\n    private ensureOperationalCredentialsSuccess(\n        context: string,\n        { statusCode, debugText, fabricIndex }: TypeFromSchema<typeof OperationalCredentials.TlvNocResponse>,\n    ) {\n        logger.debug(\n            `Commissioning step ${context} returned ${statusCode}, ${debugText}${\n                fabricIndex !== undefined ? `, fabricIndex: ${fabricIndex}` : \"\"\n            }`,\n        );\n\n        if (statusCode === OperationalCredentials.NodeOperationalCertStatus.Ok) return;\n        throw new CommissioningError(\n            `Commission error for \"${context}\": ${statusCode}, ${debugText}${\n                fabricIndex !== undefined ? `, fabricIndex: ${fabricIndex}` : \"\"\n            }`,\n        );\n    }\n\n    /** Helper method to check for errorCode/debugTest responses and throw error on failure */\n    private ensureGeneralCommissioningSuccess(\n        context: string,\n        { errorCode, debugText }: CommissioningSuccessFailureResponse,\n    ) {\n        logger.debug(`Commissioning step ${context} returned ${errorCode}, ${debugText}`);\n\n        if (errorCode === GeneralCommissioning.CommissioningError.Ok) return;\n        throw new CommissioningError(`Commission error for \"${context}\": ${errorCode}, ${debugText}`);\n    }\n\n    /**\n     * Initial Step to receive some common data used by other steps\n     */\n    private async getInitialData() {\n        const descriptorClient = this.getClusterClient(Descriptor.Cluster);\n        this.collectedCommissioningData.rootPartsList = await descriptorClient.getPartsListAttribute();\n        this.collectedCommissioningData.rootServerList = await descriptorClient.getServerListAttribute();\n\n        const networkData = await this.interactionClient.getMultipleAttributes({\n            attributes: [\n                {\n                    clusterId: NetworkCommissioning.Complete.id,\n                    attributeId: NetworkCommissioning.Complete.attributes.featureMap.id,\n                },\n                {\n                    clusterId: NetworkCommissioning.Complete.id,\n                    attributeId: NetworkCommissioning.Complete.attributes.networks.id,\n                },\n            ],\n        });\n        const networkFeatures = new Array<{\n            endpointId: number;\n            value: TypeFromPartialBitSchema<typeof NetworkCommissioning.Complete.features>;\n        }>();\n        const networkStatus = new Array<{\n            endpointId: number;\n            value: TypeFromSchema<typeof NetworkCommissioning.TlvNetworkInfo>[];\n        }>();\n        for (const {\n            path: { endpointId, attributeId },\n            value,\n        } of networkData) {\n            if (attributeId === NetworkCommissioning.Complete.attributes.featureMap.id) {\n                networkFeatures.push({ endpointId, value });\n            } else if (attributeId === NetworkCommissioning.Complete.attributes.networks.id) {\n                networkStatus.push({ endpointId, value });\n            }\n        }\n        this.collectedCommissioningData.networkFeatures = networkFeatures;\n        this.collectedCommissioningData.networkStatus = networkStatus;\n\n        const basicInfoClient = this.getClusterClient(BasicInformation.Cluster);\n        this.collectedCommissioningData.vendorId = await basicInfoClient.getVendorIdAttribute();\n        this.collectedCommissioningData.productId = await basicInfoClient.getProductIdAttribute();\n        this.collectedCommissioningData.productName = await basicInfoClient.getProductNameAttribute();\n\n        const generalCommissioningClient = this.getClusterClient(GeneralCommissioning.Cluster);\n        this.collectedCommissioningData.supportsConcurrentConnection =\n            await generalCommissioningClient.getSupportsConcurrentConnectionAttribute();\n\n        /*\n            Apple is additionally requesting:\n            * MA-rootdevice(0x0)/GeneralCommissioning(0x30)/breadcrumb(0x0)\n\n            Google is additionally requesting:\n            * MA-rootdevice(0x0)/OperationalCredentials(0x3e)/supportedFabrics(0x2)\n            * MA-rootdevice(0x0)/OperationalCredentials(0x3e)/commissionedFabrics(0x3)\n            * MA-rootdevice(0x0)/OperationalCredentials(0x3e)/fabrics(0x1), isFabricFiltered=false\n         */\n\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 3\n     * Upon completion of PASE session establishment, the Commissionee SHALL autonomously arm the Fail-safe timer for a\n     * timeout of 60 seconds. This is to guard against the Commissioner aborting the Commissioning process without\n     * arming the fail-safe, which may leave the device unable to accept additional connections.\n     * A Commissioner MAY obtain device information including guidance on the fail-safe value from the Commissionee by\n     * reading BasicCommissioningInfo attribute (see Section 11.9.5.2, \u201CBasicCommissioningInfo Attribute\u201D) prior to\n     * invoking the ArmFailSafe command.\n     */\n    private async armFailsafe() {\n        const client = this.getClusterClient(GeneralCommissioning.Cluster);\n        if (this.collectedCommissioningData.basicCommissioningInfo === undefined) {\n            const basicCommissioningInfo = await client.getBasicCommissioningInfoAttribute();\n            this.collectedCommissioningData.basicCommissioningInfo = basicCommissioningInfo;\n            this.failSafeTimeMs = basicCommissioningInfo.failSafeExpiryLengthSeconds * 1000;\n            this.commissioningStartedTime = Time.nowMs();\n            this.commissioningExpiryTime =\n                this.commissioningStartedTime + basicCommissioningInfo.maxCumulativeFailsafeSeconds * 1000;\n        }\n        this.ensureGeneralCommissioningSuccess(\n            \"armFailSafe\",\n            await client.armFailSafe({\n                breadcrumb: this.lastBreadcrumb,\n                expiryLengthSeconds: this.collectedCommissioningData.basicCommissioningInfo.failSafeExpiryLengthSeconds,\n            }),\n        );\n        this.lastFailSafeTime = Time.nowMs();\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    private async resetFailsafeTimer() {\n        try {\n            const client = this.getClusterClient(GeneralCommissioning.Cluster);\n            await client.armFailSafe({\n                breadcrumb: this.lastBreadcrumb,\n                expiryLengthSeconds: 0,\n            });\n        } catch (error) {\n            logger.error(`Error while resetting failsafe timer`, error);\n        }\n    }\n\n    /**\n     * Step 5 - 1\n     * Commissioner SHALL configure regulatory information in the Commissionee if it has at least one instance of\n     * Network Commissioning cluster on any endpoint with either the WI (i.e. Wi-Fi) or TH (i.e. Thread) feature flags\n     * set in its FeatureMap.\n     * The regulatory information is configured using SetRegulatoryConfig (see Section 11.9.6.4,\n     * \u201CSetRegulatoryConfig Command\u201D).\n     */\n    private async configureRegulatoryInformation() {\n        if (this.collectedCommissioningData.networkFeatures === undefined) {\n            throw new CommissioningError(\"No network features collected. This should never happen.\");\n        }\n        // Read the infos for all Network Commissioning clusters\n        const hasRadioNetwork = this.collectedCommissioningData.networkFeatures.some(\n            ({ value: { wiFiNetworkInterface, threadNetworkInterface } }) =>\n                wiFiNetworkInterface || threadNetworkInterface,\n        );\n\n        if (hasRadioNetwork) {\n            const client = this.getClusterClient(GeneralCommissioning.Cluster);\n            let locationCapability = await client.getLocationCapabilityAttribute();\n            if (locationCapability === GeneralCommissioning.RegulatoryLocationType.IndoorOutdoor) {\n                locationCapability = this.commissioningOptions.regulatoryLocation;\n            } else {\n                logger.debug(\n                    `Device does not support a configurable regulatory location type. Location is set to \"${\n                        locationCapability === GeneralCommissioning.RegulatoryLocationType.Indoor ? \"Indoor\" : \"Outdoor\"\n                    }\"`,\n                );\n            }\n            let countryCode = this.commissioningOptions.regulatoryCountryCode;\n            const regulatoryResult = await client.setRegulatoryConfig(\n                {\n                    breadcrumb: this.lastBreadcrumb++,\n                    newRegulatoryConfig: locationCapability,\n                    countryCode,\n                },\n                { useExtendedFailSafeMessageResponseTimeout: true },\n            );\n            if (\n                regulatoryResult.errorCode === GeneralCommissioning.CommissioningError.ValueOutsideRange &&\n                countryCode !== \"XX\"\n            ) {\n                logger.debug(\n                    `Device does not support a configurable country code. Use \"XX\" instead of \"${countryCode}\"`,\n                );\n                countryCode = \"XX\";\n                this.ensureGeneralCommissioningSuccess(\n                    \"setRegulatoryConfig\",\n                    await client.setRegulatoryConfig(\n                        {\n                            breadcrumb: this.lastBreadcrumb,\n                            newRegulatoryConfig: locationCapability,\n                            countryCode,\n                        },\n                        { useExtendedFailSafeMessageResponseTimeout: true },\n                    ),\n                );\n            } else {\n                this.ensureGeneralCommissioningSuccess(\"setRegulatoryConfig\", regulatoryResult);\n            }\n            return {\n                code: CommissioningStepResultCode.Success,\n                breadcrumb: this.lastBreadcrumb,\n            };\n        }\n        return {\n            code: CommissioningStepResultCode.Skipped,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 5 - 2\n     * Commissioner SHOULD configure UTC time, timezone, and DST offset, if the Commissionee supports the time cluster.\n     * The order of configuration of this information is not critical. The UTC time is configured using SetUtcTime\n     * command (see Section 11.16.9.1, \u201CSetUtcTime Command\u201D) while timezone and DST offset are set through TimeZone\n     * (see Section 11.16.8.6, \u201CTimeZone Attribute\u201D) and DstOffset attribute (see Section 11.16.8.7,\n     * \u201CDSTOffset Attribute\u201D), respectively.\n     */\n    private async synchronizeTime() {\n        if (\n            this.collectedCommissioningData.rootServerList !== undefined &&\n            this.collectedCommissioningData.rootServerList.find(\n                clusterId => clusterId === TimeSynchronizationCluster.id,\n            )\n        ) {\n            logger.debug(\"TimeSynchronization cluster is supported\");\n            // TODO: implement\n        }\n        return {\n            code: CommissioningStepResultCode.Skipped,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 6\n     * Commissioner SHALL establish the authenticity of the Commissionee as a certified Matter device (see Section\n     * 6.2.3, \u201CDevice Attestation Procedure\u201D).\n     */\n    private async deviceAttestation() {\n        const operationalCredentialsClusterClient = this.getClusterClient(OperationalCredentials.Cluster);\n        const { certificate: deviceAttestation } = await operationalCredentialsClusterClient.certificateChainRequest(\n            {\n                certificateType: OperationalCredentials.CertificateChainType.DacCertificate,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        // TODO: extract device public key from deviceAttestation\n        const { certificate: productAttestation } = await operationalCredentialsClusterClient.certificateChainRequest(\n            {\n                certificateType: OperationalCredentials.CertificateChainType.PaiCertificate,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        // TODO: validate deviceAttestation and productAttestation\n        const { attestationElements, attestationSignature } =\n            await operationalCredentialsClusterClient.attestationRequest(\n                {\n                    attestationNonce: Crypto.getRandomData(32),\n                },\n                { useExtendedFailSafeMessageResponseTimeout: true },\n            );\n        // TODO: validate attestationSignature using device public key\n        if (\n            deviceAttestation.length === 0 ||\n            productAttestation.length === 0 ||\n            attestationElements.length === 0 ||\n            attestationSignature.length === 0\n        ) {\n            // TODO: validate the data really\n            throw new CommissioningError(\"Device Attestation data missing from device\");\n        }\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n\n        // TODO consider Distributed Compliance Ledger Info about Commissioning Flow\n    }\n\n    /**\n     * Step 7-9\n     * 7: Following the Device Attestation Procedure yielding a decision to proceed with commissioning, the Commissioner\n     * SHALL request operational CSR from Commissionee using the CSRRequest command (see Section 11.17.6.5,\n     * \u201CCSRRequest Command\u201D). The CSRRequest command will cause the generation of a new operational key pair at the\n     * Commissionee.\n     * 8: Commissioner SHALL generate or otherwise obtain an Operational Certificate containing Operational ID after\n     * receiving the CSRResponse command from the Commissionee (see Section 11.17.6.5, \u201CCSRRequest Command\u201D), using\n     * implementation-specific means.\n     * 9: Commissioner SHALL install operational credentials (see Figure 38, \u201CNode Operational Credentials flow\u201D) on\n     * the Commissionee using the AddTrustedRootCertificate and AddNOC commands.\n     */\n    private async certificates() {\n        const operationalCredentialsClusterClient = this.getClusterClient(OperationalCredentials.Cluster);\n        const { nocsrElements, attestationSignature: csrSignature } =\n            await operationalCredentialsClusterClient.csrRequest(\n                { csrNonce: Crypto.getRandomData(32) },\n                { useExtendedFailSafeMessageResponseTimeout: true },\n            );\n        if (nocsrElements.length === 0 || csrSignature.length === 0) {\n            // TODO: validate the data really\n            throw new UnexpectedDataError(\"Invalid response from device\");\n        }\n        // TODO: validate csrSignature using device public key\n        const { certSigningRequest } = TlvCertSigningRequest.decode(nocsrElements);\n        const operationalPublicKey = CertificateManager.getPublicKeyFromCsr(certSigningRequest);\n\n        await operationalCredentialsClusterClient.addTrustedRootCertificate(\n            {\n                rootCaCertificate: this.certificateManager.rootCert,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        const peerOperationalCert = this.certificateManager.generateNoc(\n            operationalPublicKey,\n            this.fabric.fabricId,\n            this.nodeId,\n        );\n        this.ensureOperationalCredentialsSuccess(\n            \"addNoc\",\n            await operationalCredentialsClusterClient.addNoc(\n                {\n                    nocValue: peerOperationalCert,\n                    icacValue: new ByteArray(0),\n                    ipkValue: this.fabric.identityProtectionKey,\n                    adminVendorId: this.adminVendorId,\n                    caseAdminSubject: this.fabric.rootNodeId,\n                },\n                { useExtendedFailSafeMessageResponseTimeout: true },\n            ),\n        );\n\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 10\n     * Commissioner MAY configure the Access Control List (see Access Control Cluster) on the Commissionee in any way\n     * it sees fit, if the singular entry added by the AddNOC command in the previous step granting Administer\n     * privilege over CASE authentication type for the Node ID provided with the command is not sufficient to express\n     * its desired access control policies.\n     */\n    private async configureAccessControlLists() {\n        // Standard entry is sufficient in our case\n\n        return {\n            code: CommissioningStepResultCode.Skipped,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 11-12\n     * 11: If the Commissionee both supports it and requires it, the Commissioner SHALL configure the operational network\n     * at the Commissionee using commands such as AddOrUpdateWiFiNetwork (see Section 11.8.7.3, \u201CAddOrUpdateWiFiNetwork\n     * Command\u201D) and AddOrUpdateThreadNetwork (see Section 11.8.7.4, \u201CAddOrUpdateThreadNetwork Command\u201D).\n     * A Commissionee requires network commissioning if it is not already on the desired operational network.\n     * A Commissionee supports network commissioning if it has any NetworkCommissioning cluster instances.\n     * A Commissioner MAY learn about the networks visible to the Commissionee using ScanNetworks command\n     * (see Section 11.8.7.1, \u201CScanNetworks Command\u201D).\n     * 12: The Commissioner SHALL trigger the Commissionee to connect to the operational network using ConnectNetwork\n     * command (see Section 11.8.7.9, \u201CConnectNetwork Command\u201D) unless the Commissionee is already on the desired operational network.\n     */\n    private async validateNetwork() {\n        if (\n            this.collectedCommissioningData.networkFeatures === undefined ||\n            this.collectedCommissioningData.networkStatus === undefined\n        ) {\n            throw new CommissioningError(\"No network features or status collected. This should never happen.\");\n        }\n        if (\n            this.commissioningOptions.wifiNetwork === undefined &&\n            this.commissioningOptions.threadNetwork === undefined\n        ) {\n            // Check if we have no networkCommissioning cluster or an Ethernet one\n            const anyEthernetInterface =\n                this.collectedCommissioningData.networkFeatures.length === 0 ||\n                this.collectedCommissioningData.networkFeatures.some(\n                    ({ value: { ethernetNetworkInterface } }) => ethernetNetworkInterface === true,\n                );\n            const anyInterfaceConnected =\n                this.collectedCommissioningData.networkStatus.length === 0 ||\n                this.collectedCommissioningData.networkStatus.some(({ value }) =>\n                    value.some(({ connected }) => connected),\n                );\n            if (!anyEthernetInterface && !anyInterfaceConnected) {\n                throw new CommissioningError(\n                    \"No Wi-Fi/Thread network credentials are configured for commissioning and no Ethernet interface is available on the device and no interface already connected.\",\n                );\n            }\n        }\n\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    private async configureNetworkWifi() {\n        if (this.commissioningOptions.wifiNetwork === undefined) {\n            logger.debug(\"WiFi network is not configured\");\n            return {\n                code: CommissioningStepResultCode.Skipped,\n                breadcrumb: this.lastBreadcrumb,\n            };\n        }\n        if (\n            this.collectedCommissioningData.networkFeatures !== undefined &&\n            this.collectedCommissioningData.networkStatus !== undefined\n        ) {\n            const rootNetworkFeatures = this.collectedCommissioningData.networkFeatures.find(\n                ({ endpointId }) => endpointId === 0,\n            )?.value;\n            const rootNetworkStatus = this.collectedCommissioningData.networkStatus.find(\n                ({ endpointId }) => endpointId === 0,\n            )?.value;\n\n            logger.debug(\n                `Root Networks found: ${Logger.toJSON(rootNetworkFeatures)} - ${Logger.toJSON(rootNetworkStatus)}`,\n            );\n\n            if (rootNetworkFeatures?.wiFiNetworkInterface !== true) {\n                logger.debug(\"Commissionee does not support any WiFi network interface\");\n                return {\n                    code: CommissioningStepResultCode.Skipped,\n                    breadcrumb: this.lastBreadcrumb,\n                };\n            }\n            if (rootNetworkStatus !== undefined && rootNetworkStatus.length > 0 && rootNetworkStatus[0].connected) {\n                logger.debug(\"Commissionee is already connected to the WiFi network\");\n                this.collectedCommissioningData.successfullyConnectedToNetwork = true;\n                return {\n                    code: CommissioningStepResultCode.Skipped,\n                    breadcrumb: this.lastBreadcrumb,\n                };\n            }\n        }\n\n        logger.debug(\"Configuring WiFi network ...\");\n        const networkCommissioningClusterClient = this.getClusterClient(\n            NetworkCommissioning.Cluster.with(\"WiFiNetworkInterface\"),\n            EndpointNumber(0),\n            true,\n        );\n        const ssid = ByteArray.fromString(this.commissioningOptions.wifiNetwork.wifiSsid);\n        const credentials = ByteArray.fromString(this.commissioningOptions.wifiNetwork.wifiCredentials);\n\n        const { networkingStatus, wiFiScanResults, debugText } = await networkCommissioningClusterClient.scanNetworks(\n            {\n                ssid,\n                breadcrumb: this.lastBreadcrumb++,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        if (networkingStatus !== NetworkCommissioning.NetworkCommissioningStatus.Success) {\n            throw new CommissioningError(`Commissionee failed to scan for WiFi networks: ${debugText}`);\n        }\n        if (wiFiScanResults === undefined || wiFiScanResults.length === 0) {\n            throw new CommissioningError(\n                `Commissionee did not return any WiFi networks for the requested SSID ${this.commissioningOptions.wifiNetwork.wifiSsid}`,\n            );\n        }\n\n        const {\n            networkingStatus: addNetworkingStatus,\n            debugText: addDebugText,\n            networkIndex,\n        } = await networkCommissioningClusterClient.addOrUpdateWiFiNetwork(\n            {\n                ssid,\n                credentials,\n                breadcrumb: this.lastBreadcrumb++,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        if (addNetworkingStatus !== NetworkCommissioning.NetworkCommissioningStatus.Success) {\n            throw new CommissioningError(`Commissionee failed to add WiFi network: ${addDebugText}`);\n        }\n        if (networkIndex === undefined) {\n            throw new CommissioningError(`Commissionee did not return network index`);\n        }\n        logger.debug(\n            `Commissionee added WiFi network ${this.commissioningOptions.wifiNetwork.wifiSsid} with network index ${networkIndex}`,\n        );\n\n        const updatedNetworks = await networkCommissioningClusterClient.getNetworksAttribute();\n        if (updatedNetworks[networkIndex] === undefined) {\n            throw new CommissioningError(`Commissionee did not return network with index ${networkIndex}`);\n        }\n        const { networkId, connected } = updatedNetworks[networkIndex];\n        if (connected) {\n            this.collectedCommissioningData.successfullyConnectedToNetwork = true;\n            logger.debug(\n                `Commissionee is already connected to WiFi network ${\n                    this.commissioningOptions.wifiNetwork.wifiSsid\n                } (networkId ${networkId.toHex()})`,\n            );\n            return {\n                code: CommissioningStepResultCode.Success,\n                breadcrumb: this.lastBreadcrumb,\n            };\n        }\n\n        const connectResult = await networkCommissioningClusterClient.connectNetwork(\n            {\n                networkId: networkId,\n                breadcrumb: this.lastBreadcrumb++,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n\n        if (connectResult.networkingStatus !== NetworkCommissioning.NetworkCommissioningStatus.Success) {\n            throw new CommissioningError(`Commissionee failed to connect to WiFi network: ${connectResult.debugText}`);\n        }\n        this.collectedCommissioningData.successfullyConnectedToNetwork = true;\n        logger.debug(\n            `Commissionee successfully connected to WiFi network ${\n                this.commissioningOptions.wifiNetwork.wifiSsid\n            } (networkId ${networkId.toHex()})`,\n        );\n\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    private async configureNetworkThread() {\n        if (this.collectedCommissioningData.successfullyConnectedToNetwork) {\n            logger.debug(\"Node is already connected to a network. Skipping Thread configuration.\");\n            return {\n                code: CommissioningStepResultCode.Skipped,\n                breadcrumb: this.lastBreadcrumb,\n            };\n        }\n        if (this.commissioningOptions.threadNetwork === undefined) {\n            logger.debug(\"Thread network is not configured\");\n            return {\n                code: CommissioningStepResultCode.Skipped,\n                breadcrumb: this.lastBreadcrumb,\n            };\n        }\n        if (\n            this.collectedCommissioningData.networkFeatures !== undefined &&\n            this.collectedCommissioningData.networkStatus !== undefined\n        ) {\n            const rootNetworkFeatures = this.collectedCommissioningData.networkFeatures.find(\n                ({ endpointId }) => endpointId === 0,\n            )?.value;\n            const rootNetworkStatus = this.collectedCommissioningData.networkStatus.find(\n                ({ endpointId }) => endpointId === 0,\n            )?.value;\n\n            logger.debug(\n                `Root Networks found: ${Logger.toJSON(rootNetworkFeatures)} - ${Logger.toJSON(rootNetworkStatus)}`,\n            );\n\n            if (rootNetworkFeatures?.threadNetworkInterface !== true) {\n                logger.debug(\"Commissionee does not support any Thread network interface\");\n                return {\n                    code: CommissioningStepResultCode.Skipped,\n                    breadcrumb: this.lastBreadcrumb,\n                };\n            }\n            if (rootNetworkStatus !== undefined && rootNetworkStatus.length > 0 && rootNetworkStatus[0].connected) {\n                logger.debug(\"Commissionee is already connected to the Thread network\");\n                return {\n                    code: CommissioningStepResultCode.Skipped,\n                    breadcrumb: this.lastBreadcrumb,\n                };\n            }\n        }\n\n        logger.debug(\"Configuring Thread network ...\");\n        const networkCommissioningClusterClient = this.getClusterClient(\n            NetworkCommissioning.Cluster.with(\"ThreadNetworkInterface\"),\n            EndpointNumber(0),\n            true,\n        );\n\n        const { networkingStatus, threadScanResults, debugText } = await networkCommissioningClusterClient.scanNetworks(\n            { breadcrumb: this.lastBreadcrumb++ },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        if (networkingStatus !== NetworkCommissioning.NetworkCommissioningStatus.Success) {\n            throw new CommissioningError(`Commissionee failed to scan for Thread networks: ${debugText}`);\n        }\n        if (threadScanResults === undefined || threadScanResults.length === 0) {\n            throw new CommissioningError(\n                `Commissionee did not return any Thread networks for the requested Network ${this.commissioningOptions.threadNetwork.networkName}`,\n            );\n        }\n        const wantedNetworkFound = threadScanResults.find(\n            ({ networkName }) => networkName === this.commissioningOptions.threadNetwork?.networkName,\n        );\n        if (wantedNetworkFound === undefined) {\n            throw new CommissioningError(\n                `Commissionee did not return the requested Network ${\n                    this.commissioningOptions.threadNetwork.networkName\n                }: ${Logger.toJSON(threadScanResults)}`,\n            );\n        }\n        logger.debug(\n            `Commissionee found wanted Thread network ${\n                this.commissioningOptions.threadNetwork.networkName\n            }: ${Logger.toJSON(wantedNetworkFound)}`,\n        );\n\n        const {\n            networkingStatus: addNetworkingStatus,\n            debugText: addDebugText,\n            networkIndex,\n        } = await networkCommissioningClusterClient.addOrUpdateThreadNetwork(\n            {\n                operationalDataset: ByteArray.fromHex(this.commissioningOptions.threadNetwork.operationalDataset),\n                breadcrumb: this.lastBreadcrumb++,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n        if (addNetworkingStatus !== NetworkCommissioning.NetworkCommissioningStatus.Success) {\n            throw new CommissioningError(`Commissionee failed to add Thread network: ${addDebugText}`);\n        }\n        if (networkIndex === undefined) {\n            throw new CommissioningError(`Commissionee did not return network index`);\n        }\n        logger.debug(\n            `Commissionee added Thread network ${this.commissioningOptions.threadNetwork.networkName} with network index ${networkIndex}`,\n        );\n\n        const updatedNetworks = await networkCommissioningClusterClient.getNetworksAttribute();\n        if (updatedNetworks[networkIndex] === undefined) {\n            throw new CommissioningError(`Commissionee did not return network with index ${networkIndex}`);\n        }\n        const { networkId, connected } = updatedNetworks[networkIndex];\n        if (connected) {\n            logger.debug(\n                `Commissionee is already connected to Thread network ${\n                    this.commissioningOptions.threadNetwork.networkName\n                } (networkId ${networkId.toHex()})`,\n            );\n            return {\n                code: CommissioningStepResultCode.Success,\n                breadcrumb: this.lastBreadcrumb,\n            };\n        }\n\n        const connectResult = await networkCommissioningClusterClient.connectNetwork(\n            {\n                networkId: networkId,\n                breadcrumb: this.lastBreadcrumb++,\n            },\n            { useExtendedFailSafeMessageResponseTimeout: true },\n        );\n\n        if (connectResult.networkingStatus !== NetworkCommissioning.NetworkCommissioningStatus.Success) {\n            throw new CommissioningError(\n                `Commissionee failed to connect to Thread network: ${connectResult.debugText}`,\n            );\n        }\n        logger.debug(\n            `Commissionee successfully connected to Thread network ${\n                this.commissioningOptions.threadNetwork.networkName\n            } (networkId ${networkId.toHex()})`,\n        );\n\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 13-14\n     * 13: Finalization of the Commissioning process begins. An Administrator configured in the ACL of the Commissionee\n     * by the Commissioner SHALL use Operational Discovery to discover the Commissionee. This Administrator MAY be\n     * the Commissioner itself, or another Node to which the Commissioner has delegated the task.\n     * 14: The Administrator SHALL open a CASE (see Section 4.13.2, \u201CCertificate Authenticated Session Establishment\n     * (CASE)\u201D) session with the Commissionee over the operational network.\n     *\n     */\n    private async reconnectWithDevice() {\n        logger.debug(\"Reconnecting with device ...\");\n        this.interactionClient = await this.doOperativeDeviceConnectionCallback();\n        logger.debug(\"Successfully reconnected with device ...\");\n\n        this.clusterClients.clear();\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n\n    /**\n     * Step 15\n     * The Administrator having established a CASE session with the Commissionee over the operational network in the\n     * previous steps SHALL invoke the CommissioningComplete command (see Section 11.9.6.6,\n     * \u201CCommissioningComplete Command\u201D). A success response after invocation of the CommissioningComplete command ends\n     * the commissioning process.\n     */\n    private async completeCommissioning() {\n        const generalCommissioningClusterClient = this.getClusterClient(GeneralCommissioning.Cluster);\n        this.ensureGeneralCommissioningSuccess(\n            \"commissioningComplete\",\n            await generalCommissioningClusterClient.commissioningComplete(undefined, {\n                useExtendedFailSafeMessageResponseTimeout: true,\n            }),\n        );\n\n        return {\n            code: CommissioningStepResultCode.Success,\n            breadcrumb: this.lastBreadcrumb,\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["CommissioningStepResultCode"]
}
