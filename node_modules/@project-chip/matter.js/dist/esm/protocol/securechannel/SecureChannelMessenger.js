/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError, UnexpectedDataError } from "../../common/MatterError.js";
import {
  GeneralStatusCode,
  MessageType,
  ProtocolStatusCode,
  SECURE_CHANNEL_PROTOCOL_ID
} from "./SecureChannelMessages.js";
import { TlvSecureChannelStatusMessage } from "./SecureChannelStatusMessageSchema.js";
class ChannelStatusResponseError extends MatterError {
  constructor(message, generalStatusCode, protocolStatusCode) {
    super(`(${generalStatusCode}/${protocolStatusCode}) ${message}`);
    this.generalStatusCode = generalStatusCode;
    this.protocolStatusCode = protocolStatusCode;
  }
}
class SecureChannelMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  async nextMessage(expectedMessageInfo, expectedMessageType) {
    const message = await this.exchange.nextMessage();
    const messageType = message.payloadHeader.messageType;
    this.throwIfErrorStatusReport(message, expectedMessageInfo);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType)
      throw new UnexpectedDataError(
        `Received unexpected message type: ${messageType}, expected: ${expectedMessageType} (${expectedMessageInfo})`
      );
    return message;
  }
  async nextMessageDecoded(expectedMessageType, schema, expectedMessageInfo) {
    return schema.decode((await this.nextMessage(expectedMessageInfo, expectedMessageType)).payload);
  }
  async waitForSuccess(expectedMessageInfo) {
    await this.nextMessage(expectedMessageInfo, MessageType.StatusReport);
  }
  async send(message, type, schema) {
    const payload = schema.encode(message);
    await this.exchange.send(type, payload);
    return payload;
  }
  sendError(code) {
    return this.sendStatusReport(GeneralStatusCode.Failure, code);
  }
  sendSuccess() {
    return this.sendStatusReport(GeneralStatusCode.Success, ProtocolStatusCode.Success);
  }
  sendCloseSession() {
    return this.sendStatusReport(GeneralStatusCode.Success, ProtocolStatusCode.CloseSession, false);
  }
  getChannelName() {
    return this.exchange.channel.channel.name;
  }
  async close() {
    await this.exchange.close();
  }
  async sendStatusReport(generalStatus, protocolStatus, requiresAck) {
    await this.exchange.send(
      MessageType.StatusReport,
      TlvSecureChannelStatusMessage.encode({
        generalStatus,
        protocolId: SECURE_CHANNEL_PROTOCOL_ID,
        protocolStatus
      }),
      { requiresAck }
    );
  }
  throwIfErrorStatusReport(message, logHint) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== MessageType.StatusReport) return;
    const { generalStatus, protocolId, protocolStatus } = TlvSecureChannelStatusMessage.decode(payload);
    if (generalStatus !== GeneralStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general error status for protocol ${protocolId}${logHint ? ` (${logHint})` : ""}`,
        generalStatus,
        protocolStatus
      );
    }
    if (protocolStatus !== ProtocolStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general success status, but protocol status is not Success${logHint ? ` (${logHint})` : ""}`,
        generalStatus,
        protocolStatus
      );
    }
  }
}
export {
  ChannelStatusResponseError,
  SecureChannelMessenger
};
//# sourceMappingURL=SecureChannelMessenger.js.map
