/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterFlowError } from "../../common/MatterError.js";
import { Logger } from "../../log/Logger.js";
import { assertSecureSession } from "../../session/SecureSession.js";
import { CaseServer } from "../../session/case/CaseServer.js";
import { MaximumPasePairingErrorsReachedError } from "../../session/pase/PaseServer.js";
import { StatusCode, StatusResponseError } from "../interaction/StatusCode.js";
import {
  GeneralStatusCode,
  MessageType,
  ProtocolStatusCode,
  SECURE_CHANNEL_PROTOCOL_ID
} from "./SecureChannelMessages.js";
import { ChannelStatusResponseError, SecureChannelMessenger } from "./SecureChannelMessenger.js";
import { TlvSecureChannelStatusMessage } from "./SecureChannelStatusMessageSchema.js";
const logger = Logger.get("SecureChannelProtocol");
class StatusReportOnlySecureChannelProtocol {
  getId() {
    return SECURE_CHANNEL_PROTOCOL_ID;
  }
  async onNewExchange(exchange, message) {
    const messageType = message.payloadHeader.messageType;
    switch (messageType) {
      case MessageType.StatusReport:
        await this.handleInitialStatusReport(exchange, message);
        break;
      default:
        if (messageType !== MessageType.StandaloneAck) {
          throw new StatusResponseError(
            `Unexpected initial message on secure channel protocol: ${messageType.toString(16)}`,
            StatusCode.InvalidAction
          );
        }
    }
  }
  async handleInitialStatusReport(exchange, message) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== MessageType.StatusReport) {
      throw new MatterFlowError(
        `Unexpected message type on secure channel protocol, expected StatusReport: ${messageType.toString(
          16
        )}`
      );
    }
    const { generalStatus, protocolId, protocolStatus } = TlvSecureChannelStatusMessage.decode(payload);
    if (generalStatus !== GeneralStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general error status (${protocolId})`,
        generalStatus,
        protocolStatus
      );
    }
    if (protocolStatus !== ProtocolStatusCode.CloseSession) {
      throw new ChannelStatusResponseError(
        `Received general success status, but protocol status is not CloseSession`,
        generalStatus,
        protocolStatus
      );
    }
    const { session } = exchange;
    assertSecureSession(session);
    logger.debug(`Peer requested to close session ${session.name}. Remove session now.`);
    await session.destroy(false, false);
  }
  async close() {
  }
}
class SecureChannelProtocol extends StatusReportOnlySecureChannelProtocol {
  constructor(commissioningCancelledCallback) {
    super();
    this.commissioningCancelledCallback = commissioningCancelledCallback;
  }
  paseCommissioner;
  caseCommissioner = new CaseServer();
  setPaseCommissioner(paseServer) {
    this.paseCommissioner = paseServer;
  }
  removePaseCommissioner() {
    this.paseCommissioner = void 0;
  }
  async onNewExchange(exchange, message) {
    const messageType = message.payloadHeader.messageType;
    switch (messageType) {
      case MessageType.PbkdfParamRequest:
        if (this.paseCommissioner === void 0) {
          const messenger = new SecureChannelMessenger(exchange);
          await messenger.sendError(ProtocolStatusCode.InvalidParam);
          await messenger.close();
          return;
        }
        try {
          await this.paseCommissioner.onNewExchange(exchange);
        } catch (error) {
          MaximumPasePairingErrorsReachedError.accept(error);
          logger.info("Maximum number of PASE pairing errors reached, cancelling commissioning.");
          await this.commissioningCancelledCallback();
        }
        break;
      case MessageType.Sigma1:
        await this.caseCommissioner.onNewExchange(exchange);
        break;
      default:
        await super.onNewExchange(exchange, message);
    }
  }
  static isStandaloneAck(protocolId, messageType) {
    return protocolId === SECURE_CHANNEL_PROTOCOL_ID && messageType === MessageType.StandaloneAck;
  }
}
export {
  SecureChannelProtocol,
  StatusReportOnlySecureChannelProtocol
};
//# sourceMappingURL=SecureChannelProtocol.js.map
