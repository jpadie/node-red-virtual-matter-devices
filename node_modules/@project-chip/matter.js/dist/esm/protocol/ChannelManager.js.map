{
  "version": 3,
  "sources": ["../../../src/protocol/ChannelManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Channel } from \"../common/Channel.js\";\nimport { MatterError } from \"../common/MatterError.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { SecureSession } from \"../session/SecureSession.js\";\nimport { Session } from \"../session/Session.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { MessageChannel } from \"./ExchangeManager.js\";\n\nconst logger = Logger.get(\"ChannelManager\");\n\nexport class NoChannelError extends MatterError {}\n\nexport class ChannelManager {\n    readonly #channels = new Map<string, MessageChannel<any>[]>();\n    readonly #paseChannels = new Map<Session<any>, MessageChannel<any>>();\n    readonly #caseSessionsPerFabricAndNode: number;\n\n    // TODO evaluate with controller the effects of limiting the entries just for FabricIndex and not also NodeId\n    constructor(caseSessionsPerFabricAndNode = 3) {\n        this.#caseSessionsPerFabricAndNode = caseSessionsPerFabricAndNode;\n    }\n\n    #getChannelKey(fabric: Fabric, nodeId: NodeId) {\n        return `${fabric.fabricIndex}/${nodeId}`;\n    }\n\n    #findLeastActiveChannel(channels: MessageChannel<any>[]) {\n        let oldest = channels[0];\n        for (const channel of channels) {\n            if (channel.session.timestamp < oldest.session.timestamp) {\n                oldest = channel;\n            }\n        }\n        return oldest;\n    }\n\n    async setChannel(fabric: Fabric, nodeId: NodeId, channel: MessageChannel<any>) {\n        channel.closeCallback = async () => this.removeChannel(fabric, nodeId, channel.session);\n        const channelsKey = this.#getChannelKey(fabric, nodeId);\n        const currentChannels = this.#channels.get(channelsKey) ?? [];\n        if (currentChannels.length >= this.#caseSessionsPerFabricAndNode) {\n            const oldestChannel = this.#findLeastActiveChannel(currentChannels);\n            currentChannels.splice(currentChannels.indexOf(oldestChannel), 1);\n            currentChannels.push(channel);\n            this.#channels.set(channelsKey, currentChannels);\n\n            // Should always be the case\n            const { session } = oldestChannel;\n            if (session.id !== oldestChannel.session.id) {\n                logger.debug(\n                    `Existing channel for fabricIndex ${fabric.fabricIndex} and node ${nodeId} with session ${session.name} gets replaced. Consider former session already inactive and so close it.`,\n                );\n                await session.destroy(false, false);\n            }\n            logger.info(`Close oldest channel for fabric ${fabric.fabricIndex} node ${nodeId}`);\n            await oldestChannel.close();\n        } else {\n            currentChannels.push(channel);\n            this.#channels.set(channelsKey, currentChannels);\n        }\n    }\n\n    getChannel(fabric: Fabric, nodeId: NodeId, session?: Session<any>) {\n        let results = this.#channels.get(this.#getChannelKey(fabric, nodeId)) ?? [];\n        if (session !== undefined) {\n            results = results.filter(channel => channel.session.id === session.id);\n        }\n        if (results.length === 0) throw new NoChannelError(`Can't find a channel to node ${nodeId}`);\n        return results[results.length - 1]; // Return the latest added channel (or the one belonging to the session requested)\n    }\n\n    /**\n     * Returns the last established session for a Fabric and Node\n     */\n    getChannelForSession(session: Session<any>) {\n        if (session.isSecure && !session.isPase) {\n            const secureSession = session as SecureSession<any>;\n            const fabric = secureSession.fabric;\n            const nodeId = secureSession.peerNodeId;\n            if (fabric === undefined) {\n                return this.#paseChannels.get(session);\n            }\n            return this.getChannel(fabric, nodeId, session);\n        }\n        return this.#paseChannels.get(session);\n    }\n\n    async removeAllNodeChannels(fabric: Fabric, nodeId: NodeId) {\n        const channelsKey = this.#getChannelKey(fabric, nodeId);\n        const channelsToRemove = this.#channels.get(channelsKey) ?? [];\n        for (const channel of channelsToRemove) {\n            await channel.close();\n        }\n    }\n\n    async removeChannel(fabric: Fabric, nodeId: NodeId, session: Session<any>) {\n        const channelsKey = this.#getChannelKey(fabric, nodeId);\n        const fabricChannels = this.#channels.get(channelsKey) ?? [];\n        const channelEntryIndex = fabricChannels.findIndex(\n            ({ session: entrySession }) => entrySession.id === session.id,\n        );\n        const channelEntry = fabricChannels.splice(channelEntryIndex, 1)[0];\n        if (channelEntry === undefined) {\n            return;\n        }\n        await channelEntry.close();\n        this.#channels.set(channelsKey, fabricChannels);\n    }\n\n    private getOrCreateAsPaseChannel(byteArrayChannel: Channel<ByteArray>, session: Session<any>) {\n        const msgChannel = new MessageChannel(\n            byteArrayChannel,\n            session,\n            async () => void this.#paseChannels.delete(session),\n        );\n        this.#paseChannels.set(session, msgChannel);\n        return msgChannel;\n    }\n\n    async getOrCreateChannel(byteArrayChannel: Channel<ByteArray>, session: Session<any>) {\n        if (!session.isSecure) {\n            return this.getOrCreateAsPaseChannel(byteArrayChannel, session);\n        }\n        const secureSession = session as SecureSession<any>;\n        const fabric = secureSession.fabric;\n        const nodeId = secureSession.peerNodeId;\n        if (fabric === undefined) {\n            return this.getOrCreateAsPaseChannel(byteArrayChannel, session);\n        }\n\n        // Try to get\n        try {\n            return this.getChannel(fabric, nodeId, session);\n        } catch (e) {\n            NoChannelError.accept(e);\n        }\n\n        // Need to create\n        const result = new MessageChannel(byteArrayChannel, session, async () =>\n            this.removeChannel(fabric, nodeId, session),\n        );\n        await this.setChannel(fabric, nodeId, result);\n        return result;\n    }\n\n    async close() {\n        for (const channel of this.#paseChannels.values()) {\n            await channel.close();\n        }\n        this.#paseChannels.clear();\n        for (const channels of this.#channels.values()) {\n            for (const channel of channels) {\n                await channel.close();\n            }\n        }\n        this.#channels.clear();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
