/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MessageCodec, SessionType } from "../codec/MessageCodec.js";
import { ImplementationError, MatterError, MatterFlowError, NotImplementedError } from "../common/MatterError.js";
import { Crypto } from "../crypto/Crypto.js";
import { NodeId } from "../datatype/NodeId.js";
import { Logger } from "../log/Logger.js";
import { UdpInterface } from "../net/UdpInterface.js";
import { INTERACTION_PROTOCOL_ID } from "../protocol/interaction/InteractionServer.js";
import { UNICAST_UNSECURE_SESSION_ID } from "../session/SessionManager.js";
import { ByteArray } from "../util/ByteArray.js";
import { MessageExchange } from "./MessageExchange.js";
import { DuplicateMessageError } from "./MessageReceptionState.js";
import { MessageType, SECURE_CHANNEL_PROTOCOL_ID } from "./securechannel/SecureChannelMessages.js";
import { SecureChannelMessenger } from "./securechannel/SecureChannelMessenger.js";
const logger = Logger.get("ExchangeManager");
class ChannelNotConnectedError extends MatterError {
}
class MessageChannel {
  constructor(channel, session, closeCallback) {
    this.channel = channel;
    this.session = session;
    this.#closeCallback = closeCallback;
  }
  closed = false;
  #closeCallback;
  set closeCallback(callback) {
    this.#closeCallback = callback;
  }
  /** Is the underlying transport reliable? */
  get isReliable() {
    return this.channel.isReliable;
  }
  get type() {
    return this.channel.type;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel. The full encoded matter
   * message payload sent here can be as huge as allowed by the channel.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize;
  }
  send(message) {
    logger.debug("Message \xBB", MessageCodec.messageDiagnostics(message));
    const packet = this.session.encode(message);
    const bytes = MessageCodec.encodePacket(packet);
    if (bytes.length > this.maxPayloadSize) {
      logger.warn(
        `Matter message to send to ${this.name} is ${bytes.length}bytes long, which is larger than the maximum allowed size of ${this.maxPayloadSize}. This only works if both nodes support it.`
      );
    }
    return this.channel.send(bytes);
  }
  get name() {
    return `${this.channel.name} on session ${this.session.name}`;
  }
  async close() {
    const wasAlreadyClosed = this.closed;
    this.closed = true;
    await this.channel.close();
    if (!wasAlreadyClosed) {
      await this.#closeCallback?.();
    }
  }
}
class ExchangeManager {
  constructor(sessionManager, channelManager) {
    this.sessionManager = sessionManager;
    this.channelManager = channelManager;
  }
  exchangeCounter = new ExchangeCounter();
  exchanges = /* @__PURE__ */ new Map();
  protocols = /* @__PURE__ */ new Map();
  transportListeners = new Array();
  closingSessions = /* @__PURE__ */ new Set();
  addTransportInterface(netInterface) {
    const udpInterface = netInterface instanceof UdpInterface;
    this.transportListeners.push(
      netInterface.onData((socket, data) => {
        if (udpInterface && data.length > socket.maxPayloadSize) {
          logger.warn(
            `Ignoring UDP message with size ${data.length} from ${socket.name}, which is larger than the maximum allowed size of ${socket.maxPayloadSize}.`
          );
          return;
        }
        try {
          this.onMessage(socket, data).catch((error) => logger.error(error));
        } catch (error) {
          logger.warn("Ignoring UDP message with error", error);
        }
      })
    );
  }
  hasProtocolHandler(protocolId) {
    return this.protocols.has(protocolId);
  }
  getProtocolHandler(protocolId) {
    return this.protocols.get(protocolId);
  }
  addProtocolHandler(protocol) {
    if (this.hasProtocolHandler(protocol.getId())) {
      throw new ImplementationError(`Handler for protocol ${protocol.getId()} already registered.`);
    }
    this.protocols.set(protocol.getId(), protocol);
  }
  initiateExchange(fabric, nodeId, protocolId) {
    return this.initiateExchangeWithChannel(this.channelManager.getChannel(fabric, nodeId), protocolId);
  }
  initiateExchangeWithChannel(channel, protocolId) {
    const exchangeId = this.exchangeCounter.getIncrementedCounter();
    const exchangeIndex = exchangeId | 65536;
    const exchange = MessageExchange.initiate(channel, exchangeId, protocolId);
    this.#addExchange(exchangeIndex, exchange);
    return exchange;
  }
  async close() {
    for (const protocol of this.protocols.values()) {
      await protocol.close();
    }
    for (const netListener of this.transportListeners) {
      await netListener.close();
    }
    this.transportListeners.length = 0;
    for (const exchange of this.exchanges.values()) {
      await exchange.destroy();
    }
    this.exchanges.clear();
  }
  async onMessage(channel, messageBytes) {
    const packet = MessageCodec.decodePacket(messageBytes);
    if (packet.header.sessionType === SessionType.Group)
      throw new NotImplementedError("Group messages are not supported");
    let session;
    if (packet.header.sessionType === SessionType.Unicast) {
      if (packet.header.sessionId === UNICAST_UNSECURE_SESSION_ID) {
        const initiatorNodeId = packet.header.sourceNodeId ?? NodeId.UNSPECIFIED_NODE_ID;
        session = this.sessionManager.getUnsecureSession(initiatorNodeId) ?? this.sessionManager.createUnsecureSession({
          initiatorNodeId
        });
      } else {
        session = this.sessionManager.getSession(packet.header.sessionId);
      }
    } else if (packet.header.sessionType === SessionType.Group) {
      if (packet.header.sourceNodeId !== void 0) {
      }
    }
    if (session === void 0) {
      throw new MatterFlowError(
        `Cannot find a session for ID ${packet.header.sessionId}${packet.header.sourceNodeId !== void 0 ? ` and source NodeId ${packet.header.sourceNodeId}` : ""}`
      );
    }
    const messageId = packet.header.messageId;
    let isDuplicate;
    try {
      session?.updateMessageCounter(packet.header.messageId, packet.header.sourceNodeId);
      isDuplicate = false;
    } catch (e) {
      DuplicateMessageError.accept(e);
      isDuplicate = true;
    }
    const aad = messageBytes.slice(0, messageBytes.length - packet.applicationPayload.length);
    const message = session.decode(packet, aad);
    const exchangeIndex = message.payloadHeader.isInitiatorMessage ? message.payloadHeader.exchangeId : message.payloadHeader.exchangeId | 65536;
    let exchange = this.exchanges.get(exchangeIndex);
    if (exchange !== void 0 && (exchange.session.id !== session.id || exchange.isInitiator === message.payloadHeader.isInitiatorMessage)) {
      exchange = void 0;
    }
    if (exchange !== void 0) {
      await exchange.onMessageReceived(message, isDuplicate);
    } else {
      if (session.closingAfterExchangeFinished) {
        throw new MatterFlowError(
          `Session with ID ${packet.header.sessionId} marked for closure, decline new exchange creation.`
        );
      }
      const protocolHandler = this.protocols.get(message.payloadHeader.protocolId);
      if (protocolHandler !== void 0 && message.payloadHeader.isInitiatorMessage && !isDuplicate) {
        const exchange2 = MessageExchange.fromInitialMessage(
          await this.channelManager.getOrCreateChannel(channel, session),
          message
        );
        this.#addExchange(exchangeIndex, exchange2);
        await exchange2.onMessageReceived(message);
        await protocolHandler.onNewExchange(exchange2, message);
      } else if (message.payloadHeader.requiresAck) {
        const exchange2 = MessageExchange.fromInitialMessage(
          await this.channelManager.getOrCreateChannel(channel, session),
          message
        );
        this.#addExchange(exchangeIndex, exchange2);
        await exchange2.send(MessageType.StandaloneAck, new ByteArray(0), {
          includeAcknowledgeMessageId: message.packetHeader.messageId
        });
        await exchange2.close();
        logger.debug(
          `Ignoring unsolicited message ${messageId} for protocol ${message.payloadHeader.protocolId}.`
        );
      } else {
        if (protocolHandler === void 0) {
          throw new MatterFlowError(`Unsupported protocol ${message.payloadHeader.protocolId}`);
        }
        if (isDuplicate) {
          logger.info(
            `Ignoring duplicate message ${messageId} (requires no ack) for protocol ${message.payloadHeader.protocolId}.`
          );
          return;
        } else {
          logger.info(
            `Discarding unexpected message ${messageId} for protocol ${message.payloadHeader.protocolId}, exchangeIndex ${exchangeIndex} and sessionId ${session.id} : ${Logger.toJSON(message)}`
          );
        }
      }
    }
  }
  async deleteExchange(exchangeIndex) {
    const exchange = this.exchanges.get(exchangeIndex);
    if (exchange === void 0) {
      logger.info(`Exchange with index ${exchangeIndex} to delete not found or already deleted.`);
      return;
    }
    const { session } = exchange;
    if (session.isSecure && session.closingAfterExchangeFinished) {
      logger.debug(
        `Exchange index ${exchangeIndex} Session ${session.name} is already marked for closure. Close session now.`
      );
      try {
        await this.closeSession(session);
      } catch (error) {
        logger.error(`Error closing session ${session.name}. Ignoring.`, error);
      }
    }
    this.exchanges.delete(exchangeIndex);
  }
  async closeSession(session) {
    const sessionId = session.id;
    const sessionName = session.name;
    if (this.sessionManager.getSession(sessionId) === void 0) {
      return;
    }
    if (this.closingSessions.has(sessionId)) {
      return;
    }
    this.closingSessions.add(sessionId);
    for (const [_exchangeIndex, exchange] of this.exchanges.entries()) {
      if (exchange.session.id === sessionId) {
        await exchange.destroy();
      }
    }
    if (session.sendCloseMessageWhenClosing) {
      const channel = this.channelManager.getChannelForSession(session);
      logger.debug(`Channel for session ${session.name} is ${channel?.name}`);
      if (channel !== void 0) {
        const exchange = this.initiateExchangeWithChannel(channel, SECURE_CHANNEL_PROTOCOL_ID);
        logger.debug(`Initiated exchange ${!!exchange} to close session ${sessionName}`);
        if (exchange !== void 0) {
          try {
            const messenger = new SecureChannelMessenger(exchange);
            await messenger.sendCloseSession();
            await messenger.close();
          } catch (error) {
            if (error instanceof ChannelNotConnectedError) {
              logger.debug("Session already closed because channel is disconnected.");
            } else {
              logger.error("Error closing session", error);
            }
          }
        }
        await exchange.destroy();
      }
    }
    if (session.closingAfterExchangeFinished) {
      await session.destroy(false, false);
    }
    this.sessionManager.removeSession(sessionId);
    this.closingSessions.delete(sessionId);
  }
  #addExchange(exchangeIndex, exchange) {
    exchange.closed.on(() => this.deleteExchange(exchangeIndex));
    this.exchanges.set(exchangeIndex, exchange);
  }
}
class ExchangeCounter {
  exchangeCounter = Crypto.getRandomUInt16();
  getIncrementedCounter() {
    this.exchangeCounter++;
    if (this.exchangeCounter > 65535) {
      this.exchangeCounter = 0;
    }
    return this.exchangeCounter;
  }
}
class ExchangeProvider {
  constructor(exchangeManager, channel, reconnectChannelFunc) {
    this.exchangeManager = exchangeManager;
    this.channel = channel;
    this.reconnectChannelFunc = reconnectChannelFunc;
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  getProtocolHandler(protocolId) {
    return this.exchangeManager.getProtocolHandler(protocolId);
  }
  addProtocolHandler(handler) {
    this.exchangeManager.addProtocolHandler(handler);
  }
  initiateExchange() {
    return this.exchangeManager.initiateExchangeWithChannel(this.channel, INTERACTION_PROTOCOL_ID);
  }
  async reconnectChannel() {
    if (this.reconnectChannelFunc === void 0) return false;
    this.channel = await this.reconnectChannelFunc();
    return true;
  }
  get session() {
    return this.channel.session;
  }
  get channelType() {
    return this.channel.type;
  }
}
export {
  ChannelNotConnectedError,
  ExchangeCounter,
  ExchangeManager,
  ExchangeProvider,
  MessageChannel
};
//# sourceMappingURL=ExchangeManager.js.map
