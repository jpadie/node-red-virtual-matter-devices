{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/InteractionEndpointStructure.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AnyAttributeServer } from \"../../cluster/server/AttributeServer.js\";\nimport { ClusterServer } from \"../../cluster/server/ClusterServer.js\";\nimport { CommandServer } from \"../../cluster/server/CommandServer.js\";\nimport { AnyEventServer } from \"../../cluster/server/EventServer.js\";\nimport { ImplementationError, InternalError } from \"../../common/MatterError.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { Mei } from \"../../datatype/ManufacturerExtensibleIdentifier.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { AttributeModel, ClusterModel, MatterModel } from \"../../model/index.js\";\nimport { AttributeList } from \"../../model/standard/elements/AttributeList.js\";\nimport { EventList } from \"../../model/standard/elements/EventList.js\";\nimport { AcceptedCommandList, GeneratedCommandList } from \"../../model/standard/elements/index.js\";\nimport { TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { Observable } from \"../../util/Observable.js\";\nimport { TlvAttributePath, TlvCommandPath, TlvEventPath, WildcardPathFlagsBitmap } from \"./InteractionProtocol.js\";\nimport {\n    AttributePath,\n    AttributeWithPath,\n    CommandPath,\n    CommandWithPath,\n    EventPath,\n    EventWithPath,\n    attributePathToId,\n    commandPathToId,\n    eventPathToId,\n    genericElementPathToId,\n} from \"./InteractionServer.js\";\nimport { StatusCode, StatusResponseError } from \"./StatusCode.js\";\n\n/**\n * List of global attributes to skip when the WildcardSkipGlobalAttributes bit is set in an Wildcard Path Flags\n * @see {@link MatterSpecification.v13.Core} \u00A78.2.1.7\n */\nconst GLOBAL_COMMANDLIST_IDS = [GeneratedCommandList.id, AcceptedCommandList.id];\nconst GLOBAL_ATTRIBUTES_LIST = [...GLOBAL_COMMANDLIST_IDS, EventList.id, AttributeList.id];\n\n// Build a list of cluster IDs that are used for diagnostics to not always filter through model\n// TODO Find a way to also incorporate custom clusters here\nconst DIAGNOSTICS_CLUSTER_IDS = MatterModel.standard.clusters\n    .filter(cluster => cluster.diagnostics && cluster.id !== undefined)\n    .map(cluster => cluster.id as ClusterId);\n\nexport class InteractionEndpointStructure {\n    endpoints = new Map<EndpointNumber, EndpointInterface>();\n    attributes = new Map<string, AnyAttributeServer<any>>();\n    attributePaths = new Array<AttributePath>();\n    events = new Map<string, AnyEventServer<any, any>>();\n    eventPaths = new Array<EventPath>();\n    commands = new Map<string, CommandServer<any, any>>();\n    commandPaths = new Array<CommandPath>();\n    change = Observable(); // TODO adjust to AsyncObservable when we remove legacy API\n\n    public clear() {\n        this.endpoints.clear();\n        this.attributes.clear();\n        this.attributePaths.length = 0;\n        this.events.clear();\n        this.eventPaths.length = 0;\n        this.commands.clear();\n        this.commandPaths.length = 0;\n    }\n\n    public close() {\n        for (const endpoint of this.endpoints.values()) {\n            endpoint.close();\n        }\n    }\n\n    public initializeFromEndpoint(endpoint: EndpointInterface) {\n        this.clear();\n\n        this.verifyAndInitializeStructureElementsFromEndpoint(endpoint); // Initialize Data from Root Endpoint\n        this.initializeStructureFromEndpoints(endpoint); // Initialize Data from Child Endpoints\n\n        this.change.emit();\n    }\n\n    private initializeStructureFromEndpoints(endpoint: EndpointInterface) {\n        const endpoints = endpoint.getChildEndpoints();\n        for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {\n            this.verifyAndInitializeStructureElementsFromEndpoint(endpoints[endpointIndex]);\n            this.initializeStructureFromEndpoints(endpoints[endpointIndex]);\n        }\n    }\n\n    private verifyAndInitializeStructureElementsFromEndpoint(endpoint: EndpointInterface) {\n        if (endpoint.number === undefined) {\n            throw new InternalError(`Endpoint ID is undefined. It needs to be initialized first!`);\n        }\n\n        endpoint.verifyRequiredClusters();\n\n        for (const cluster of endpoint.getAllClusterServers()) {\n            const {\n                id: clusterId,\n                attributes: clusterAttributes,\n                events: clusterEvents,\n                commands: clusterCommands,\n            } = cluster;\n\n            // Add attributes\n            for (const name in clusterAttributes) {\n                const attribute = clusterAttributes[name];\n                const path = { endpointId: endpoint.number, clusterId, attributeId: attribute.id };\n                this.attributes.set(attributePathToId(path), attribute);\n                this.attributePaths.push(path);\n            }\n\n            // Add events\n            for (const name in clusterEvents) {\n                const event = clusterEvents[name];\n                const path = { endpointId: endpoint.number, clusterId, eventId: event.id };\n                this.events.set(eventPathToId(path), event);\n                this.eventPaths.push(path);\n            }\n\n            // Add commands\n            for (const name in clusterCommands) {\n                const command = clusterCommands[name];\n                const path = { endpointId: endpoint.number, clusterId, commandId: command.invokeId };\n                this.commands.set(commandPathToId(path), command);\n                this.commandPaths.push(path);\n            }\n        }\n\n        if (this.endpoints.has(endpoint.number))\n            throw new ImplementationError(`Endpoint ID ${endpoint.number} exists twice`);\n\n        this.endpoints.set(endpoint.number, endpoint);\n    }\n\n    toHex(value: number | bigint | undefined) {\n        return value === undefined ? \"*\" : `0x${value.toString(16)}`;\n    }\n\n    resolveGenericElementName(\n        nodeId: NodeId | undefined,\n        endpointId: EndpointNumber | undefined,\n        clusterId: ClusterId | undefined,\n        elementId: number | undefined,\n        elementMap: Map<string, any>,\n    ) {\n        const nodeIdPrefix = nodeId === undefined ? \"\" : `${this.toHex(nodeId)}/`;\n        if (endpointId === undefined) {\n            return `${nodeIdPrefix}*/${this.toHex(clusterId)}/${this.toHex(elementId)}`;\n        }\n        const endpoint = this.endpoints.get(endpointId);\n        if (endpoint === undefined) {\n            return `${nodeIdPrefix}unknown(${this.toHex(endpointId)})/${this.toHex(clusterId)}/${this.toHex(\n                elementId,\n            )}`;\n        }\n        const endpointName = `${endpoint.name}(${this.toHex(endpointId)})`;\n\n        if (clusterId === undefined) {\n            return `${nodeIdPrefix}${endpointName}/*/${this.toHex(elementId)}`;\n        }\n        const cluster = endpoint.getClusterServerById(clusterId);\n        if (cluster === undefined) {\n            return `${nodeIdPrefix}${endpointName}/unknown(${this.toHex(clusterId)})/${this.toHex(elementId)}`;\n        }\n        const clusterName = `${cluster.name}(${this.toHex(clusterId)})`;\n\n        if (elementId === undefined) {\n            return `${nodeIdPrefix}${endpointName}/${clusterName}/*`;\n        }\n        const element = elementMap.get(genericElementPathToId(endpointId, clusterId, elementId));\n        const elementName = `${element?.name ?? \"unknown\"}(${this.toHex(elementId)})`;\n        return `${nodeIdPrefix}${endpointName}/${clusterName}/${elementName}`;\n    }\n\n    resolveAttributeName({ nodeId, endpointId, clusterId, attributeId }: TypeFromSchema<typeof TlvAttributePath>) {\n        return this.resolveGenericElementName(nodeId, endpointId, clusterId, attributeId, this.attributes);\n    }\n\n    resolveEventName({ nodeId, endpointId, clusterId, eventId, isUrgent }: TypeFromSchema<typeof TlvEventPath>) {\n        return `${isUrgent ? \"!\" : \"\"}${this.resolveGenericElementName(\n            nodeId,\n            endpointId,\n            clusterId,\n            eventId,\n            this.events,\n        )}`;\n    }\n\n    resolveCommandName({ endpointId, clusterId, commandId }: TypeFromSchema<typeof TlvCommandPath>) {\n        return this.resolveGenericElementName(undefined, endpointId, clusterId, commandId, this.commands);\n    }\n\n    getEndpoint(endpointId: EndpointNumber): EndpointInterface | undefined {\n        return this.endpoints.get(endpointId);\n    }\n\n    hasEndpoint(endpointId: EndpointNumber): boolean {\n        return this.endpoints.has(endpointId);\n    }\n\n    getClusterServer(endpointId: EndpointNumber, clusterId: ClusterId): ClusterServer | undefined {\n        return this.endpoints.get(endpointId)?.getClusterServerById(clusterId);\n    }\n\n    hasClusterServer(endpointId: EndpointNumber, clusterId: ClusterId): boolean {\n        return !!this.getClusterServer(endpointId, clusterId);\n    }\n\n    getAttribute(\n        endpointId: EndpointNumber,\n        clusterId: ClusterId,\n        attributeId: AttributeId,\n    ): AnyAttributeServer<any> | undefined {\n        return this.attributes.get(attributePathToId({ endpointId, clusterId, attributeId }));\n    }\n\n    hasAttribute(endpointId: EndpointNumber, clusterId: ClusterId, attributeId: AttributeId): boolean {\n        return !!this.getAttribute(endpointId, clusterId, attributeId);\n    }\n\n    validateConcreteAttributePath(endpointId: EndpointNumber, clusterId: ClusterId, attributeId: AttributeId) {\n        if (!this.hasEndpoint(endpointId)) {\n            throw new StatusResponseError(`Endpoint ${endpointId} does not exist.`, StatusCode.UnsupportedEndpoint);\n        }\n        if (!this.hasClusterServer(endpointId, clusterId)) {\n            throw new StatusResponseError(`Cluster ${clusterId} does not exist.`, StatusCode.UnsupportedCluster);\n        }\n        if (this.hasAttribute(endpointId, clusterId, attributeId)) return true;\n        throw new StatusResponseError(`Attribute ${attributeId} does not exist`, StatusCode.UnsupportedAttribute);\n    }\n\n    getEvent(endpointId: EndpointNumber, clusterId: ClusterId, eventId: EventId): AnyEventServer<any, any> | undefined {\n        return this.events.get(eventPathToId({ endpointId, clusterId, eventId }));\n    }\n\n    hasEvent(endpointId: EndpointNumber, clusterId: ClusterId, eventId: EventId): boolean {\n        return !!this.getEvent(endpointId, clusterId, eventId);\n    }\n\n    validateConcreteEventPath(endpointId: EndpointNumber, clusterId: ClusterId, eventId: EventId) {\n        if (!this.hasEndpoint(endpointId)) {\n            throw new StatusResponseError(`Endpoint ${endpointId} does not exist.`, StatusCode.UnsupportedEndpoint);\n        }\n        if (!this.hasClusterServer(endpointId, clusterId)) {\n            throw new StatusResponseError(`Cluster ${clusterId} does not exist.`, StatusCode.UnsupportedCluster);\n        }\n        if (this.hasEvent(endpointId, clusterId, eventId)) return true;\n        throw new StatusResponseError(`Event ${eventId} does not exist`, StatusCode.UnsupportedEvent);\n    }\n\n    getCommand(\n        endpointId: EndpointNumber,\n        clusterId: ClusterId,\n        commandId: CommandId,\n    ): CommandServer<any, any> | undefined {\n        return this.commands.get(commandPathToId({ endpointId, clusterId, commandId }));\n    }\n\n    hasCommand(endpointId: EndpointNumber, clusterId: ClusterId, commandId: CommandId): boolean {\n        return !!this.getCommand(endpointId, clusterId, commandId);\n    }\n\n    validateConcreteCommandPath(endpointId: EndpointNumber, clusterId: ClusterId, commandId: CommandId) {\n        if (!this.hasEndpoint(endpointId)) {\n            throw new StatusResponseError(`Endpoint ${endpointId} does not exist.`, StatusCode.UnsupportedEndpoint);\n        }\n        if (!this.hasClusterServer(endpointId, clusterId)) {\n            throw new StatusResponseError(`Cluster ${clusterId} does not exist.`, StatusCode.UnsupportedCluster);\n        }\n        if (this.hasCommand(endpointId, clusterId, commandId)) return true;\n        throw new StatusResponseError(`Command ${commandId} does not exist`, StatusCode.UnsupportedCommand);\n    }\n\n    /** Checks if the given attribute matches the wildcard path flags */\n    attributePathMatchesWildcardPathFlags(\n        { endpointId, clusterId, attributeId }: AttributePath,\n        wildcardPathFlags?: TypeFromPartialBitSchema<typeof WildcardPathFlagsBitmap>,\n    ) {\n        if (wildcardPathFlags === undefined) return false;\n        if (wildcardPathFlags.skipRootNode && endpointId === 0) {\n            return true;\n        }\n\n        // Only check if the attribute ID is a global attribute ID\n        if (attributeId >= 0xfff8 && attributeId <= 0xfffb) {\n            if (wildcardPathFlags.skipGlobalAttributes && GLOBAL_ATTRIBUTES_LIST.includes(attributeId)) {\n                return true;\n            }\n            if (wildcardPathFlags.skipAttributeList && attributeId === AttributeList.id) {\n                return true;\n            }\n            if (wildcardPathFlags.skipEventList && attributeId === EventList.id) {\n                return true;\n            }\n            if (wildcardPathFlags.skipCommandLists && GLOBAL_COMMANDLIST_IDS.includes(attributeId)) {\n                return true;\n            }\n        }\n\n        if (\n            wildcardPathFlags.skipCustomElements &&\n            (Mei.hasCustomMeiPrefix(clusterId) || Mei.hasCustomMeiPrefix(attributeId))\n        ) {\n            return true;\n        }\n\n        const cluster = MatterModel.standard.get(ClusterModel, clusterId);\n        if (cluster !== undefined) {\n            const attribute = cluster.get(AttributeModel, attributeId);\n            if (attribute !== undefined) {\n                if (wildcardPathFlags.skipFixedAttributes && attribute.fixed) {\n                    return true;\n                }\n                if (wildcardPathFlags.skipChangesOmittedAttributes && attribute.changesOmitted) {\n                    return true;\n                }\n            }\n            if (wildcardPathFlags.skipDiagnosticsClusters && DIAGNOSTICS_CLUSTER_IDS.includes(clusterId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    getAttributes(filters: TypeFromSchema<typeof TlvAttributePath>[], onlyWritable = false): AttributeWithPath[] {\n        const result = new Array<AttributeWithPath>();\n\n        filters.forEach(({ endpointId, clusterId, attributeId, wildcardPathFlags }) => {\n            this.validateAnyPathDataTypes({ endpointId, clusterId, attributeId });\n            if (endpointId !== undefined && clusterId !== undefined && attributeId !== undefined) {\n                const path = { endpointId, clusterId, attributeId };\n                const attribute = this.attributes.get(attributePathToId(path));\n                if (attribute === undefined) return;\n                if (onlyWritable && !attribute.isWritable) return;\n                if (this.attributePathMatchesWildcardPathFlags(path)) return;\n                result.push({ path, attribute });\n            } else {\n                this.attributePaths\n                    .filter(\n                        path =>\n                            (endpointId === undefined || endpointId === path.endpointId) &&\n                            (clusterId === undefined || clusterId === path.clusterId) &&\n                            (attributeId === undefined || attributeId === path.attributeId),\n                    )\n                    .forEach(path => {\n                        const attribute = this.attributes.get(attributePathToId(path));\n                        if (attribute === undefined) return;\n                        if (onlyWritable && !attribute.isWritable) return;\n                        if (this.attributePathMatchesWildcardPathFlags(path, wildcardPathFlags)) return;\n                        result.push({ path, attribute });\n                    });\n            }\n        });\n\n        return result;\n    }\n\n    getEvents(filters: TypeFromSchema<typeof TlvEventPath>[]): EventWithPath[] {\n        const result = new Array<EventWithPath>();\n\n        filters.forEach(({ endpointId, clusterId, eventId, isUrgent }) => {\n            this.validateAnyPathDataTypes({ endpointId, clusterId, eventId });\n            if (endpointId !== undefined && clusterId !== undefined && eventId !== undefined) {\n                const path = { endpointId, clusterId, eventId, isUrgent };\n                const event = this.events.get(eventPathToId(path));\n                if (event === undefined) return;\n                result.push({ path, event });\n            } else {\n                this.eventPaths\n                    .filter(\n                        path =>\n                            (endpointId === undefined || endpointId === path.endpointId) &&\n                            (clusterId === undefined || clusterId === path.clusterId) &&\n                            (eventId === undefined || eventId === path.eventId),\n                    )\n                    .forEach(({ endpointId, clusterId, eventId }) => {\n                        const path = { endpointId, clusterId, eventId, isUrgent };\n                        const event = this.events.get(eventPathToId(path));\n                        if (event === undefined) return;\n                        result.push({ path, event });\n                    });\n            }\n        });\n\n        return result;\n    }\n\n    getCommands(filters: TypeFromSchema<typeof TlvCommandPath>[]): CommandWithPath[] {\n        const result = new Array<CommandWithPath>();\n\n        filters.forEach(({ endpointId, clusterId, commandId }) => {\n            this.validateAnyPathDataTypes({ endpointId, clusterId, commandId });\n            if (endpointId !== undefined && clusterId !== undefined && commandId !== undefined) {\n                const path = { endpointId, clusterId, commandId };\n                const command = this.commands.get(commandPathToId(path));\n                if (command === undefined) return;\n                result.push({ path, command });\n            } else {\n                this.commandPaths\n                    .filter(\n                        path =>\n                            (endpointId === undefined || endpointId === path.endpointId) &&\n                            (clusterId === undefined || clusterId === path.clusterId) &&\n                            (commandId === undefined || commandId === path.commandId),\n                    )\n                    .forEach(path => {\n                        const command = this.commands.get(commandPathToId(path));\n                        if (command === undefined) return;\n                        result.push({ path, command });\n                    });\n            }\n        });\n\n        return result;\n    }\n\n    // ValidationError will return ConstraintError ... we need to see if this is correct always\n    validateAnyPathDataTypes(data: {\n        endpointId?: EndpointNumber;\n        clusterId?: ClusterId;\n        attributeId?: AttributeId;\n        eventId?: EventId;\n        commandId?: CommandId;\n    }) {\n        const { endpointId, clusterId, attributeId, eventId, commandId } = data;\n\n        if (endpointId !== undefined) {\n            EndpointNumber(endpointId);\n        }\n        if (clusterId !== undefined) {\n            ClusterId(clusterId);\n        }\n        if (attributeId !== undefined) {\n            AttributeId(attributeId);\n        }\n        if (eventId !== undefined) {\n            EventId(eventId);\n        }\n        if (commandId !== undefined) {\n            CommandId(commandId);\n        }\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAUA,SAAS,qBAAqB,qBAAqB;AACnD,SAAS,mBAAmB;AAC5B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,sBAAsB;AAC/B,SAAS,eAAe;AACxB,SAAS,WAAW;AAGpB,SAAS,gBAAgB,cAAc,mBAAmB;AAC1D,SAAS,qBAAqB;AAC9B,SAAS,iBAAiB;AAC1B,SAAS,qBAAqB,4BAA4B;AAG1D,SAAS,kBAAkB;AAE3B;AAAA,EAOI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACG;AACP,SAAS,YAAY,2BAA2B;AAMhD,MAAM,yBAAyB,CAAC,qBAAqB,IAAI,oBAAoB,EAAE;AAC/E,MAAM,yBAAyB,CAAC,GAAG,wBAAwB,UAAU,IAAI,cAAc,EAAE;AAIzF,MAAM,0BAA0B,YAAY,SAAS,SAChD,OAAO,aAAW,QAAQ,eAAe,QAAQ,OAAO,MAAS,EACjE,IAAI,aAAW,QAAQ,EAAe;AAEpC,MAAM,6BAA6B;AAAA,EACtC,YAAY,oBAAI,IAAuC;AAAA,EACvD,aAAa,oBAAI,IAAqC;AAAA,EACtD,iBAAiB,IAAI,MAAqB;AAAA,EAC1C,SAAS,oBAAI,IAAsC;AAAA,EACnD,aAAa,IAAI,MAAiB;AAAA,EAClC,WAAW,oBAAI,IAAqC;AAAA,EACpD,eAAe,IAAI,MAAmB;AAAA,EACtC,SAAS,WAAW;AAAA;AAAA,EAEb,QAAQ;AACX,SAAK,UAAU,MAAM;AACrB,SAAK,WAAW,MAAM;AACtB,SAAK,eAAe,SAAS;AAC7B,SAAK,OAAO,MAAM;AAClB,SAAK,WAAW,SAAS;AACzB,SAAK,SAAS,MAAM;AACpB,SAAK,aAAa,SAAS;AAAA,EAC/B;AAAA,EAEO,QAAQ;AACX,eAAW,YAAY,KAAK,UAAU,OAAO,GAAG;AAC5C,eAAS,MAAM;AAAA,IACnB;AAAA,EACJ;AAAA,EAEO,uBAAuB,UAA6B;AACvD,SAAK,MAAM;AAEX,SAAK,iDAAiD,QAAQ;AAC9D,SAAK,iCAAiC,QAAQ;AAE9C,SAAK,OAAO,KAAK;AAAA,EACrB;AAAA,EAEQ,iCAAiC,UAA6B;AAClE,UAAM,YAAY,SAAS,kBAAkB;AAC7C,aAAS,gBAAgB,GAAG,gBAAgB,UAAU,QAAQ,iBAAiB;AAC3E,WAAK,iDAAiD,UAAU,aAAa,CAAC;AAC9E,WAAK,iCAAiC,UAAU,aAAa,CAAC;AAAA,IAClE;AAAA,EACJ;AAAA,EAEQ,iDAAiD,UAA6B;AAClF,QAAI,SAAS,WAAW,QAAW;AAC/B,YAAM,IAAI,cAAc,6DAA6D;AAAA,IACzF;AAEA,aAAS,uBAAuB;AAEhC,eAAW,WAAW,SAAS,qBAAqB,GAAG;AACnD,YAAM;AAAA,QACF,IAAI;AAAA,QACJ,YAAY;AAAA,QACZ,QAAQ;AAAA,QACR,UAAU;AAAA,MACd,IAAI;AAGJ,iBAAW,QAAQ,mBAAmB;AAClC,cAAM,YAAY,kBAAkB,IAAI;AACxC,cAAM,OAAO,EAAE,YAAY,SAAS,QAAQ,WAAW,aAAa,UAAU,GAAG;AACjF,aAAK,WAAW,IAAI,kBAAkB,IAAI,GAAG,SAAS;AACtD,aAAK,eAAe,KAAK,IAAI;AAAA,MACjC;AAGA,iBAAW,QAAQ,eAAe;AAC9B,cAAM,QAAQ,cAAc,IAAI;AAChC,cAAM,OAAO,EAAE,YAAY,SAAS,QAAQ,WAAW,SAAS,MAAM,GAAG;AACzE,aAAK,OAAO,IAAI,cAAc,IAAI,GAAG,KAAK;AAC1C,aAAK,WAAW,KAAK,IAAI;AAAA,MAC7B;AAGA,iBAAW,QAAQ,iBAAiB;AAChC,cAAM,UAAU,gBAAgB,IAAI;AACpC,cAAM,OAAO,EAAE,YAAY,SAAS,QAAQ,WAAW,WAAW,QAAQ,SAAS;AACnF,aAAK,SAAS,IAAI,gBAAgB,IAAI,GAAG,OAAO;AAChD,aAAK,aAAa,KAAK,IAAI;AAAA,MAC/B;AAAA,IACJ;AAEA,QAAI,KAAK,UAAU,IAAI,SAAS,MAAM;AAClC,YAAM,IAAI,oBAAoB,eAAe,SAAS,MAAM,eAAe;AAE/E,SAAK,UAAU,IAAI,SAAS,QAAQ,QAAQ;AAAA,EAChD;AAAA,EAEA,MAAM,OAAoC;AACtC,WAAO,UAAU,SAAY,MAAM,KAAK,MAAM,SAAS,EAAE,CAAC;AAAA,EAC9D;AAAA,EAEA,0BACI,QACA,YACA,WACA,WACA,YACF;AACE,UAAM,eAAe,WAAW,SAAY,KAAK,GAAG,KAAK,MAAM,MAAM,CAAC;AACtE,QAAI,eAAe,QAAW;AAC1B,aAAO,GAAG,YAAY,KAAK,KAAK,MAAM,SAAS,CAAC,IAAI,KAAK,MAAM,SAAS,CAAC;AAAA,IAC7E;AACA,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU;AAC9C,QAAI,aAAa,QAAW;AACxB,aAAO,GAAG,YAAY,WAAW,KAAK,MAAM,UAAU,CAAC,KAAK,KAAK,MAAM,SAAS,CAAC,IAAI,KAAK;AAAA,QACtF;AAAA,MACJ,CAAC;AAAA,IACL;AACA,UAAM,eAAe,GAAG,SAAS,IAAI,IAAI,KAAK,MAAM,UAAU,CAAC;AAE/D,QAAI,cAAc,QAAW;AACzB,aAAO,GAAG,YAAY,GAAG,YAAY,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA,IACpE;AACA,UAAM,UAAU,SAAS,qBAAqB,SAAS;AACvD,QAAI,YAAY,QAAW;AACvB,aAAO,GAAG,YAAY,GAAG,YAAY,YAAY,KAAK,MAAM,SAAS,CAAC,KAAK,KAAK,MAAM,SAAS,CAAC;AAAA,IACpG;AACA,UAAM,cAAc,GAAG,QAAQ,IAAI,IAAI,KAAK,MAAM,SAAS,CAAC;AAE5D,QAAI,cAAc,QAAW;AACzB,aAAO,GAAG,YAAY,GAAG,YAAY,IAAI,WAAW;AAAA,IACxD;AACA,UAAM,UAAU,WAAW,IAAI,uBAAuB,YAAY,WAAW,SAAS,CAAC;AACvF,UAAM,cAAc,GAAG,SAAS,QAAQ,SAAS,IAAI,KAAK,MAAM,SAAS,CAAC;AAC1E,WAAO,GAAG,YAAY,GAAG,YAAY,IAAI,WAAW,IAAI,WAAW;AAAA,EACvE;AAAA,EAEA,qBAAqB,EAAE,QAAQ,YAAY,WAAW,YAAY,GAA4C;AAC1G,WAAO,KAAK,0BAA0B,QAAQ,YAAY,WAAW,aAAa,KAAK,UAAU;AAAA,EACrG;AAAA,EAEA,iBAAiB,EAAE,QAAQ,YAAY,WAAW,SAAS,SAAS,GAAwC;AACxG,WAAO,GAAG,WAAW,MAAM,EAAE,GAAG,KAAK;AAAA,MACjC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK;AAAA,IACT,CAAC;AAAA,EACL;AAAA,EAEA,mBAAmB,EAAE,YAAY,WAAW,UAAU,GAA0C;AAC5F,WAAO,KAAK,0BAA0B,QAAW,YAAY,WAAW,WAAW,KAAK,QAAQ;AAAA,EACpG;AAAA,EAEA,YAAY,YAA2D;AACnE,WAAO,KAAK,UAAU,IAAI,UAAU;AAAA,EACxC;AAAA,EAEA,YAAY,YAAqC;AAC7C,WAAO,KAAK,UAAU,IAAI,UAAU;AAAA,EACxC;AAAA,EAEA,iBAAiB,YAA4B,WAAiD;AAC1F,WAAO,KAAK,UAAU,IAAI,UAAU,GAAG,qBAAqB,SAAS;AAAA,EACzE;AAAA,EAEA,iBAAiB,YAA4B,WAA+B;AACxE,WAAO,CAAC,CAAC,KAAK,iBAAiB,YAAY,SAAS;AAAA,EACxD;AAAA,EAEA,aACI,YACA,WACA,aACmC;AACnC,WAAO,KAAK,WAAW,IAAI,kBAAkB,EAAE,YAAY,WAAW,YAAY,CAAC,CAAC;AAAA,EACxF;AAAA,EAEA,aAAa,YAA4B,WAAsB,aAAmC;AAC9F,WAAO,CAAC,CAAC,KAAK,aAAa,YAAY,WAAW,WAAW;AAAA,EACjE;AAAA,EAEA,8BAA8B,YAA4B,WAAsB,aAA0B;AACtG,QAAI,CAAC,KAAK,YAAY,UAAU,GAAG;AAC/B,YAAM,IAAI,oBAAoB,YAAY,UAAU,oBAAoB,WAAW,mBAAmB;AAAA,IAC1G;AACA,QAAI,CAAC,KAAK,iBAAiB,YAAY,SAAS,GAAG;AAC/C,YAAM,IAAI,oBAAoB,WAAW,SAAS,oBAAoB,WAAW,kBAAkB;AAAA,IACvG;AACA,QAAI,KAAK,aAAa,YAAY,WAAW,WAAW,EAAG,QAAO;AAClE,UAAM,IAAI,oBAAoB,aAAa,WAAW,mBAAmB,WAAW,oBAAoB;AAAA,EAC5G;AAAA,EAEA,SAAS,YAA4B,WAAsB,SAAwD;AAC/G,WAAO,KAAK,OAAO,IAAI,cAAc,EAAE,YAAY,WAAW,QAAQ,CAAC,CAAC;AAAA,EAC5E;AAAA,EAEA,SAAS,YAA4B,WAAsB,SAA2B;AAClF,WAAO,CAAC,CAAC,KAAK,SAAS,YAAY,WAAW,OAAO;AAAA,EACzD;AAAA,EAEA,0BAA0B,YAA4B,WAAsB,SAAkB;AAC1F,QAAI,CAAC,KAAK,YAAY,UAAU,GAAG;AAC/B,YAAM,IAAI,oBAAoB,YAAY,UAAU,oBAAoB,WAAW,mBAAmB;AAAA,IAC1G;AACA,QAAI,CAAC,KAAK,iBAAiB,YAAY,SAAS,GAAG;AAC/C,YAAM,IAAI,oBAAoB,WAAW,SAAS,oBAAoB,WAAW,kBAAkB;AAAA,IACvG;AACA,QAAI,KAAK,SAAS,YAAY,WAAW,OAAO,EAAG,QAAO;AAC1D,UAAM,IAAI,oBAAoB,SAAS,OAAO,mBAAmB,WAAW,gBAAgB;AAAA,EAChG;AAAA,EAEA,WACI,YACA,WACA,WACmC;AACnC,WAAO,KAAK,SAAS,IAAI,gBAAgB,EAAE,YAAY,WAAW,UAAU,CAAC,CAAC;AAAA,EAClF;AAAA,EAEA,WAAW,YAA4B,WAAsB,WAA+B;AACxF,WAAO,CAAC,CAAC,KAAK,WAAW,YAAY,WAAW,SAAS;AAAA,EAC7D;AAAA,EAEA,4BAA4B,YAA4B,WAAsB,WAAsB;AAChG,QAAI,CAAC,KAAK,YAAY,UAAU,GAAG;AAC/B,YAAM,IAAI,oBAAoB,YAAY,UAAU,oBAAoB,WAAW,mBAAmB;AAAA,IAC1G;AACA,QAAI,CAAC,KAAK,iBAAiB,YAAY,SAAS,GAAG;AAC/C,YAAM,IAAI,oBAAoB,WAAW,SAAS,oBAAoB,WAAW,kBAAkB;AAAA,IACvG;AACA,QAAI,KAAK,WAAW,YAAY,WAAW,SAAS,EAAG,QAAO;AAC9D,UAAM,IAAI,oBAAoB,WAAW,SAAS,mBAAmB,WAAW,kBAAkB;AAAA,EACtG;AAAA;AAAA,EAGA,sCACI,EAAE,YAAY,WAAW,YAAY,GACrC,mBACF;AACE,QAAI,sBAAsB,OAAW,QAAO;AAC5C,QAAI,kBAAkB,gBAAgB,eAAe,GAAG;AACpD,aAAO;AAAA,IACX;AAGA,QAAI,eAAe,SAAU,eAAe,OAAQ;AAChD,UAAI,kBAAkB,wBAAwB,uBAAuB,SAAS,WAAW,GAAG;AACxF,eAAO;AAAA,MACX;AACA,UAAI,kBAAkB,qBAAqB,gBAAgB,cAAc,IAAI;AACzE,eAAO;AAAA,MACX;AACA,UAAI,kBAAkB,iBAAiB,gBAAgB,UAAU,IAAI;AACjE,eAAO;AAAA,MACX;AACA,UAAI,kBAAkB,oBAAoB,uBAAuB,SAAS,WAAW,GAAG;AACpF,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,QACI,kBAAkB,uBACjB,IAAI,mBAAmB,SAAS,KAAK,IAAI,mBAAmB,WAAW,IAC1E;AACE,aAAO;AAAA,IACX;AAEA,UAAM,UAAU,YAAY,SAAS,IAAI,cAAc,SAAS;AAChE,QAAI,YAAY,QAAW;AACvB,YAAM,YAAY,QAAQ,IAAI,gBAAgB,WAAW;AACzD,UAAI,cAAc,QAAW;AACzB,YAAI,kBAAkB,uBAAuB,UAAU,OAAO;AAC1D,iBAAO;AAAA,QACX;AACA,YAAI,kBAAkB,gCAAgC,UAAU,gBAAgB;AAC5E,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,UAAI,kBAAkB,2BAA2B,wBAAwB,SAAS,SAAS,GAAG;AAC1F,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEA,cAAc,SAAoD,eAAe,OAA4B;AACzG,UAAM,SAAS,IAAI,MAAyB;AAE5C,YAAQ,QAAQ,CAAC,EAAE,YAAY,WAAW,aAAa,kBAAkB,MAAM;AAC3E,WAAK,yBAAyB,EAAE,YAAY,WAAW,YAAY,CAAC;AACpE,UAAI,eAAe,UAAa,cAAc,UAAa,gBAAgB,QAAW;AAClF,cAAM,OAAO,EAAE,YAAY,WAAW,YAAY;AAClD,cAAM,YAAY,KAAK,WAAW,IAAI,kBAAkB,IAAI,CAAC;AAC7D,YAAI,cAAc,OAAW;AAC7B,YAAI,gBAAgB,CAAC,UAAU,WAAY;AAC3C,YAAI,KAAK,sCAAsC,IAAI,EAAG;AACtD,eAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAAA,MACnC,OAAO;AACH,aAAK,eACA;AAAA,UACG,WACK,eAAe,UAAa,eAAe,KAAK,gBAChD,cAAc,UAAa,cAAc,KAAK,eAC9C,gBAAgB,UAAa,gBAAgB,KAAK;AAAA,QAC3D,EACC,QAAQ,UAAQ;AACb,gBAAM,YAAY,KAAK,WAAW,IAAI,kBAAkB,IAAI,CAAC;AAC7D,cAAI,cAAc,OAAW;AAC7B,cAAI,gBAAgB,CAAC,UAAU,WAAY;AAC3C,cAAI,KAAK,sCAAsC,MAAM,iBAAiB,EAAG;AACzE,iBAAO,KAAK,EAAE,MAAM,UAAU,CAAC;AAAA,QACnC,CAAC;AAAA,MACT;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EAEA,UAAU,SAAiE;AACvE,UAAM,SAAS,IAAI,MAAqB;AAExC,YAAQ,QAAQ,CAAC,EAAE,YAAY,WAAW,SAAS,SAAS,MAAM;AAC9D,WAAK,yBAAyB,EAAE,YAAY,WAAW,QAAQ,CAAC;AAChE,UAAI,eAAe,UAAa,cAAc,UAAa,YAAY,QAAW;AAC9E,cAAM,OAAO,EAAE,YAAY,WAAW,SAAS,SAAS;AACxD,cAAM,QAAQ,KAAK,OAAO,IAAI,cAAc,IAAI,CAAC;AACjD,YAAI,UAAU,OAAW;AACzB,eAAO,KAAK,EAAE,MAAM,MAAM,CAAC;AAAA,MAC/B,OAAO;AACH,aAAK,WACA;AAAA,UACG,WACK,eAAe,UAAa,eAAe,KAAK,gBAChD,cAAc,UAAa,cAAc,KAAK,eAC9C,YAAY,UAAa,YAAY,KAAK;AAAA,QACnD,EACC,QAAQ,CAAC,EAAE,YAAAA,aAAY,WAAAC,YAAW,SAAAC,SAAQ,MAAM;AAC7C,gBAAM,OAAO,EAAE,YAAAF,aAAY,WAAAC,YAAW,SAAAC,UAAS,SAAS;AACxD,gBAAM,QAAQ,KAAK,OAAO,IAAI,cAAc,IAAI,CAAC;AACjD,cAAI,UAAU,OAAW;AACzB,iBAAO,KAAK,EAAE,MAAM,MAAM,CAAC;AAAA,QAC/B,CAAC;AAAA,MACT;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EAEA,YAAY,SAAqE;AAC7E,UAAM,SAAS,IAAI,MAAuB;AAE1C,YAAQ,QAAQ,CAAC,EAAE,YAAY,WAAW,UAAU,MAAM;AACtD,WAAK,yBAAyB,EAAE,YAAY,WAAW,UAAU,CAAC;AAClE,UAAI,eAAe,UAAa,cAAc,UAAa,cAAc,QAAW;AAChF,cAAM,OAAO,EAAE,YAAY,WAAW,UAAU;AAChD,cAAM,UAAU,KAAK,SAAS,IAAI,gBAAgB,IAAI,CAAC;AACvD,YAAI,YAAY,OAAW;AAC3B,eAAO,KAAK,EAAE,MAAM,QAAQ,CAAC;AAAA,MACjC,OAAO;AACH,aAAK,aACA;AAAA,UACG,WACK,eAAe,UAAa,eAAe,KAAK,gBAChD,cAAc,UAAa,cAAc,KAAK,eAC9C,cAAc,UAAa,cAAc,KAAK;AAAA,QACvD,EACC,QAAQ,UAAQ;AACb,gBAAM,UAAU,KAAK,SAAS,IAAI,gBAAgB,IAAI,CAAC;AACvD,cAAI,YAAY,OAAW;AAC3B,iBAAO,KAAK,EAAE,MAAM,QAAQ,CAAC;AAAA,QACjC,CAAC;AAAA,MACT;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,yBAAyB,MAMtB;AACC,UAAM,EAAE,YAAY,WAAW,aAAa,SAAS,UAAU,IAAI;AAEnE,QAAI,eAAe,QAAW;AAC1B,qBAAe,UAAU;AAAA,IAC7B;AACA,QAAI,cAAc,QAAW;AACzB,gBAAU,SAAS;AAAA,IACvB;AACA,QAAI,gBAAgB,QAAW;AAC3B,kBAAY,WAAW;AAAA,IAC3B;AACA,QAAI,YAAY,QAAW;AACvB,cAAQ,OAAO;AAAA,IACnB;AACA,QAAI,cAAc,QAAW;AACzB,gBAAU,SAAS;AAAA,IACvB;AAAA,EACJ;AACJ;",
  "names": ["endpointId", "clusterId", "eventId"]
}
