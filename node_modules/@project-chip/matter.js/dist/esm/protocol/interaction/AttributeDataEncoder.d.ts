import { AttributeId } from "../../datatype/AttributeId.js";
import { ClusterId } from "../../datatype/ClusterId.js";
import { EndpointNumber } from "../../datatype/EndpointNumber.js";
import { NodeId } from "../../datatype/NodeId.js";
import { TlvEncodingOptions, TlvSchema, TlvStream, TypeFromSchema } from "../../tlv/TlvSchema.js";
import { TlvAttributeReport, TlvAttributeReportData, TlvDataReport, TlvEventData, TlvEventReport } from "./InteractionProtocol.js";
/** Type for TlvAttributeReport where the real data are represented with the schema and the JS value. */
export type AttributeReportPayload = Omit<TypeFromSchema<typeof TlvAttributeReport>, "attributeData"> & {
    attributeData?: AttributeDataPayload;
    hasFabricSensitiveData: boolean;
};
/** Type for TlvAttributeReportData where the real data are represented with the schema and the JS value. */
type AttributeDataPayload = Omit<TypeFromSchema<typeof TlvAttributeReportData>, "data"> & {
    schema: TlvSchema<any>;
    payload: any;
};
/** Type for TlvEventReport where the real data are represented with the schema and the JS value. */
export type EventReportPayload = Omit<TypeFromSchema<typeof TlvEventReport>, "eventData"> & {
    eventData?: EventDataPayload;
    hasFabricSensitiveData: boolean;
};
/** Type for TlvEventData where the real data are represented with the schema and the JS value. */
export type EventDataPayload = Omit<TypeFromSchema<typeof TlvEventData>, "data"> & {
    schema: TlvSchema<any>;
    payload: any;
};
/** Type for TlvDataReport where the real data are represented with the schema and the JS value. */
export type DataReportPayload = Omit<TypeFromSchema<typeof TlvDataReport>, "attributeReports" | "eventReports"> & {
    attributeReportsPayload?: AttributeReportPayload[];
    eventReportsPayload?: EventReportPayload[];
};
/** Encodes an AttributeReportPayload into a TlvStream (used for TlvAny type). */
export declare function encodeAttributePayload(attributePayload: AttributeReportPayload, options?: TlvEncodingOptions): TlvStream;
/** Encodes an EventReportPayload into a TlvStream (used for TlvAny type). */
export declare function encodeEventPayload(eventPayload: EventReportPayload, options?: TlvEncodingOptions): TlvStream;
/** Return if an AttributeReportPayload can be chunked or not. */
export declare function canAttributePayloadBeChunked(attributePayload: AttributeReportPayload): boolean;
/** Chunk an AttributeReportPayload into multiple AttributeReportPayloads. */
export declare function chunkAttributePayload(attributePayload: AttributeReportPayload): AttributeReportPayload[];
/**
 * Sort function to sort AttributeReportPayloads by nodeId/EndpointId/clusterId/attributeId to generate an ideal
 * ground for tag compression.
 */
export declare function sortAttributeDataByPath(data1: AttributeReportPayload, data2: AttributeReportPayload): 0 | 1 | -1;
/** Sort and use Tag compression to compress a list of AttributeReportPayloads. */
export declare function compressAttributeDataReportTags(data: AttributeReportPayload[]): {
    hasFabricSensitiveData: boolean;
    attributeData: AttributeDataPayload | undefined;
    attributeStatus: import("../../tlv/TlvObject.js").TypeFromFields<{
        path: import("../../tlv/TlvObject.js").FieldType<import("../../tlv/TlvObject.js").TypeFromFields<{
            enableTagCompression: import("../../tlv/TlvObject.js").OptionalFieldType<boolean>;
            nodeId: import("../../tlv/TlvObject.js").OptionalFieldType<NodeId>;
            endpointId: import("../../tlv/TlvObject.js").OptionalFieldType<EndpointNumber>;
            clusterId: import("../../tlv/TlvObject.js").OptionalFieldType<ClusterId>;
            attributeId: import("../../tlv/TlvObject.js").OptionalFieldType<AttributeId>;
            listIndex: import("../../tlv/TlvObject.js").OptionalFieldType<number | null>;
            wildcardPathFlags: import("../../tlv/TlvObject.js").OptionalFieldType<import("../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                skipRootNode: import("../../schema/BitmapSchema.js").BitFlag;
                skipGlobalAttributes: import("../../schema/BitmapSchema.js").BitFlag;
                skipAttributeList: import("../../schema/BitmapSchema.js").BitFlag;
                skipEventList: import("../../schema/BitmapSchema.js").BitFlag;
                skipCommandLists: import("../../schema/BitmapSchema.js").BitFlag;
                skipCustomElements: import("../../schema/BitmapSchema.js").BitFlag;
                skipFixedAttributes: import("../../schema/BitmapSchema.js").BitFlag;
                skipChangesOmittedAttributes: import("../../schema/BitmapSchema.js").BitFlag;
                skipDiagnosticsClusters: import("../../schema/BitmapSchema.js").BitFlag;
            }>>;
        }>>;
        status: import("../../tlv/TlvObject.js").FieldType<import("../../tlv/TlvObject.js").TypeFromFields<{
            status: import("../../tlv/TlvObject.js").OptionalFieldType<import("../../cluster/export.js").Status>;
            clusterStatus: import("../../tlv/TlvObject.js").OptionalFieldType<import("../../cluster/export.js").Status>;
        }>>;
    }> | undefined;
}[];
export {};
//# sourceMappingURL=AttributeDataEncoder.d.ts.map