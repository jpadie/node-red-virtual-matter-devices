{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/InteractionClient.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterController } from \"../../MatterController.js\";\nimport {\n    Attribute,\n    AttributeJsType,\n    Command,\n    Event,\n    RequestType,\n    ResponseType,\n    TlvNoResponse,\n} from \"../../cluster/Cluster.js\";\nimport { resolveAttributeName, resolveCommandName, resolveEventName } from \"../../cluster/ClusterHelper.js\";\nimport { ImplementationError, MatterFlowError, UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { EventNumber } from \"../../datatype/EventNumber.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { MessageExchange } from \"../../protocol/MessageExchange.js\";\nimport { ProtocolHandler } from \"../../protocol/ProtocolHandler.js\";\nimport { Time, Timer, TimerCallback } from \"../../time/Time.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { ExchangeProvider } from \"../ExchangeManager.js\";\nimport { DecodedAttributeReportValue, normalizeAndDecodeReadAttributeReport } from \"./AttributeDataDecoder.js\";\nimport { DecodedEventData, DecodedEventReportValue, normalizeAndDecodeReadEventReport } from \"./EventDataDecoder.js\";\nimport {\n    DataReport,\n    IncomingInteractionClientMessenger,\n    InteractionClientMessenger,\n    ReadRequest,\n} from \"./InteractionMessenger.js\";\nimport { TlvEventFilter } from \"./InteractionProtocol.js\";\nimport {\n    INTERACTION_MODEL_REVISION,\n    INTERACTION_PROTOCOL_ID,\n    attributePathToId,\n    clusterPathToId,\n} from \"./InteractionServer.js\";\nimport { StatusCode, StatusResponseError } from \"./StatusCode.js\";\n\nconst logger = Logger.get(\"InteractionClient\");\n\nconst REQUEST_ALL = [{}];\nconst DEFAULT_TIMED_REQUEST_TIMEOUT_MS = 10_000; // 10 seconds\nconst DEFAULT_MINIMUM_RESPONSE_TIMEOUT_WITH_FAILSAFE_MS = 30_000; // 30 seconds\n\nexport interface AttributeStatus {\n    path: {\n        nodeId?: NodeId;\n        endpointId?: EndpointNumber;\n        clusterId?: ClusterId;\n        attributeId?: AttributeId;\n    };\n    status: StatusCode;\n}\n\nexport class SubscriptionClient implements ProtocolHandler<MatterController> {\n    private readonly subscriptionListeners = new Map<number, (dataReport: DataReport) => void>();\n    private readonly subscriptionUpdateTimers = new Map<number, Timer>();\n\n    constructor() {}\n\n    getId() {\n        return INTERACTION_PROTOCOL_ID;\n    }\n\n    registerSubscriptionListener(subscriptionId: number, listener: (dataReport: DataReport) => void) {\n        this.subscriptionListeners.set(subscriptionId, listener);\n    }\n\n    removeSubscriptionListener(subscriptionId: number) {\n        this.subscriptionListeners.delete(subscriptionId);\n    }\n\n    registerSubscriptionUpdateTimer(subscriptionId: number, timer: Timer) {\n        this.subscriptionUpdateTimers.set(subscriptionId, timer);\n    }\n\n    removeSubscriptionUpdateTimer(subscriptionId: number) {\n        this.subscriptionUpdateTimers.get(subscriptionId)?.stop();\n        this.subscriptionUpdateTimers.delete(subscriptionId);\n    }\n\n    async onNewExchange(exchange: MessageExchange<MatterController>) {\n        const messenger = new IncomingInteractionClientMessenger(exchange);\n        const dataReport = await messenger.readDataReports(false);\n        const subscriptionId = dataReport.subscriptionId;\n        if (subscriptionId === undefined) {\n            await messenger.sendStatus(StatusCode.InvalidSubscription);\n            throw new UnexpectedDataError(\"Invalid Data report without Subscription ID\");\n        }\n        const listener = this.subscriptionListeners.get(subscriptionId);\n        const timer = this.subscriptionUpdateTimers.get(subscriptionId);\n        if (listener === undefined) {\n            await messenger.sendStatus(StatusCode.InvalidSubscription);\n            logger.info(`Received data for unknown subscription ID ${subscriptionId}. Cancel this subscription.`);\n            if (timer !== undefined) {\n                // Should not happen but let's make sure to clean up\n                this.removeSubscriptionUpdateTimer(subscriptionId);\n            }\n            await messenger.close();\n            return;\n        }\n        await messenger.sendStatus(StatusCode.Success);\n        await messenger.close();\n\n        if (timer !== undefined) {\n            timer.stop().start(); // Restart timer because we received data\n        }\n        listener(dataReport);\n    }\n\n    async close() {\n        this.subscriptionListeners.clear();\n        this.subscriptionUpdateTimers.forEach(timer => timer.stop());\n        this.subscriptionUpdateTimers.clear();\n    }\n}\n\nexport class InteractionClient {\n    // TODO Add storage for these data to be able to optimize follow up subscriptions by only request updated data\n    private readonly subscribedLocalValues = new Map<string, any>();\n    private readonly subscribedClusterDataVersions = new Map<string, number>();\n    private readonly ownSubscriptionIds = new Set<number>();\n    private readonly subscriptionClient: SubscriptionClient;\n\n    constructor(\n        private readonly exchangeProvider: ExchangeProvider,\n        readonly nodeId: NodeId,\n    ) {\n        if (this.exchangeProvider.hasProtocolHandler(INTERACTION_PROTOCOL_ID)) {\n            const client = this.exchangeProvider.getProtocolHandler(INTERACTION_PROTOCOL_ID);\n            if (!(client instanceof SubscriptionClient)) {\n                throw new ImplementationError(\n                    `Already existing protocol handler ${INTERACTION_PROTOCOL_ID} is not a SubscriptionClient.`,\n                );\n            }\n            this.subscriptionClient = client;\n        } else {\n            this.subscriptionClient = new SubscriptionClient();\n            this.exchangeProvider.addProtocolHandler(this.subscriptionClient);\n        }\n    }\n\n    registerSubscriptionListener(subscriptionId: number, listener: (dataReport: DataReport) => void) {\n        this.ownSubscriptionIds.add(subscriptionId);\n        this.subscriptionClient.registerSubscriptionListener(subscriptionId, listener);\n    }\n\n    removeSubscription(subscriptionId: number) {\n        this.ownSubscriptionIds.delete(subscriptionId);\n        this.subscriptionClient.removeSubscriptionListener(subscriptionId);\n        this.subscriptionClient.removeSubscriptionUpdateTimer(subscriptionId);\n    }\n\n    async getAllAttributes(\n        options: {\n            dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n            isFabricFiltered?: boolean;\n        } = {},\n    ): Promise<DecodedAttributeReportValue<any>[]> {\n        const { dataVersionFilters, isFabricFiltered } = options;\n        return (\n            await this.getMultipleAttributesAndEvents({\n                attributes: REQUEST_ALL,\n                dataVersionFilters,\n                isFabricFiltered,\n            })\n        ).attributeReports;\n    }\n\n    async getAllEvents(\n        options: {\n            eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n            isFabricFiltered?: boolean;\n        } = {},\n    ): Promise<DecodedEventReportValue<any>[]> {\n        const { eventFilters, isFabricFiltered } = options;\n        return (await this.getMultipleAttributesAndEvents({ events: REQUEST_ALL, eventFilters, isFabricFiltered }))\n            .eventReports;\n    }\n\n    async getAllAttributesAndEvents(\n        options: {\n            dataVersionFilters?: {\n                endpointId: EndpointNumber;\n                clusterId: ClusterId;\n                dataVersion: number;\n            }[];\n            eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n            isFabricFiltered?: boolean;\n        } = {},\n    ): Promise<{\n        attributeReports: DecodedAttributeReportValue<any>[];\n        eventReports: DecodedEventReportValue<any>[];\n    }> {\n        const { dataVersionFilters, eventFilters, isFabricFiltered } = options;\n        return this.getMultipleAttributesAndEvents({\n            attributes: REQUEST_ALL,\n            events: REQUEST_ALL,\n            eventFilters,\n            dataVersionFilters,\n            isFabricFiltered,\n        });\n    }\n\n    async getMultipleAttributes(\n        options: {\n            attributes?: { endpointId?: EndpointNumber; clusterId?: ClusterId; attributeId?: AttributeId }[];\n            dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n            isFabricFiltered?: boolean;\n        } = {},\n    ): Promise<DecodedAttributeReportValue<any>[]> {\n        const { attributes, dataVersionFilters, isFabricFiltered } = options;\n        return (await this.getMultipleAttributesAndEvents({ attributes, dataVersionFilters, isFabricFiltered }))\n            .attributeReports;\n    }\n\n    async getMultipleEvents(\n        options: {\n            events?: { endpointId?: EndpointNumber; clusterId?: ClusterId; eventId?: EventId }[];\n            eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n            isFabricFiltered?: boolean;\n        } = {},\n    ): Promise<DecodedEventReportValue<any>[]> {\n        const { events, eventFilters, isFabricFiltered } = options;\n        return (await this.getMultipleAttributesAndEvents({ events, eventFilters, isFabricFiltered })).eventReports;\n    }\n\n    async getMultipleAttributesAndEvents(\n        options: {\n            attributes?: { endpointId?: EndpointNumber; clusterId?: ClusterId; attributeId?: AttributeId }[];\n            dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n            events?: { endpointId?: EndpointNumber; clusterId?: ClusterId; eventId?: EventId }[];\n            eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n            isFabricFiltered?: boolean;\n        } = {},\n    ): Promise<{\n        attributeReports: DecodedAttributeReportValue<any>[];\n        eventReports: DecodedEventReportValue<any>[];\n    }> {\n        const {\n            attributes: attributeRequests,\n            dataVersionFilters,\n            events: eventRequests,\n            eventFilters,\n            isFabricFiltered = true,\n        } = options;\n        if (attributeRequests === undefined && eventRequests === undefined) {\n            throw new ImplementationError(\"When reading attributes and events, at least one must be specified.\");\n        }\n\n        const readPathsCount = (attributeRequests?.length ?? 0) + (eventRequests?.length ?? 0);\n        if (readPathsCount > 9) {\n            logger.debug(\n                \"Read interactions with more then 9 paths might be not allowed by the device. Consider splitting then into several read requests.\",\n            );\n        }\n\n        return this.withMessenger<{\n            attributeReports: DecodedAttributeReportValue<any>[];\n            eventReports: DecodedEventReportValue<any>[];\n        }>(async messenger => {\n            return await this.processReadRequest(messenger, {\n                attributeRequests,\n                dataVersionFilters: dataVersionFilters?.map(({ endpointId, clusterId, dataVersion }) => ({\n                    path: { endpointId, clusterId },\n                    dataVersion,\n                })),\n                eventRequests,\n                eventFilters,\n                isFabricFiltered,\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n            });\n        });\n    }\n\n    async getAttribute<A extends Attribute<any, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        attribute: A;\n        isFabricFiltered?: boolean;\n        alwaysRequestFromRemote?: boolean;\n    }): Promise<AttributeJsType<A> | undefined> {\n        const { endpointId, clusterId, attribute, alwaysRequestFromRemote = false, isFabricFiltered } = options;\n        const response = await this.getAttributeWithVersion({\n            endpointId,\n            clusterId,\n            attribute,\n            alwaysRequestFromRemote,\n            isFabricFiltered,\n        });\n        return response?.value;\n    }\n\n    async getAttributeWithVersion<A extends Attribute<any, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        attribute: A;\n        isFabricFiltered?: boolean;\n        alwaysRequestFromRemote?: boolean;\n    }): Promise<{ value: AttributeJsType<A>; version: number } | undefined> {\n        const { endpointId, clusterId, attribute, alwaysRequestFromRemote = false, isFabricFiltered } = options;\n        const { id: attributeId } = attribute;\n        if (!alwaysRequestFromRemote) {\n            const value = this.subscribedLocalValues.get(attributePathToId({ endpointId, clusterId, attributeId }));\n            const version = this.subscribedClusterDataVersions.get(clusterPathToId({ endpointId, clusterId }));\n            if (value !== undefined && version !== undefined) {\n                return { value, version } as { value: AttributeJsType<A>; version: number };\n            }\n        }\n\n        const { attributeReports } = await this.getMultipleAttributesAndEvents({\n            attributes: [{ endpointId, clusterId, attributeId }],\n            isFabricFiltered,\n        });\n\n        if (attributeReports.length === 0) {\n            return undefined;\n        }\n        if (attributeReports.length > 1) {\n            throw new UnexpectedDataError(\"Unexpected response with more then one attribute\");\n        }\n        return { value: attributeReports[0].value, version: attributeReports[0].version };\n    }\n\n    async getEvent<T, E extends Event<T, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        event: E;\n        minimumEventNumber?: EventNumber;\n        isFabricFiltered?: boolean;\n    }): Promise<DecodedEventData<T>[] | undefined> {\n        const { endpointId, clusterId, event, minimumEventNumber, isFabricFiltered = true } = options;\n        const { id: eventId } = event;\n        const response = await this.getMultipleAttributesAndEvents({\n            events: [{ endpointId, clusterId, eventId }],\n            eventFilters: minimumEventNumber !== undefined ? [{ eventMin: minimumEventNumber }] : undefined,\n            isFabricFiltered,\n        });\n        return response?.eventReports[0]?.events;\n    }\n\n    private async processReadRequest(\n        messenger: InteractionClientMessenger,\n        request: ReadRequest,\n    ): Promise<{ attributeReports: DecodedAttributeReportValue<any>[]; eventReports: DecodedEventReportValue<any>[] }> {\n        const { attributeRequests, eventRequests } = request;\n        logger.debug(\n            `Sending read request to ${messenger.getExchangeChannelName()} for attributes ${attributeRequests\n                ?.map(path => resolveAttributeName(path))\n                .join(\", \")} and events ${eventRequests?.map(path => resolveEventName(path)).join(\", \")}`,\n        );\n        // Send read request and combine all (potentially chunked) responses\n        const response = await messenger.sendReadRequest(request);\n\n        // Normalize and decode the response\n        const normalizedResult = {\n            attributeReports: normalizeAndDecodeReadAttributeReport(response.attributeReports ?? []),\n            eventReports: normalizeAndDecodeReadEventReport(response.eventReports ?? []),\n        };\n        logger.debug(\n            `Received read response with attributes ${normalizedResult.attributeReports\n                .map(({ path, value }) => `${resolveAttributeName(path)} = ${Logger.toJSON(value)}`)\n                .join(\", \")} and events ${normalizedResult.eventReports\n                .map(({ path, events }) => `${resolveEventName(path)} = ${Logger.toJSON(events)}`)\n                .join(\", \")}`,\n        );\n        return normalizedResult;\n    }\n\n    async setAttribute<T>(options: {\n        attributeData: {\n            endpointId: EndpointNumber;\n            clusterId: ClusterId;\n            attribute: Attribute<T, any>;\n            value: T;\n            dataVersion?: number;\n        };\n        asTimedRequest?: boolean;\n        timedRequestTimeoutMs?: number;\n        suppressResponse?: boolean;\n    }): Promise<void> {\n        const { attributeData, asTimedRequest, timedRequestTimeoutMs, suppressResponse } = options;\n        const { endpointId, clusterId, attribute, value, dataVersion } = attributeData;\n        const response = await this.setMultipleAttributes({\n            attributes: [{ endpointId, clusterId, attribute, value, dataVersion }],\n            asTimedRequest,\n            timedRequestTimeoutMs,\n            suppressResponse,\n        });\n\n        // Response contains Status error if there was an error on write\n        if (response.length) {\n            const {\n                path: { endpointId, clusterId, attributeId },\n                status,\n            } = response[0];\n            if (status !== undefined && status !== StatusCode.Success) {\n                throw new StatusResponseError(\n                    `Error setting attribute ${endpointId}/${clusterId}/${attributeId}`,\n                    status,\n                );\n            }\n        }\n    }\n\n    async setMultipleAttributes(options: {\n        attributes: {\n            endpointId: EndpointNumber;\n            clusterId: ClusterId;\n            attribute: Attribute<any, any>;\n            value: any;\n            dataVersion?: number;\n        }[];\n        asTimedRequest?: boolean;\n        timedRequestTimeoutMs?: number;\n        suppressResponse?: boolean;\n    }): Promise<AttributeStatus[]> {\n        const {\n            attributes,\n            asTimedRequest,\n            timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,\n            suppressResponse = false, // TODO needs to be TRUE for Group writes\n        } = options;\n        return this.withMessenger<AttributeStatus[]>(async messenger => {\n            logger.debug(\n                `Sending write request: ${attributes\n                    .map(\n                        ({ endpointId, clusterId, attribute: { id }, value, dataVersion }) =>\n                            `${resolveAttributeName({ endpointId, clusterId, attributeId: id })} = ${Logger.toJSON(\n                                value,\n                            )} (version=${dataVersion})`,\n                    )\n                    .join(\", \")}`,\n            );\n            const writeRequests = attributes.map(\n                ({ endpointId, clusterId, attribute: { id, schema }, value, dataVersion }) => ({\n                    path: { endpointId, clusterId, attributeId: id },\n                    data: schema.encodeTlv(value, { forWriteInteraction: true }),\n                    dataVersion,\n                }),\n            );\n            const timedRequest =\n                attributes.some(({ attribute: { timed } }) => timed) ||\n                asTimedRequest === true ||\n                options.timedRequestTimeoutMs !== undefined;\n            if (timedRequest) {\n                await messenger.sendTimedRequest(timedRequestTimeoutMs);\n            }\n            const response = await messenger.sendWriteCommand({\n                suppressResponse,\n                timedRequest,\n                writeRequests,\n                moreChunkedMessages: false,\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n            });\n            if (response === undefined) {\n                if (!suppressResponse) {\n                    throw new MatterFlowError(`No response received from write interaction but expected.`);\n                }\n                return [];\n            }\n            return response.writeResponses\n                .flatMap(\n                    ({ status: { status, clusterStatus }, path: { nodeId, endpointId, clusterId, attributeId } }) => {\n                        return {\n                            path: { nodeId, endpointId, clusterId, attributeId },\n                            status: status ?? clusterStatus ?? StatusCode.Failure,\n                        };\n                    },\n                )\n                .filter(({ status }) => status !== StatusCode.Success);\n        });\n    }\n\n    async subscribeAttribute<A extends Attribute<any, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        attribute: A;\n        minIntervalFloorSeconds: number;\n        maxIntervalCeilingSeconds: number;\n        isFabricFiltered?: boolean;\n        knownDataVersion?: number;\n        keepSubscriptions?: boolean;\n        listener?: (value: AttributeJsType<A>, version: number) => void;\n        updateTimeoutHandler?: TimerCallback;\n    }): Promise<void> {\n        const {\n            endpointId,\n            clusterId,\n            attribute,\n            minIntervalFloorSeconds,\n            maxIntervalCeilingSeconds,\n            isFabricFiltered = true,\n            listener,\n            knownDataVersion,\n            keepSubscriptions = true,\n            updateTimeoutHandler,\n        } = options;\n        return this.withMessenger<void>(async messenger => {\n            const { id: attributeId } = attribute;\n            logger.debug(\n                `Sending subscribe request for attribute: ${resolveAttributeName({\n                    endpointId,\n                    clusterId,\n                    attributeId,\n                })}`,\n            );\n            const {\n                report,\n                subscribeResponse: { subscriptionId, maxInterval },\n            } = await messenger.sendSubscribeRequest({\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n                attributeRequests: [{ endpointId, clusterId, attributeId }],\n                dataVersionFilters:\n                    knownDataVersion !== undefined\n                        ? [{ path: { endpointId, clusterId }, dataVersion: knownDataVersion }]\n                        : undefined,\n                keepSubscriptions,\n                minIntervalFloorSeconds,\n                maxIntervalCeilingSeconds,\n                isFabricFiltered,\n            });\n\n            const subscriptionListener = (dataReport: DataReport) => {\n                if (!Array.isArray(dataReport.attributeReports) || !dataReport.attributeReports.length) {\n                    logger.debug(\"Subscription result empty\");\n                    return;\n                }\n\n                const data = normalizeAndDecodeReadAttributeReport(dataReport.attributeReports);\n\n                if (data.length === 0) {\n                    throw new MatterFlowError(\"Subscription result reporting undefined/no value not specified\");\n                }\n                if (data.length > 1) {\n                    throw new UnexpectedDataError(\"Unexpected response with more then one attribute\");\n                }\n                const {\n                    path: { endpointId, clusterId, attributeId },\n                    value,\n                    version,\n                } = data[0];\n                if (value === undefined)\n                    throw new MatterFlowError(\"Subscription result reporting undefined value not specified.\");\n\n                this.subscribedLocalValues.set(attributePathToId({ endpointId, clusterId, attributeId }), value);\n                this.subscribedClusterDataVersions.set(clusterPathToId({ endpointId, clusterId }), version);\n                listener?.(value, version);\n            };\n            this.registerSubscriptionListener(subscriptionId, subscriptionListener);\n            if (updateTimeoutHandler !== undefined) {\n                this.registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler);\n            }\n            subscriptionListener(report);\n            return;\n        });\n    }\n\n    async subscribeEvent<T, E extends Event<T, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        event: E;\n        minIntervalFloorSeconds: number;\n        maxIntervalCeilingSeconds: number;\n        isUrgent?: boolean;\n        minimumEventNumber?: EventNumber;\n        isFabricFiltered?: boolean;\n        listener?: (value: DecodedEventData<T>) => void;\n        updateTimeoutHandler?: TimerCallback;\n    }): Promise<void> {\n        return this.withMessenger<void>(async messenger => {\n            const {\n                endpointId,\n                clusterId,\n                event,\n                minIntervalFloorSeconds,\n                maxIntervalCeilingSeconds,\n                isUrgent,\n                minimumEventNumber,\n                isFabricFiltered = true,\n                listener,\n                updateTimeoutHandler,\n            } = options;\n            const { id: eventId } = event;\n            logger.debug(\n                `Sending subscribe request for event: ${resolveEventName({ endpointId, clusterId, eventId })}`,\n            );\n            const {\n                report,\n                subscribeResponse: { subscriptionId, maxInterval },\n            } = await messenger.sendSubscribeRequest({\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n                eventRequests: [{ endpointId, clusterId, eventId, isUrgent }],\n                eventFilters: minimumEventNumber !== undefined ? [{ eventMin: minimumEventNumber }] : undefined,\n                keepSubscriptions: true,\n                minIntervalFloorSeconds,\n                maxIntervalCeilingSeconds,\n                isFabricFiltered,\n            });\n\n            const subscriptionListener = (dataReport: DataReport) => {\n                if (!Array.isArray(dataReport.eventReports) || !dataReport.eventReports.length) {\n                    logger.debug(\"Subscription result empty\");\n                    return;\n                }\n\n                const data = normalizeAndDecodeReadEventReport(dataReport.eventReports);\n\n                if (data.length === 0) {\n                    throw new MatterFlowError(\"Received empty subscription result value.\");\n                }\n                if (data.length > 1) {\n                    throw new UnexpectedDataError(\"Unexpected response with more then one attribute.\");\n                }\n                const { events } = data[0];\n                if (events === undefined)\n                    throw new MatterFlowError(\"Subscription result reporting undefined value not specified.\");\n\n                events.forEach(event => listener?.(event));\n            };\n            this.registerSubscriptionListener(subscriptionId, subscriptionListener);\n            if (updateTimeoutHandler !== undefined) {\n                this.registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler);\n            }\n            subscriptionListener(report);\n            return;\n        });\n    }\n\n    async subscribeAllAttributesAndEvents(options: {\n        minIntervalFloorSeconds: number;\n        maxIntervalCeilingSeconds: number;\n        attributeListener?: (data: DecodedAttributeReportValue<any>) => void;\n        eventListener?: (data: DecodedEventReportValue<any>) => void;\n        isUrgent?: boolean;\n        keepSubscriptions?: boolean;\n        isFabricFiltered?: boolean;\n        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n        dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n        updateTimeoutHandler?: TimerCallback;\n    }): Promise<{\n        attributeReports?: DecodedAttributeReportValue<any>[];\n        eventReports?: DecodedEventReportValue<any>[];\n    }> {\n        const {\n            minIntervalFloorSeconds,\n            maxIntervalCeilingSeconds,\n            attributeListener,\n            eventListener,\n            isUrgent,\n            keepSubscriptions = true,\n            isFabricFiltered = true,\n            eventFilters,\n            dataVersionFilters,\n            updateTimeoutHandler,\n        } = options;\n        return this.subscribeMultipleAttributesAndEvents({\n            attributes: REQUEST_ALL,\n            events: [{ isUrgent }],\n            minIntervalFloorSeconds,\n            maxIntervalCeilingSeconds,\n            keepSubscriptions,\n            isFabricFiltered,\n            attributeListener,\n            eventListener,\n            eventFilters,\n            dataVersionFilters,\n            updateTimeoutHandler,\n        });\n    }\n\n    async subscribeMultipleAttributesAndEvents(options: {\n        attributes: { endpointId?: EndpointNumber; clusterId?: ClusterId; attributeId?: AttributeId }[];\n        events: { endpointId?: EndpointNumber; clusterId?: ClusterId; eventId?: EventId; isUrgent?: boolean }[];\n        minIntervalFloorSeconds: number;\n        maxIntervalCeilingSeconds: number;\n        keepSubscriptions?: boolean;\n        isFabricFiltered?: boolean;\n        attributeListener?: (data: DecodedAttributeReportValue<any>) => void;\n        eventListener?: (data: DecodedEventReportValue<any>) => void;\n        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n        dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n        updateTimeoutHandler?: TimerCallback;\n    }): Promise<{\n        attributeReports?: DecodedAttributeReportValue<any>[];\n        eventReports?: DecodedEventReportValue<any>[];\n    }> {\n        const {\n            attributes: attributeRequests,\n            events: eventRequests,\n            minIntervalFloorSeconds,\n            maxIntervalCeilingSeconds,\n            keepSubscriptions = true,\n            isFabricFiltered = true,\n            attributeListener,\n            eventListener,\n            eventFilters,\n            dataVersionFilters,\n            updateTimeoutHandler,\n        } = options;\n\n        const subscriptionPathsCount = (attributeRequests?.length ?? 0) + (eventRequests?.length ?? 0);\n        if (subscriptionPathsCount > 3) {\n            logger.debug(\"Subscribe interactions with more then 3 paths might be not allowed by the device.\");\n        }\n\n        return this.withMessenger<{\n            attributeReports?: DecodedAttributeReportValue<any>[];\n            eventReports?: DecodedEventReportValue<any>[];\n        }>(async messenger => {\n            logger.debug(\n                `Sending subscribe request: attributes: ${attributeRequests\n                    .map(path => resolveAttributeName(path))\n                    .join(\", \")} and events: ${eventRequests.map(path => resolveEventName(path)).join(\", \")}`,\n            );\n            const {\n                report,\n                subscribeResponse: { subscriptionId, maxInterval },\n            } = await messenger.sendSubscribeRequest({\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n                attributeRequests,\n                eventRequests,\n                keepSubscriptions,\n                minIntervalFloorSeconds,\n                maxIntervalCeilingSeconds,\n                isFabricFiltered,\n                eventFilters,\n                dataVersionFilters: dataVersionFilters?.map(({ endpointId, clusterId, dataVersion }) => ({\n                    path: { endpointId, clusterId },\n                    dataVersion,\n                })),\n            });\n            logger.info(\n                `Subscription successfully initialized with ID ${subscriptionId} and maxInterval ${maxInterval}s.`,\n            );\n\n            const subscriptionListener = (dataReport: {\n                attributeReports?: DecodedAttributeReportValue<any>[];\n                eventReports?: DecodedEventReportValue<any>[];\n            }) => {\n                if (\n                    (!Array.isArray(dataReport.attributeReports) || !dataReport.attributeReports.length) &&\n                    (!Array.isArray(dataReport.eventReports) || !dataReport.eventReports.length)\n                ) {\n                    logger.debug(\"Subscription result empty\");\n                    return;\n                }\n                const { attributeReports, eventReports } = dataReport;\n\n                if (attributeReports !== undefined) {\n                    attributeReports.forEach(data => {\n                        const {\n                            path: { endpointId, clusterId, attributeId },\n                            value,\n                            version,\n                        } = data;\n                        logger.debug(\n                            `Received attribute update: ${resolveAttributeName({\n                                endpointId,\n                                clusterId,\n                                attributeId,\n                            })} = ${Logger.toJSON(value)} (version=${version})`,\n                        );\n                        if (value === undefined) throw new MatterFlowError(\"Received empty subscription result value.\");\n                        this.subscribedLocalValues.set(\n                            attributePathToId({ endpointId, clusterId, attributeId }),\n                            value,\n                        );\n                        this.subscribedClusterDataVersions.set(clusterPathToId({ endpointId, clusterId }), version);\n                        attributeListener?.(data);\n                    });\n                }\n\n                if (eventReports !== undefined) {\n                    eventReports.forEach(data => {\n                        logger.debug(\n                            `Received event update: ${resolveEventName(data.path)}: ${Logger.toJSON(data.events)}`,\n                        );\n                        eventListener?.(data);\n                    });\n                }\n            };\n            this.registerSubscriptionListener(subscriptionId, dataReport => {\n                subscriptionListener({\n                    attributeReports:\n                        dataReport.attributeReports !== undefined\n                            ? normalizeAndDecodeReadAttributeReport(dataReport.attributeReports)\n                            : undefined,\n                    eventReports:\n                        dataReport.eventReports !== undefined\n                            ? normalizeAndDecodeReadEventReport(dataReport.eventReports)\n                            : undefined,\n                });\n            });\n\n            if (updateTimeoutHandler !== undefined) {\n                this.registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler);\n            }\n\n            const seedReport = {\n                attributeReports:\n                    report.attributeReports !== undefined\n                        ? normalizeAndDecodeReadAttributeReport(report.attributeReports)\n                        : undefined,\n                eventReports:\n                    report.eventReports !== undefined\n                        ? normalizeAndDecodeReadEventReport(report.eventReports)\n                        : undefined,\n            };\n            subscriptionListener(seedReport);\n            return seedReport;\n        });\n    }\n\n    async invoke<C extends Command<any, any, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        request: RequestType<C>;\n        command: C;\n        asTimedRequest?: boolean;\n        timedRequestTimeoutMs?: number;\n        useExtendedFailSafeMessageResponseTimeout?: boolean;\n    }): Promise<ResponseType<C>> {\n        const {\n            endpointId,\n            clusterId,\n            request,\n            command: { requestId, requestSchema, responseId, responseSchema, optional, timed },\n            asTimedRequest,\n            timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,\n            useExtendedFailSafeMessageResponseTimeout = false,\n        } = options;\n        const timedRequest = timed || asTimedRequest === true || options.timedRequestTimeoutMs !== undefined;\n\n        return this.withMessenger<ResponseType<C>>(async messenger => {\n            logger.debug(\n                `Invoking command: ${resolveCommandName({\n                    endpointId,\n                    clusterId,\n                    commandId: requestId,\n                })} with ${Logger.toJSON(request)}`,\n            );\n\n            requestSchema.validate(request);\n\n            const commandFields = requestSchema.encodeTlv(request);\n\n            if (timedRequest) {\n                await messenger.sendTimedRequest(timedRequestTimeoutMs);\n            }\n\n            const invokeResponse = await messenger.sendInvokeCommand(\n                {\n                    invokeRequests: [{ commandPath: { endpointId, clusterId, commandId: requestId }, commandFields }],\n                    timedRequest,\n                    suppressResponse: false,\n                    interactionModelRevision: INTERACTION_MODEL_REVISION,\n                },\n                useExtendedFailSafeMessageResponseTimeout\n                    ? DEFAULT_MINIMUM_RESPONSE_TIMEOUT_WITH_FAILSAFE_MS\n                    : undefined,\n            );\n            if (invokeResponse === undefined) {\n                throw new MatterFlowError(\"No response received from invoke interaction but expected.\");\n            }\n            const { invokeResponses } = invokeResponse;\n            if (invokeResponses.length === 0) {\n                throw new MatterFlowError(\"Received invoke response with no invoke results.\");\n            }\n            const { command, status } = invokeResponses[0];\n            if (status !== undefined) {\n                const resultCode = status.status.status;\n                if (resultCode !== StatusCode.Success)\n                    throw new StatusResponseError(\n                        `Received non-success result: ${resultCode}`,\n                        resultCode ?? StatusCode.Failure,\n                        status.status.clusterStatus,\n                    );\n                if ((responseSchema as any) !== TlvNoResponse)\n                    throw new MatterFlowError(\"A response was expected for this command.\");\n                return undefined as unknown as ResponseType<C>; // ResponseType is void, force casting the empty result\n            }\n            if (command !== undefined) {\n                const {\n                    commandPath: { commandId },\n                    commandFields,\n                } = command;\n                if (commandId !== responseId) {\n                    throw new MatterFlowError(\n                        `Received invoke response with unexpected command ID ${commandId}, expected ${responseId}.`,\n                    );\n                }\n                if (commandFields === undefined) {\n                    if ((responseSchema as any) !== TlvNoResponse)\n                        throw new MatterFlowError(`A response was expected for command ${requestId}.`);\n                    return undefined as unknown as ResponseType<C>; // ResponseType is void, force casting the empty result\n                }\n                const response = responseSchema.decodeTlv(commandFields);\n                logger.debug(\n                    `Received invoke response: ${resolveCommandName({\n                        endpointId,\n                        clusterId,\n                        commandId: requestId,\n                    })} with ${Logger.toJSON(response)})}`,\n                );\n                return response;\n            }\n            if (optional) {\n                return undefined as ResponseType<C>; // ResponseType allows undefined for optional commands\n            }\n            throw new MatterFlowError(\"Received invoke response with no result nor response.\");\n        });\n    }\n\n    // TODO Add to ClusterClient when needed/when Group communication is implemented\n    async invokeWithSuppressedResponse<C extends Command<any, any, any>>(options: {\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        request: RequestType<C>;\n        command: C;\n        asTimedRequest?: boolean;\n        timedRequestTimeoutMs?: number;\n    }): Promise<void> {\n        const {\n            endpointId,\n            clusterId,\n            request,\n            command: { requestId, requestSchema, timed },\n            asTimedRequest,\n            timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,\n        } = options;\n        const timedRequest = timed || asTimedRequest === true || options.timedRequestTimeoutMs !== undefined;\n\n        return this.withMessenger<void>(async messenger => {\n            logger.debug(\n                `Invoking command with suppressedResponse: ${resolveCommandName({\n                    endpointId,\n                    clusterId,\n                    commandId: requestId,\n                })} with ${Logger.toJSON(request)}`,\n            );\n            const commandFields = requestSchema.encodeTlv(request);\n\n            if (timedRequest) {\n                await messenger.sendTimedRequest(timedRequestTimeoutMs);\n            }\n\n            const invokeResponse = await messenger.sendInvokeCommand({\n                invokeRequests: [{ commandPath: { endpointId, clusterId, commandId: requestId }, commandFields }],\n                timedRequest,\n                suppressResponse: true,\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n            });\n            if (invokeResponse !== undefined) {\n                throw new MatterFlowError(\n                    \"Response received from invoke interaction but none expected because response is suppressed.\",\n                );\n            }\n\n            logger.debug(\n                `Invoke successful: ${resolveCommandName({\n                    endpointId,\n                    clusterId,\n                    commandId: requestId,\n                })}`,\n            );\n        });\n    }\n\n    private async withMessenger<T>(invoke: (messenger: InteractionClientMessenger) => Promise<T>): Promise<T> {\n        const messenger = new InteractionClientMessenger(this.exchangeProvider);\n        try {\n            return await invoke(messenger);\n        } finally {\n            await messenger.close();\n        }\n    }\n\n    private registerSubscriptionUpdateTimer(\n        subscriptionId: number,\n        maxInterval: number,\n        updateTimeoutHandler: TimerCallback,\n    ) {\n        if (!this.ownSubscriptionIds.has(subscriptionId)) {\n            throw new MatterFlowError(\n                `Cannot register update timer for subscription ${subscriptionId} because it is not owned by this client.`,\n            );\n        }\n\n        // TODO: Add measurement of latency and also consider this in the timeout calculation\n        maxInterval += 5; // Add 5 seconds to the maxInterval to allow at least one full resubmission cycle before assuming the subscription is lost\n        const timer = Time.getTimer(\"Subscription retry\", maxInterval * 1000, () => {\n            logger.info(`Subscription ${subscriptionId} timed out ...`);\n            this.removeSubscription(subscriptionId);\n            // We remove all data because we don't know which data is still valid, so we better read from remote if needed\n            this.subscribedLocalValues.clear();\n            this.subscribedClusterDataVersions.clear();\n            updateTimeoutHandler();\n        }).start();\n        this.subscriptionClient.registerSubscriptionUpdateTimer(subscriptionId, timer);\n    }\n\n    close() {\n        for (const subscriptionId of this.ownSubscriptionIds) {\n            this.removeSubscription(subscriptionId);\n        }\n        this.subscribedLocalValues.clear();\n        this.subscribedClusterDataVersions.clear();\n    }\n\n    get session() {\n        return this.exchangeProvider.session;\n    }\n\n    get channelType() {\n        return this.exchangeProvider.channelType;\n    }\n}\n"],
  "mappings": "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",
  "names": ["endpointId", "clusterId", "attributeId", "event", "commandFields"]
}
