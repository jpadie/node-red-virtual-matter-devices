/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterController } from "../../MatterController.js";
import { Attribute, AttributeJsType, Command, Event, RequestType, ResponseType } from "../../cluster/Cluster.js";
import { AttributeId } from "../../datatype/AttributeId.js";
import { ClusterId } from "../../datatype/ClusterId.js";
import { EndpointNumber } from "../../datatype/EndpointNumber.js";
import { EventId } from "../../datatype/EventId.js";
import { EventNumber } from "../../datatype/EventNumber.js";
import { NodeId } from "../../datatype/NodeId.js";
import { MessageExchange } from "../../protocol/MessageExchange.js";
import { ProtocolHandler } from "../../protocol/ProtocolHandler.js";
import { Timer, TimerCallback } from "../../time/Time.js";
import { TypeFromSchema } from "../../tlv/TlvSchema.js";
import { ExchangeProvider } from "../ExchangeManager.js";
import { DecodedAttributeReportValue } from "./AttributeDataDecoder.js";
import { DecodedEventData, DecodedEventReportValue } from "./EventDataDecoder.js";
import { DataReport } from "./InteractionMessenger.js";
import { TlvEventFilter } from "./InteractionProtocol.js";
import { StatusCode } from "./StatusCode.js";
export interface AttributeStatus {
    path: {
        nodeId?: NodeId;
        endpointId?: EndpointNumber;
        clusterId?: ClusterId;
        attributeId?: AttributeId;
    };
    status: StatusCode;
}
export declare class SubscriptionClient implements ProtocolHandler<MatterController> {
    private readonly subscriptionListeners;
    private readonly subscriptionUpdateTimers;
    constructor();
    getId(): number;
    registerSubscriptionListener(subscriptionId: number, listener: (dataReport: DataReport) => void): void;
    removeSubscriptionListener(subscriptionId: number): void;
    registerSubscriptionUpdateTimer(subscriptionId: number, timer: Timer): void;
    removeSubscriptionUpdateTimer(subscriptionId: number): void;
    onNewExchange(exchange: MessageExchange<MatterController>): Promise<void>;
    close(): Promise<void>;
}
export declare class InteractionClient {
    private readonly exchangeProvider;
    readonly nodeId: NodeId;
    private readonly subscribedLocalValues;
    private readonly subscribedClusterDataVersions;
    private readonly ownSubscriptionIds;
    private readonly subscriptionClient;
    constructor(exchangeProvider: ExchangeProvider, nodeId: NodeId);
    registerSubscriptionListener(subscriptionId: number, listener: (dataReport: DataReport) => void): void;
    removeSubscription(subscriptionId: number): void;
    getAllAttributes(options?: {
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        isFabricFiltered?: boolean;
    }): Promise<DecodedAttributeReportValue<any>[]>;
    getAllEvents(options?: {
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
    }): Promise<DecodedEventReportValue<any>[]>;
    getAllAttributesAndEvents(options?: {
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
    }): Promise<{
        attributeReports: DecodedAttributeReportValue<any>[];
        eventReports: DecodedEventReportValue<any>[];
    }>;
    getMultipleAttributes(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        isFabricFiltered?: boolean;
    }): Promise<DecodedAttributeReportValue<any>[]>;
    getMultipleEvents(options?: {
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
    }): Promise<DecodedEventReportValue<any>[]>;
    getMultipleAttributesAndEvents(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
    }): Promise<{
        attributeReports: DecodedAttributeReportValue<any>[];
        eventReports: DecodedEventReportValue<any>[];
    }>;
    getAttribute<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        isFabricFiltered?: boolean;
        alwaysRequestFromRemote?: boolean;
    }): Promise<AttributeJsType<A> | undefined>;
    getAttributeWithVersion<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        isFabricFiltered?: boolean;
        alwaysRequestFromRemote?: boolean;
    }): Promise<{
        value: AttributeJsType<A>;
        version: number;
    } | undefined>;
    getEvent<T, E extends Event<T, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        event: E;
        minimumEventNumber?: EventNumber;
        isFabricFiltered?: boolean;
    }): Promise<DecodedEventData<T>[] | undefined>;
    private processReadRequest;
    setAttribute<T>(options: {
        attributeData: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            attribute: Attribute<T, any>;
            value: T;
            dataVersion?: number;
        };
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        suppressResponse?: boolean;
    }): Promise<void>;
    setMultipleAttributes(options: {
        attributes: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            attribute: Attribute<any, any>;
            value: any;
            dataVersion?: number;
        }[];
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        suppressResponse?: boolean;
    }): Promise<AttributeStatus[]>;
    subscribeAttribute<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        isFabricFiltered?: boolean;
        knownDataVersion?: number;
        keepSubscriptions?: boolean;
        listener?: (value: AttributeJsType<A>, version: number) => void;
        updateTimeoutHandler?: TimerCallback;
    }): Promise<void>;
    subscribeEvent<T, E extends Event<T, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        event: E;
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        isUrgent?: boolean;
        minimumEventNumber?: EventNumber;
        isFabricFiltered?: boolean;
        listener?: (value: DecodedEventData<T>) => void;
        updateTimeoutHandler?: TimerCallback;
    }): Promise<void>;
    subscribeAllAttributesAndEvents(options: {
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        attributeListener?: (data: DecodedAttributeReportValue<any>) => void;
        eventListener?: (data: DecodedEventReportValue<any>) => void;
        isUrgent?: boolean;
        keepSubscriptions?: boolean;
        isFabricFiltered?: boolean;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        updateTimeoutHandler?: TimerCallback;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
    }>;
    subscribeMultipleAttributesAndEvents(options: {
        attributes: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        events: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
            isUrgent?: boolean;
        }[];
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        keepSubscriptions?: boolean;
        isFabricFiltered?: boolean;
        attributeListener?: (data: DecodedAttributeReportValue<any>) => void;
        eventListener?: (data: DecodedEventReportValue<any>) => void;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        updateTimeoutHandler?: TimerCallback;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
    }>;
    invoke<C extends Command<any, any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        request: RequestType<C>;
        command: C;
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        useExtendedFailSafeMessageResponseTimeout?: boolean;
    }): Promise<ResponseType<C>>;
    invokeWithSuppressedResponse<C extends Command<any, any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        request: RequestType<C>;
        command: C;
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
    }): Promise<void>;
    private withMessenger;
    private registerSubscriptionUpdateTimer;
    close(): void;
    get session(): import("../../session/Session.js").Session<MatterController>;
    get channelType(): import("../../common/Channel.js").ChannelType;
}
//# sourceMappingURL=InteractionClient.d.ts.map