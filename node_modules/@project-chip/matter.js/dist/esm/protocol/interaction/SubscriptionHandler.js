/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { FabricScopedAttributeServer } from "../../cluster/server/AttributeServer.js";
import { FabricSensitiveEventServer } from "../../cluster/server/EventServer.js";
import { InternalError } from "../../common/MatterError.js";
import { EventNumber } from "../../datatype/EventNumber.js";
import { Logger } from "../../log/Logger.js";
import { NetworkError } from "../../net/Network.js";
import { Time } from "../../time/Time.js";
import { MaybePromise } from "../../util/Promises.js";
import { isObject } from "../../util/Type.js";
import { RetransmissionLimitReachedError } from "../MessageExchange.js";
import { InteractionServerMessenger } from "./InteractionMessenger.js";
import {
  INTERACTION_MODEL_REVISION,
  INTERACTION_PROTOCOL_ID,
  attributePathToId,
  clusterPathToId,
  eventPathToId
} from "./InteractionServer.js";
import { StatusCode, StatusResponseError } from "./StatusCode.js";
import { MAX_INTERVAL_PUBLISHER_LIMIT_S } from "./SubscriptionOptions.js";
const logger = Logger.get("SubscriptionHandler");
class SubscriptionHandler {
  subscriptionId;
  session;
  endpointStructure;
  attributeRequests;
  dataVersionFilters;
  eventRequests;
  eventFilters;
  isFabricFiltered;
  cancelCallback;
  readAttribute;
  readEvent;
  lastUpdateTimeMs = 0;
  updateTimer;
  sendDelayTimer;
  outstandingAttributeUpdates = /* @__PURE__ */ new Map();
  outstandingEventUpdates = /* @__PURE__ */ new Set();
  attributeListeners = /* @__PURE__ */ new Map();
  eventListeners = /* @__PURE__ */ new Map();
  sendUpdatesActivated = false;
  #maxIntervalMs;
  #sendIntervalMs;
  minIntervalFloorMs;
  maxIntervalCeilingMs;
  server;
  fabric;
  peerNodeId;
  sendingUpdateInProgress = false;
  sendNextUpdateImmediately = false;
  sendUpdateErrorCounter = 0;
  attributeUpdatePromises = /* @__PURE__ */ new Set();
  constructor(options) {
    const {
      subscriptionId,
      session,
      endpointStructure,
      attributeRequests,
      dataVersionFilters,
      eventRequests,
      eventFilters,
      isFabricFiltered,
      minIntervalFloor,
      maxIntervalCeiling,
      cancelCallback,
      subscriptionOptions
    } = options;
    this.subscriptionId = subscriptionId;
    this.session = session;
    this.endpointStructure = endpointStructure;
    this.attributeRequests = attributeRequests;
    this.dataVersionFilters = dataVersionFilters;
    this.eventRequests = eventRequests;
    this.eventFilters = eventFilters;
    this.isFabricFiltered = isFabricFiltered;
    this.cancelCallback = cancelCallback;
    this.readAttribute = options.readAttribute;
    this.readEvent = options.readEvent;
    this.server = this.session.context;
    this.fabric = this.session.associatedFabric;
    this.peerNodeId = this.session.peerNodeId;
    this.minIntervalFloorMs = minIntervalFloor * 1e3;
    this.maxIntervalCeilingMs = maxIntervalCeiling * 1e3;
    const { maxInterval, sendInterval } = this.determineSendingIntervals(
      subscriptionOptions.minIntervalSeconds * 1e3,
      subscriptionOptions.maxIntervalSeconds * 1e3,
      subscriptionOptions.randomizationWindowSeconds * 1e3
    );
    this.#maxIntervalMs = maxInterval;
    this.#sendIntervalMs = sendInterval;
    this.updateTimer = Time.getTimer("Subscription update", this.#sendIntervalMs, () => this.prepareDataUpdate());
    this.sendDelayTimer = Time.getTimer("Subscription delay", 50, () => this.sendUpdate());
  }
  determineSendingIntervals(subscriptionMinIntervalMs, subscriptionMaxIntervalMs, subscriptionRandomizationWindowMs) {
    const maxInterval = Math.min(
      Math.max(
        subscriptionMinIntervalMs,
        Math.max(this.minIntervalFloorMs, Math.min(subscriptionMaxIntervalMs, this.maxIntervalCeilingMs))
      ) + Math.floor(subscriptionRandomizationWindowMs * Math.random()),
      MAX_INTERVAL_PUBLISHER_LIMIT_S * 1e3
    );
    let sendInterval = Math.floor(maxInterval / 2);
    if (sendInterval < 6e4) {
      sendInterval = Math.max(this.minIntervalFloorMs, Math.floor(maxInterval * 0.8));
    }
    if (sendInterval < subscriptionMinIntervalMs) {
      logger.warn(
        `Determined subscription send interval of ${sendInterval}ms is too low. Using maxInterval (${maxInterval}ms) instead.`
      );
      sendInterval = subscriptionMinIntervalMs;
    }
    return { maxInterval, sendInterval };
  }
  registerNewAttributes() {
    const newAttributes = new Array();
    const attributeErrors = new Array();
    const formerAttributes = new Set(this.attributeListeners.keys());
    if (this.attributeRequests !== void 0) {
      this.attributeRequests.forEach((path) => {
        const attributes = this.endpointStructure.getAttributes([path]);
        if (attributes.length === 0) {
          const { endpointId, clusterId, attributeId } = path;
          if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
            logger.debug(
              `Subscription attribute ${this.endpointStructure.resolveAttributeName(
                path
              )}: ignore non-existing attribute`
            );
          } else {
            try {
              this.endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
              throw new InternalError(
                "validateConcreteAttributePath check should throw StatusResponseError but did not."
              );
            } catch (e) {
              StatusResponseError.accept(e);
              logger.debug(
                `Subscription attribute ${this.endpointStructure.resolveAttributeName(
                  path
                )}: unsupported path: Status=${e.code}`
              );
              attributeErrors.push({ path, status: { status: e.code } });
            }
          }
          return;
        }
        attributes.forEach(({ path: path2, attribute }) => {
          formerAttributes.delete(attributePathToId(path2));
          const existingAttributeListener = this.attributeListeners.get(attributePathToId(path2));
          if (existingAttributeListener !== void 0) {
            const { attribute: existingAttribute, listener: existingListener } = existingAttributeListener;
            if (existingAttribute !== attribute) {
              if (existingListener !== void 0) {
                existingAttribute.removeValueChangeListener(existingListener);
              }
              this.attributeListeners.delete(attributePathToId(path2));
            } else {
              return;
            }
          }
          if (attribute.isSubscribable) {
            const listener = (value, version) => this.attributeChangeListener(path2, attribute.schema, version, value);
            attribute.addValueChangeListener(listener);
            this.attributeListeners.set(attributePathToId(path2), { attribute, listener });
          } else {
            this.attributeListeners.set(attributePathToId(path2), { attribute });
          }
          newAttributes.push({ path: path2, attribute });
        });
      });
    }
    this.unregisterAttributeListeners(Array.from(formerAttributes.values()));
    return { newAttributes, attributeErrors };
  }
  unregisterAttributeListeners(list) {
    for (const pathId of list) {
      const existingAttributeListener = this.attributeListeners.get(pathId);
      if (existingAttributeListener !== void 0) {
        const { attribute, listener } = existingAttributeListener;
        if (listener !== void 0) {
          attribute.removeValueChangeListener(listener);
        }
        this.attributeListeners.delete(pathId);
      }
    }
  }
  registerNewEvents() {
    const newEvents = new Array();
    const eventErrors = new Array();
    const formerEvents = new Set(this.eventListeners.keys());
    if (this.eventRequests !== void 0) {
      this.eventRequests.forEach((path) => {
        const events = this.endpointStructure.getEvents([path]);
        if (events.length === 0) {
          const { endpointId, clusterId, eventId } = path;
          if (endpointId === void 0 || clusterId === void 0 || eventId === void 0) {
            logger.debug(
              `Subscription event ${this.endpointStructure.resolveEventName(
                path
              )}: ignore non-existing event`
            );
          } else {
            try {
              this.endpointStructure.validateConcreteEventPath(endpointId, clusterId, eventId);
              throw new InternalError(
                "validateConcreteEventPath should throw StatusResponseError but did not."
              );
            } catch (e) {
              StatusResponseError.accept(e);
              logger.debug(
                `Subscription event ${this.endpointStructure.resolveEventName(
                  path
                )}: unsupported path: Status=${e.code}`
              );
              eventErrors.push({ path, status: { status: e.code } });
            }
          }
          return;
        }
        events.forEach(({ path: path2, event }) => {
          formerEvents.delete(eventPathToId(path2));
          const existingEventListener = this.eventListeners.get(eventPathToId(path2));
          if (existingEventListener !== void 0) {
            const { event: existingEvent, listener: existingListener } = existingEventListener;
            if (existingEvent !== event) {
              if (existingListener !== void 0) {
                existingEvent.removeListener(existingListener);
              }
              this.eventListeners.delete(eventPathToId(path2));
            } else {
              return;
            }
          }
          const listener = (newEvent) => this.eventChangeListener(path2, event.schema, newEvent);
          event.addListener(listener);
          newEvents.push({ path: path2, event });
          this.eventListeners.set(eventPathToId(path2), { event, listener });
        });
      });
    }
    this.unregisterEventListeners(Array.from(formerEvents.values()));
    return { newEvents, eventErrors };
  }
  unregisterEventListeners(list) {
    for (const pathId of list) {
      const existingEventListener = this.eventListeners.get(pathId);
      if (existingEventListener !== void 0) {
        const { event, listener } = existingEventListener;
        if (listener !== void 0) {
          event.removeListener(listener);
        }
        this.eventListeners.delete(pathId);
      }
    }
  }
  /**
   * Update the session after an endpoint structure change. The method will initialize all missing new attributes and
   * events and will remove listeners no longer needed.
   * Newly added attributes are then treated ad "changed values" and will be sent as subscription data update to the
   * controller. The data of newly added events are not sent automatically.
   */
  async updateSubscription() {
    const { newAttributes } = this.registerNewAttributes();
    for (const { path, attribute } of newAttributes) {
      const { version, value } = await this.readAttribute(path, attribute);
      this.outstandingAttributeUpdates.set(attributePathToId(path), {
        attribute,
        path,
        schema: attribute.schema,
        version,
        value
      });
    }
    const { newEvents } = this.registerNewEvents();
    newEvents.flatMap(({ path, event }) => {
      const { schema } = event;
      const matchingEvents = event.get(this.session, this.isFabricFiltered, void 0, this.eventFilters);
      return matchingEvents.map((data) => ({
        event,
        schema,
        path,
        data
      }));
    }).sort((a, b) => {
      const eventNumberA = a.data?.eventNumber ?? EventNumber(0);
      const eventNumberB = b.data?.eventNumber ?? EventNumber(0);
      if (eventNumberA > eventNumberB) {
        return 1;
      } else if (eventNumberA < eventNumberB) {
        return -1;
      } else {
        return 0;
      }
    }).forEach((event) => this.outstandingEventUpdates.add(event));
    this.prepareDataUpdate();
  }
  get maxInterval() {
    return Math.ceil(this.#maxIntervalMs / 1e3);
  }
  get sendInterval() {
    return Math.ceil(this.#sendIntervalMs / 1e3);
  }
  activateSendingUpdates() {
    if (this.eventFilters !== void 0) this.eventFilters.length = 0;
    if (this.dataVersionFilters !== void 0) this.dataVersionFilters.length = 0;
    this.sendUpdatesActivated = true;
    if (this.outstandingAttributeUpdates.size > 0 || this.outstandingEventUpdates.size > 0) {
      void this.sendUpdate();
    }
    this.updateTimer = Time.getTimer(
      "Subscription update",
      this.#sendIntervalMs,
      () => this.prepareDataUpdate()
    ).start();
  }
  /**
   * Check if data should be sent straight away or delayed because the minimum interval is not reached. Delay real
   * sending by 50ms in any case to mke sure to catch all updates.
   */
  prepareDataUpdate() {
    if (this.sendDelayTimer.isRunning) {
      return;
    }
    if (!this.sendUpdatesActivated) {
      return;
    }
    this.updateTimer.stop();
    const now = Time.nowMs();
    const timeSinceLastUpdateMs = now - this.lastUpdateTimeMs;
    if (timeSinceLastUpdateMs < this.minIntervalFloorMs) {
      this.updateTimer = Time.getTimer(
        "Subscription update",
        this.minIntervalFloorMs - timeSinceLastUpdateMs,
        () => this.prepareDataUpdate()
      ).start();
      return;
    }
    this.sendDelayTimer.start();
    this.updateTimer = Time.getTimer(
      "Subscription update",
      this.#sendIntervalMs,
      () => this.prepareDataUpdate()
    ).start();
  }
  /**
   * Determine all attributes that have changed since the last update and send them tout to the subscriber.
   */
  async sendUpdate() {
    if (this.sendingUpdateInProgress) {
      logger.debug("Sending update already in progress, delaying update ...");
      this.sendNextUpdateImmediately = true;
      return;
    }
    const attributeUpdatesToSend = new Array();
    const attributeUpdates = {};
    Array.from(this.outstandingAttributeUpdates.values()).forEach((entry) => {
      const {
        path: { nodeId, endpointId, clusterId }
      } = entry;
      const pathId = `${nodeId}-${endpointId}-${clusterId}`;
      attributeUpdates[pathId] = attributeUpdates[pathId] ?? [];
      attributeUpdates[pathId].push(entry);
    });
    this.outstandingAttributeUpdates.clear();
    Object.values(attributeUpdates).forEach(
      (data) => attributeUpdatesToSend.push(
        ...data.sort(({ version: versionA }, { version: versionB }) => versionA - versionB)
      )
    );
    const eventUpdatesToSend = Array.from(this.outstandingEventUpdates.values());
    this.outstandingEventUpdates.clear();
    this.lastUpdateTimeMs = Time.nowMs();
    this.sendingUpdateInProgress = true;
    try {
      await this.sendUpdateMessage(attributeUpdatesToSend, eventUpdatesToSend);
      this.sendUpdateErrorCounter = 0;
    } catch (error) {
      if (this.server.isClosing) {
        return;
      }
      this.sendUpdateErrorCounter++;
      logger.error(
        `Error sending subscription update message (error count=${this.sendUpdateErrorCounter}):`,
        error
      );
      if (this.sendUpdateErrorCounter <= 2) {
        const newAttributeUpdatesToSend = Array.from(this.outstandingAttributeUpdates.values());
        this.outstandingAttributeUpdates.clear();
        const newEventUpdatesToSend = Array.from(this.outstandingEventUpdates.values());
        this.outstandingEventUpdates.clear();
        [...attributeUpdatesToSend, ...newAttributeUpdatesToSend].forEach(
          (update) => this.outstandingAttributeUpdates.set(attributePathToId(update.path), update)
        );
        [...eventUpdatesToSend, ...newEventUpdatesToSend].forEach(
          (update) => this.outstandingEventUpdates.add(update)
        );
      } else {
        logger.error(
          `Sending update failed 3 times in a row, canceling subscription ${this.subscriptionId} and let controller subscribe again.`
        );
        this.sendNextUpdateImmediately = false;
        if (error instanceof RetransmissionLimitReachedError || error instanceof NetworkError) {
          await this.session.destroy(false);
        } else {
          throw error;
        }
      }
    }
    this.sendingUpdateInProgress = false;
    if (this.sendNextUpdateImmediately) {
      logger.debug("Sending delayed update immediately after last one was sent.");
      this.sendNextUpdateImmediately = false;
      await this.sendUpdate();
    }
  }
  async sendInitialReport(messenger) {
    this.updateTimer.stop();
    const { newAttributes, attributeErrors } = this.registerNewAttributes();
    const dataVersionFilterMap = new Map(
      this.dataVersionFilters?.map(({ path, dataVersion }) => [clusterPathToId(path), dataVersion]) ?? []
    );
    let attributesFilteredWithVersion = false;
    const attributes = new Array();
    for (const { path, attribute } of newAttributes) {
      try {
        const { value, version } = await this.readAttribute(path, attribute);
        if (value === void 0) continue;
        const { nodeId, endpointId, clusterId } = path;
        const versionFilterValue = endpointId !== void 0 && clusterId !== void 0 ? dataVersionFilterMap.get(clusterPathToId({ nodeId, endpointId, clusterId })) : void 0;
        if (versionFilterValue !== void 0 && versionFilterValue === version) {
          attributesFilteredWithVersion = true;
          continue;
        }
        attributes.push({ path, value, version, schema: attribute.schema, attribute });
      } catch (error) {
        logger.error(`Error reading attribute ${this.endpointStructure.resolveAttributeName(path)}:`, error);
      }
    }
    const attributeReportsPayload = attributes.map(
      ({ path, schema, value, version, attribute }) => ({
        hasFabricSensitiveData: attribute.hasFabricSensitiveData,
        attributeData: {
          path,
          dataVersion: version,
          payload: value,
          schema
        }
      })
    );
    attributeErrors.forEach(
      (attributeStatus) => attributeReportsPayload.push({
        hasFabricSensitiveData: false,
        attributeStatus
      })
    );
    const { newEvents, eventErrors } = this.registerNewEvents();
    let eventsFiltered = false;
    const eventReportsPayload = new Array();
    for (const { path, event } of newEvents) {
      const { schema } = event;
      try {
        const matchingEvents = await this.readEvent(path, event, this.eventFilters);
        if (matchingEvents.length === 0) {
          eventsFiltered = true;
        } else {
          matchingEvents.forEach(({ eventNumber, priority, epochTimestamp, data }) => {
            eventReportsPayload.push({
              hasFabricSensitiveData: event.hasFabricSensitiveData,
              eventData: {
                path,
                eventNumber,
                priority,
                epochTimestamp,
                payload: data,
                schema
              }
            });
          });
        }
      } catch (error) {
        logger.error(`Error reading event ${this.endpointStructure.resolveEventName(path)}:`, error);
      }
    }
    eventReportsPayload.sort((a, b) => {
      const eventNumberA = a.eventData?.eventNumber ?? 0;
      const eventNumberB = b.eventData?.eventNumber ?? 0;
      if (eventNumberA > eventNumberB) {
        return 1;
      } else if (eventNumberA < eventNumberB) {
        return -1;
      } else {
        return 0;
      }
    });
    if (attributes.length === 0 && !attributesFilteredWithVersion && eventReportsPayload.length === 0 && !eventsFiltered) {
      throw new StatusResponseError(
        "Subscription failed because no attributes or events are matching the query",
        StatusCode.InvalidAction
      );
    }
    eventErrors.forEach(
      (eventStatus) => eventReportsPayload.push({
        hasFabricSensitiveData: false,
        eventStatus
      })
    );
    logger.debug(
      `Initialize Subscription with ${attributes.length} attributes and ${eventReportsPayload.length} events.`
    );
    this.lastUpdateTimeMs = Time.nowMs();
    await messenger.sendDataReport(
      {
        suppressResponse: false,
        // we always need proper response for initial report
        subscriptionId: this.subscriptionId,
        interactionModelRevision: INTERACTION_MODEL_REVISION,
        attributeReportsPayload,
        eventReportsPayload
      },
      this.isFabricFiltered
    );
  }
  attributeChangeListener(path, schema, version, value) {
    const changeResult = this.attributeChangeHandler(path, schema, version, value);
    if (MaybePromise.is(changeResult)) {
      const resolver = Promise.resolve(changeResult).catch((error) => logger.error(`Error handling attribute change:`, error)).finally(() => this.attributeUpdatePromises.delete(resolver));
      this.attributeUpdatePromises.add(resolver);
    }
  }
  attributeChangeHandler(path, schema, version, value) {
    const attributeListenerData = this.attributeListeners.get(attributePathToId(path));
    if (attributeListenerData === void 0) return;
    const { attribute } = attributeListenerData;
    if (attribute instanceof FabricScopedAttributeServer) {
      return this.readAttribute(path, attribute).then(({ value: value2 }) => {
        this.outstandingAttributeUpdates.set(attributePathToId(path), {
          attribute,
          path,
          schema,
          version,
          value: value2
        });
        this.prepareDataUpdate();
      });
    }
    this.outstandingAttributeUpdates.set(attributePathToId(path), { attribute, path, schema, version, value });
    this.prepareDataUpdate();
  }
  eventChangeListener(path, schema, newEvent) {
    const eventListenerData = this.eventListeners.get(eventPathToId(path));
    if (eventListenerData === void 0) return;
    const { event } = eventListenerData;
    if (event instanceof FabricSensitiveEventServer) {
      const { data } = newEvent;
      if (isObject(data) && "fabricIndex" in data && data.fabricIndex !== this.session.fabric?.fabricIndex) {
        return;
      }
    }
    this.outstandingEventUpdates.add({ event, path, schema, data: newEvent });
    if (path.isUrgent) {
      this.prepareDataUpdate();
    }
  }
  async flush() {
    this.sendDelayTimer.stop();
    logger.debug(
      `Flushing subscription ${this.subscriptionId} with ${this.outstandingAttributeUpdates.size} attributes and ${this.outstandingEventUpdates.size} events`
    );
    if (this.outstandingAttributeUpdates.size > 0 || this.outstandingEventUpdates.size > 0) {
      void this.sendUpdate();
    }
  }
  async cancel(flush = false, cancelledByPeer = false) {
    this.sendUpdatesActivated = false;
    if (this.attributeUpdatePromises.size) {
      const resolvers = [...this.attributeUpdatePromises.values()];
      this.attributeUpdatePromises.clear();
      await Promise.all(resolvers);
    }
    this.updateTimer.stop();
    this.sendDelayTimer.stop();
    this.unregisterAttributeListeners(Array.from(this.attributeListeners.keys()));
    this.unregisterEventListeners(Array.from(this.eventListeners.keys()));
    if (flush) {
      await this.flush();
    }
    this.session.removeSubscription(this.subscriptionId);
    this.cancelCallback();
    if (cancelledByPeer) {
      await this.session.context.startAnnouncement();
    }
  }
  async sendUpdateMessage(attributes, events) {
    logger.debug(
      `Sending subscription update message for ID ${this.subscriptionId} with ${attributes.length} attributes and ${events.length} events`
    );
    const exchange = this.server.initiateExchange(this.fabric, this.peerNodeId, INTERACTION_PROTOCOL_ID);
    if (exchange === void 0) return;
    logger.debug(
      `Sending subscription changes for ID ${this.subscriptionId}: ${attributes.map(
        ({ path, value, version }) => `${this.endpointStructure.resolveAttributeName(path)}=${Logger.toJSON(value)} (${version})`
      ).join(", ")}`
    );
    const messenger = new InteractionServerMessenger(exchange);
    try {
      if (attributes.length === 0 && events.length === 0) {
        await messenger.sendDataReport(
          {
            suppressResponse: true,
            // suppressResponse true for empty DataReports
            subscriptionId: this.subscriptionId,
            interactionModelRevision: INTERACTION_MODEL_REVISION
          },
          this.isFabricFiltered
        );
      } else {
        await messenger.sendDataReport(
          {
            suppressResponse: false,
            // Non empty data reports always need to send response
            subscriptionId: this.subscriptionId,
            interactionModelRevision: INTERACTION_MODEL_REVISION,
            attributeReportsPayload: attributes.map(({ path, schema, value, version, attribute }) => ({
              hasFabricSensitiveData: attribute.hasFabricSensitiveData,
              attributeData: {
                path,
                dataVersion: version,
                schema,
                payload: value
              }
            })),
            eventReportsPayload: events.map(({ path, schema, event, data }) => {
              const { eventNumber, priority, epochTimestamp, data: payload } = data;
              return {
                hasFabricSensitiveData: event.hasFabricSensitiveData,
                eventData: {
                  path,
                  eventNumber,
                  priority,
                  epochTimestamp,
                  schema,
                  payload
                }
              };
            })
          },
          this.isFabricFiltered
        );
      }
    } catch (e) {
      if (StatusResponseError.is(e, StatusCode.InvalidSubscription, StatusCode.Failure)) {
        logger.info(`Subscription ${this.subscriptionId} cancelled by peer.`);
        await this.cancel(false, true);
      } else {
        await this.cancel(false);
        throw e;
      }
    } finally {
      await messenger.close();
    }
  }
}
export {
  SubscriptionHandler
};
//# sourceMappingURL=SubscriptionHandler.js.map
