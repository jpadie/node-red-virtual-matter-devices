{
  "version": 3,
  "sources": ["../../../src/storage/StorageBackendMemory.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { StorageError, SyncStorage } from \"./Storage.js\";\nimport { SupportedStorageTypes } from \"./StringifyTools.js\";\n\nexport class StorageBackendMemory extends SyncStorage {\n    protected isInitialized = false;\n\n    constructor(protected store: any = {}) {\n        super();\n    }\n\n    get initialized() {\n        return this.isInitialized;\n    }\n\n    static async create(store: any = {}) {\n        const storage = new StorageBackendMemory(store);\n        storage.initialize();\n        return storage;\n    }\n\n    private createContextKey(contexts: string[]) {\n        const key = contexts.join(\".\");\n        if (!key.length || key.includes(\"..\") || key.startsWith(\".\") || key.endsWith(\".\"))\n            throw new StorageError(\"Context must not be an empty string.\");\n        return key;\n    }\n\n    initialize() {\n        if (this.initialized) throw new StorageError(\"Storage already initialized!\");\n        this.isInitialized = true;\n        // nothing else to do\n    }\n\n    close() {\n        this.isInitialized = false;\n        // nothing to do\n    }\n\n    clear() {\n        this.store = {};\n    }\n\n    get<T extends SupportedStorageTypes>(contexts: string[], key: string): T | undefined {\n        if (!this.initialized) throw new StorageError(\"Storage is not initialized\");\n        if (!contexts.length || !key.length) throw new StorageError(\"Context and key must not be empty.\");\n        return this.store[this.createContextKey(contexts)]?.[key];\n    }\n\n    #setKey(contexts: string[], key: string, value: SupportedStorageTypes) {\n        if (!contexts.length || !key.length) throw new StorageError(\"Context and key must not be empty.\");\n        const contextKey = this.createContextKey(contexts);\n        if (this.store[contextKey] === undefined) {\n            this.store[contextKey] = {};\n        }\n        this.store[contextKey][key] = value;\n    }\n\n    set(\n        contexts: string[],\n        keyOrValues: string | Record<string, SupportedStorageTypes>,\n        value?: SupportedStorageTypes,\n    ) {\n        if (!this.initialized) throw new StorageError(\"Storage is not initialized\");\n        if (typeof keyOrValues === \"string\") {\n            this.#setKey(contexts, keyOrValues, value);\n        } else {\n            Object.entries(keyOrValues).forEach(([key, value]) => {\n                this.#setKey(contexts, key, value);\n            });\n        }\n    }\n\n    delete(contexts: string[], key: string) {\n        if (!this.initialized) throw new StorageError(\"Storage is not initialized\");\n        if (!contexts.length || !key.length) throw new StorageError(\"Context and key must not be empty.\");\n        delete this.store[this.createContextKey(contexts)]?.[key];\n    }\n\n    keys(contexts: string[]) {\n        if (!this.initialized) throw new StorageError(\"Storage is not initialized\");\n        if (!contexts.length) throw new StorageError(\"Context must not be empty!\");\n        return Object.keys(this.store[this.createContextKey(contexts)] ?? {});\n    }\n\n    values(contexts: string[]) {\n        // Initialize and context checks are done by keys method\n        const values = {} as Record<string, SupportedStorageTypes>;\n        for (const key of this.keys(contexts)) {\n            values[key] = this.get(contexts, key);\n        }\n        return values;\n    }\n\n    contexts(contexts: string[]) {\n        if (!this.initialized) throw new StorageError(\"Storage is not initialized\");\n        const contextKey = contexts.length ? this.createContextKey(contexts) : \"\";\n        const startContextKey = contextKey.length ? `${contextKey}.` : \"\";\n        const foundContexts = new Array<string>();\n        Object.keys(this.store).forEach(key => {\n            if (key.startsWith(startContextKey)) {\n                const subKeys = key.substring(startContextKey.length).split(\".\");\n                if (subKeys.length < 1) return; // should never happen\n                const context = subKeys[0];\n                if (!foundContexts.includes(context)) {\n                    foundContexts.push(context);\n                }\n            }\n        });\n        return foundContexts;\n    }\n\n    clearAll(contexts: string[]) {\n        if (!this.initialized) throw new StorageError(\"Storage is not initialized\");\n        const contextKey = this.createContextKey(contexts);\n        if (contextKey.length) {\n            delete this.store[contextKey];\n        }\n        const startContextKey = contextKey.length ? `${contextKey}.` : \"\";\n        Object.keys(this.store).forEach(key => {\n            if (key.startsWith(startContextKey)) {\n                delete this.store[key];\n            }\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
