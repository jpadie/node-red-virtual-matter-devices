/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterController } from "./MatterController.js";
import { MatterNode } from "./MatterNode.js";
import { CommissionableDevice, CommissionableDeviceIdentifiers, DiscoveryData } from "./common/Scanner.js";
import { ServerAddress } from "./common/ServerAddress.js";
import { CaseAuthenticatedTag } from "./datatype/CaseAuthenticatedTag.js";
import { FabricId } from "./datatype/FabricId.js";
import { FabricIndex } from "./datatype/FabricIndex.js";
import { NodeId } from "./datatype/NodeId.js";
import { VendorId } from "./datatype/VendorId.js";
import { CommissioningControllerNodeOptions, PairedNode } from "./device/PairedNode.js";
import { Environment } from "./environment/Environment.js";
import { MdnsBroadcaster } from "./mdns/MdnsBroadcaster.js";
import { MdnsScanner } from "./mdns/MdnsScanner.js";
import { CommissioningOptions } from "./protocol/ControllerCommissioner.js";
import { InteractionClient } from "./protocol/interaction/InteractionClient.js";
import { TypeFromPartialBitSchema } from "./schema/BitmapSchema.js";
import { DiscoveryCapabilitiesBitmap } from "./schema/PairingCodeSchema.js";
import { SyncStorage } from "./storage/Storage.js";
import { StorageContext } from "./storage/StorageContext.js";
import { SupportedStorageTypes } from "./storage/StringifyTools.js";
export type ControllerEnvironmentOptions = {
    /**
     * Environment to register the node with on start()
     */
    readonly environment: Environment;
    /**
     * Unique id to register to node.
     */
    readonly id: string;
};
/**
 * Constructor options for the CommissioningController class
 */
export type CommissioningControllerOptions = CommissioningControllerNodeOptions & {
    /**
     * Local port number to use for the UDP interface. By default, a random port number will be generated
     * (strongly recommended!).
     */
    readonly localPort?: number;
    /** Listening address for IPv4. By default, the interface will listen on all IPv4 addresses. */
    readonly listeningAddressIpv4?: string;
    /** Listening address for IPv6. By default, the interface will listen on all IPv6 addresses. */
    readonly listeningAddressIpv6?: string;
    /**
     * If set to false, the controller will not connect to any device on startup. You need to use connectNode() or
     * connect() to connect to the relevant nodes in this case. Else all nodes are connected on startup.
     * */
    readonly autoConnect?: boolean;
    /** Admin Vendor ID used for all commissioning operations. Cannot be changed afterward. Default: 0xFFF1 */
    readonly adminVendorId?: VendorId;
    /**
     * Controller own Fabric ID used to initialize the Controller the first time and to generate the Root certificate.
     * Cannot be changed afterward.
     * Default: 1
     */
    readonly adminFabricId?: FabricId;
    /**
     * Fabric Index used to initialize the Controller the first time. Cannot be changed afterward.
     * Default: 1
     */
    readonly adminFabricIndex?: FabricIndex;
    /**
     * CASE Authenticated Tags used to initialize the Controller the first time. Cannot be changed afterward.
     * Maximum 3 tags are supported.
     */
    readonly caseAuthenticatedTags?: CaseAuthenticatedTag[];
    /**
     * When used with the new API Environment set the environment here and the CommissioningServer will self-register
     * on the environment when you call start().
     */
    readonly environment?: ControllerEnvironmentOptions;
};
/** Options needed to commission a new node */
export type NodeCommissioningOptions = CommissioningControllerNodeOptions & {
    /** Commission related options. */
    commissioning?: CommissioningOptions;
    /** Discovery related options. */
    discovery: ({
        /**
         * Device identifiers (Short or Long Discriminator, Product/Vendor-Ids, Device-type or a pre-discovered
         * instance Id, or "nothing" to discover all commissionable matter devices) to use for discovery.
         * If the property commissionableDevice is provided this property is ignored.
         */
        identifierData: CommissionableDeviceIdentifiers;
    } | {
        /**
         * Commissionable device object returned by a discovery run.
         * If this property is provided then identifierData and knownAddress are ignored.
         */
        commissionableDevice: CommissionableDevice;
    }) & {
        /**
         * Discovery capabilities to use for discovery. These are included in the QR code normally and defined if BLE
         * is supported for initial commissioning.
         */
        discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>;
        /**
         * Known address of the device to use for discovery. if this is set this will be tried first before discovering
         * the device.
         */
        knownAddress?: ServerAddress;
        /** Timeout in seconds for the discovery process. Default: 30 seconds */
        timeoutSeconds?: number;
    };
    /** Passcode to use for commissioning. */
    passcode: number;
};
/** Controller class to commission and connect multiple nodes into one fabric. */
export declare class CommissioningController extends MatterNode {
    private readonly options;
    private started;
    private ipv4Disabled?;
    private readonly listeningAddressIpv4?;
    private readonly listeningAddressIpv6?;
    private environment?;
    private storage?;
    private mdnsScanner?;
    private controllerInstance?;
    private connectedNodes;
    private sessionDisconnectedHandler;
    /**
     * Creates a new CommissioningController instance
     *
     * @param options The options for the CommissioningController
     */
    constructor(options: CommissioningControllerOptions);
    get nodeId(): NodeId | undefined;
    get paseCommissionerData(): {
        rootCertificateData: import("./certificate/RootCertificateManager.js").RootCertificateManager.Data;
        fabricData: import("./fabric/Fabric.js").FabricJsonObject;
    };
    assertIsAddedToMatterServer(): {
        mdnsScanner: MdnsScanner;
        storage: StorageContext<any> | undefined;
        environment: Environment | undefined;
    };
    assertControllerIsStarted(errorText?: string): MatterController;
    /** Internal method to initialize a MatterController instance. */
    private initializeController;
    /**
     * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned node.
     */
    commissionNode(nodeOptions: NodeCommissioningOptions, connectNodeAfterCommissioning?: boolean): Promise<NodeId>;
    /**
     * Completes the commissioning process for a node when the initial commissioning process was done by a PASE
     * commissioner. This method should be called to discover the device operational and complete the commissioning
     * process.
     */
    completeCommissioningForNode(peerNodeId: NodeId, discoveryData?: DiscoveryData): Promise<void>;
    /** Check if a given node id is commissioned on this controller. */
    isNodeCommissioned(nodeId: NodeId): boolean;
    /**
     * Remove a Node id from the controller. This method should only be used if the decommission method on the
     * PairedNode instance returns an error. By default it tries to decommission the node from the controller but will
     * remove it also in case of an error during decommissioning. Ideally try to decommission the node before and only
     * use this in case of an error.
     */
    removeNode(nodeId: NodeId, tryDecommissioning?: boolean): Promise<void>;
    disconnectNode(nodeId: NodeId): Promise<void>;
    /**
     * Connect to an already paired Node.
     * After connection the endpoint data of the device is analyzed and an object structure is created.
     */
    connectNode(nodeId: NodeId, connectOptions?: CommissioningControllerNodeOptions): Promise<PairedNode>;
    private enhanceDeviceDetailsFromCache;
    private enhanceDeviceDetailsFromRemote;
    /**
     * Connects to all paired nodes.
     * After connection the endpoint data of the device is analyzed and an object structure is created.
     */
    connect(connectOptions?: CommissioningControllerNodeOptions): Promise<PairedNode[]>;
    /**
     * Set the MDNS Scanner instance. Should be only used internally
     *
     * @param mdnsScanner MdnsScanner instance
     */
    setMdnsScanner(mdnsScanner: MdnsScanner): void;
    /**
     * Set the MDNS Broadcaster instance. Should be only used internally
     *
     * @param _mdnsBroadcaster MdnsBroadcaster instance
     */
    setMdnsBroadcaster(_mdnsBroadcaster: MdnsBroadcaster): void;
    /**
     * Set the Storage instance. Should be only used internally
     *
     * @param storage storage context to use
     */
    setStorage(storage: StorageContext<SyncStorage>): void;
    /** Returns true if t least one node is commissioned/paired with this controller instance. */
    isCommissioned(): boolean;
    /**
     * Creates and Return a new InteractionClient to communicate with a node. This is mainly used internally and should
     * not be used directly. See the PairedNode class for the public API.
     */
    createInteractionClient(nodeId: NodeId): Promise<InteractionClient>;
    /** Returns the PairedNode instance for a given node id, if this node is connected. */
    getConnectedNode(nodeId: NodeId): PairedNode | undefined;
    /** Returns an array with the Node Ids for all commissioned nodes. */
    getCommissionedNodes(): NodeId[];
    getCommissionedNodesDetails(): {
        nodeId: NodeId;
        operationalAddress: string | undefined;
        advertisedName: string | undefined;
        discoveryData: DiscoveryData | undefined;
        basicInformationData: Record<string, SupportedStorageTypes> | undefined;
    }[];
    /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */
    close(): Promise<void>;
    getPort(): number | undefined;
    initialize(ipv4Disabled: boolean): void;
    /** Initialize the controller and connect to all commissioned nodes if autoConnect is not set to false. */
    start(): Promise<void>;
    cancelCommissionableDeviceDiscovery(identifierData: CommissionableDeviceIdentifiers, discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>): void;
    discoverCommissionableDevices(identifierData: CommissionableDeviceIdentifiers, discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>, discoveredCallback?: (device: CommissionableDevice) => void, timeoutSeconds?: number): Promise<CommissionableDevice[]>;
    resetStorage(): Promise<void>;
    /** Returns active session information for all connected nodes. */
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("./fabric/Fabric.js").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
}
//# sourceMappingURL=CommissioningController.d.ts.map