/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ByteArray } from "./ByteArray.js";
function isIPv4(ip) {
  return ip.includes(".");
}
function isIPv6(ip) {
  return ip.includes(":");
}
function iPv4ToNumber(ip) {
  const dataView = iPv4ToArray(ip).getDataView();
  return dataView.getUint32(0);
}
function iPv4ToArray(ip) {
  const array = new Uint8Array(4);
  const ipParts = ip.split(".");
  for (let i = 0; i < 4; i++) {
    array[i] = parseInt(ipParts[i]);
  }
  return array;
}
function iPv4ToByteArray(ip) {
  return ByteArray.from(iPv4ToArray(ip));
}
function iPv6ToArray(ip) {
  const array = new Uint16Array(8);
  let ipParts = ip.split(":");
  const valueCount = ipParts.filter((value) => value !== "").length;
  if (valueCount !== 8) {
    ipParts = ip.replace("::", ":".padEnd((8 - valueCount) * 2 + 1, "0:")).split(":");
  }
  let index = 0;
  ipParts.forEach((part) => {
    if (part === "") return;
    array[index++] = parseInt(part, 16);
  });
  return array;
}
function iPv6ToByteArray(ip) {
  return ByteArray.from(Array.from(iPv6ToArray(ip)).flatMap((value) => [value >> 8, value & 255]));
}
function onSameNetwork(ip1, ip2, mask) {
  if (isIPv4(ip1)) {
    if (!isIPv4(ip2) || !isIPv4(mask)) return false;
    const ip1Number = iPv4ToNumber(ip1);
    const ip2Number = iPv4ToNumber(ip2);
    const maskNumber = iPv4ToNumber(mask);
    return (ip1Number & maskNumber) === (ip2Number & maskNumber);
  } else {
    if (isIPv4(ip2) || isIPv4(mask)) return false;
    const ip1Array = iPv6ToArray(ip1);
    const ip2Array = iPv6ToArray(ip2);
    const maskArray = iPv6ToArray(mask);
    for (let i = 0; i < 16; i++) {
      const mask2 = maskArray[i];
      if (mask2 === 0) return true;
      if ((ip1Array[i] & mask2) !== (ip2Array[i] & mask2)) return false;
    }
  }
}
export {
  iPv4ToArray,
  iPv4ToByteArray,
  iPv4ToNumber,
  iPv6ToArray,
  iPv6ToByteArray,
  isIPv4,
  isIPv6,
  onSameNetwork
};
//# sourceMappingURL=Ip.js.map
