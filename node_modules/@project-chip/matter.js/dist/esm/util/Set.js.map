{
  "version": 3,
  "sources": ["../../../src/util/Set.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Observable } from \"./Observable.js\";\n\n/**\n * A read-only set.\n */\nexport interface ImmutableSet<T> {\n    [Symbol.iterator]: () => Iterator<T, undefined>;\n    has(item: T): boolean;\n    get size(): number;\n}\n\n/**\n * A write-only set.\n */\nexport interface MutableSet<T, AddT = T> {\n    add(definition: AddT): void;\n    delete(definition: T): boolean;\n    clear(): void;\n}\n\n/**\n * Set change events.\n */\nexport interface ObservableSet<T> {\n    get added(): Observable<[T]>;\n    get deleted(): Observable<[T]>;\n}\n\n/**\n * An interface for index set lookup.\n */\nexport interface IndexedSet<T> {\n    get<F extends keyof T>(field: F, value: T[F]): T | undefined;\n}\n\n/**\n * A generic set implementation supporting all interfaces in this module.\n *\n * Unused features have minimal performance impact.\n */\nexport class BasicSet<T, AddT = T> implements ImmutableSet<T>, MutableSet<T, AddT>, ObservableSet<T>, IndexedSet<T> {\n    #entries = new Set<T>();\n    #added?: Observable<[T]>;\n    #deleted?: Observable<[T]>;\n    #indices?: {\n        [field in keyof T]?: Map<any, T>;\n    };\n\n    [Symbol.iterator]() {\n        return this.#entries[Symbol.iterator]();\n    }\n\n    get size() {\n        return this.#entries.size;\n    }\n\n    has(item: T) {\n        return this.#entries.has(item);\n    }\n\n    add(item: AddT) {\n        const created = this.create(item);\n\n        if (this.#entries.has(item as any)) {\n            return;\n        }\n\n        this.#entries.add(item as any);\n\n        if (this.#indices) {\n            for (const field in this.#indices) {\n                const value = created[field];\n                if (value === undefined) {\n                    continue;\n                }\n\n                const index = this.#indices[field];\n                if (index === undefined || index.has(value)) {\n                    continue;\n                }\n\n                index.set(value, created);\n            }\n        }\n\n        this.#added?.emit(created);\n    }\n\n    get<F extends keyof T>(field: F, value: T[F]) {\n        if (!this.#indices) {\n            this.#indices = {};\n        }\n        let index = this.#indices[field];\n        if (index === undefined) {\n            index = new Map<any, T>();\n            for (const item of this) {\n                const value = item[field];\n                if (value === undefined || index.has(value)) {\n                    continue;\n                }\n                index.set(value, item);\n            }\n            this.#indices[field] = index;\n        }\n        return index?.get(value);\n    }\n\n    delete(item: T) {\n        if (!this.#entries.delete(item)) {\n            return false;\n        }\n\n        if (this.#indices) {\n            for (const field in this.#indices) {\n                const value = item[field];\n                if (value === undefined) {\n                    continue;\n                }\n\n                const index = this.#indices[field];\n                if (index !== undefined && index.get(value) === item) {\n                    index.delete(value);\n                }\n            }\n        }\n\n        this.#deleted?.emit(item);\n\n        return true;\n    }\n\n    clear() {\n        this.#entries.clear();\n    }\n\n    get added() {\n        if (this.#added === undefined) {\n            this.#added = Observable();\n        }\n        return this.#added;\n    }\n\n    get deleted() {\n        if (this.#deleted === undefined) {\n            this.#deleted = Observable();\n        }\n        return this.#deleted;\n    }\n\n    protected create(definition: AddT) {\n        return definition as unknown as T;\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,kBAAkB;AAwCpB,MAAM,SAAuG;AAAA,EAChH,WAAW,oBAAI,IAAO;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EAIA,CAAC,OAAO,QAAQ,IAAI;AAChB,WAAO,KAAK,SAAS,OAAO,QAAQ,EAAE;AAAA,EAC1C;AAAA,EAEA,IAAI,OAAO;AACP,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EAEA,IAAI,MAAS;AACT,WAAO,KAAK,SAAS,IAAI,IAAI;AAAA,EACjC;AAAA,EAEA,IAAI,MAAY;AACZ,UAAM,UAAU,KAAK,OAAO,IAAI;AAEhC,QAAI,KAAK,SAAS,IAAI,IAAW,GAAG;AAChC;AAAA,IACJ;AAEA,SAAK,SAAS,IAAI,IAAW;AAE7B,QAAI,KAAK,UAAU;AACf,iBAAW,SAAS,KAAK,UAAU;AAC/B,cAAM,QAAQ,QAAQ,KAAK;AAC3B,YAAI,UAAU,QAAW;AACrB;AAAA,QACJ;AAEA,cAAM,QAAQ,KAAK,SAAS,KAAK;AACjC,YAAI,UAAU,UAAa,MAAM,IAAI,KAAK,GAAG;AACzC;AAAA,QACJ;AAEA,cAAM,IAAI,OAAO,OAAO;AAAA,MAC5B;AAAA,IACJ;AAEA,SAAK,QAAQ,KAAK,OAAO;AAAA,EAC7B;AAAA,EAEA,IAAuB,OAAU,OAAa;AAC1C,QAAI,CAAC,KAAK,UAAU;AAChB,WAAK,WAAW,CAAC;AAAA,IACrB;AACA,QAAI,QAAQ,KAAK,SAAS,KAAK;AAC/B,QAAI,UAAU,QAAW;AACrB,cAAQ,oBAAI,IAAY;AACxB,iBAAW,QAAQ,MAAM;AACrB,cAAMA,SAAQ,KAAK,KAAK;AACxB,YAAIA,WAAU,UAAa,MAAM,IAAIA,MAAK,GAAG;AACzC;AAAA,QACJ;AACA,cAAM,IAAIA,QAAO,IAAI;AAAA,MACzB;AACA,WAAK,SAAS,KAAK,IAAI;AAAA,IAC3B;AACA,WAAO,OAAO,IAAI,KAAK;AAAA,EAC3B;AAAA,EAEA,OAAO,MAAS;AACZ,QAAI,CAAC,KAAK,SAAS,OAAO,IAAI,GAAG;AAC7B,aAAO;AAAA,IACX;AAEA,QAAI,KAAK,UAAU;AACf,iBAAW,SAAS,KAAK,UAAU;AAC/B,cAAM,QAAQ,KAAK,KAAK;AACxB,YAAI,UAAU,QAAW;AACrB;AAAA,QACJ;AAEA,cAAM,QAAQ,KAAK,SAAS,KAAK;AACjC,YAAI,UAAU,UAAa,MAAM,IAAI,KAAK,MAAM,MAAM;AAClD,gBAAM,OAAO,KAAK;AAAA,QACtB;AAAA,MACJ;AAAA,IACJ;AAEA,SAAK,UAAU,KAAK,IAAI;AAExB,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ;AACJ,SAAK,SAAS,MAAM;AAAA,EACxB;AAAA,EAEA,IAAI,QAAQ;AACR,QAAI,KAAK,WAAW,QAAW;AAC3B,WAAK,SAAS,WAAW;AAAA,IAC7B;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,UAAU;AACV,QAAI,KAAK,aAAa,QAAW;AAC7B,WAAK,WAAW,WAAW;AAAA,IAC/B;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEU,OAAO,YAAkB;AAC/B,WAAO;AAAA,EACX;AACJ;",
  "names": ["value"]
}
