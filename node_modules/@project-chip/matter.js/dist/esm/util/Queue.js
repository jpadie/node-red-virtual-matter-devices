/**
 * Promise-based blocking queue.
 *
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterFlowError } from "../common/MatterError.js";
import { Time } from "../time/Time.js";
import { createPromise } from "./Promises.js";
import { EndOfStreamError, NoResponseTimeoutError } from "./Stream.js";
class Queue {
  queue = new Array();
  pendingRead;
  closed = false;
  async read(timeoutMs = 6e4) {
    const { promise, resolver, rejecter } = createPromise();
    if (this.closed) throw new EndOfStreamError();
    const data = this.queue.shift();
    if (data !== void 0) {
      return data;
    }
    if (this.pendingRead !== void 0) throw new MatterFlowError("Only one pending read is supported");
    this.pendingRead = {
      resolver,
      rejecter,
      timeoutTimer: Time.getTimer(
        "Queue timeout",
        timeoutMs,
        () => rejecter(new NoResponseTimeoutError())
      ).start()
    };
    return promise;
  }
  async write(data) {
    if (this.closed) throw new EndOfStreamError();
    if (this.pendingRead !== void 0) {
      this.pendingRead.timeoutTimer?.stop();
      this.pendingRead.resolver(data);
      this.pendingRead = void 0;
      return;
    }
    this.queue.push(data);
  }
  close() {
    if (this.closed) return;
    this.closed = true;
    if (this.pendingRead === void 0) return;
    this.pendingRead.timeoutTimer?.stop();
    this.pendingRead.rejecter(new EndOfStreamError());
  }
}
export {
  Queue
};
//# sourceMappingURL=Queue.js.map
