{
  "version": 3,
  "sources": ["../../../src/util/Observable.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport \"../polyfills/disposable.js\";\nimport { MaybePromise } from \"./Promises.js\";\n\nconst logger = Logger.get(\"Observable\");\n\n/**\n * A callback function for observables.\n *\n * The observer return value effects how an {@link Observable} emits:\n *\n *   - If an observer returns undefined the {@link Observable} invokes the next observer immediately.\n *\n *   - If an observer returns a {@link Promise}, the {@link Observable} awaits the return value then continues as\n *     described here.  The emitter must then await the {@link Promise} returned by {@link Observable.emit}.\n *\n *   - Any other return value is returned by {@link Observable.emit} and subsequent observers do not see emission.\n *\n * @param payload a list of arguments to be emitted\n */\nexport interface Observer<T extends any[] = any[], R = void> {\n    (...payload: T): MaybePromise<R | undefined>;\n    [observant]?: boolean;\n}\n\n/**\n * A discrete event that may be monitored via callback.  Could call it \"event\" but that could be confused with Matter\n * cluster events and/or DOM events.\n *\n * @param T arguments, should be a named tuple\n */\nexport interface Observable<T extends any[] = any[], R = void> extends AsyncIterable<T>, PromiseLike<T> {\n    /**\n     * Notify observers.\n     */\n    emit(...args: T): R | undefined;\n\n    /**\n     * Add an observer.\n     */\n    on(observer: Observer<T, R>): void;\n\n    /**\n     * Remove an observer.\n     */\n    off(observer: Observer<T, R>): void;\n\n    /**\n     * Add an observer that emits once then is unregistered.\n     */\n    once(observer: Observer<T, R>): void;\n\n    /**\n     * True if there is at least one observer registered.\n     */\n    isObserved: boolean;\n\n    /**\n     * Determine whether an observer is registered.\n     */\n    isObservedBy(observer: Observer<T, R>): boolean;\n\n    /**\n     * This flag indicates whether the observable is asynchronous.  Any observable that accepts promise returns may\n     * be asynchronous but this information is not available at runtime unless you specify here, typically via\n     * {@link AsyncObservable}.\n     */\n    isAsync?: boolean;\n\n    /**\n     * Observable supports standard \"for await (const value of observable\").\n     *\n     * Using an observer in this manner limits your listener to the first parameter normally emitted and your observer\n     * cannot return a value.\n     */\n    [Symbol.asyncIterator](): AsyncIterator<T[0]>;\n\n    /**\n     * Release resources associated with the observable.\n     */\n    [Symbol.dispose](): void;\n}\n\n/**\n * An observer may designate itself as \"not observant\" for the purposes of {@link Observable.isObserved} by returning\n * false from this field.\n */\nexport const observant = Symbol(\"consider-observed\");\n\n/**\n * An {@link Observable} that explicitly supports asynchronous observers.\n */\nexport interface AsyncObservable<T extends any[] = any[], R = void> extends Observable<T, MaybePromise<R>> {\n    isAsync: true;\n}\n\nfunction defaultErrorHandler(error: Error) {\n    throw error;\n}\n\nexport type ObserverErrorHandler = (error: Error, observer: Observer<any[], any>) => void;\n\n/**\n * A concrete {@link Observable} implementation.\n */\nexport class BasicObservable<T extends any[] = any[], R = void> implements Observable<T, R> {\n    #errorHandler: ObserverErrorHandler;\n    #observers?: Set<Observer<T, R>>;\n    #once?: Set<Observer<T, R>>;\n    #isAsync?: boolean;\n\n    #joinIteration?: () => Promise<Next<T>>;\n    #removeIterator?: () => void;\n    #stopIteration?: () => void;\n\n    constructor(errorHandler?: ObserverErrorHandler, isAsync?: boolean) {\n        this.#errorHandler = errorHandler ?? defaultErrorHandler;\n        this.#isAsync = isAsync;\n    }\n\n    [Symbol.dispose]() {\n        this.#observers = this.#once = undefined;\n\n        this.#stopIteration?.();\n    }\n\n    get isAsync() {\n        return this.#isAsync;\n    }\n\n    set isAsync(isAsync: boolean | undefined) {\n        this.#isAsync = isAsync;\n    }\n\n    get isObserved() {\n        if (this.#observers) {\n            for (const observer of this.#observers) {\n                if (observer[observant] !== false) {\n                    return true;\n                }\n            }\n        }\n\n        if (this.#once) {\n            for (const observer of this.#once) {\n                if (observer[observant] !== false) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    isObservedBy(observer: Observer<T, R>) {\n        return !!this.#observers?.has(observer);\n    }\n\n    emit(...payload: T): R | undefined {\n        if (!this.#observers) {\n            return;\n        }\n\n        // Iterate over a clone of observers so we do not trigger new observers added during observation\n        const iterator = [...this.#observers][Symbol.iterator]();\n\n        const emitNext = (previousEmitResult?: R): R | undefined => {\n            if (previousEmitResult !== undefined) {\n                return previousEmitResult;\n            }\n\n            for (let iteration = iterator.next(); !iteration.done; iteration = iterator.next()) {\n                let result;\n\n                const observer = iteration.value;\n\n                try {\n                    result = observer(...payload);\n                } catch (e) {\n                    if (e instanceof Error) {\n                        this.#errorHandler(e, observer);\n                    } else {\n                        this.#errorHandler(new Error(`${e}`), observer);\n                    }\n                }\n\n                if (this.#once?.has(observer)) {\n                    this.#once.delete(observer);\n                    this.#observers?.delete(observer);\n                }\n\n                if (result === undefined) {\n                    continue;\n                }\n\n                if (MaybePromise.is(result)) {\n                    if (!this.isAsync) {\n                        let identity: string;\n                        if (observer.name) {\n                            identity = ` \"${observer.name}\"`;\n                        } else {\n                            identity = \"\";\n                        }\n\n                        result.then(undefined, error =>\n                            logger.error(`Unhandled error in async observer${identity}:`, error),\n                        );\n\n                        continue;\n                    }\n\n                    return result.then(result => {\n                        if (result === undefined) {\n                            return emitNext();\n                        }\n                        return result;\n                    }) as R;\n                }\n\n                return result;\n            }\n        };\n\n        return emitNext();\n    }\n\n    on(observer: Observer<T, R>) {\n        if (!this.#observers) {\n            this.#observers = new Set();\n        }\n        this.#observers.add(observer);\n    }\n\n    off(observer: Observer<T, R>) {\n        this.#observers?.delete(observer);\n    }\n\n    once(observer: Observer<T, R>) {\n        this.on(observer);\n        if (!this.#once) {\n            this.#once = new Set();\n        }\n        this.#once.add(observer);\n    }\n\n    then<TResult1 = T, TResult2 = never>(\n        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n    ): PromiseLike<TResult1 | TResult2> {\n        return new Promise<T>(resolve => {\n            this.once((...payload): undefined => {\n                resolve(payload);\n            });\n        }).then(onfulfilled, onrejected);\n    }\n\n    async *[Symbol.asyncIterator](): AsyncIterator<T[0]> {\n        let promise = this.#addIterator();\n\n        try {\n            while (promise) {\n                const next = await promise;\n                if (next) {\n                    promise = next.promise;\n                    yield next.value;\n                }\n            }\n        } finally {\n            this.#removeIterator?.();\n        }\n    }\n\n    #addIterator() {\n        if (this.#joinIteration) {\n            return this.#joinIteration();\n        }\n\n        let resolve: (next: Next<T>) => void;\n        let iteratorCount = 1;\n\n        function newPromise() {\n            return new Promise<Next<T>>(r => (resolve = r));\n        }\n\n        let promise = newPromise();\n\n        function observer(...args: T): undefined {\n            const oldResolve = resolve;\n            promise = newPromise();\n            oldResolve({ value: args[0], promise });\n        }\n\n        this.on(observer);\n\n        this.#joinIteration = () => {\n            iteratorCount++;\n            return promise;\n        };\n\n        this.#removeIterator = () => {\n            if (!iteratorCount--) {\n                this.#stopIteration?.();\n            }\n        };\n\n        this.#stopIteration = () => {\n            this.off(observer);\n            resolve(undefined);\n            this.#stopIteration = undefined;\n            this.#removeIterator = undefined;\n        };\n    }\n}\n\ntype Next<T> = undefined | { value: T; promise: Promise<Next<T>> };\n\nfunction constructObservable(errorHandler?: ObserverErrorHandler) {\n    return new BasicObservable(errorHandler);\n}\n\n/**\n * Create an {@link Observable}.\n */\nexport const Observable = constructObservable as unknown as {\n    new <T extends any[], R = void>(errorHandler?: ObserverErrorHandler): Observable<T, R>;\n    <T extends any[], R = void>(errorHandler?: ObserverErrorHandler): Observable<T, R>;\n};\n\nfunction constructAsyncObservable(errorHandler?: ObserverErrorHandler) {\n    return new BasicObservable(errorHandler, true);\n}\n\n/**\n * Create an {@link AsyncObservable} that explicitly supports asynchronous results\n */\nexport const AsyncObservable = constructAsyncObservable as unknown as {\n    new <T extends any[], R = void>(errorHandler?: ObserverErrorHandler): AsyncObservable<T, R>;\n    <T extends any[], R = void>(errorHandler?: ObserverErrorHandler): AsyncObservable<T, R>;\n};\n\nfunction event<E, N extends string>(emitter: E, name: N) {\n    const observer = (emitter as any)[name];\n    if (typeof !observer?.on !== \"function\") {\n        throw new ImplementationError(`Invalid event name ${name}`);\n    }\n    return observer as Observable;\n}\n\n/**\n * A set of observables.  You can bind events using individual observables or the methods emulating a subset Node's\n * EventEmitter.\n *\n * To maintain type safety, implementers define events as observable child properties.\n */\nexport class EventEmitter {\n    emit<This, N extends EventEmitter.NamesOf<This>>(this: This, name: N, ...payload: EventEmitter.PayloadOf<This, N>) {\n        event(this, name).emit(...payload);\n    }\n\n    addListener<This, N extends EventEmitter.NamesOf<This>>(\n        this: This,\n        name: N,\n        handler: EventEmitter.ObserverOf<This, N>,\n    ) {\n        event(this, name).on(handler as any);\n    }\n\n    removeListener<This, N extends EventEmitter.NamesOf<This>>(\n        this: This,\n        name: N,\n        handler: EventEmitter.ObserverOf<This, N>,\n    ) {\n        event(this, name).off(handler as any);\n    }\n\n    get eventNames() {\n        return Object.keys(this).filter(k => typeof (this as any)[k]?.on === \"function\");\n    }\n\n    [Symbol.dispose]() {\n        for (const name of this.eventNames) {\n            (this as unknown as Record<string, Observable>)[name][Symbol.dispose]?.();\n        }\n    }\n}\n\nexport namespace EventEmitter {\n    /**\n     * Legal event names.  If there are no events defined, assume this is an\n     * untyped instance and allow any argument.\n     */\n    export type NamesOf<This> = [EventNames<This>] extends [never] ? string : EventNames<This>;\n\n    export type EventNames<This> = string &\n        keyof {\n            [K in keyof This as This[K] extends Observable ? K : never]: true;\n        };\n\n    /**\n     * Arguments for an event.  If there are no events defined, assume this is\n     * an untyped emitter and allow any argument.\n     */\n    export type PayloadOf<This, E extends string> = [EventPayload<This, E>] extends [never]\n        ? any[]\n        : EventPayload<This, E>;\n\n    export type EventPayload<This, E extends string> = This extends { [K in E]: Observable<infer T extends any[]> }\n        ? T\n        : never;\n\n    export type ObserverOf<This, E extends string> = Observable<PayloadOf<This, E>>;\n}\n\n/**\n * An {@link Observable} that proxies to another {@link Observable}.\n *\n * Emits emitted here instead emit on the target {@link Observable}.  Events emitted on the target emit locally via\n * a listener installed by the proxy.\n *\n * This is useful for managing a subset of {@link Observer}s for an {@link Observable}.\n *\n * Note that this \"proxy\" acts as a proxy but is not a JS {@link Proxy}.\n */\nexport class ObservableProxy extends BasicObservable {\n    #target: Observable;\n    #emitter = super.emit.bind(this);\n\n    constructor(target: Observable) {\n        super();\n\n        Object.defineProperty(this.#emitter, observant, {\n            get() {\n                return this.isObserved;\n            },\n        });\n\n        this.#target = target;\n        this.#target.on(this.#emitter);\n        this.emit = this.#target.emit.bind(this.#target);\n    }\n\n    override [Symbol.dispose]() {\n        this.#target.off(this.#emitter);\n        super[Symbol.dispose]();\n    }\n\n    override get isAsync() {\n        return this.#target.isAsync;\n    }\n\n    override get isObserved(): boolean {\n        return this.#target.isObserved;\n    }\n\n    override emit: (...payload: any) => any | undefined;\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
