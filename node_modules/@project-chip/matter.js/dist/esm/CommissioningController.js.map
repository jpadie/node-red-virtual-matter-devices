{
  "version": 3,
  "sources": ["../../src/CommissioningController.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MatterController } from \"./MatterController.js\";\nimport { MatterNode } from \"./MatterNode.js\";\nimport { GlobalAttributes } from \"./cluster/Cluster.js\";\nimport { SupportedAttributeClient } from \"./cluster/client/AttributeClient.js\";\nimport { BasicInformation } from \"./cluster/definitions/BasicInformationCluster.js\";\nimport { ImplementationError, InternalError } from \"./common/MatterError.js\";\nimport { CommissionableDevice, CommissionableDeviceIdentifiers, DiscoveryData } from \"./common/Scanner.js\";\nimport { ServerAddress } from \"./common/ServerAddress.js\";\nimport { CaseAuthenticatedTag } from \"./datatype/CaseAuthenticatedTag.js\";\nimport { EndpointNumber } from \"./datatype/EndpointNumber.js\";\nimport { FabricId } from \"./datatype/FabricId.js\";\nimport { FabricIndex } from \"./datatype/FabricIndex.js\";\nimport { NodeId } from \"./datatype/NodeId.js\";\nimport { VendorId } from \"./datatype/VendorId.js\";\nimport { CommissioningControllerNodeOptions, PairedNode } from \"./device/PairedNode.js\";\nimport { Environment } from \"./environment/Environment.js\";\nimport { MdnsService } from \"./environment/MdnsService.js\";\nimport { Logger } from \"./log/Logger.js\";\nimport { MdnsBroadcaster } from \"./mdns/MdnsBroadcaster.js\";\nimport { MdnsScanner } from \"./mdns/MdnsScanner.js\";\nimport { Network } from \"./net/Network.js\";\nimport { UdpInterface } from \"./net/UdpInterface.js\";\nimport { ControllerStore } from \"./node/client/storage/ControllerStore.js\";\nimport { CommissioningOptions } from \"./protocol/ControllerCommissioner.js\";\nimport { ControllerDiscovery } from \"./protocol/ControllerDiscovery.js\";\nimport { InteractionClient } from \"./protocol/interaction/InteractionClient.js\";\nimport { TypeFromPartialBitSchema } from \"./schema/BitmapSchema.js\";\nimport { DiscoveryCapabilitiesBitmap } from \"./schema/PairingCodeSchema.js\";\nimport { SyncStorage } from \"./storage/Storage.js\";\nimport { StorageContext } from \"./storage/StorageContext.js\";\nimport { SupportedStorageTypes } from \"./storage/StringifyTools.js\";\n\nconst logger = new Logger(\"CommissioningController\");\n\n// TODO how to enhance \"getting devices\" as API? Or is getDevices() enough?\n// TODO decline using setRoot*Cluster\n// TODO Decline cluster access after announced/paired\n\nexport type ControllerEnvironmentOptions = {\n    /**\n     * Environment to register the node with on start()\n     */\n    readonly environment: Environment;\n\n    /**\n     * Unique id to register to node.\n     */\n    readonly id: string;\n};\n\n/**\n * Constructor options for the CommissioningController class\n */\nexport type CommissioningControllerOptions = CommissioningControllerNodeOptions & {\n    /**\n     * Local port number to use for the UDP interface. By default, a random port number will be generated\n     * (strongly recommended!).\n     */\n    readonly localPort?: number;\n\n    /** Listening address for IPv4. By default, the interface will listen on all IPv4 addresses. */\n    readonly listeningAddressIpv4?: string;\n\n    /** Listening address for IPv6. By default, the interface will listen on all IPv6 addresses. */\n    readonly listeningAddressIpv6?: string;\n\n    /**\n     * If set to false, the controller will not connect to any device on startup. You need to use connectNode() or\n     * connect() to connect to the relevant nodes in this case. Else all nodes are connected on startup.\n     * */\n    readonly autoConnect?: boolean;\n\n    /** Admin Vendor ID used for all commissioning operations. Cannot be changed afterward. Default: 0xFFF1 */\n    readonly adminVendorId?: VendorId;\n\n    /**\n     * Controller own Fabric ID used to initialize the Controller the first time and to generate the Root certificate.\n     * Cannot be changed afterward.\n     * Default: 1\n     */\n    readonly adminFabricId?: FabricId;\n\n    /**\n     * Fabric Index used to initialize the Controller the first time. Cannot be changed afterward.\n     * Default: 1\n     */\n    readonly adminFabricIndex?: FabricIndex;\n\n    /**\n     * CASE Authenticated Tags used to initialize the Controller the first time. Cannot be changed afterward.\n     * Maximum 3 tags are supported.\n     */\n    readonly caseAuthenticatedTags?: CaseAuthenticatedTag[];\n\n    /**\n     * When used with the new API Environment set the environment here and the CommissioningServer will self-register\n     * on the environment when you call start().\n     */\n    readonly environment?: ControllerEnvironmentOptions;\n};\n\n/** Options needed to commission a new node */\nexport type NodeCommissioningOptions = CommissioningControllerNodeOptions & {\n    /** Commission related options. */\n    commissioning?: CommissioningOptions;\n\n    /** Discovery related options. */\n    discovery: (\n        | {\n              /**\n               * Device identifiers (Short or Long Discriminator, Product/Vendor-Ids, Device-type or a pre-discovered\n               * instance Id, or \"nothing\" to discover all commissionable matter devices) to use for discovery.\n               * If the property commissionableDevice is provided this property is ignored.\n               */\n              identifierData: CommissionableDeviceIdentifiers;\n          }\n        | {\n              /**\n               * Commissionable device object returned by a discovery run.\n               * If this property is provided then identifierData and knownAddress are ignored.\n               */\n              commissionableDevice: CommissionableDevice;\n          }\n    ) & {\n        /**\n         * Discovery capabilities to use for discovery. These are included in the QR code normally and defined if BLE\n         * is supported for initial commissioning.\n         */\n        discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>;\n\n        /**\n         * Known address of the device to use for discovery. if this is set this will be tried first before discovering\n         * the device.\n         */\n        knownAddress?: ServerAddress;\n\n        /** Timeout in seconds for the discovery process. Default: 30 seconds */\n        timeoutSeconds?: number;\n    };\n\n    /** Passcode to use for commissioning. */\n    passcode: number;\n};\n\n/** Controller class to commission and connect multiple nodes into one fabric. */\nexport class CommissioningController extends MatterNode {\n    private started = false;\n    private ipv4Disabled?: boolean;\n    private readonly listeningAddressIpv4?: string;\n    private readonly listeningAddressIpv6?: string;\n\n    private environment?: Environment; // Set when new API was initialized correctly\n    private storage?: StorageContext;\n\n    private mdnsScanner?: MdnsScanner;\n\n    private controllerInstance?: MatterController;\n    private connectedNodes = new Map<NodeId, PairedNode>();\n    private sessionDisconnectedHandler = new Map<NodeId, () => Promise<void>>();\n\n    /**\n     * Creates a new CommissioningController instance\n     *\n     * @param options The options for the CommissioningController\n     */\n    constructor(private readonly options: CommissioningControllerOptions) {\n        super();\n    }\n\n    get nodeId() {\n        return this.controllerInstance?.nodeId;\n    }\n\n    get paseCommissionerData() {\n        const controller = this.assertControllerIsStarted(\n            \"The CommissioningController needs to be started to get the PASE commissioner data.\",\n        );\n        return {\n            rootCertificateData: controller.rootCertificateData,\n            fabricData: controller.fabricData,\n        };\n    }\n\n    assertIsAddedToMatterServer() {\n        if (this.mdnsScanner === undefined || (this.storage === undefined && this.environment === undefined)) {\n            throw new ImplementationError(\"Add the node to the Matter instance before.\");\n        }\n        if (!this.started) {\n            throw new ImplementationError(\"The node needs to be started before interacting with the controller.\");\n        }\n        return { mdnsScanner: this.mdnsScanner, storage: this.storage, environment: this.environment };\n    }\n\n    assertControllerIsStarted(errorText?: string) {\n        if (this.controllerInstance === undefined) {\n            throw new ImplementationError(\n                errorText ?? \"Controller instance not yet started. Please call start() first.\",\n            );\n        }\n        return this.controllerInstance;\n    }\n\n    /** Internal method to initialize a MatterController instance. */\n    private async initializeController() {\n        const { mdnsScanner, storage, environment } = this.assertIsAddedToMatterServer();\n        if (this.controllerInstance !== undefined) {\n            return this.controllerInstance;\n        }\n        const { localPort, adminFabricId, adminVendorId, adminFabricIndex, caseAuthenticatedTags } = this.options;\n\n        // Initialize the Storage in a compatible way for the legacy API and new style for new API\n        // TODO: clean this up when we really implement ControllerNode/ClientNode concepts in new API\n        const environmentStore = environment !== undefined ? environment.get(ControllerStore) : undefined;\n        const sessionStorage = environmentStore?.sessionStorage ?? storage?.createContext(\"SessionManager\");\n        const rootCertificateStorage =\n            environmentStore?.credentialsStorage ?? storage?.createContext(\"RootCertificateManager\");\n        const fabricStorage = environmentStore?.credentialsStorage ?? storage?.createContext(\"MatterController\");\n        const nodesStorage = environmentStore?.nodesStorage ?? storage?.createContext(\"MatterController\");\n        if (\n            sessionStorage === undefined ||\n            rootCertificateStorage === undefined ||\n            fabricStorage === undefined ||\n            nodesStorage === undefined\n        ) {\n            throw new InternalError(\"Storage not initialized correctly.\"); // Should not happen\n        }\n\n        return await MatterController.create({\n            sessionStorage,\n            rootCertificateStorage,\n            fabricStorage,\n            nodesStorage,\n            mdnsScanner,\n            netInterfaceIpv4: this.ipv4Disabled\n                ? undefined\n                : await UdpInterface.create(Network.get(), \"udp4\", localPort, this.listeningAddressIpv4),\n            netInterfaceIpv6: await UdpInterface.create(Network.get(), \"udp6\", localPort, this.listeningAddressIpv6),\n            sessionClosedCallback: peerNodeId => {\n                logger.info(`Session for peer node ${peerNodeId} disconnected ...`);\n                const handler = this.sessionDisconnectedHandler.get(peerNodeId);\n                if (handler !== undefined) {\n                    handler().catch(error => logger.warn(`Error while handling session disconnect: ${error}`));\n                }\n            },\n            adminVendorId,\n            adminFabricId,\n            adminFabricIndex,\n            caseAuthenticatedTags,\n        });\n    }\n\n    /**\n     * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned node.\n     */\n    async commissionNode(nodeOptions: NodeCommissioningOptions, connectNodeAfterCommissioning = true) {\n        this.assertIsAddedToMatterServer();\n        const controller = this.assertControllerIsStarted();\n\n        const nodeId = await controller.commission(nodeOptions);\n\n        if (connectNodeAfterCommissioning) {\n            await this.connectNode(nodeId, {\n                ...nodeOptions,\n                autoSubscribe: nodeOptions.autoSubscribe ?? this.options.autoSubscribe,\n                subscribeMinIntervalFloorSeconds:\n                    nodeOptions.subscribeMinIntervalFloorSeconds ?? this.options.subscribeMinIntervalFloorSeconds,\n                subscribeMaxIntervalCeilingSeconds:\n                    nodeOptions.subscribeMaxIntervalCeilingSeconds ?? this.options.subscribeMaxIntervalCeilingSeconds,\n            });\n        }\n\n        return nodeId;\n    }\n\n    /**\n     * Completes the commissioning process for a node when the initial commissioning process was done by a PASE\n     * commissioner. This method should be called to discover the device operational and complete the commissioning\n     * process.\n     */\n    completeCommissioningForNode(peerNodeId: NodeId, discoveryData?: DiscoveryData) {\n        this.assertIsAddedToMatterServer();\n        const controller = this.assertControllerIsStarted();\n        return controller.completeCommissioning(peerNodeId, discoveryData);\n    }\n\n    /** Check if a given node id is commissioned on this controller. */\n    isNodeCommissioned(nodeId: NodeId) {\n        const controller = this.assertControllerIsStarted();\n        return controller.getCommissionedNodes().includes(nodeId) ?? false;\n    }\n\n    /**\n     * Remove a Node id from the controller. This method should only be used if the decommission method on the\n     * PairedNode instance returns an error. By default it tries to decommission the node from the controller but will\n     * remove it also in case of an error during decommissioning. Ideally try to decommission the node before and only\n     * use this in case of an error.\n     */\n    async removeNode(nodeId: NodeId, tryDecommissioning = true) {\n        const controller = this.assertControllerIsStarted();\n        const node = this.connectedNodes.get(nodeId);\n        if (tryDecommissioning) {\n            try {\n                if (node == undefined) {\n                    throw new ImplementationError(`Node ${nodeId} is not connected.`);\n                }\n                await node.decommission();\n            } catch (error) {\n                logger.warn(`Decommissioning node ${nodeId} failed with error, remove node anyway: ${error}`);\n            }\n        }\n        if (node !== undefined) {\n            node.close();\n        }\n        await controller.removeNode(nodeId);\n        this.connectedNodes.delete(nodeId);\n    }\n\n    async disconnectNode(nodeId: NodeId) {\n        const node = this.connectedNodes.get(nodeId);\n        if (node === undefined) {\n            throw new ImplementationError(`Node ${nodeId} is not connected!`);\n        }\n        await this.controllerInstance?.disconnect(nodeId);\n    }\n\n    /**\n     * Connect to an already paired Node.\n     * After connection the endpoint data of the device is analyzed and an object structure is created.\n     */\n    async connectNode(nodeId: NodeId, connectOptions?: CommissioningControllerNodeOptions) {\n        const controller = this.assertControllerIsStarted();\n\n        if (!controller.getCommissionedNodes().includes(nodeId)) {\n            throw new ImplementationError(`Node ${nodeId} is not commissioned!`);\n        }\n\n        const existingNode = this.connectedNodes.get(nodeId);\n        if (existingNode !== undefined) {\n            if (!existingNode.isConnected) {\n                await existingNode.reconnect();\n            }\n            return existingNode;\n        }\n\n        const pairedNode = await PairedNode.create(\n            nodeId,\n            this,\n            connectOptions,\n            async () => this.createInteractionClient(nodeId),\n            handler => this.sessionDisconnectedHandler.set(nodeId, handler),\n        );\n        this.connectedNodes.set(nodeId, pairedNode);\n\n        if (connectOptions?.autoSubscribe !== false) {\n            await this.enhanceDeviceDetailsFromCache(nodeId, pairedNode);\n        } else {\n            await this.enhanceDeviceDetailsFromRemote(nodeId, pairedNode);\n        }\n\n        return pairedNode;\n    }\n\n    private async enhanceDeviceDetailsFromCache(nodeId: NodeId, pairedNode: PairedNode) {\n        const controller = this.assertControllerIsStarted();\n\n        const globalAttributeKeys = Object.keys(GlobalAttributes({}));\n        const basicInformationClient = pairedNode.getRootClusterClient(BasicInformation.Cluster);\n        if (basicInformationClient === undefined) {\n            logger.info(`No basic information cluster found for node ${nodeId}`);\n            return;\n        }\n        const basicInformationData = {} as Record<string, SupportedStorageTypes>;\n        for (const attributeName of Object.keys(basicInformationClient.attributes)) {\n            if (globalAttributeKeys.includes(attributeName)) {\n                continue;\n            }\n            const attribute = (basicInformationClient.attributes as any)[attributeName];\n            if (attribute instanceof SupportedAttributeClient) {\n                try {\n                    basicInformationData[attributeName] = await attribute.get();\n                } catch (error) {\n                    logger.info(`Error while getting attribute ${attributeName} for node ${nodeId}: ${error}`);\n                }\n            }\n        }\n        await controller.enhanceCommissionedNodeDetails(nodeId, { basicInformationData });\n    }\n\n    private async enhanceDeviceDetailsFromRemote(nodeId: NodeId, pairedNode: PairedNode) {\n        const controller = this.assertControllerIsStarted();\n\n        const globalAttributeKeys = Object.keys(GlobalAttributes({}));\n        try {\n            const interactionClient = await pairedNode.getInteractionClient();\n            const basicInformationAttributes = await interactionClient.getMultipleAttributes({\n                attributes: [{ endpointId: EndpointNumber(0), clusterId: BasicInformation.Cluster.id }],\n            });\n            const basicInformationData = {} as Record<string, SupportedStorageTypes>;\n            for (const {\n                path: { attributeName },\n                value,\n            } of basicInformationAttributes) {\n                if (!globalAttributeKeys.includes(attributeName)) {\n                    basicInformationData[attributeName] = value;\n                }\n            }\n            await controller.enhanceCommissionedNodeDetails(nodeId, { basicInformationData });\n        } catch (error) {\n            logger.info(`Error while enhancing basic information for node ${nodeId}: ${error}`);\n        }\n    }\n\n    /**\n     * Connects to all paired nodes.\n     * After connection the endpoint data of the device is analyzed and an object structure is created.\n     */\n    async connect(connectOptions?: CommissioningControllerNodeOptions) {\n        const controller = this.assertControllerIsStarted();\n\n        if (!controller.isCommissioned()) {\n            throw new ImplementationError(\n                \"Controller instance not yet paired with any device, so nothing to connect to.\",\n            );\n        }\n\n        for (const nodeId of controller.getCommissionedNodes()) {\n            await this.connectNode(nodeId, connectOptions);\n        }\n        return Array.from(this.connectedNodes.values());\n    }\n\n    /**\n     * Set the MDNS Scanner instance. Should be only used internally\n     *\n     * @param mdnsScanner MdnsScanner instance\n     */\n    setMdnsScanner(mdnsScanner: MdnsScanner) {\n        this.mdnsScanner = mdnsScanner;\n    }\n\n    /**\n     * Set the MDNS Broadcaster instance. Should be only used internally\n     *\n     * @param _mdnsBroadcaster MdnsBroadcaster instance\n     */\n    setMdnsBroadcaster(_mdnsBroadcaster: MdnsBroadcaster) {\n        // not needed\n    }\n\n    /**\n     * Set the Storage instance. Should be only used internally\n     *\n     * @param storage storage context to use\n     */\n    setStorage(storage: StorageContext<SyncStorage>) {\n        this.storage = storage;\n        this.environment = undefined;\n    }\n\n    /** Returns true if t least one node is commissioned/paired with this controller instance. */\n    isCommissioned() {\n        const controller = this.assertControllerIsStarted();\n\n        return controller.isCommissioned();\n    }\n\n    /**\n     * Creates and Return a new InteractionClient to communicate with a node. This is mainly used internally and should\n     * not be used directly. See the PairedNode class for the public API.\n     */\n    async createInteractionClient(nodeId: NodeId): Promise<InteractionClient> {\n        const controller = this.assertControllerIsStarted();\n        return controller.connect(nodeId);\n    }\n\n    /** Returns the PairedNode instance for a given node id, if this node is connected. */\n    getConnectedNode(nodeId: NodeId) {\n        return this.connectedNodes.get(nodeId);\n    }\n\n    /** Returns an array with the Node Ids for all commissioned nodes. */\n    getCommissionedNodes() {\n        const controller = this.assertControllerIsStarted();\n\n        return controller.getCommissionedNodes() ?? [];\n    }\n\n    getCommissionedNodesDetails() {\n        const controller = this.assertControllerIsStarted();\n\n        return controller.getCommissionedNodesDetails() ?? [];\n    }\n\n    /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */\n    async close() {\n        for (const node of this.connectedNodes.values()) {\n            node.close();\n        }\n        await this.controllerInstance?.close();\n        this.controllerInstance = undefined;\n        this.connectedNodes.clear();\n        this.ipv4Disabled = undefined;\n        this.started = false;\n    }\n\n    getPort(): number | undefined {\n        return this.options.localPort;\n    }\n\n    initialize(ipv4Disabled: boolean) {\n        if (this.started) {\n            throw new ImplementationError(\"Controller instance already started.\");\n        }\n        if (this.ipv4Disabled !== undefined && this.ipv4Disabled !== ipv4Disabled) {\n            throw new ImplementationError(\n                \"Changing the IPv4 disabled flag after starting the controller is not supported.\",\n            );\n        }\n        this.ipv4Disabled = ipv4Disabled;\n    }\n\n    /** Initialize the controller and connect to all commissioned nodes if autoConnect is not set to false. */\n    async start() {\n        if (this.ipv4Disabled === undefined) {\n            if (this.options.environment === undefined) {\n                throw new ImplementationError(\"Initialization not done. Add the controller to the MatterServer first.\");\n            }\n\n            const { environment, id } = this.options.environment;\n            const controllerStore = await ControllerStore.create(environment, id);\n\n            environment.set(ControllerStore, controllerStore);\n\n            const mdnsService = await environment.load(MdnsService);\n            this.ipv4Disabled = !mdnsService.enableIpv4;\n            this.setMdnsBroadcaster(mdnsService.broadcaster);\n            this.setMdnsScanner(mdnsService.scanner);\n\n            this.environment = environment;\n            const runtime = environment.runtime;\n            runtime.add(this);\n        }\n        this.started = true;\n        if (this.controllerInstance === undefined) {\n            this.controllerInstance = await this.initializeController();\n        }\n        if (this.options.autoConnect !== false && this.controllerInstance.isCommissioned()) {\n            await this.connect();\n        }\n    }\n\n    cancelCommissionableDeviceDiscovery(\n        identifierData: CommissionableDeviceIdentifiers,\n        discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>,\n    ) {\n        this.assertIsAddedToMatterServer();\n        const controller = this.assertControllerIsStarted();\n        controller\n            .collectScanners(discoveryCapabilities)\n            .forEach(scanner => ControllerDiscovery.cancelCommissionableDeviceDiscovery(scanner, identifierData));\n    }\n\n    async discoverCommissionableDevices(\n        identifierData: CommissionableDeviceIdentifiers,\n        discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>,\n        discoveredCallback?: (device: CommissionableDevice) => void,\n        timeoutSeconds = 900,\n    ) {\n        this.assertIsAddedToMatterServer();\n        const controller = this.assertControllerIsStarted();\n        return await ControllerDiscovery.discoverCommissionableDevices(\n            controller.collectScanners(discoveryCapabilities),\n            timeoutSeconds,\n            identifierData,\n            discoveredCallback,\n        );\n    }\n\n    async resetStorage() {\n        this.assertControllerIsStarted(\n            \"Storage cannot be reset while the controller is operating! Please close the controller first.\",\n        );\n        const { storage, environment } = this.assertIsAddedToMatterServer();\n        if (environment !== undefined) {\n            const controllerStore = environment.get(ControllerStore);\n            await controllerStore.erase();\n        } else if (storage !== undefined) {\n            await storage.clearAll();\n        } else {\n            throw new InternalError(\"Storage not initialized correctly.\"); // Should not happen\n        }\n    }\n\n    /** Returns active session information for all connected nodes. */\n    getActiveSessionInformation() {\n        return this.controllerInstance?.getActiveSessionInformation() ?? [];\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
