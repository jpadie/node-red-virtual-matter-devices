/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Important note: This file is part of the legacy matter-node (internal) API and should not be used anymore directly!
 * Please use the new API classes!
 * @deprecated
 */
import { NodeCommissioningOptions } from "./CommissioningController.js";
import { RootCertificateManager } from "./certificate/RootCertificateManager.js";
import { GeneralCommissioning } from "./cluster/definitions/GeneralCommissioningCluster.js";
import { DiscoveryData, Scanner } from "./common/Scanner.js";
import { ServerAddressIp } from "./common/ServerAddress.js";
import { CaseAuthenticatedTag } from "./datatype/CaseAuthenticatedTag.js";
import { FabricId } from "./datatype/FabricId.js";
import { FabricIndex } from "./datatype/FabricIndex.js";
import { NodeId } from "./datatype/NodeId.js";
import { VendorId } from "./datatype/VendorId.js";
import { Fabric, FabricJsonObject } from "./fabric/Fabric.js";
import { MdnsScanner } from "./mdns/MdnsScanner.js";
import { NetInterface } from "./net/NetInterface.js";
import { RetransmissionLimitReachedError } from "./protocol/MessageExchange.js";
import { InteractionClient } from "./protocol/interaction/InteractionClient.js";
import { TypeFromPartialBitSchema } from "./schema/BitmapSchema.js";
import { DiscoveryCapabilitiesBitmap } from "./schema/PairingCodeSchema.js";
import { SessionParameters } from "./session/Session.js";
import { ResumptionRecord, SessionManager } from "./session/SessionManager.js";
import { StorageContext } from "./storage/StorageContext.js";
import { SupportedStorageTypes } from "./storage/StringifyTools.js";
import { TypeFromSchema } from "./tlv/TlvSchema.js";
import { ByteArray } from "./util/ByteArray.js";
import { Construction } from "./util/Construction.js";
declare const TlvCommissioningSuccessFailureResponse: import("./tlv/TlvObject.js").ObjectSchema<{
    /** Contain the result of the operation. */
    errorCode: import("./tlv/TlvObject.js").FieldType<GeneralCommissioning.CommissioningError>;
    /** Should help developers in troubleshooting errors. The value MAY go into logs or crash reports, not User UIs. */
    debugText: import("./tlv/TlvObject.js").FieldType<string>;
}>;
export type CommissioningSuccessFailureResponse = TypeFromSchema<typeof TlvCommissioningSuccessFailureResponse>;
export type CommissionedNodeDetails = {
    operationalServerAddress?: ServerAddressIp;
    discoveryData?: DiscoveryData;
    basicInformationData?: Record<string, SupportedStorageTypes>;
};
/**
 * Special Error instance used to detect if the retransmission limit was reached during pairing for case or pase.
 * Mainly means that the device was not responding to the pairing request.
 */
export declare class PairRetransmissionLimitReachedError extends RetransmissionLimitReachedError {
}
export declare class MatterController {
    #private;
    static create(options: {
        sessionStorage: StorageContext;
        rootCertificateStorage: StorageContext;
        fabricStorage: StorageContext;
        nodesStorage: StorageContext;
        mdnsScanner: MdnsScanner;
        netInterfaceIpv4: NetInterface | undefined;
        netInterfaceIpv6: NetInterface;
        sessionClosedCallback?: (peerNodeId: NodeId) => void;
        adminVendorId?: VendorId;
        adminFabricId?: FabricId;
        adminFabricIndex?: FabricIndex;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<MatterController>;
    static createAsPaseCommissioner(options: {
        rootCertificateData: RootCertificateManager.Data;
        fabricData: FabricJsonObject;
        mdnsScanner?: MdnsScanner;
        netInterfaceIpv4?: NetInterface | undefined;
        netInterfaceIpv6?: NetInterface;
        sessionClosedCallback?: (peerNodeId: NodeId) => void;
    }): Promise<MatterController>;
    readonly sessionManager: SessionManager<MatterController>;
    private readonly channelManager;
    private readonly exchangeManager;
    private readonly paseClient;
    private readonly caseClient;
    private netInterfaceBle;
    private bleScanner;
    private readonly commissionedNodes;
    readonly sessionStorage: StorageContext;
    readonly fabricStorage?: StorageContext;
    readonly nodesStorage: StorageContext;
    private readonly mdnsScanner;
    private readonly netInterfaceIpv4;
    private readonly netInterfaceIpv6;
    private readonly certificateManager;
    private readonly fabric;
    private readonly adminVendorId;
    private readonly sessionClosedCallback?;
    get construction(): Construction<MatterController>;
    constructor(options: {
        sessionStorage: StorageContext;
        fabricStorage?: StorageContext;
        nodesStorage: StorageContext;
        mdnsScanner?: MdnsScanner;
        netInterfaceIpv4?: NetInterface;
        netInterfaceIpv6?: NetInterface;
        certificateManager: RootCertificateManager;
        fabric: Fabric;
        adminVendorId: VendorId;
        sessionClosedCallback?: (peerNodeId: NodeId) => void;
    });
    get nodeId(): NodeId;
    get rootCertificateData(): RootCertificateManager.Data;
    get fabricData(): FabricJsonObject;
    /** Returns our default session parameters for us as a controller. */
    get sessionParameters(): SessionParameters;
    addTransportInterface(netInterface: NetInterface): void;
    collectScanners(discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>): Scanner[];
    /**
     * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first
     * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after
     * each other. It returns the NodeId of the commissioned device.
     * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing
     * request or the passode did not match to any discovered device/address.
     *
     * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
     * to complete the commissioning process.
     * Return true when the commissioning process is completed successfully, false on error.
     */
    commission(options: NodeCommissioningOptions, completeCommissioningCallback?: (peerNodeId: NodeId, discoveryData?: DiscoveryData) => Promise<boolean>): Promise<NodeId>;
    disconnect(nodeId: NodeId): Promise<void>;
    removeNode(nodeId: NodeId): Promise<void>;
    /**
     * Method to start commission process with a PASE pairing.
     * If this not successful and throws an RetransmissionLimitReachedError the address is invalid or the passcode
     * is wrong.
     */
    private initializePaseSecureChannel;
    /**
     * Method to commission a device with a PASE secure channel. It returns the NodeId of the commissioned device on
     * success.
     */
    private commissionDevice;
    /**
     * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.
     */
    completeCommissioning(peerNodeId: NodeId, discoveryData?: DiscoveryData): Promise<void>;
    private reconnectLastKnownAddress;
    private connectOrDiscoverNode;
    /**
     * Resume a device connection and establish a CASE session that was previously paired with the controller. This
     * method will try to connect to the device using the previously used server address (if set). If that fails, the
     * device is discovered again using its operational instance details.
     * It returns the operational MessageChannel on success.
     */
    private resume;
    /** Pair with an operational device (already commissioned) and establish a CASE session. */
    private pair;
    isCommissioned(): boolean;
    getCommissionedNodes(): NodeId[];
    getCommissionedNodesDetails(): {
        nodeId: NodeId;
        operationalAddress: string | undefined;
        advertisedName: string | undefined;
        discoveryData: DiscoveryData | undefined;
        basicInformationData: Record<string, SupportedStorageTypes> | undefined;
    }[];
    private setOperationalDeviceData;
    enhanceCommissionedNodeDetails(nodeId: NodeId, data: {
        basicInformationData: Record<string, SupportedStorageTypes>;
    }): Promise<void>;
    private getLastOperationalAddress;
    private storeCommissionedNodes;
    /**
     * Connect to the device by opening a channel and creating a new CASE session if necessary.
     * Returns a InteractionClient on success.
     */
    connect(peerNodeId: NodeId, timeoutSeconds?: number, discoveryData?: DiscoveryData): Promise<InteractionClient>;
    getNextAvailableSessionId(): Promise<number>;
    getResumptionRecord(resumptionId: ByteArray): ResumptionRecord | undefined;
    findResumptionRecordByNodeId(nodeId: NodeId): ResumptionRecord | undefined;
    saveResumptionRecord(resumptionRecord: ResumptionRecord): Promise<void>;
    announce(): void;
    close(): Promise<void>;
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("./fabric/Fabric.js").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
}
export {};
//# sourceMappingURL=MatterController.d.ts.map