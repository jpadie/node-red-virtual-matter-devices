{
  "version": 3,
  "sources": ["../../../src/common/FailsafeTimer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { Time, Timer } from \"../time/Time.js\";\nimport type { FailsafeContext } from \"./FailsafeContext.js\";\nimport { MatterFlowError } from \"./MatterError.js\";\n\nexport class MatterFabricConflictError extends MatterFlowError {}\n\nconst logger = Logger.get(\"FailsafeTimer\");\n\n/**\n * Manages the failsafe timer associated with a {@link FailsafeContext}.\n */\nexport class FailsafeTimer {\n    #expiryCallback: () => Promise<void>;\n    #failsafeTimer: Timer;\n    #maxCumulativeFailsafeTimer: Timer;\n\n    constructor(\n        public associatedFabric: Fabric | undefined,\n        expiryLengthSeconds: number,\n        maxCumulativeFailsafeSeconds: number,\n        expiryCallback: () => Promise<void>,\n    ) {\n        this.#expiryCallback = expiryCallback;\n        this.#failsafeTimer = this.#startFailsafeTimer(expiryLengthSeconds);\n        this.#maxCumulativeFailsafeTimer = Time.getTimer(\n            \"Max cumulative failsafe\",\n            maxCumulativeFailsafeSeconds * 1000,\n            () => this.expire(),\n        ).start();\n    }\n\n    async close() {\n        if (this.#failsafeTimer.isRunning) {\n            this.#failsafeTimer.stop();\n        }\n        if (this.#maxCumulativeFailsafeTimer.isRunning) {\n            this.#maxCumulativeFailsafeTimer.stop();\n        }\n    }\n\n    /** Handle \"Re-Arming\" an existing FailSafe context to extend the timer, expire or fail if not allowed. */\n    async reArm(associatedFabric: Fabric | undefined, expiryLengthSeconds: number) {\n        if (!this.#failsafeTimer.isRunning) {\n            throw new MatterFlowError(\"FailSafe already expired.\");\n        }\n\n        if (this.associatedFabric?.fabricIndex !== associatedFabric?.fabricIndex) {\n            throw new MatterFlowError(\n                `FailSafe already armed (index=${this.associatedFabric?.fabricIndex}) with different fabric (index=${associatedFabric?.fabricIndex}).`,\n            );\n        }\n\n        this.#failsafeTimer.stop();\n\n        if (expiryLengthSeconds === 0) {\n            // If ExpiryLengthSeconds is 0 and the fail-safe timer was already armed and the accessing fabric matches\n            // the Fabric currently associated with the fail-safe context, then the fail-safe timer SHALL be\n            // immediately expired (see further below for side-effects of expiration).\n            await this.expire();\n        } else {\n            // If ExpiryLengthSeconds is non-zero and the fail-safe timer was currently armed, and the accessing Fabric\n            // matches the fail-safe context\u2019s associated Fabric, then the fail-safe timer SHALL be re- armed to expire\n            // in ExpiryLengthSeconds.\n            this.#failsafeTimer = this.#startFailsafeTimer(expiryLengthSeconds);\n        }\n    }\n\n    /** Expire the FailSafe context. This is called by the timer and can also be called manually if needed. */\n    async expire() {\n        this.complete();\n        await this.#expiryCallback();\n    }\n\n    /** Complete the FailSafe context. This is called when the commissioning is completed. */\n    complete() {\n        this.#failsafeTimer.stop();\n        this.#maxCumulativeFailsafeTimer.stop();\n    }\n\n    #startFailsafeTimer(expiryLengthSeconds: number) {\n        return Time.getTimer(\"Failsafe expiration\", expiryLengthSeconds * 1000, () =>\n            this.expire().catch(e => logger.error(\"Error during failsafe expiration\", e)),\n        ).start();\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,SAAS,cAAc;AACvB,SAAS,YAAmB;AAE5B,SAAS,uBAAuB;AAEzB,MAAM,kCAAkC,gBAAgB;AAAC;AAEhE,MAAM,SAAS,OAAO,IAAI,eAAe;AAKlC,MAAM,cAAc;AAAA,EAKvB,YACW,kBACP,qBACA,8BACA,gBACF;AAJS;AAKP,SAAK,kBAAkB;AACvB,SAAK,iBAAiB,KAAK,oBAAoB,mBAAmB;AAClE,SAAK,8BAA8B,KAAK;AAAA,MACpC;AAAA,MACA,+BAA+B;AAAA,MAC/B,MAAM,KAAK,OAAO;AAAA,IACtB,EAAE,MAAM;AAAA,EACZ;AAAA,EAjBA;AAAA,EACA;AAAA,EACA;AAAA,EAiBA,MAAM,QAAQ;AACV,QAAI,KAAK,eAAe,WAAW;AAC/B,WAAK,eAAe,KAAK;AAAA,IAC7B;AACA,QAAI,KAAK,4BAA4B,WAAW;AAC5C,WAAK,4BAA4B,KAAK;AAAA,IAC1C;AAAA,EACJ;AAAA;AAAA,EAGA,MAAM,MAAM,kBAAsC,qBAA6B;AAC3E,QAAI,CAAC,KAAK,eAAe,WAAW;AAChC,YAAM,IAAI,gBAAgB,2BAA2B;AAAA,IACzD;AAEA,QAAI,KAAK,kBAAkB,gBAAgB,kBAAkB,aAAa;AACtE,YAAM,IAAI;AAAA,QACN,iCAAiC,KAAK,kBAAkB,WAAW,kCAAkC,kBAAkB,WAAW;AAAA,MACtI;AAAA,IACJ;AAEA,SAAK,eAAe,KAAK;AAEzB,QAAI,wBAAwB,GAAG;AAI3B,YAAM,KAAK,OAAO;AAAA,IACtB,OAAO;AAIH,WAAK,iBAAiB,KAAK,oBAAoB,mBAAmB;AAAA,IACtE;AAAA,EACJ;AAAA;AAAA,EAGA,MAAM,SAAS;AACX,SAAK,SAAS;AACd,UAAM,KAAK,gBAAgB;AAAA,EAC/B;AAAA;AAAA,EAGA,WAAW;AACP,SAAK,eAAe,KAAK;AACzB,SAAK,4BAA4B,KAAK;AAAA,EAC1C;AAAA,EAEA,oBAAoB,qBAA6B;AAC7C,WAAO,KAAK;AAAA,MAAS;AAAA,MAAuB,sBAAsB;AAAA,MAAM,MACpE,KAAK,OAAO,EAAE,MAAM,OAAK,OAAO,MAAM,oCAAoC,CAAC,CAAC;AAAA,IAChF,EAAE,MAAM;AAAA,EACZ;AACJ;",
  "names": []
}
