/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { UnexpectedDataError } from "../common/MatterError.js";
import { ByteArray, Endian } from "../util/ByteArray.js";
import { DataReader } from "../util/DataReader.js";
import { toHex } from "../util/Number.js";
import { isObject } from "../util/Type.js";
const OBJECT_ID_KEY = "_objectId";
const TAG_ID_KEY = "_tag";
const BYTES_KEY = "_bytes";
const ELEMENTS_KEY = "_elements";
const BITS_PADDING = "_padding";
const TYPE_OVERRIDE_KEY = "_type";
const RAW_DATA_KEY = "_raw";
var DerType = /* @__PURE__ */ ((DerType2) => {
  DerType2[DerType2["Boolean"] = 1] = "Boolean";
  DerType2[DerType2["Integer"] = 2] = "Integer";
  DerType2[DerType2["BitString"] = 3] = "BitString";
  DerType2[DerType2["OctetString"] = 4] = "OctetString";
  DerType2[DerType2["Null"] = 5] = "Null";
  DerType2[DerType2["ObjectIdentifier"] = 6] = "ObjectIdentifier";
  DerType2[DerType2["UTF8String"] = 12] = "UTF8String";
  DerType2[DerType2["Sequence"] = 16] = "Sequence";
  DerType2[DerType2["Set"] = 17] = "Set";
  DerType2[DerType2["PrintableString"] = 19] = "PrintableString";
  DerType2[DerType2["T16String"] = 20] = "T16String";
  DerType2[DerType2["IA5String"] = 22] = "IA5String";
  DerType2[DerType2["UtcDate"] = 23] = "UtcDate";
  DerType2[DerType2["GeneralizedTime"] = 24] = "GeneralizedTime";
  return DerType2;
})(DerType || {});
const CONSTRUCTED = 32;
var DerClass = /* @__PURE__ */ ((DerClass2) => {
  DerClass2[DerClass2["Universal"] = 0] = "Universal";
  DerClass2[DerClass2["Application"] = 64] = "Application";
  DerClass2[DerClass2["ContextSpecific"] = 128] = "ContextSpecific";
  DerClass2[DerClass2["Private"] = 192] = "Private";
  return DerClass2;
})(DerClass || {});
const ObjectId = (objectId) => ({
  [TAG_ID_KEY]: 6 /* ObjectIdentifier */,
  [BYTES_KEY]: ByteArray.fromHex(objectId)
});
const DerObject = (objectId, content = {}) => ({ [OBJECT_ID_KEY]: ObjectId(objectId), ...content });
const BitByteArray = (data, padding = 0) => ({
  [TAG_ID_KEY]: 3 /* BitString */,
  [BYTES_KEY]: data,
  [BITS_PADDING]: padding
});
const ContextTagged = (tagId, value) => ({
  [TAG_ID_KEY]: tagId | 128 /* ContextSpecific */ | CONSTRUCTED,
  [BYTES_KEY]: value === void 0 ? new ByteArray(0) : DerCodec.encode(value)
});
const ContextTaggedBytes = (tagId, value) => ({
  [TAG_ID_KEY]: tagId | 128 /* ContextSpecific */,
  [BYTES_KEY]: value
});
const DatatypeOverride = (type, value) => ({
  [TYPE_OVERRIDE_KEY]: type,
  [RAW_DATA_KEY]: value
});
const RawBytes = (bytes) => ({
  [BYTES_KEY]: bytes
});
class DerCodec {
  static encode(value) {
    if (Array.isArray(value)) {
      return this.encodeArray(value);
    } else if (value instanceof ByteArray) {
      return this.encodeOctetString(value);
    } else if (value instanceof Date) {
      return this.encodeDate(value);
    } else if (typeof value === "string") {
      return this.encodeString(value);
    } else if (typeof value === "number" || typeof value === "bigint") {
      return this.encodeInteger(value);
    } else if (typeof value === "boolean") {
      return this.encodeBoolean(value);
    } else if (value === void 0) {
      return new ByteArray(0);
    } else if (isObject(value)) {
      if (value[TAG_ID_KEY] !== void 0) {
        const { [TAG_ID_KEY]: tagId, [BITS_PADDING]: bitsPadding, [BYTES_KEY]: bytes } = value;
        if (typeof tagId !== "number") {
          throw new UnexpectedDataError("Tag ID is non-numeric");
        }
        if (bitsPadding !== void 0 && typeof bitsPadding !== "number") {
          throw new UnexpectedDataError("Bits padding is not a numeric byte value");
        }
        if (bytes === void 0 || !ArrayBuffer.isView(bytes)) {
          throw new UnexpectedDataError("DER bytes is not a byte array");
        }
        return this.encodeAsn1(
          tagId,
          bitsPadding === void 0 ? bytes : ByteArray.concat(ByteArray.of(bitsPadding), bytes)
        );
      } else if (value[TYPE_OVERRIDE_KEY] !== void 0 && value[RAW_DATA_KEY] !== void 0) {
        if (value[TYPE_OVERRIDE_KEY] === 2 /* Integer */ && value[RAW_DATA_KEY] instanceof ByteArray) {
          return this.encodeInteger(value[RAW_DATA_KEY]);
        } else if (value[TYPE_OVERRIDE_KEY] === 3 /* BitString */ && typeof value[RAW_DATA_KEY] === "number") {
          return this.encodeBitString(value[RAW_DATA_KEY]);
        } else if (value[TYPE_OVERRIDE_KEY] === 19 /* PrintableString */ && typeof value[RAW_DATA_KEY] === "string") {
          return this.encodePrintableString(value[RAW_DATA_KEY]);
        } else if (value[TYPE_OVERRIDE_KEY] === 22 /* IA5String */ && typeof value[RAW_DATA_KEY] === "string") {
          return this.encodeIA5String(value[RAW_DATA_KEY]);
        } else {
          throw new UnexpectedDataError(`Unsupported override type ${value[TYPE_OVERRIDE_KEY]}`);
        }
      } else if (value[BYTES_KEY] !== void 0 && value[BYTES_KEY] instanceof ByteArray && Object.keys(value).length === 1) {
        return value[BYTES_KEY];
      } else if (value[TYPE_OVERRIDE_KEY] === void 0 && value[BYTES_KEY] === void 0) {
        return this.encodeObject(value);
      } else {
        throw new UnexpectedDataError(`Unsupported object type ${typeof value}`);
      }
    } else {
      throw new UnexpectedDataError(`Unsupported type ${typeof value}`);
    }
  }
  static encodeDate(date) {
    if (date.getFullYear() > 2049) {
      return this.encodeAsn1(
        24 /* GeneralizedTime */,
        ByteArray.fromString(
          date.toISOString().replace(/[-:.T]/g, "").slice(0, 14) + "Z"
        )
      );
    } else
      return this.encodeAsn1(
        23 /* UtcDate */,
        ByteArray.fromString(
          date.toISOString().replace(/[-:.T]/g, "").slice(2, 14) + "Z"
        )
      );
  }
  static encodeBoolean(bool) {
    return this.encodeAsn1(1 /* Boolean */, ByteArray.of(bool ? 255 : 0));
  }
  static encodeArray(array) {
    return this.encodeAsn1(
      17 /* Set */ | CONSTRUCTED,
      ByteArray.concat(...array.map((element) => this.encode(element)))
    );
  }
  static encodeOctetString(value) {
    return this.encodeAsn1(4 /* OctetString */, value);
  }
  static encodeObject(object) {
    const attributes = new Array();
    for (const key in object) {
      attributes.push(this.encode(object[key]));
    }
    return this.encodeAsn1(16 /* Sequence */ | CONSTRUCTED, ByteArray.concat(...attributes));
  }
  static encodeString(value) {
    return this.encodeAsn1(12 /* UTF8String */, ByteArray.fromString(value));
  }
  static encodePrintableString(value) {
    if (!/^[A-Za-z0-9 '()+,-./:=?]*$/g.test(value)) {
      throw new UnexpectedDataError(`String ${value} is not a printable string.`);
    }
    return this.encodeAsn1(19 /* PrintableString */, ByteArray.fromString(value));
  }
  static encodeIA5String(value) {
    if (!/^[\x00-\x7F]*$/.test(value)) {
      throw new UnexpectedDataError(`String ${value} is not an IA5 string.`);
    }
    return this.encodeAsn1(22 /* IA5String */, ByteArray.fromString(value));
  }
  static encodeInteger(value) {
    const isByteArray = ArrayBuffer.isView(value);
    let valueBytes;
    if (isByteArray) {
      valueBytes = value;
    } else {
      valueBytes = ByteArray.fromHex(toHex(value));
    }
    const byteArray = ByteArray.concat(new ByteArray(1), valueBytes);
    const dataView = byteArray.getDataView();
    let start = 0;
    while (true) {
      if (dataView.getUint8(start) !== 0) break;
      if (dataView.getUint8(start + 1) >= 128) break;
      start++;
      if (start === byteArray.length - 1) break;
    }
    return this.encodeAsn1(2 /* Integer */, byteArray.slice(start));
  }
  static encodeBitString(value) {
    const reversedBits = value.toString(2).padStart(8, "0");
    const unusedBits = reversedBits.indexOf("1");
    const bitByteArray = ByteArray.of(parseInt(reversedBits.split("").reverse().join(""), 2));
    return this.encode(BitByteArray(bitByteArray, unusedBits === -1 ? 8 : unusedBits));
  }
  static encodeLengthBytes(value) {
    const byteArray = new ByteArray(5);
    const dataView = byteArray.getDataView();
    dataView.setUint32(1, value);
    let start = 0;
    while (true) {
      if (dataView.getUint8(start) !== 0) break;
      start++;
      if (start === 4) break;
    }
    const lengthLength = byteArray.length - start;
    if (lengthLength > 1 || dataView.getUint8(start) >= 128) {
      start--;
      dataView.setUint8(start, 128 + lengthLength);
    }
    return byteArray.slice(start);
  }
  static encodeAsn1(tag, data) {
    return ByteArray.concat(ByteArray.of(tag), this.encodeLengthBytes(data.length), data);
  }
  static decode(data) {
    return this.decodeRec(new DataReader(data, Endian.Big));
  }
  static decodeRec(reader) {
    const { tag, bytes } = this.decodeAsn1(reader);
    if (tag === 3 /* BitString */)
      return { [TAG_ID_KEY]: tag, [BYTES_KEY]: bytes.slice(1), [BITS_PADDING]: bytes[0] };
    if ((tag & CONSTRUCTED) === 0) return { [TAG_ID_KEY]: tag, [BYTES_KEY]: bytes };
    const elementsReader = new DataReader(bytes, Endian.Big);
    const elements = [];
    while (elementsReader.getRemainingBytesCount() > 0) {
      elements.push(this.decodeRec(elementsReader));
    }
    return { [TAG_ID_KEY]: tag, [BYTES_KEY]: bytes, [ELEMENTS_KEY]: elements };
  }
  static decodeAsn1(reader) {
    const tag = reader.readUInt8();
    let length = reader.readUInt8();
    if ((length & 128) !== 0) {
      let lengthLength = length & 127;
      length = 0;
      while (lengthLength > 0) {
        length = (length << 8) + reader.readUInt8();
        lengthLength--;
      }
    }
    const bytes = reader.readByteArray(length);
    return { tag, bytes };
  }
}
export {
  BITS_PADDING,
  BYTES_KEY,
  BitByteArray,
  ContextTagged,
  ContextTaggedBytes,
  DatatypeOverride,
  DerCodec,
  DerObject,
  DerType,
  ELEMENTS_KEY,
  OBJECT_ID_KEY,
  ObjectId,
  RAW_DATA_KEY,
  RawBytes,
  TAG_ID_KEY,
  TYPE_OVERRIDE_KEY
};
//# sourceMappingURL=DerCodec.js.map
