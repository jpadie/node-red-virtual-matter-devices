{
  "version": 3,
  "sources": ["../../../src/codec/DnsCodec.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError, NotImplementedError, UnexpectedDataError } from \"../common/MatterError.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataReader } from \"../util/DataReader.js\";\nimport { DataWriter } from \"../util/DataWriter.js\";\nimport { isIPv4, isIPv6 } from \"../util/Ip.js\";\n\n/**\n * The maximum MDNS message size to usually fit into one UDP network MTU packet. Data are split into multiple messages\n * when needed.\n */\nexport const MAX_MDNS_MESSAGE_SIZE = 1232; // 1280bytes (IPv6 packet size) - 8bytes (UDP header) - 40bytes (IPv6 IP header, IPv4 is only 20bytes)\n\nexport const PtrRecord = (name: string, ptr: string, ttl = 120, flushCache = false): DnsRecord<string> => ({\n    name,\n    value: ptr,\n    ttl,\n    recordType: DnsRecordType.PTR,\n    recordClass: DnsRecordClass.IN,\n    flushCache,\n});\nexport const ARecord = (name: string, ip: string, ttl = 120, flushCache = false): DnsRecord<string> => ({\n    name,\n    value: ip,\n    ttl,\n    recordType: DnsRecordType.A,\n    recordClass: DnsRecordClass.IN,\n    flushCache,\n});\nexport const AAAARecord = (name: string, ip: string, ttl = 120, flushCache = false): DnsRecord<string> => ({\n    name,\n    value: ip,\n    ttl,\n    recordType: DnsRecordType.AAAA,\n    recordClass: DnsRecordClass.IN,\n    flushCache,\n});\nexport const TxtRecord = (name: string, entries: string[], ttl = 120, flushCache = false): DnsRecord<string[]> => ({\n    name,\n    value: entries,\n    ttl,\n    recordType: DnsRecordType.TXT,\n    recordClass: DnsRecordClass.IN,\n    flushCache,\n});\nexport const SrvRecord = (\n    name: string,\n    srv: SrvRecordValue,\n    ttl = 120,\n    flushCache = false,\n): DnsRecord<SrvRecordValue> => ({\n    name,\n    value: srv,\n    ttl,\n    recordType: DnsRecordType.SRV,\n    recordClass: DnsRecordClass.IN,\n    flushCache,\n});\n\nexport type SrvRecordValue = {\n    priority: number;\n    weight: number;\n    port: number;\n    target: string;\n};\n\nexport type DnsQuery = {\n    name: string;\n    recordType: DnsRecordType;\n    recordClass: DnsRecordClass;\n    uniCastResponse?: boolean;\n};\n\nexport type DnsRecord<T> = {\n    name: string;\n    recordType: DnsRecordType;\n    recordClass: DnsRecordClass;\n    flushCache?: boolean;\n    ttl: number;\n    value: T;\n};\n\nexport type DnsMessage = {\n    transactionId: number;\n    messageType: DnsMessageType;\n    queries: DnsQuery[];\n    answers: DnsRecord<any>[];\n    authorities: DnsRecord<any>[];\n    additionalRecords: DnsRecord<any>[];\n};\n\nexport type DnsMessagePartiallyPreEncoded = Omit<DnsMessage, \"answers\" | \"additionalRecords\"> & {\n    answers: (DnsRecord<any> | ByteArray)[];\n    additionalRecords: (DnsRecord<any> | ByteArray)[];\n};\n\nexport enum DnsMessageType {\n    Query = 0x0000,\n    TruncatedQuery = 0x0200,\n    Response = 0x8400, // Authoritative Answer\n    TruncatedResponse = 0x8600,\n}\n\nexport enum DnsRecordType {\n    A = 0x01,\n    PTR = 0x0c,\n    TXT = 0x10,\n    AAAA = 0x1c,\n    SRV = 0x21,\n    NSEC = 0x2f,\n    ANY = 0xff,\n}\n\nexport enum DnsRecordClass {\n    IN = 0x01,\n    ANY = 0xff,\n}\n\nexport class DnsCodec {\n    static decode(message: ByteArray): DnsMessage | undefined {\n        try {\n            const reader = new DataReader(message, Endian.Big);\n            const transactionId = reader.readUInt16();\n            const messageType = reader.readUInt16();\n            const queriesCount = reader.readUInt16();\n            const answersCount = reader.readUInt16();\n            const authoritiesCount = reader.readUInt16();\n            const additionalRecordsCount = reader.readUInt16();\n            const queries = new Array<DnsQuery>();\n            for (let i = 0; i < queriesCount; i++) {\n                queries.push(this.decodeQuery(reader, message));\n            }\n            const answers = new Array<DnsRecord<any>>();\n            for (let i = 0; i < answersCount; i++) {\n                answers.push(this.decodeRecord(reader, message));\n            }\n            const authorities = new Array<DnsRecord<any>>();\n            for (let i = 0; i < authoritiesCount; i++) {\n                authorities.push(this.decodeRecord(reader, message));\n            }\n            const additionalRecords = new Array<DnsRecord<any>>();\n            for (let i = 0; i < additionalRecordsCount; i++) {\n                additionalRecords.push(this.decodeRecord(reader, message));\n            }\n            return { transactionId, messageType, queries, answers, authorities, additionalRecords };\n        } catch (error) {\n            return undefined;\n        }\n    }\n\n    private static decodeQuery(reader: DataReader<Endian.Big>, message: ByteArray): DnsQuery {\n        const name = this.decodeQName(reader, message);\n        const recordType = reader.readUInt16();\n        const classInt = reader.readUInt16();\n        const uniCastResponse = (classInt & 0x8000) !== 0;\n        const recordClass = classInt & 0x7fff;\n        return { name, recordType, recordClass, uniCastResponse };\n    }\n\n    private static decodeRecord(reader: DataReader<Endian.Big>, message: ByteArray): DnsRecord<any> {\n        const name = this.decodeQName(reader, message);\n        const recordType = reader.readUInt16();\n        const classInt = reader.readUInt16();\n        const flushCache = (classInt & 0x8000) !== 0;\n        const recordClass = classInt & 0x7fff;\n        const ttl = reader.readUInt32();\n        const valueLength = reader.readUInt16();\n        const valueBytes = reader.readByteArray(valueLength);\n        const value = this.decodeRecordValue(valueBytes, recordType, message);\n        return { name, recordType, recordClass, ttl, value, flushCache };\n    }\n\n    private static decodeQName(reader: DataReader<Endian.Big>, message: ByteArray) {\n        const messageReader = new DataReader(message, Endian.Big);\n        const qNameItems = new Array<string>();\n        while (true) {\n            const itemLength = reader.readUInt8();\n            if (itemLength === 0) break;\n            if ((itemLength & 0xc0) !== 0) {\n                // Compressed Qname\n                const indexInMessage = reader.readUInt8() | ((itemLength & 0x3f) << 8);\n                messageReader.setOffset(indexInMessage);\n                qNameItems.push(this.decodeQName(messageReader, message));\n                break;\n            }\n            qNameItems.push(reader.readUtf8String(itemLength));\n        }\n        return qNameItems.join(\".\");\n    }\n\n    private static decodeRecordValue(valueBytes: ByteArray, recordType: DnsRecordType, message: ByteArray) {\n        switch (recordType) {\n            case DnsRecordType.PTR:\n                return this.decodeQName(new DataReader(valueBytes, Endian.Big), message);\n            case DnsRecordType.SRV:\n                return this.decodeSrvRecord(valueBytes, message);\n            case DnsRecordType.TXT:\n                return this.decodeTxtRecord(valueBytes);\n            case DnsRecordType.AAAA:\n                return this.decodeAaaaRecord(valueBytes);\n            case DnsRecordType.A:\n                return this.decodeARecord(valueBytes);\n            default:\n                // Unknown type, don't decode\n                return valueBytes;\n        }\n    }\n\n    private static decodeSrvRecord(valueBytes: ByteArray, message: ByteArray): SrvRecordValue {\n        const reader = new DataReader(valueBytes, Endian.Big);\n        const priority = reader.readUInt16();\n        const weight = reader.readUInt16();\n        const port = reader.readUInt16();\n        const target = this.decodeQName(reader, message);\n        return { priority, weight, port, target };\n    }\n\n    private static decodeTxtRecord(valueBytes: ByteArray): string[] {\n        const reader = new DataReader(valueBytes, Endian.Big);\n        const result = new Array<string>();\n        let bytesRead = 0;\n        while (bytesRead < valueBytes.length) {\n            const length = reader.readUInt8();\n            result.push(reader.readUtf8String(length));\n            bytesRead += length + 1;\n        }\n        return result;\n    }\n\n    private static decodeAaaaRecord(valueBytes: ByteArray): string {\n        const reader = new DataReader(valueBytes, Endian.Big);\n        const ipItems = new Array<string>();\n        for (let i = 0; i < 8; i++) {\n            ipItems.push(reader.readUInt16().toString(16));\n        }\n        // Compress 0 sequences\n        const zeroSequences = new Array<{ start: number; length: number }>();\n        for (let i = 0; i < 8; i++) {\n            if (ipItems[i] !== \"0\") continue;\n            const start = i;\n            i++;\n            while (i < 8 && ipItems[i] === \"0\") {\n                i++;\n            }\n            zeroSequences.push({ start, length: i - start });\n        }\n        if (zeroSequences.length > 0) {\n            zeroSequences.sort((a, b) => a.length - b.length);\n            const { start, length } = zeroSequences[0];\n            ipItems[start] = \"\";\n            ipItems.splice(start + 1, length - 1);\n        }\n        return ipItems.join(\":\");\n    }\n\n    private static decodeARecord(valueBytes: ByteArray): string {\n        const reader = new DataReader(valueBytes, Endian.Big);\n        const ipItems = new Array<string>();\n        for (let i = 0; i < 4; i++) {\n            ipItems.push(reader.readUInt8().toString());\n        }\n        return ipItems.join(\".\");\n    }\n\n    static encode({\n        messageType,\n        transactionId = 0,\n        queries = [],\n        answers = [],\n        authorities = [],\n        additionalRecords = [],\n    }: Partial<DnsMessagePartiallyPreEncoded>): ByteArray {\n        if (messageType === undefined) throw new InternalError(\"Message type must be specified!\");\n        if (queries.length > 0 && messageType !== DnsMessageType.Query && messageType !== DnsMessageType.TruncatedQuery)\n            throw new InternalError(\"Queries can only be included in query messages!\");\n        if (authorities.length > 0) throw new NotImplementedError(\"Authority answers are not supported yet!\");\n\n        const writer = new DataWriter(Endian.Big);\n        writer.writeUInt16(transactionId);\n        writer.writeUInt16(messageType);\n        writer.writeUInt16(queries.length);\n        writer.writeUInt16(answers.length);\n        writer.writeUInt16(authorities.length);\n        writer.writeUInt16(additionalRecords.length);\n        queries.forEach(({ name, recordClass, recordType, uniCastResponse = false }) => {\n            writer.writeByteArray(this.encodeQName(name));\n            writer.writeUInt16(recordType);\n            writer.writeUInt16(recordClass | (uniCastResponse ? 0x8000 : 0));\n        });\n        [...answers, ...authorities, ...additionalRecords].forEach(record => {\n            if (record instanceof ByteArray) {\n                writer.writeByteArray(record);\n            } else {\n                writer.writeByteArray(this.encodeRecord(record));\n            }\n        });\n        return writer.toByteArray();\n    }\n\n    static encodeRecord(record: DnsRecord<any>): ByteArray {\n        const { name, recordType, recordClass, ttl, value, flushCache = false } = record;\n\n        const writer = new DataWriter(Endian.Big);\n        writer.writeByteArray(this.encodeQName(name));\n        writer.writeUInt16(recordType);\n        writer.writeUInt16(recordClass | (flushCache ? 0x8000 : 0));\n        writer.writeUInt32(ttl);\n        const encodedValue = this.encodeRecordValue(value, recordType);\n        writer.writeUInt16(encodedValue.length);\n        writer.writeByteArray(encodedValue);\n        return writer.toByteArray();\n    }\n\n    private static encodeRecordValue(value: any, recordType: DnsRecordType): ByteArray {\n        switch (recordType) {\n            case DnsRecordType.PTR:\n                return this.encodeQName(value as string);\n            case DnsRecordType.SRV:\n                return this.encodeSrvRecord(value as SrvRecordValue);\n            case DnsRecordType.TXT:\n                return this.encodeTxtRecord(value as string[]);\n            case DnsRecordType.AAAA:\n                return this.encodeAaaaRecord(value as string);\n            case DnsRecordType.A:\n                return this.encodeARecord(value as string);\n            default:\n                if (value instanceof ByteArray) return value;\n                throw new UnexpectedDataError(`Unsupported record type ${recordType}`);\n        }\n    }\n\n    private static encodeARecord(ip: string) {\n        if (!isIPv4(ip)) throw new UnexpectedDataError(`Invalid A Record value: ${ip}`);\n        const writer = new DataWriter(Endian.Big);\n        ip.split(\".\").forEach(part => {\n            writer.writeUInt8(parseInt(part));\n        });\n        return writer.toByteArray();\n    }\n\n    private static encodeAaaaRecord(ip: string) {\n        if (!isIPv6(ip)) throw new UnexpectedDataError(`Invalid AAAA Record value: ${ip}`);\n        const writer = new DataWriter(Endian.Big);\n        const parts = ip.split(\":\");\n        parts.forEach(part => {\n            if (part === \"\") {\n                const compressedParts = 8 - parts.length;\n                for (let i = 0; i < compressedParts; i++) {\n                    writer.writeUInt16(0);\n                }\n            }\n            writer.writeUInt16(parseInt(part, 16));\n        });\n        return writer.toByteArray();\n    }\n\n    private static encodeTxtRecord(entries: string[]) {\n        const writer = new DataWriter(Endian.Big);\n        entries.forEach(entry => {\n            const entryData = ByteArray.fromString(entry);\n            writer.writeUInt8(entryData.length);\n            writer.writeByteArray(entryData);\n        });\n        return writer.toByteArray();\n    }\n\n    private static encodeSrvRecord({ priority, weight, port, target }: SrvRecordValue) {\n        const writer = new DataWriter(Endian.Big);\n        writer.writeUInt16(priority);\n        writer.writeUInt16(weight);\n        writer.writeUInt16(port);\n        writer.writeByteArray(this.encodeQName(target));\n        return writer.toByteArray();\n    }\n\n    private static encodeQName(qname: string) {\n        const writer = new DataWriter(Endian.Big);\n        if (qname.length > 0) {\n            qname.split(\".\").forEach(label => {\n                const labelData = ByteArray.fromString(label);\n                writer.writeUInt8(labelData.length);\n                writer.writeByteArray(labelData);\n            });\n        }\n        writer.writeUInt8(0);\n        return writer.toByteArray();\n    }\n}\n"],
  "mappings": "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",
  "names": ["DnsMessageType", "DnsRecordType", "DnsRecordClass"]
}
