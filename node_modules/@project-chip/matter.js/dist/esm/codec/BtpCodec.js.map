{
  "version": 3,
  "sources": ["../../../src/codec/BtpCodec.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BleError } from \"../ble/Ble.js\";\nimport { BtpProtocolError } from \"../ble/BtpSessionHandler.js\";\nimport { VendorId } from \"../datatype/VendorId.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataReader } from \"../util/DataReader.js\";\nimport { DataWriter } from \"../util/DataWriter.js\";\n\nexport interface BtpHandshakeRequest {\n    versions: number[];\n    attMtu: number;\n    clientWindowSize: number;\n}\n\nexport interface BtpHandshakeResponse {\n    version: number;\n    attMtu: number;\n    windowSize: number;\n}\n\nexport interface BtpPacketPayload {\n    ackNumber?: number;\n    sequenceNumber: number;\n    messageLength?: number;\n    segmentPayload?: ByteArray;\n}\n\nexport interface DecodedBtpPacketPayload extends BtpPacketPayload {\n    segmentPayload: ByteArray;\n}\n\nexport interface BtpHeader {\n    isHandshakeRequest: boolean;\n    hasManagementOpcode: boolean;\n    hasAckNumber: boolean;\n    isEndingSegment: boolean;\n    isContinuingSegment: boolean;\n    isBeginningSegment: boolean;\n}\n\nexport interface BtpPacket {\n    header: BtpHeader;\n    payload: BtpPacketPayload;\n}\n\nexport interface DecodedBtpPacket {\n    header: BtpHeader;\n    payload: DecodedBtpPacketPayload;\n}\n\nexport enum BtpHeaderBits {\n    HandshakeBit = 0b01000000,\n    ManagementMsg = 0b00100000,\n    AckMsg = 0b00001000,\n    EndSegment = 0b00000100,\n    ContinuingSegment = 0b00000010,\n    BeginSegment = 0b00000001,\n}\n\nexport enum BtpOpcode {\n    HandshakeManagementOpcode = 0x6c,\n}\n\nconst HANDSHAKE_HEADER = 0b01100101;\n\nexport class BtpCodec {\n    static decodeBtpHandshakeRequest(data: ByteArray): BtpHandshakeRequest {\n        const reader = new DataReader(data, Endian.Little);\n        return this.decodeHandshakeRequestPayload(reader);\n    }\n\n    static decodeBtpPacket(data: ByteArray): DecodedBtpPacket {\n        const reader = new DataReader(data, Endian.Little);\n\n        const header = this.decodeBtpPacketHeader(reader);\n\n        return {\n            header,\n            payload: this.decodeBtpPacketPayload(reader, header),\n        };\n    }\n\n    static encodeBtpPacket({ header, payload }: BtpPacket): ByteArray {\n        return ByteArray.concat(this.encodeBtpPacketHeader(header), this.encodeBtpPacketPayload(header, payload));\n    }\n\n    static encodeBtpHandshakeRequest({ versions, attMtu, clientWindowSize }: BtpHandshakeRequest): ByteArray {\n        const writer = new DataWriter(Endian.Little);\n        writer.writeUInt8(HANDSHAKE_HEADER);\n        writer.writeUInt8(BtpOpcode.HandshakeManagementOpcode);\n        writer.writeUInt8((versions[1] << 4) | versions[0]);\n        writer.writeUInt8((versions[3] << 4) | versions[2]);\n        writer.writeUInt8((versions[5] << 4) | versions[4]);\n        writer.writeUInt8((versions[7] << 4) | versions[6]);\n        writer.writeUInt16(attMtu);\n        writer.writeUInt8(clientWindowSize);\n        return writer.toByteArray();\n    }\n\n    static encodeBtpHandshakeResponse({ version, attMtu, windowSize }: BtpHandshakeResponse): ByteArray {\n        const writer = new DataWriter(Endian.Little);\n        writer.writeUInt8(HANDSHAKE_HEADER);\n        writer.writeUInt8(BtpOpcode.HandshakeManagementOpcode);\n        writer.writeUInt8(version & 0x0f); //reserved bit and final version\n        writer.writeUInt16(attMtu);\n        writer.writeUInt8(windowSize);\n        return writer.toByteArray();\n    }\n\n    private static decodeBtpPacketPayload(\n        reader: DataReader<Endian.Little>,\n        header: BtpHeader,\n    ): DecodedBtpPacketPayload {\n        const { hasAckNumber, isBeginningSegment } = header;\n        const ackNumber = hasAckNumber ? reader.readUInt8() : undefined;\n        const sequenceNumber = reader.readUInt8();\n        const messageLength = isBeginningSegment ? reader.readUInt16() : undefined;\n        const segmentPayload = reader.getRemainingBytes();\n\n        return { ackNumber, sequenceNumber, messageLength, segmentPayload };\n    }\n\n    private static encodeBtpPacketPayload(\n        { hasAckNumber, isBeginningSegment, isContinuingSegment, isEndingSegment }: BtpHeader,\n        { ackNumber, sequenceNumber, messageLength, segmentPayload }: BtpPacketPayload,\n    ): ByteArray {\n        const writer = new DataWriter(Endian.Little);\n\n        // Validate Header against Payload fields to make sure they match together\n        if (!hasAckNumber && ackNumber !== undefined) {\n            throw new BtpProtocolError(\"Ack number shouldn't be set because header flag is not set.\");\n        }\n        if (hasAckNumber && ackNumber === undefined) {\n            throw new BtpProtocolError(\"Ack number needs to be set because header flag is set.\");\n        }\n        if (isBeginningSegment && isContinuingSegment) {\n            throw new BtpProtocolError(\"Beginning and continuing segment flags can't be set at the same time.\");\n        }\n        if (isEndingSegment && !isContinuingSegment && !isBeginningSegment) {\n            throw new BtpProtocolError(\"Ending segment flag can't be set without continuing segment flag.\");\n        }\n        if (\n            (isBeginningSegment || isContinuingSegment) &&\n            (segmentPayload === undefined || segmentPayload.length === 0)\n        ) {\n            throw new BtpProtocolError(\"Payload needs to be set because header flag indicates a message with payload.\");\n        }\n        if (isBeginningSegment && messageLength === undefined) {\n            throw new BtpProtocolError(\"Message length needs to be set because packet is a beginning segment.\");\n        }\n        if (!isBeginningSegment && messageLength !== undefined) {\n            throw new BtpProtocolError(\n                \"Message length shouldn't be set because the package is not a beginning segment.\",\n            );\n        }\n\n        if (ackNumber !== undefined) {\n            writer.writeUInt8(ackNumber);\n        }\n\n        writer.writeUInt8(sequenceNumber);\n\n        if (messageLength !== undefined) {\n            writer.writeUInt16(messageLength);\n        }\n\n        if (segmentPayload !== undefined) {\n            writer.writeByteArray(segmentPayload);\n        }\n        return writer.toByteArray();\n    }\n\n    private static decodeHandshakeRequestPayload(reader: DataReader<Endian.Little>): BtpHandshakeRequest {\n        const header = reader.readUInt8();\n        const opcode = reader.readUInt8();\n        let version = reader.readUInt8();\n\n        if (header !== HANDSHAKE_HEADER) {\n            throw new BtpProtocolError(\"Header for expected BTP Handshake Request is incorrect.\");\n        }\n        if (opcode !== BtpOpcode.HandshakeManagementOpcode) {\n            throw new BtpProtocolError(\"Management Opcode for BTP Handshake Request is incorrect.\");\n        }\n\n        const ver: number[] = [];\n        ver[0] = (version & 0xf0) >> 4;\n        ver[1] = version & 0x0f;\n\n        version = reader.readUInt8();\n        ver[2] = (version & 0xf0) >> 4;\n        ver[3] = version & 0x0f;\n\n        version = reader.readUInt8();\n        ver[4] = (version & 0xf0) >> 4;\n        ver[5] = version & 0x0f;\n\n        version = reader.readUInt8();\n        ver[6] = (version & 0xf0) >> 4;\n        ver[7] = version & 0x0f;\n\n        const versions = ver.filter(v => v !== 0);\n        if (versions.length === 0) {\n            throw new BtpProtocolError(\"No valid version provided.\");\n        }\n\n        const attMtu = reader.readUInt16();\n        const clientWindowSize = reader.readUInt8();\n\n        return { versions, attMtu, clientWindowSize };\n    }\n\n    static decodeBtpHandshakeResponsePayload(data: ByteArray): BtpHandshakeResponse {\n        const reader = new DataReader(data, Endian.Little);\n        const header = reader.readUInt8();\n        if (header !== HANDSHAKE_HEADER) {\n            throw new BtpProtocolError(\"Header for expected BTP Handshake Request is incorrect.\");\n        }\n\n        const opcode = reader.readUInt8();\n        if (opcode !== BtpOpcode.HandshakeManagementOpcode) {\n            throw new BtpProtocolError(\"Management Opcode for BTP Handshake Request is incorrect.\");\n        }\n\n        const version = reader.readUInt8() & 0x0f;\n        const attMtu = reader.readUInt16();\n        const windowSize = reader.readUInt8();\n        return { version, attMtu, windowSize };\n    }\n\n    private static decodeBtpPacketHeader(reader: DataReader<Endian.Little>): BtpHeader {\n        const headerBits = reader.readUInt8();\n        const isHandshakeRequest = (headerBits & BtpHeaderBits.HandshakeBit) !== 0;\n        const hasManagementOpcode = (headerBits & BtpHeaderBits.ManagementMsg) !== 0;\n        const hasAckNumber = (headerBits & BtpHeaderBits.AckMsg) !== 0;\n        const isEndingSegment = (headerBits & BtpHeaderBits.EndSegment) !== 0;\n        const isContinuingSegment = (headerBits & BtpHeaderBits.ContinuingSegment) !== 0;\n        const isBeginningSegment = (headerBits & BtpHeaderBits.BeginSegment) !== 0;\n\n        if (hasManagementOpcode) {\n            throw new BtpProtocolError(\"Management Opcode for BTPHandshake Request is not expected\");\n        }\n\n        return {\n            isHandshakeRequest,\n            hasManagementOpcode,\n            hasAckNumber,\n            isEndingSegment,\n            isContinuingSegment,\n            isBeginningSegment,\n        };\n    }\n\n    private static encodeBtpPacketHeader({\n        isHandshakeRequest,\n        hasManagementOpcode,\n        hasAckNumber,\n        isEndingSegment,\n        isContinuingSegment,\n        isBeginningSegment,\n    }: BtpHeader): ByteArray {\n        const writer = new DataWriter(Endian.Little);\n\n        if (isHandshakeRequest || hasManagementOpcode) {\n            throw new BtpProtocolError(\"Please use the specific methods to encode a Handshake packet\");\n        }\n\n        const header =\n            // (isHandshakeRequest ? BtpHeaderBits.HandshakeBit : 0) | ... but always false here\n            // (hasManagementOpcode ? BtpHeaderBits.ManagementMsg : 0) | ... but alw<ys false here\n            (hasAckNumber ? BtpHeaderBits.AckMsg : 0) |\n            (isEndingSegment ? BtpHeaderBits.EndSegment : 0) |\n            (isContinuingSegment ? BtpHeaderBits.ContinuingSegment : 0) |\n            (isBeginningSegment ? BtpHeaderBits.BeginSegment : 0);\n\n        writer.writeUInt8(header);\n        return writer.toByteArray();\n    }\n\n    static encodeBleAdvertisementData(\n        discriminator: number,\n        vendorId: VendorId,\n        productId: number,\n        hasAdditionalAdvertisementData = false,\n    ) {\n        const writer = new DataWriter(Endian.Little);\n        writer.writeUInt8(0x02);\n        writer.writeUInt8(0x01);\n        writer.writeUInt8(0x06);\n        writer.writeUInt8(0x0b);\n        writer.writeUInt8(0x16);\n        writer.writeUInt16(0xfff6);\n        writer.writeUInt8(0x00);\n        writer.writeUInt16(discriminator);\n        writer.writeUInt16(vendorId);\n        writer.writeUInt16(productId);\n        writer.writeUInt8(hasAdditionalAdvertisementData ? 0x01 : 0x00);\n        return writer.toByteArray();\n    }\n\n    static decodeBleAdvertisementData(data: ByteArray) {\n        const reader = new DataReader(data, Endian.Little);\n        if (\n            reader.readUInt8() !== 0x02 ||\n            reader.readUInt8() !== 0x01 ||\n            reader.readUInt8() !== 0x06 ||\n            reader.readUInt8() !== 0x0b ||\n            reader.readUInt8() !== 0x16\n        ) {\n            throw new BleError(\"Invalid BLE advertisement data\");\n        }\n        const serviceUuid = reader.readUInt16();\n        if (serviceUuid !== 0xfff6) {\n            throw new BleError(\"Invalid BLE advertisement data\");\n        }\n        const { discriminator, vendorId, productId, hasAdditionalAdvertisementData } =\n            this.decodeBleAdvertisementServiceData(reader.getRemainingBytes());\n        return { discriminator, vendorId, productId, hasAdditionalAdvertisementData };\n    }\n\n    static decodeBleAdvertisementServiceData(data: ByteArray) {\n        const reader = new DataReader(data, Endian.Little);\n        if (reader.readUInt8() !== 0x00) {\n            throw new BleError(\"Invalid BLE advertisement data\");\n        }\n        const discriminator = reader.readUInt16();\n        const vendorId = reader.readUInt16();\n        const productId = reader.readUInt16();\n        const hasAdditionalAdvertisementData = !!reader.readUInt8();\n        return { discriminator, vendorId, productId, hasAdditionalAdvertisementData };\n    }\n}\n"],
  "mappings": "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",
  "names": ["BtpHeaderBits", "BtpOpcode"]
}
