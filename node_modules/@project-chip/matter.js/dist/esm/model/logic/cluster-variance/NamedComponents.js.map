{
  "version": 3,
  "sources": ["../../../../../src/model/logic/cluster-variance/NamedComponents.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { describeList } from \"../../../util/String.js\";\nimport { ClusterModel } from \"../../models/index.js\";\nimport { InferredComponent, InferredComponents } from \"./InferredComponents.js\";\n\n/**\n * An inferred component with generated name and documentation.\n */\nexport type NamedComponent = InferredComponent & {\n    name: string;\n    documentation: string;\n};\n\n/**\n * A set of components keyed by generated names.\n */\nexport type NamedComponents = NamedComponent[];\n\n/**\n * Compute name and documentation a set of inferred components.\n */\nexport function NamedComponents(cluster: ClusterModel, inferredComponents: InferredComponents) {\n    let base = { mandatory: [], optional: [] } as InferredComponent;\n    const components = [] as NamedComponents;\n    const namedComponentMap = {} as { [name: string]: NamedComponent };\n    const featureNames = Object.fromEntries(cluster.features.map(f => [f.name, f.description || f.name]));\n\n    for (const component of inferredComponents) {\n        let name;\n\n        const contributorDocumentation = Array<string>();\n\n        const allOf = component.condition?.allOf;\n        if (allOf) {\n            const names = allOf.map(f => featureNames[f]);\n            name = names.join(\"And\");\n            contributorDocumentation.push(\n                `it supports feature${allOf.length === 1 ? \"\" : \"s\"}`,\n                describeList(\"and\", ...names),\n            );\n        }\n\n        const anyOf = component.condition?.anyOf;\n        if (anyOf) {\n            const names = anyOf.map(f => featureNames[f]);\n            const members = Array<string>();\n            if (name) {\n                members.push(name);\n            }\n            members.push(...anyOf);\n            name = names.join(\"Or\");\n            if (contributorDocumentation.length) {\n                contributorDocumentation.push(\"and it\");\n            }\n            contributorDocumentation.push(\n                `it supports feature${anyOf.length === 1 ? \"\" : \"s\"}`,\n                describeList(\"or\", ...names),\n            );\n        }\n\n        const not = component.condition?.not;\n        if (not) {\n            name = `${name || \"\"}Not${featureNames[not]}`;\n            if (contributorDocumentation.length) {\n                contributorDocumentation.push(\"and it\");\n            }\n            contributorDocumentation.push(\"doesn't support feature\", not);\n        }\n\n        if (!name) {\n            base = component;\n        } else {\n            contributorDocumentation.unshift(`A ${cluster.name}Cluster supports these elements if`);\n\n            let namedComponent = namedComponentMap[name];\n            if (!namedComponent) {\n                namedComponent = {\n                    name,\n                    documentation: `${contributorDocumentation.join(\" \")}.`,\n                    ...component,\n                };\n                namedComponentMap[name] = namedComponent;\n\n                components.push(namedComponent);\n            }\n        }\n    }\n\n    return { base, components };\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,oBAAoB;AAoBtB,SAAS,gBAAgB,SAAuB,oBAAwC;AAC3F,MAAI,OAAO,EAAE,WAAW,CAAC,GAAG,UAAU,CAAC,EAAE;AACzC,QAAM,aAAa,CAAC;AACpB,QAAM,oBAAoB,CAAC;AAC3B,QAAM,eAAe,OAAO,YAAY,QAAQ,SAAS,IAAI,OAAK,CAAC,EAAE,MAAM,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;AAEpG,aAAW,aAAa,oBAAoB;AACxC,QAAI;AAEJ,UAAM,2BAA2B,MAAc;AAE/C,UAAM,QAAQ,UAAU,WAAW;AACnC,QAAI,OAAO;AACP,YAAM,QAAQ,MAAM,IAAI,OAAK,aAAa,CAAC,CAAC;AAC5C,aAAO,MAAM,KAAK,KAAK;AACvB,+BAAyB;AAAA,QACrB,sBAAsB,MAAM,WAAW,IAAI,KAAK,GAAG;AAAA,QACnD,aAAa,OAAO,GAAG,KAAK;AAAA,MAChC;AAAA,IACJ;AAEA,UAAM,QAAQ,UAAU,WAAW;AACnC,QAAI,OAAO;AACP,YAAM,QAAQ,MAAM,IAAI,OAAK,aAAa,CAAC,CAAC;AAC5C,YAAM,UAAU,MAAc;AAC9B,UAAI,MAAM;AACN,gBAAQ,KAAK,IAAI;AAAA,MACrB;AACA,cAAQ,KAAK,GAAG,KAAK;AACrB,aAAO,MAAM,KAAK,IAAI;AACtB,UAAI,yBAAyB,QAAQ;AACjC,iCAAyB,KAAK,QAAQ;AAAA,MAC1C;AACA,+BAAyB;AAAA,QACrB,sBAAsB,MAAM,WAAW,IAAI,KAAK,GAAG;AAAA,QACnD,aAAa,MAAM,GAAG,KAAK;AAAA,MAC/B;AAAA,IACJ;AAEA,UAAM,MAAM,UAAU,WAAW;AACjC,QAAI,KAAK;AACL,aAAO,GAAG,QAAQ,EAAE,MAAM,aAAa,GAAG,CAAC;AAC3C,UAAI,yBAAyB,QAAQ;AACjC,iCAAyB,KAAK,QAAQ;AAAA,MAC1C;AACA,+BAAyB,KAAK,2BAA2B,GAAG;AAAA,IAChE;AAEA,QAAI,CAAC,MAAM;AACP,aAAO;AAAA,IACX,OAAO;AACH,+BAAyB,QAAQ,KAAK,QAAQ,IAAI,oCAAoC;AAEtF,UAAI,iBAAiB,kBAAkB,IAAI;AAC3C,UAAI,CAAC,gBAAgB;AACjB,yBAAiB;AAAA,UACb;AAAA,UACA,eAAe,GAAG,yBAAyB,KAAK,GAAG,CAAC;AAAA,UACpD,GAAG;AAAA,QACP;AACA,0BAAkB,IAAI,IAAI;AAE1B,mBAAW,KAAK,cAAc;AAAA,MAClC;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,EAAE,MAAM,WAAW;AAC9B;",
  "names": []
}
