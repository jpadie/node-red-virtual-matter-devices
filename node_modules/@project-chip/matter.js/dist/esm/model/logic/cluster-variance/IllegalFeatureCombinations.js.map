{
  "version": 3,
  "sources": ["../../../../../src/model/logic/cluster-variance/IllegalFeatureCombinations.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../../common/MatterError.js\";\nimport { isDeepEqual } from \"../../../util/DeepEqual.js\";\nimport { Conformance } from \"../../aspects/index.js\";\nimport { ClusterModel, FieldModel } from \"../../models/index.js\";\nimport { FeatureBitmap } from \"./FeatureBitmap.js\";\n\nexport type IllegalFeatureCombinations = FeatureBitmap[];\n\ntype Choices = {\n    [name: string]: {\n        exclusive: boolean;\n        features: string[];\n    };\n};\n\n/**\n * Analyzes feature conformance to ascertain feature combinations that are unsupported.  Uses rules to match the\n * conformance AST.\n *\n * Rule matching is not exhaustive but supports a significant subset of the conformance dialect that is inclusive of all\n * feature conformances used by the 1.1 specifications.\n *\n * Throws an error if conformance does not adhere to supported rules.  This indicates the ruleset needs augmentation.\n */\nexport function IllegalFeatureCombinations(cluster: ClusterModel) {\n    const illegal = [] as IllegalFeatureCombinations;\n    const choices = {} as Choices;\n\n    for (const f of cluster.features) {\n        addFeatureNode(f, f.conformance.ast, illegal, choices);\n    }\n\n    function add(flags: FeatureBitmap) {\n        if (!illegal.some(e => isDeepEqual(e, flags))) {\n            illegal.push(flags);\n        }\n    }\n\n    let requiresFeatures = false;\n\n    for (const choice of Object.values(choices)) {\n        // If choices are mutually exclusive, reject any two flags in combination\n        if (choice.exclusive) {\n            for (const f1 of choice.features) {\n                for (const f2 of choice.features) {\n                    if (f1 !== f2) {\n                        add({ [f1]: true, [f2]: true });\n                    }\n                }\n            }\n        }\n\n        // At least one feature choice must be enabled\n        const flags = FeatureBitmap();\n        for (const f of choice.features) {\n            flags[f] = false;\n        }\n        add(flags);\n        requiresFeatures = true;\n    }\n\n    return { illegal, requiresFeatures };\n}\n\nfunction addFeatureNode(\n    feature: FieldModel,\n    node: Conformance.Ast,\n    illegal: IllegalFeatureCombinations,\n    choices: Choices,\n) {\n    function unsupported() {\n        throw new InternalError(`New rule required to support ${feature.path} conformance \"${feature.conformance}\"`);\n    }\n\n    /**\n     * Extract a feature name.\n     */\n    function extractName(node: Conformance.Ast): string {\n        if (node.type === Conformance.Special.Name) {\n            return node.param;\n        }\n        unsupported();\n        return \"\"; // Unreachable\n    }\n\n    /**\n     * Extract a flag for a single feature.  Fails unless the AST is for NAME or !NAME.\n     */\n    function extractFeatureFlag(node: Conformance.Ast) {\n        switch (node.type) {\n            case Conformance.Special.Name:\n                return { [node.param]: true };\n\n            case Conformance.Operator.NOT:\n                return { [extractName(node.param)]: false };\n\n            default:\n                unsupported();\n        }\n    }\n\n    /**\n     * Extends a flag set with flag values that are disallowed given the base feature set.\n     */\n    function addExclusivityRequirement(flags: FeatureBitmap, node: Conformance.Ast) {\n        switch (node.type) {\n            case Conformance.OR:\n                addExclusivityRequirement(flags, node.param.lhs);\n                addExclusivityRequirement(flags, node.param.rhs);\n                break;\n\n            default:\n                Object.assign(flags, extractFeatureFlag(node));\n                break;\n        }\n    }\n\n    /**\n     * Add illegal feature sets for features that must be enabled based on the state of other features.\n     */\n    function addDependencyRequirement(feature: string, node: Conformance.Ast) {\n        switch (node.type) {\n            case Conformance.Special.Name:\n                illegal.push({ [feature]: true, [node.param]: false });\n                break;\n\n            case Conformance.AND:\n                addDependencyRequirement(feature, node.param.lhs);\n                addDependencyRequirement(feature, node.param.rhs);\n                break;\n\n            default:\n                unsupported();\n        }\n    }\n\n    /**\n     * Extract a feature flag disjunction.  Supports | and !.\n     */\n    function extractDisjunctFeatures(node: Conformance.Ast) {\n        const result = {} as FeatureBitmap;\n\n        function extract(node: Conformance.Ast, invert = false) {\n            switch (node.type) {\n                case Conformance.Special.Name:\n                    result[node.param] = !invert;\n                    break;\n\n                case Conformance.Operator.OR:\n                    extract(node.param.lhs, invert);\n                    extract(node.param.rhs, invert);\n                    break;\n\n                case Conformance.Operator.NOT:\n                    extract(node.param, !invert);\n                    break;\n\n                default:\n                    unsupported();\n            }\n        }\n\n        extract(node);\n\n        return result;\n    }\n\n    switch (node.type) {\n        case Conformance.Special.Desc:\n        case Conformance.Special.Empty:\n        case Conformance.Flag.Optional:\n        case Conformance.Flag.Provisional:\n            break;\n\n        case Conformance.Flag.Deprecated:\n        case Conformance.Flag.Disallowed:\n            illegal.push({ [feature.name]: true });\n            break;\n\n        case Conformance.Special.Group:\n            node.param.forEach(ast => addFeatureNode(feature, ast, illegal, choices));\n            break;\n\n        case Conformance.Special.Choice:\n            if (node.param.num > 1) {\n                unsupported();\n            }\n            let choice = choices[node.param.name];\n            if (choice) {\n                choice.features.push(feature.name);\n            } else {\n                choice = choices[node.param.name] = {\n                    exclusive: !node.param.orMore,\n                    features: [feature.name],\n                };\n            }\n            break;\n\n        case Conformance.Special.Name:\n            illegal.push({ [node.param]: true, [feature.name]: false });\n            break;\n\n        case Conformance.Special.OptionalIf:\n            switch (node.param.type) {\n                case Conformance.AND:\n                case Conformance.Special.Name:\n                    addDependencyRequirement(feature.name, node.param);\n                    break;\n\n                case Conformance.OR: {\n                    const flags = FeatureBitmap({ [feature.name]: true });\n                    addExclusivityRequirement(flags, node.param);\n                    illegal.push(flags);\n                    break;\n                }\n\n                case Conformance.Operator.NOT: {\n                    illegal.push({ [feature.name]: true, [extractName(node.param.param)]: true });\n                    break;\n                }\n\n                default:\n                    unsupported();\n            }\n            break;\n\n        case Conformance.Operator.AND: {\n            // Handles simple conjunctions like \"FOO & BAR\" and \"(STA|PAU|FA|CON) & !SFR\"\n            const lhsFeatures = extractDisjunctFeatures(node.param.lhs);\n            const rhsFeature = extractFeatureFlag(node.param.rhs);\n\n            for (const lhsFeature in lhsFeatures) {\n                illegal.push({\n                    feature: false,\n                    [lhsFeature]: lhsFeatures[lhsFeature],\n                    ...rhsFeature,\n                });\n            }\n            break;\n        }\n\n        default:\n            unsupported();\n            break;\n    }\n}\n"],
  "mappings": "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",
  "names": ["node", "feature"]
}
