{
  "version": 3,
  "sources": ["../../../../../src/model/logic/cluster-variance/InferredComponents.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NotImplementedError } from \"../../../common/MatterError.js\";\nimport { isDeepEqual } from \"../../../util/DeepEqual.js\";\nimport { AttributeModel, ClusterModel, ValueModel } from \"../../models/index.js\";\nimport { VarianceCondition } from \"./VarianceCondition.js\";\n\n/**\n * Lists mandatory and optional elements for a specific context.\n */\nexport type InferredComponent = {\n    mandatory: ValueModel[];\n    optional: ValueModel[];\n    condition?: VarianceCondition;\n};\n\n/**\n * A list of component definitions.\n */\nexport type InferredComponents = InferredComponent[];\n\n/**\n * Details components generated by analyzing variance of cluster elements.\n */\nexport function InferredComponents(cluster: ClusterModel): InferredComponents {\n    const result = [] as InferredComponents;\n    cluster.allAces.forEach(child => addElement(result, child));\n    return result;\n}\n\ntype VarianceMatcher = {\n    pattern: RegExp;\n    processor: (add: (optional?: boolean, condition?: VarianceCondition) => void, match: string[]) => void;\n};\n\nfunction pattern(...parts: string[]) {\n    parts = parts.map(p => {\n        switch (p) {\n            case \"[\":\n            case \"]\":\n            case \"(\":\n            case \")\":\n                return `\\\\${p}`;\n\n            default:\n                return p;\n        }\n    });\n    return new RegExp(`^${parts.join(\"\")}$`);\n}\n\nconst FEATURE_NAME = \"[A-Z_][A-Z_0-9]+\";\nconst FEATURE = `(${FEATURE_NAME})`;\nconst CONJUNCT_FEATURES = `(${FEATURE_NAME}(?: & ${FEATURE_NAME})*)`;\nconst DISJUNCT_FEATURES = CONJUNCT_FEATURES.replace(/&/g, \"[|,]\");\nconst FIELD = \"[A-Z][A-Za-z_$]*[a-z][A-Za-z_$]*\";\nconst CONJUNCT_FIELDS = `(${FIELD}(?: & ${FIELD})*)`;\nconst DISJUNCT_FIELDS = CONJUNCT_FIELDS.replace(/&/g, \"[|,]\");\nconst AND = \" & \";\nconst NOT = \"!\";\n\nfunction splitConjunction(conjunction: string) {\n    return conjunction.split(\" & \");\n}\n\nfunction splitDisjunction(disjunction: string) {\n    return disjunction.split(\" | \");\n}\n\n/**\n * We use a rules-based approach to infer cluster variance.  The goal is to classify into as few sets as possible.  This\n * leads to fewer duplicated elements and reduced complexity of generated clusters.\n *\n * Matches string form rather than the AST because that is also simpler for the moment.  This is less fragile than it\n * may appear because string is normalized product of parser -> AST -> serializer.\n *\n * Note also that this only applies to conformance of cluster-level elements. There is considerably more variance in\n * field-level conformance but we handle that with the record validator which supports the entire dialect.\n */\nconst VarianceMatchers: VarianceMatcher[] = [\n    // Mandatory, unconditional\n    {\n        pattern: pattern(\"(?:|M)\"),\n        processor(add) {\n            add();\n        },\n    },\n\n    // Optional, unconditional\n    {\n        pattern: pattern(\"(?:O|desc)\"),\n        processor(add) {\n            add(true);\n        },\n    },\n\n    // fieldName (optional, unconditional).  Ignores field reference which can only be enforced at runtime\n    {\n        pattern: pattern(FIELD),\n        processor(add) {\n            add(true);\n        },\n    },\n\n    // fieldName > num (optional, unconditional).  Ignores field expression\n    {\n        pattern: pattern(FIELD, \" > \", \"\\\\d+\"),\n        processor(add) {\n            add(true);\n        },\n    },\n\n    // fieldName, O (optional, unconditional).  Ignores field reference\n    {\n        pattern: pattern(FIELD, \", \", \"O\"),\n        processor(add) {\n            add(true);\n        },\n    },\n\n    // FOO & fieldName (field ignored as must be runtime enforced)\n    {\n        pattern: pattern(FEATURE, AND, FIELD),\n        processor(add, match) {\n            add(true, { allOf: match });\n        },\n    },\n\n    // FOO<& BAR>*\n    {\n        pattern: pattern(CONJUNCT_FEATURES),\n        processor(add, match) {\n            add(false, { allOf: splitConjunction(match[0]) });\n        },\n    },\n\n    // [FOO<& BAR>*]\n    {\n        pattern: pattern(\"[\", CONJUNCT_FEATURES, \"]\"),\n        processor(add, match) {\n            add(true, { allOf: splitConjunction(match[0]) });\n        },\n    },\n\n    // [FOO<| BAR>+]\n    {\n        pattern: pattern(\"[\", DISJUNCT_FEATURES, \"]\"),\n        processor(add, match) {\n            add(true, { anyOf: splitDisjunction(match[0]) });\n        },\n    },\n\n    // FOO<| BAR>* or FOO<, BAR>*\n    {\n        pattern: pattern(DISJUNCT_FEATURES),\n        processor(add, match) {\n            add(false, { anyOf: splitDisjunction(match[0]) });\n        },\n    },\n\n    // Field<| Field>* or Field<, Field>* (optional, unconditional).  Ignores field references\n    {\n        pattern: pattern(DISJUNCT_FIELDS),\n        processor(add) {\n            add(true);\n        },\n    },\n\n    // FOO, [BAR]\n    {\n        pattern: pattern(FEATURE, \", \", \"[\", FEATURE, \"]\"),\n        processor(add, match) {\n            // Must add to two sets because optionality differs\n            add(false, { allOf: [match[0]] });\n            add(true, { allOf: [match[1]] });\n        },\n    },\n\n    // !FOO & BAR\n    {\n        pattern: pattern(NOT, FEATURE, AND, FEATURE),\n        processor(add, match) {\n            add(false, { allOf: [match[1]], not: match[0] });\n        },\n    },\n\n    // !FOO & [BAR]\n    {\n        pattern: pattern(NOT, FEATURE, AND, \"[\", FEATURE, \"]\"),\n        processor(add, match) {\n            add(true, { allOf: [match[1]], not: match[0] });\n        },\n    },\n\n    // !FOO & (BAR<| BIZ>*)\n    {\n        pattern: pattern(NOT, FEATURE, AND, \"(\", DISJUNCT_FEATURES, \")\"),\n        processor(add, match) {\n            add(true, { allOf: splitDisjunction(match[1]), not: match[0] });\n        },\n    },\n\n    // !FOO\n    {\n        pattern: pattern(NOT, FEATURE),\n        processor(add, match) {\n            add(false, { not: match[0] });\n        },\n    },\n\n    // [!FOO]\n    {\n        pattern: pattern(\"[\", NOT, FEATURE, \"]\"),\n        processor(add, match) {\n            add(true, { not: match[0] });\n        },\n    },\n\n    // [!FOO & BAR]\n    {\n        pattern: pattern(\"[\", NOT, FEATURE, AND, FEATURE, \"]\"),\n        processor(add, match) {\n            add(true, { not: match[0], allOf: [match[1]] });\n        },\n    },\n\n    // FOO & BAR, [BIZ]\n    {\n        pattern: pattern(FEATURE, AND, FEATURE, \", \", \"[\", FEATURE, \"]\"),\n        processor(add, match) {\n            add(false, { allOf: match.slice(0, 2) });\n            add(true, { allOf: [match[2]] });\n        },\n    },\n\n    // FOO, O\n    {\n        pattern: pattern(FEATURE, \", \", \"O\"),\n        processor(add, match) {\n            add(false, { allOf: [match[0]] });\n            add(true);\n        },\n    },\n];\n\nfunction addElement(components: InferredComponents, element: ValueModel) {\n    if (AttributeModel.isGlobal(element)) {\n        return;\n    }\n\n    let text = element.conformance.toString();\n\n    if (text === \"X\") {\n        return;\n    }\n\n    while (true) {\n        if (text.match(/^[DP], /)) {\n            text = text.substring(3);\n        } else {\n            break;\n        }\n    }\n\n    if (text === \"D\") {\n        text = \"O\";\n    } else if (text === \"P\") {\n        text = \"M\";\n    }\n\n    for (const matcher of VarianceMatchers) {\n        const match = text.match(matcher.pattern);\n        if (match) {\n            matcher.processor((optional, condition) => {\n                addVariance(components, element, optional, condition);\n            }, match.slice(1));\n            return;\n        }\n    }\n    throw new NotImplementedError(`New rule needed for conformance \"${element.conformance}\" (element ${element.path})`);\n}\n\nfunction addVariance(\n    components: InferredComponents,\n    element: ValueModel,\n    optional?: boolean,\n    condition?: VarianceCondition,\n) {\n    let into: InferredComponent | undefined;\n\n    // Find set\n    for (const existing of components) {\n        if (isDeepEqual(existing.condition, condition)) {\n            into = existing;\n            break;\n        }\n    }\n\n    // If set does not exist, create it\n    if (!into) {\n        into = {\n            condition,\n            optional: [],\n            mandatory: [],\n        };\n        if (condition) {\n            components.push(into);\n        } else {\n            // Unconditional elements should always be detailed first\n            components.unshift(into);\n        }\n    }\n\n    // Add the element to the set\n    if (optional) {\n        into.optional.push(element);\n    } else {\n        into.mandatory.push(element);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
