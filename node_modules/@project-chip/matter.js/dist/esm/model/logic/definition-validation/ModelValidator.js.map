{
  "version": 3,
  "sources": ["../../../../../src/model/logic/definition-validation/ModelValidator.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ElementTag } from \"../../definitions/index.js\";\nimport { CommandModel, Model, RequirementModel } from \"../../models/index.js\";\n\n/**\n * Base class for all model validators.\n */\nexport class ModelValidator<T extends Model> {\n    constructor(protected model: T) {}\n\n    validate() {\n        this.validateProperty({ name: \"name\", type: \"string\", required: true });\n        this.validateProperty({ name: \"description\", type: \"string\" });\n        this.validateProperty({ name: \"details\", type: \"string\" });\n        this.validateProperty({ name: \"children\", type: Array });\n        this.validateProperty({ name: \"type\", type: \"string\" });\n        this.validateProperty({ name: \"xref\", type: Model.CrossReference });\n\n        if (this.model.type) {\n            const base = this.model.base;\n            if (!base) {\n                this.error(\"TYPE_UNKNOWN\", `Type ${this.model.type} does not resolve`);\n            }\n        }\n\n        if (this.model.xref) {\n            const parentXref = this.model.parent?.effectiveXref;\n            if (parentXref && this.model.xref === parentXref) {\n                delete this.model.xref;\n            }\n        }\n\n        this.validateChildUniqueness();\n    }\n\n    error(code: string, message: string) {\n        this.model.error(code, message);\n    }\n\n    protected validateStructure(requireId: boolean, ...childTypes: (new (...args: any) => Model)[]) {\n        this.validateProperty({ name: \"id\", type: \"number\", required: requireId });\n        if (this.model.children && childTypes.length) {\n            let index = 0;\n            for (const child of this.model.children) {\n                let ok = false;\n                for (const type of childTypes) {\n                    if (child instanceof type) {\n                        ok = true;\n                        break;\n                    }\n                }\n                if (!ok) {\n                    this.error(\"UNACCEPTABLE_TYPE\", `${child.path} type ${child.constructor.name} is not allowed`);\n                }\n                index++;\n            }\n        }\n    }\n\n    protected validateProperty({ name, type, required, nullable }: Model.PropertyValidation) {\n        const value = (this.model as any)[name];\n        if (value === undefined) {\n            if (required) {\n                this.error(\"REQUIRED_PROPERTY\", `Missing required property ${name}`);\n                return;\n            }\n            return;\n        }\n        if (value === null) {\n            if (nullable) {\n                this.error(\"NULL_PROPERTY\", `Property ${name} is null`);\n                return;\n            }\n            return;\n        }\n        if (Number.isNaN(value)) {\n            this.error(\"NAN_PROPERTY\", `Property ${name} is NaN`);\n        }\n        if (type === undefined) {\n            return;\n        }\n        if (typeof type === \"string\") {\n            if (typeof value !== type) {\n                this.error(\"NON_STRING_PROPERTY\", `Property ${name} type is ${typeof value} (expected ${type})`);\n            }\n            return;\n        }\n        if (typeof type === \"function\") {\n            if (!(value instanceof type)) {\n                this.error(\"PROPERTY_NOT_INSTANCE\", `Property ${name} is not an instance of ${type.name}`);\n            }\n            return;\n        }\n        if (!Object.values(type).includes(value)) {\n            this.error(\"INVALID_ENUM_KEY\", `Property ${name} value ${value} is not in enum`);\n        }\n    }\n\n    private validateChildUniqueness() {\n        const identities = {} as { [identity: string]: number };\n\n        for (const child of this.model.children) {\n            function addIdentity(id: string | number) {\n                if (child instanceof CommandModel) {\n                    id = `${id}:${child.direction}`;\n                } else if (child instanceof RequirementModel) {\n                    id = `${id}:${child.element}`;\n                }\n                const identity = `${child.tag};${id};${(child as any).conformance}`;\n                if (identities[identity]) {\n                    identities[identity]++;\n                } else {\n                    identities[identity] = 1;\n                }\n            }\n\n            addIdentity(child.name);\n\n            if (child.effectiveId) {\n                addIdentity(child.effectiveId);\n            }\n        }\n\n        for (const identity in identities) {\n            if (identities[identity] > 1) {\n                const parts = identity.split(\";\");\n                this.error(\"DUPLICATE_CHILD\", `Duplicate ${parts[0]} ${parts[1]}`);\n            }\n        }\n    }\n}\n\nexport namespace ModelValidator {\n    export const validators = {} as {\n        [key in ElementTag]: new (model: any) => ModelValidator<any>;\n    };\n}\n"],
  "mappings": "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",
  "names": ["addIdentity", "ModelValidator"]
}
