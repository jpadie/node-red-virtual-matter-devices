{
  "version": 3,
  "sources": ["../../../../src/model/logic/ModelVariantTraversal.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { Conformance } from \"../aspects/Conformance.js\";\nimport { ElementTag, Specification } from \"../definitions/index.js\";\nimport { AnyElement } from \"../elements/index.js\";\nimport { Model, ValueModel } from \"../models/index.js\";\nimport { ModelTraversal } from \"./ModelTraversal.js\";\n\nconst logger = Logger.get(\"ModelVariantTraversal\");\n\n/**\n * This is a map of equivalent models keyed by \"source name\".  The source name is a string that identifies the source of\n * the variant, such as \"chip\", \"spec\" or \"local\".\n */\nexport type VariantMap = { [sourceName: string]: Model };\n\n/**\n * Internal variant map that collects multiple variants within the same model.  This is then spread into individual\n * VariantMaps, one for each output variant.\n */\ntype VariantMultimap = { [sourceName: string]: Model[] };\n\n/**\n * Input to traverse().\n */\nexport type TraverseMap = { [sourceName: string]: Model | AnyElement };\n\n/**\n * Supplies operational information about a set of variants.\n */\nexport interface VariantDetail {\n    /**\n     * The shared tag across all variants.\n     */\n    tag: ElementTag;\n\n    /**\n     * The highest priority ID across all variants, if any variant has an ID.\n     */\n    id?: number;\n\n    /**\n     * The canonical name to use for the variants.\n     */\n    name: string;\n\n    /**\n     * The actual variants.\n     */\n    map: VariantMap;\n}\n\n/**\n * Visits multiple model hierarchies simultaneously and builds state.\n */\nexport abstract class ModelVariantTraversal<S = void> {\n    protected clusterState: ClusterState | undefined;\n    private visiting = false;\n    private modelTraversal = new ModelTraversal();\n\n    /**\n     * Create a new visitor.  Must list the valid names of sources.  The order of this list implies the priority used\n     * for choosing a name when multiple model variants have different names.\n     */\n    constructor(\n        private revision: Specification.Revision,\n        private sourceNames: string[],\n    ) {}\n\n    /**\n     * Initiate traversal.  The class is stateful so this call should not be invoked while traversal is ongoing.\n     */\n    traverse(variants: TraverseMap): S {\n        // Ensure it's clear this class is stateful\n        if (this.visiting) {\n            throw new InternalError(\"ModelVariantVisitor.visit called with active visit; reentrancy not supported\");\n        }\n\n        // Ensure prior crash doesn't muddy the waters\n        delete this.clusterState;\n\n        this.visiting = true;\n        try {\n            return this.visitVariants(\n                this.createVariantDetail(\n                    Object.fromEntries(\n                        Object.entries(variants).map(([sourceName, element]) => {\n                            if (!(element instanceof Model)) {\n                                element = Model.create(element);\n                            }\n                            return [sourceName, element];\n                        }),\n                    ),\n                ),\n            );\n        } finally {\n            this.visiting = false;\n        }\n    }\n\n    /**\n     * This is the primary callback.  It is invoked for every set of variants during traversal.  It may optionally\n     * return state that is returned from traverse().\n     *\n     * @param variants the set of equivalent models\n     * @param recurse call this function to recurse into variant children\n     */\n    protected abstract visit(variants: VariantDetail, recurse: () => S[]): S;\n\n    /**\n     * Get the canonical name for a model.  Within cluster scope alternate names may be selected, otherwise the name of\n     * the model is returned.\n     */\n    protected getCanonicalName(model: Model) {\n        if (this.clusterState) {\n            const name = this.clusterState.canonicalNames.get(model);\n            if (name !== undefined) {\n                return name;\n            }\n        }\n        return model.name;\n    }\n\n    /**\n     * Determine if we are entering a cluster and install cluster state if so.\n     */\n    protected enterCluster(variants: VariantDetail) {\n        if (variants.tag === ElementTag.Cluster) {\n            this.clusterState = {\n                canonicalNames: computeCanonicalNames(this.revision, this.sourceNames, variants),\n            };\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * This is the function that actually recurses during the visit.\n     */\n    private visitVariants(variants: VariantDetail): S {\n        // Note that the only role ModelTraversal plays here is to protect against loops.  We do the actual traversal\n        // ourselves\n        const state = this.modelTraversal.operation(() => {\n            return this.visit(variants, () => {\n                const enteredCluster = this.enterCluster(variants);\n\n                // Group children across variants\n                const mappings = this.mapChildren(variants);\n\n                // Visit children\n                const result = Array<S>();\n                mappings: for (const childVariants of mappings) {\n                    const detail = this.createVariantDetail(childVariants);\n\n                    // If a cluster child is defined directly in one variant but inherited in another, ignore the\n                    // direct variant so we will continue to properly reflect the inheritance structure.  Only do\n                    // this if the element doesn't actually have overrides though\n                    let inherited = false;\n                    let overrides = false;\n                    if (variants.tag === ElementTag.Cluster) {\n                        for (const k in variants.map) {\n                            if (childVariants[k] === undefined) {\n                                const inheritedModel = variants.map[k].base?.member(detail.name, [detail.tag]);\n                                if (inheritedModel) {\n                                    inherited = true;\n                                }\n                                continue;\n                            }\n                            const child = childVariants[k];\n                            if (child instanceof ValueModel && child.overridesShadow) {\n                                overrides = true;\n                            }\n                        }\n                    }\n                    if (inherited && !overrides) {\n                        continue mappings;\n                    }\n\n                    result.push(this.visitVariants(detail));\n                }\n\n                // Remove cluster state\n                if (enteredCluster) {\n                    delete this.clusterState;\n                }\n\n                return result;\n            });\n        });\n\n        return state;\n    }\n\n    /**\n     * Group children across variants with the same identity.\n     */\n    private mapChildren(variants: VariantDetail): VariantMap[] {\n        const multimaps = this.mapChildrenToMultimap(variants);\n\n        const result = Array<VariantMap>();\n\n        // The multimap allows for multiple mapped variants that vary by conformance.  We must match these across\n        // sources to create a \"non-multi map\". Algorithm is:\n        //\n        //   - If two variants have conformance and it is the same, they match\n        //   - For variants with no conformance matches:\n        //     - If the source contributes a single variant without conformance, it matches all variants\n        //     - Otherwise variants match in insertion order with other unmatched variants\n        //\n        // This allows for conformance override but means:\n        //\n        //  1. To ensure proper matching you must a.) provide conformance, or b.) override variants in insertion\n        //     order (possibly variants even if there's no change)\n        //  2. You cannot override conformance to a conformance value that is already used; matching conformance always\n        //     overrides the matched variant\n\n        for (const multimap of multimaps) {\n            const maps = Array<VariantMap>();\n\n            for (const incomingSource in multimap) {\n                const variants = multimap[incomingSource];\n                let unmatchedIncoming: undefined | Model[];\n\n                function addUnmatched(variant: Model) {\n                    if (unmatchedIncoming) {\n                        unmatchedIncoming.push(variant);\n                    } else {\n                        unmatchedIncoming = [variant];\n                    }\n                }\n\n                // For each variant, match based on conformance or add to \"unmatched\" set\n                nextIncomingVariant: for (const incomingVariant of variants) {\n                    // Obtain conformance string\n                    const incomingConformance = conformanceStr(incomingVariant);\n                    if (incomingConformance === undefined) {\n                        // Can't match on conformance; fall back to positional insertion\n                        addUnmatched(incomingVariant);\n                        continue;\n                    }\n\n                    // With conformance we search through each variant in each map we've already created.  The first\n                    // match goes to this variant unless another variant in the source matched (which will result in a\n                    // DUPLICATE_CHILD validation error\n                    for (const establishedMap of maps) {\n                        if (establishedMap[incomingSource]) {\n                            // This source has already filled this map\n                            continue;\n                        }\n\n                        for (const establishedSource in establishedMap) {\n                            const establishedConformance = conformanceStr(establishedMap[establishedSource]);\n                            if (\n                                establishedConformance === undefined ||\n                                establishedConformance !== incomingConformance\n                            ) {\n                                // No conformance or conformance doesn't match\n                                continue;\n                            }\n\n                            // Found a match; insert variant\n                            establishedMap[incomingSource] = incomingVariant;\n\n                            continue nextIncomingVariant;\n                        }\n                    }\n\n                    // Conformance doesn't match any established variants.  Use positional insertion\n                    addUnmatched(incomingVariant);\n                }\n\n                // Now insert unmatched variants in insertion order\n                if (!unmatchedIncoming) {\n                    continue;\n                }\n                nextUnmatched: for (const variant of unmatchedIncoming) {\n                    // Insert into first established map this source has not yet contributed to\n                    for (const established of maps) {\n                        if (established[incomingSource] === undefined) {\n                            // This map is open for this source so insert here\n                            established[incomingSource] = variant;\n                            continue nextUnmatched;\n                        }\n                    }\n\n                    // All maps filled by this source; add another map\n                    maps.push({ [incomingSource]: variant });\n                }\n            }\n\n            result.push(...maps);\n        }\n\n        return result;\n    }\n\n    /**\n     * Group children across variants with the same identity allowing for multiple definitions of an identity.  This is\n     * the primary function of {@link mapChildren} but allows for multiple definitions of the same element.\n     */\n    private mapChildrenToMultimap(variants: VariantDetail): VariantMultimap[] {\n        type ChildMapping = {\n            // List of children associated by ID or name (ID gets priority)\n            slots: VariantMultimap[];\n\n            // Map of IDs to first slot the ID appeared\n            idToSlot: { [id: string]: number };\n\n            // Map of names to first slot the name appeared\n            nameToSlot: { [name: string]: number };\n        };\n        const mappings = {} as { [tag: string]: ChildMapping };\n\n        // Iterate over each model variant\n        for (const [sourceName, variant] of Object.entries(variants.map)) {\n            // For each applicable child of this variant, associated it with a slot\n            for (let i = 0; i < variant.children.length; i++) {\n                const child = variant.children[i];\n\n                if (!child.appliesTo(this.revision)) {\n                    continue;\n                }\n\n                const mapping =\n                    mappings[child.tag] || (mappings[child.tag] = { slots: [], idToSlot: {}, nameToSlot: {} });\n\n                const idKey = child.key;\n                let nameKey = this.getCanonicalName(child);\n\n                if (child.discriminator !== undefined) {\n                    nameKey = `${nameKey}\u241C${child.discriminator}`;\n                }\n\n                let slot;\n\n                // Find existing slot by ID\n                if (idKey !== undefined) {\n                    slot = mapping.idToSlot[idKey];\n                }\n\n                // Find existing slot by name\n                if (slot === undefined) {\n                    slot = mapping.nameToSlot[nameKey];\n                }\n\n                // Create a new slot if necessary\n                if (slot === undefined) {\n                    slot = mapping.slots.length;\n                    mapping.slots.push({});\n                }\n\n                // Map the child's ID to the slot\n                if (idKey !== undefined) {\n                    if (mapping.idToSlot[idKey] === undefined) {\n                        mapping.idToSlot[idKey] = slot;\n                    }\n                }\n\n                // Map the child's name to the slot\n                if (mapping.nameToSlot[nameKey] === undefined) {\n                    mapping.nameToSlot[nameKey] = slot;\n                }\n\n                // Update the slot\n                if (mapping.slots[slot][sourceName]) {\n                    mapping.slots[slot][sourceName].push(child);\n                } else {\n                    mapping.slots[slot][sourceName] = [child];\n                }\n            }\n        }\n\n        return Object.values(mappings).flatMap(v => v.slots);\n    }\n\n    /**\n     * Create a VariantDetail from a VariantMap.\n     */\n    private createVariantDetail(map: VariantMap): VariantDetail {\n        let tag: ElementTag | undefined;\n        let id: number | undefined;\n        let name: string | undefined;\n\n        this.sourceNames.forEach(sourceName => {\n            const variant = map[sourceName];\n            if (variant) {\n                if (!tag) {\n                    tag = variant.tag;\n                } else if (tag !== variant.tag) {\n                    // Sanity check\n                    throw new InternalError(\n                        `Variant tag mismatch; previous variant identified as ${tag} but ${sourceName} identifies as ${tag}`,\n                    );\n                }\n                if (!id) {\n                    id = variant.id;\n                }\n                if (!name) {\n                    name = this.getCanonicalName(variant);\n                }\n            }\n        });\n\n        if (!tag) {\n            // Sanity check\n            throw new InternalError(\"No tag identified in variant set\");\n        }\n        if (!name) {\n            // Sanity check\n            throw new InternalError(\"No name identified in variant set\");\n        }\n\n        return { tag, id, name, map };\n    }\n}\n\n/**\n * Map of Model -> name\n */\ntype NameMapping = Map<Model, string>;\n\n/**\n * This type manages state that changes when we enter a cluster.\n */\ntype ClusterState = {\n    canonicalNames: NameMapping;\n};\n\n/**\n * We go to a whole lot of work to choose proper datatype names.  This is to reduce the number of manual overrides we\n * need to correct dirty data.\n *\n * This may seem like an unreasonable amount of logic but with evolving specifications and 3k+ named elements (and\n * counting) it seems worthwhile.\n *\n * ModelVariantTraversal calls this function each time it enters a cluster. Thus we are only dealing with names scoped\n * to a single cluster\n */\nfunction computeCanonicalNames(revision: Specification.Revision, sourceNames: string[], variants: VariantDetail) {\n    // First, infer name equivalence of datatypes based on usage.  There is no ID on datatypes.  This is a reliable\n    // alternative.  We perform this iteratively as new mappings could appear from subfields of previously- unknown\n    // equivalent datatypes\n    const datatypeNameMap = new Map<Model, string>();\n    let numberOfMappings;\n\n    do {\n        numberOfMappings = datatypeNameMap.size;\n        inferEquivalentDatatypes(revision, sourceNames, variants, datatypeNameMap);\n    } while (numberOfMappings != datatypeNameMap.size);\n\n    // Now that we generally what what equals what, go through the names and choose the name for the final model\n    const canonicalNames = chooseCanonicalNames(revision, sourceNames, variants, datatypeNameMap);\n\n    return canonicalNames;\n}\n\n/**\n * Populate the canonical datatype name lookup for a specific cluster.  This is pretty ugly but in pseudo code:\n *\n * For each datatype that has a base type:\n *\n *  - Find the name referenced by the variant of highest priority\n *\n *  - Add a mapping from the referenced name to the name we found\n */\nfunction inferEquivalentDatatypes(\n    revision: Specification.Revision,\n    sourceNames: string[],\n    variants: VariantDetail,\n    datatypeNameMap: NameMapping,\n) {\n    type ModelNameMapping = {\n        mapTo: string | undefined;\n        priority: number;\n    };\n    const nameVariants = new Map<Model, ModelNameMapping>();\n\n    // Create a new traversal to visit each element\n    const traversal = new (class extends ModelVariantTraversal {\n        override visit(variants: VariantDetail, recurse: () => void[]) {\n            let mapEntry: ModelNameMapping | undefined;\n\n            for (let priority = 0; priority < sourceNames.length; priority++) {\n                const sourceName = sourceNames[priority];\n                const variant = variants.map[sourceName];\n\n                // Only elements with a base type local to the cluster are of\n                // interest.  Global types we map manually so they should be\n                // correct\n                const base = variant?.base;\n                if (!base || base.parent?.tag !== ElementTag.Cluster) {\n                    continue;\n                }\n\n                // Create a new map entry if this is the highest priority\n                // position\n                if (!mapEntry) {\n                    mapEntry = {\n                        mapTo: base.name,\n                        priority,\n                    };\n                }\n\n                // Find existing entry\n                const existingEntry = nameVariants.get(base);\n\n                // Replace existing entry if this is a higher priority. Otherwise the types should in theory be\n                // equivalent.  If they're not it's a definition bug that will need to be corrected manually\n                if (existingEntry) {\n                    if (existingEntry.priority > mapEntry.priority) {\n                        nameVariants.set(base, mapEntry);\n                    } else if (existingEntry.priority === mapEntry.priority && existingEntry.mapTo !== mapEntry.mapTo) {\n                        logger.warn(\n                            `Mapping ${sourceName} ${base.tag} ${base.name} to ${existingEntry.mapTo} but it also maps to ${mapEntry.mapTo}`,\n                        );\n                    }\n                } else {\n                    nameVariants.set(base, mapEntry);\n                }\n            }\n\n            recurse();\n        }\n\n        override enterCluster() {\n            // Do not call base logic because it is uses inferCanonicalNames, but do install existing mappings that may\n            // be present from previous iterations of this function\n            if (variants.tag === ElementTag.Cluster) {\n                this.clusterState = { canonicalNames: datatypeNameMap };\n                return true;\n            }\n            return false;\n        }\n    })(revision, sourceNames);\n    traversal.traverse(variants.map);\n\n    // Convert the internal structure to NameMappings\n    for (const [model, mapEntry] of nameVariants) {\n        if (mapEntry.mapTo && mapEntry.mapTo !== model.name) {\n            datatypeNameMap.set(model, mapEntry.mapTo);\n        }\n    }\n}\n\n/**\n * Heuristically select the best name for each element.  Priority does affect this selection but it's not absolute\n */\nfunction chooseCanonicalNames(\n    revision: Specification.Revision,\n    sourceNames: string[],\n    variants: VariantDetail,\n    datatypeNameMap: NameMapping,\n): NameMapping {\n    const canonicalNames = new Map<Model, string>();\n\n    const traversal = new (class extends ModelVariantTraversal {\n        visit(variants: VariantDetail, recurse: () => void) {\n            let canonicalName: string | undefined;\n\n            // First, choose the canonical name\n            for (let i = 0; i < sourceNames.length; i++) {\n                const name = variants.map[sourceNames[i]]?.name;\n\n                // We give absolute priority to the highest priority element. This is presumably an editorial decision\n                // made by a human\n                if (!i && name !== undefined) {\n                    break;\n                }\n\n                // If this is the first item, use its name\n                if (!canonicalName) {\n                    canonicalName = name;\n                    continue;\n                }\n\n                // Prefer the shortest available name.  CHIP tends to add non-standard prefixes because they have a\n                // global namespace. When we scrape the spec we sometimes pick up extraneous garbage\n                if (name?.length < canonicalName?.length) {\n                    canonicalName = name;\n                    continue;\n                }\n\n                // If two names are equivalent except for case, prefer the one with more capital letters.  This corrects\n                // for case issues that can arise from automatic camelization in our spec scraper\n                if (canonicalName?.toLowerCase() === name?.toLowerCase()) {\n                    if (canonicalName === name) {\n                        continue;\n                    }\n\n                    if (canonicalName.replace(/[^A-Z]/g, \"\").length < name.replace(/[^A-Z]/g, \"\").length) {\n                        canonicalName = name;\n                        continue;\n                    }\n                }\n            }\n\n            // We should have found a name but if not, fall back to the name chosen previously\n            if (!canonicalName) {\n                canonicalName = variants.name;\n            }\n\n            // Now install a mapping for any losing variants to the preferred name\n            for (const sourceName in variants.map) {\n                const variant = variants.map[sourceName];\n                if (variant.name !== canonicalName) {\n                    canonicalNames.set(variant, canonicalName);\n                }\n            }\n\n            recurse();\n        }\n\n        override enterCluster(variants: VariantDetail) {\n            // Disable default logic, just ensure our datatype names are always installed so datatypes match up\n            // correctly\n            if (variants.tag === ElementTag.Cluster) {\n                this.clusterState = { canonicalNames: datatypeNameMap };\n                return true;\n            }\n            return false;\n        }\n    })(revision, sourceNames);\n\n    traversal.traverse(variants.map);\n\n    return canonicalNames;\n}\n\nfunction conformanceStr(model: Model) {\n    const conformance = (model as { conformance?: Conformance }).conformance?.toString();\n    if (conformance === \"\") {\n        return undefined;\n    }\n    return conformance;\n}\n"],
  "mappings": "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",
  "names": ["addUnmatched", "variants"]
}
