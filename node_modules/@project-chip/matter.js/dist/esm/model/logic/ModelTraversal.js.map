{
  "version": 3,
  "sources": ["../../../../src/model/logic/ModelTraversal.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SchemaImplementationError } from \"../../behavior/errors.js\";\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { Access, Aspect, Constraint } from \"../aspects/index.js\";\nimport { ElementTag, FeatureSet, FieldValue, Metatype } from \"../definitions/index.js\";\nimport { AnyElement } from \"../elements/index.js\";\nimport { Children } from \"../models/Children.js\";\nimport { PropertyModel, type ClusterModel, type CommandModel, type Model, type ValueModel } from \"../models/index.js\";\nimport * as Elements from \"../standard/elements/index.js\";\n\nconst OPERATION_DEPTH_LIMIT = 20;\n\nlet memos: Memos | undefined;\n\n/**\n * This class performs lookups of models in the scope of a specific model.  We use a class so the lookup can maintain\n * state and guard against circular references.\n *\n * Any logic that requires traversal of a multi-model ownership or inheritance should use this class.\n *\n */\nexport class ModelTraversal {\n    #operationDepth = 0;\n    #dismissed?: Set<Model>;\n\n    /**\n     * Perform an operation with iteration tracking.  If iteration depth limit\n     */\n    operation<T>(operator: () => T, toDismiss?: Model): T {\n        if (this.#operationDepth > OPERATION_DEPTH_LIMIT) {\n            throw new InternalError(\"Likely cycle detected (or OPERATION_DEPTH_LIMIT needs to be bumped)\");\n        }\n\n        if (toDismiss && this.#dismissed?.has(toDismiss)) {\n            toDismiss = undefined;\n        }\n\n        if (toDismiss) {\n            if (!this.#dismissed) {\n                this.#dismissed = new Set();\n            }\n            this.#dismissed.add(toDismiss);\n        }\n        this.#operationDepth++;\n        try {\n            return operator();\n        } finally {\n            this.#operationDepth--;\n            if (toDismiss) {\n                this.#dismissed?.delete(toDismiss);\n            }\n        }\n    }\n\n    /**\n     * Perform an operation with a model dismissed from consideration for type lookup.\n     */\n    operationWithDismissal<T>(toDismiss: Model | undefined, operator: () => T): T {\n        return this.operation(operator, toDismiss);\n    }\n\n    /**\n     * Determine the type for a model.  This is the string name of the base model.  Usually this is simply the type\n     * field but we infer the type in some cases where it is not supplied explicitly:\n     *\n     * - Children of maps and enums are uints of corresponding size\n     * - Models that shadow another model in their parent's inheritance effectively inherit from the shadow so have\n     *   their own name as the type name\n     */\n    getTypeName(model: Model | undefined): string | undefined {\n        if (!model) {\n            return undefined;\n        }\n\n        if (model.type) {\n            return model.type;\n        }\n\n        // Commands, events and clusters always represent structs\n        if (model.tag === ElementTag.Command || model.tag === ElementTag.Event || model.tag === ElementTag.Cluster) {\n            return \"struct\";\n        }\n\n        return this.operation(() => {\n            let result: string | undefined;\n            const name = model.name;\n            this.visitInheritance(parentOf(model), ancestor => {\n                // If parented by enum or bitmap, infer type as uint of same size\n                if ((ancestor as { effectiveMetatype?: string }).effectiveMetatype) {\n                    switch (ancestor.name) {\n                        case Elements.enum8.name:\n                        case Elements.map8.name:\n                            result = Elements.uint8.name;\n                            return false;\n\n                        case Elements.enum16.name:\n                        case Elements.map16.name:\n                            result = Elements.uint16.name;\n                            return false;\n\n                        case Elements.map32.name:\n                            result = Elements.uint32.name;\n                            return false;\n\n                        case Elements.map64.name:\n                            result = Elements.uint64.name;\n                            return false;\n                    }\n                }\n\n                // If I shadow a field my type is the same as the overridden field\n                const shadow = ancestor.children.select(name, [model.tag], this.#dismissed);\n                if (shadow?.type) {\n                    // The shadow's name is the same as mine so this is actually my own name\n                    result = shadow.name;\n                    return false;\n                }\n            });\n\n            return result;\n        });\n    }\n\n    /**\n     * Find the model in my inheritance hierarchy that has semantic meaning. This will be the first inherited model with\n     * a metatype.\n     */\n    findMetabase(model: Model | undefined): Model | undefined {\n        return this.operation(() => {\n            while (model && !(model as any).metatype) {\n                model = this.findBase(model);\n            }\n            return model;\n        });\n    }\n\n    /**\n     * Find the model a model derives from, if any.\n     */\n    findBase(model: Model | undefined): Model | undefined {\n        if (!model) {\n            return;\n        }\n\n        if (memos?.bases.has(model)) {\n            return memos.bases.get(model);\n        }\n\n        const base = this.operationWithDismissal(model, () => {\n            // If I override another element (same identity and tag in parent's inheritance hierarchy) then I implicitly\n            // inherit from the shadow.\n            //\n            // Semantics would be wonky if the model designates a different type than the shadow, but we support this by\n            // ignoring the shadow in this case.\n            const shadow = this.findShadow(model);\n            if (\n                shadow !== undefined &&\n                (model.type === undefined || model.type === shadow.type || model.type === shadow.name)\n            ) {\n                return shadow;\n            }\n\n            // Obtain the name of my base type\n            const type = this.getTypeName(model);\n            if (type === undefined) {\n                return;\n            }\n\n            const path = type.split(\".\");\n\n            // Unqualified path.  This is the common case\n            if (path.length === 1) {\n                // Allowed tags represent a priority so search each tag independently\n                for (const tag of model.allowedBaseTags) {\n                    const found = this.findType(parentOf(model), path[0], tag);\n                    if (found) {\n                        return found;\n                    }\n                }\n                return;\n            }\n\n            // Qualified path.  Identify the leaf parent then perform name/tag search within.  This is fun because we\n            // have to search scopes until we match the full path\n            for (const tag of model.allowedBaseTags) {\n                const found = this.findQualifiedType(parentOf(model), path, tag);\n                if (found) {\n                    return found;\n                }\n            }\n        });\n\n        memos?.bases.set(model, base);\n\n        return base;\n    }\n\n    /**\n     * Find the first global model this model derives from, if any.\n     */\n    findGlobalBase(model: Model | undefined): Model | undefined {\n        if (!model) {\n            return;\n        }\n        let result: Model | undefined;\n\n        this.visitInheritance(model, model => {\n            if (model.isGlobal) {\n                result = model;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determine whether this model derives from another.\n     */\n    instanceOf(model: Model | undefined, other: Model | AnyElement | undefined): boolean {\n        if (!model || !other) {\n            return false;\n        }\n        if (model === other) {\n            return true;\n        }\n        let result = false;\n\n        this.visitInheritance(model, model => {\n            if (model.name === other.name && model.isGlobal === other.isGlobal) {\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Find an xref from this model or a parent.\n     */\n    findXref(model: Model | undefined): Model.CrossReference | undefined {\n        return this.operationWithDismissal(model, () => {\n            if (!model) {\n                return;\n            }\n            if (model.xref) {\n                return model.xref;\n            }\n            return this.findXref(parentOf(model));\n        });\n    }\n\n    /**\n     * Find the model this model derives from that has children, if any.\n     */\n    findDefiningModel(model: ValueModel | undefined): ValueModel | undefined {\n        let result: ValueModel | undefined;\n        this.visitInheritance(model, model => {\n            if (!model.isType) {\n                return false;\n            }\n            if (model.children.length) {\n                result = model as ValueModel;\n                return false;\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Find a child in the parent's inheritance hierarchy with the same tag and ID/name.\n     */\n    findShadow(model: Model | undefined): Model | undefined {\n        if (model === undefined) {\n            return undefined;\n        }\n\n        if (memos?.shadows.has(model)) {\n            return memos.shadows.get(model);\n        }\n\n        let shadow: Model | undefined;\n\n        this.operationWithDismissal(model, () => {\n            this.visitInheritance(this.findBase(parentOf(model)), parent => {\n                if (model.id !== undefined && model.tag !== ElementTag.Command) {\n                    shadow = parent.children.select(model.id, [model.tag], this.#dismissed);\n                    if (shadow) {\n                        return false;\n                    }\n                }\n                shadow = parent.children.select(model.name, [model.tag], this.#dismissed);\n                if (shadow) {\n                    return false;\n                }\n            });\n        });\n\n        memos?.shadows.set(model, shadow);\n\n        return shadow;\n    }\n\n    /**\n     * Get an aspect that reflects extension of any shadowed aspects.  Note that this searches the parent's inheritance\n     * and the model's inheritance. This is because aspects can be inherited by overriding an element in the parent or\n     * by direct type inheritance.  Aspects in shadowed elements take priority as they are presumably more specific.\n     */\n    findAspect(model: Model | undefined, symbol: symbol): Aspect<any> | undefined {\n        if (!model) {\n            return;\n        }\n\n        return this.operation(() => {\n            let aspect = (model as any)[symbol] as Aspect<any> | undefined;\n\n            const inheritedAspect = this.findAspect(this.findBase(model), symbol);\n            if (inheritedAspect) {\n                if (aspect) {\n                    aspect = inheritedAspect.extend(aspect);\n                } else {\n                    aspect = inheritedAspect;\n                }\n            }\n\n            return aspect;\n        });\n    }\n\n    /**\n     * Constraint aspects are specialized because we infer constraint fields that are referenced in other models.\n     */\n    findConstraint(model: ValueModel, symbol: symbol, field?: \"value\" | \"min\" | \"max\"): Constraint | undefined {\n        return this.operation(() => {\n            let constraint = this.findAspect(model, symbol) as Constraint;\n            if (constraint === undefined) {\n                return;\n            }\n\n            const bounds = {} as Constraint.Ast;\n\n            const resolve = (field: \"value\" | \"min\" | \"max\") => {\n                const value = constraint[field];\n                const name = FieldValue.referenced(value);\n                if (name === undefined) {\n                    return;\n                }\n\n                const referenced = this.findMember(parentOf(model), name, [\n                    ElementTag.Attribute,\n                    ElementTag.Field,\n                ]) as ValueModel;\n                if (!referenced) {\n                    return;\n                }\n\n                const otherConstraint = this.findConstraint(referenced, symbol, field);\n                if (otherConstraint?.[field]) {\n                    bounds[field] = otherConstraint[field];\n                }\n            };\n\n            // The only reason the field filter exists is that some fields referenced in constraints are circularly\n            // constrained (e.g. min of max field is max of min field and vice versa).  By only loading the field of\n            // interest we avoid infinite loops\n            if (field) {\n                resolve(field);\n            } else {\n                resolve(\"value\");\n                resolve(\"min\");\n                resolve(\"max\");\n            }\n\n            if (Object.keys(bounds).length) {\n                constraint = constraint.extend(bounds);\n            }\n\n            return constraint;\n        });\n    }\n\n    /**\n     * Access aspects are specialized because access controls are inherited from the owner if not otherwise defined.\n     *\n     * That means access controls may come from 5 places, in order of priority:\n     *\n     *   1. The model itself\n     *   2. A shadowed model in the owner hierarchy\n     *   3. An overridden model in the model's class hierarchy\n     *   4. A model in the parent hierarchy\n     *   5. Access.Default\n     *\n     * This method uses {@link findAspect} for 1-3 then extends the result with 4 & 5 as necessary until\n     * {@link Access.complete} is true.\n     */\n    findAccess(model: ValueModel | undefined, symbol: symbol, VM: typeof ValueModel): Access {\n        if (model === undefined) {\n            return Access.Default;\n        }\n\n        return this.operation(() => {\n            const access = this.findAspect(model, symbol) as Access | undefined;\n\n            if (!access) {\n                return this.findAccess(this.findOwner(VM, model), symbol, VM);\n            }\n\n            if (access.complete) {\n                return access;\n            }\n\n            return this.findAccess(this.findOwner(VM, model), symbol, VM).extend(access);\n        });\n    }\n\n    /**\n     * Search inherited scope for a named member.\n     */\n    findMember(scope: Model | undefined, key: Children.Selector, allowedTags: ElementTag[]): Model | undefined {\n        return this.operation(() => {\n            while (scope) {\n                const result = scope.children.select(key, allowedTags, this.#dismissed);\n                if (result) {\n                    return result;\n                }\n                scope = this.findBase(scope);\n            }\n        });\n    }\n\n    /**\n     * Retrieve all children of a specific type, including those inherited from the base or a shadow.  Does not include\n     * members overridden by a deeper member.\n     */\n    findChildren(scope: Model, tags: ElementTag[]) {\n        const members = Array<Model>();\n\n        // This is a map of identity (based on tag + id/name + discriminator) to a priority based on inheritance depth\n        const defined = {} as Record<string, number | undefined>;\n\n        let level = 0;\n        this.visitInheritance(scope, model => {\n            level++;\n            for (const child of model.children) {\n                if (!tags.includes(child.tag)) {\n                    continue;\n                }\n\n                // Identify and skip shadows based on ID\n                let numericIdentity;\n                if (child.id !== undefined) {\n                    numericIdentity = `i\u241C${child.tag}\u241C${child.id}\u241C${child.discriminator ?? \"\"}`;\n                    const numericLevel = defined[numericIdentity];\n                    if (numericLevel !== undefined && numericLevel < level) {\n                        continue;\n                    }\n                }\n\n                // Identify and skip shadows based on name\n                const nameIdentity = `s\u241C${child.tag}\u241C${child.name}\u241C${child.discriminator ?? \"\"}`;\n                const nameLevel = defined[nameIdentity];\n                if (nameLevel !== undefined && nameLevel < level) {\n                    continue;\n                }\n\n                // Mark the level in which we saw these members\n                if (numericIdentity) {\n                    defined[numericIdentity] = level;\n                }\n                defined[nameIdentity] = level;\n\n                // Found a member\n                members.push(child);\n            }\n        });\n\n        return members;\n    }\n\n    /**\n     * Filter a model's members as follows:\n     *\n     *   - If the member is deprecated, ignore it\n     *\n     *   - If there is only a single member of a given name, select that member\n     *\n     *   - If there are multiple members with the same name but there is no cluster throw an error\n     *\n     *   - If there are multiple members with the same name, use conformance to select the member that is applicable\n     *     based on active features in the provided cluster\n     *\n     *   - If there are multiple applicable members based on conformance the definitions conflict and throw an error\n     *\n     * Note that \"active\" in this case does not imply the member is conformant, only that conflicts are resolved.\n     *\n     * Note 2 - members may not be differentiated with conformance rules that rely on field values in this way. That\n     * will probably never be necessary and would require an entirely different (more complicated) structure.\n     */\n    findActiveMembers(scope: Model & { members: PropertyModel[] }, conformantOnly: boolean, cluster?: ClusterModel) {\n        const features = cluster?.featureNames ?? new FeatureSet();\n        const supportedFeatures = cluster?.supportedFeatures ?? new FeatureSet();\n\n        const selectedMembers = {} as Record<string, ValueModel>;\n        for (const member of scope.members) {\n            if (member.isDeprecated) {\n                continue;\n            }\n\n            if (conformantOnly && !member.conformance.isApplicable(features, supportedFeatures)) {\n                continue;\n            }\n\n            const other = selectedMembers[member.name];\n            if (other !== undefined) {\n                if (!conformantOnly && !member.conformance.isApplicable(features, supportedFeatures)) {\n                    continue;\n                }\n\n                if (other.conformance.isApplicable(features, supportedFeatures)) {\n                    throw new SchemaImplementationError(\n                        scope,\n                        `There are multiple definitions of \"${member.name}\" that cannot be differentiated by conformance`,\n                    );\n                }\n\n                // This member takes precedence and will overwrite below\n            }\n\n            selectedMembers[member.name] = member;\n        }\n\n        return Object.values(selectedMembers);\n    }\n\n    /**\n     * Search inherited scope for a bit definition.\n     */\n    findBitDefinition(scope: Model | undefined, bit: number) {\n        return this.operation(() => {\n            while (scope) {\n                if (!scope.isType) {\n                    return;\n                }\n\n                if ((scope as ValueModel).effectiveMetatype !== Metatype.bitmap) {\n                    scope = parentOf(scope);\n                    continue;\n                }\n\n                for (const c of (scope as ValueModel).children) {\n                    if (c.constraint.test(bit)) {\n                        return c;\n                    }\n                }\n\n                scope = this.findBase(scope);\n            }\n        });\n    }\n\n    /**\n     * Search inherited and structural type scope for a named type.\n     */\n    findType(scope: Model | undefined, name: string, tag: ElementTag): Model | undefined {\n        if (!scope) {\n            return;\n        }\n\n        const memoKey = `${name} ${tag}`;\n        const memosForScope = memos?.types.get(scope);\n        if (memosForScope && memoKey in memosForScope) {\n            return memosForScope[memoKey];\n        }\n\n        const type = this.operation(() => {\n            const queue = Array<Model>(scope as Model);\n            for (scope = queue.shift(); scope; scope = queue.shift()) {\n                if (scope.isTypeScope) {\n                    const result = scope.children.select(name, tag, this.#dismissed);\n                    if (result) {\n                        return result;\n                    }\n                }\n\n                // Search inherited scope next\n                const inheritedScope = this.findBase(scope);\n                if (inheritedScope) {\n                    queue.unshift(inheritedScope);\n                }\n\n                // Search parent scope once all inherited scope is searched\n                const parent = parentOf(scope);\n                if (parent) {\n                    queue.push(parent);\n                }\n            }\n        });\n\n        if (memos) {\n            const memosForScope = memos.types.get(scope);\n            if (memosForScope) {\n                memosForScope[memoKey] = type;\n            } else {\n                memos.types.set(scope, { [memoKey]: type });\n            }\n        }\n\n        return type;\n    }\n\n    /**\n     * Similar to findType but operates with a qualified type name.\n     *\n     * Unlike findType, a qualified type may reference an element parented by any other, not just those with\n     * parent.isTypeScope === true.\n     *\n     * This is quite complicated and would be painfully slow except in practice we don't use many qualified types and\n     * those we do use resolve with few failing branches in the search once the root qualifier of the name matches.\n     */\n    findQualifiedType(scope: Model | undefined, path: string[], tag: ElementTag): Model | undefined {\n        if (!scope) {\n            return;\n        }\n\n        function resolve(scope: Model, position = 0): Model | undefined {\n            // The last position is the target model and must match tag type\n            if (position === path.length - 1) {\n                return scope.children.select(path[position], tag);\n            }\n\n            // Intermediate positions are just namespaces into which we recurse\n            for (const subscope of scope.children.selectAll(path[position])) {\n                const result = resolve(subscope, position + 1);\n                if (result) {\n                    return result;\n                }\n            }\n\n            // Special case for \"Matter\" element which normally cannot be referenced.  This allows for creating\n            // \"absolute\" paths by prefixing with \"Matter.\".\n            if (position === 0 && scope.tag === ElementTag.Matter && path[0] === \"Matter\") {\n                const result = resolve(scope, position + 1);\n                if (result) {\n                    return result;\n                }\n            }\n\n            // Path is not resolvable in this scope\n        }\n\n        return this.operation(() => {\n            const queue = Array<Model>(scope as Model);\n            for (scope = queue.shift(); scope; scope = queue.shift()) {\n                // First attempt to resolve in the current scope\n                const resolved = resolve(scope);\n                if (resolved) {\n                    return resolved;\n                }\n\n                // Search inherited scope next\n                const inheritedScope = this.findBase(scope);\n                if (inheritedScope) {\n                    queue.unshift(inheritedScope);\n                }\n\n                // Search parent scope once all inherited scope is searched\n                const parent = parentOf(scope);\n                if (parent) {\n                    queue.push(parent);\n                }\n            }\n        });\n    }\n\n    /**\n     * Find the response model for a command.\n     */\n    findResponse(command: CommandModel) {\n        if (command.response && command.response !== \"status\") {\n            return new ModelTraversal().findType(command, command.response, ElementTag.Command);\n        }\n    }\n\n    /**\n     * Find all children of a node that reference a specific type.\n     */\n    findReferences(scope: Model | undefined, type: Model | undefined): Model[] {\n        if (!scope || !type) {\n            return [];\n        }\n\n        const references = Array<Model>();\n        this.visit(scope, model => {\n            // This is the most common method for referencing\n            if (this.findBase(model) === type) {\n                references.push(model);\n                return;\n            }\n\n            // A command may reference its response\n            if (model.tag === ElementTag.Command && this.findResponse(model as CommandModel) === type) {\n                references.push(model);\n                return;\n            }\n\n            // This is not common but the default value can reference another field\n            if (model.isType) {\n                const defaultValue = (model as ValueModel).default;\n                if (FieldValue.is(defaultValue, FieldValue.reference)) {\n                    if ((defaultValue as FieldValue.Reference).name === type.name) {\n                        references.push(model);\n                    }\n                }\n            }\n        });\n\n        return references;\n    }\n\n    /**\n     * Find an owning model of a specific type.\n     */\n    findOwner<T extends Model>(constructor: Model.Type<T>, model: Model | undefined): T | undefined {\n        const parent = parentOf(model);\n\n        if (!parent || parent instanceof constructor) {\n            return parent;\n        }\n\n        return this.operation(() => {\n            return this.findOwner(constructor, parent);\n        });\n    }\n\n    /**\n     * Find the root model.\n     */\n    findRoot(model: Model | undefined): Model | undefined {\n        if (!model) {\n            return undefined;\n        }\n\n        const parent = parentOf(model);\n        if (!parent) {\n            return model;\n        }\n\n        return this.operation(() => {\n            return this.findRoot(parent);\n        });\n    }\n\n    /**\n     * Visit all nodes in the model tree.\n     */\n    visit(model: Model, visitor: (model: Model) => boolean | void): boolean | undefined {\n        return this.operation(() => {\n            if (visitor(model) === false) {\n                return false;\n            }\n            for (const c of model.children) {\n                if (this.visit(c, visitor) === false) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Visit all nodes in the inheritance hierarchy until the visitor returns false.\n     */\n    visitInheritance(model: Model | undefined, visitor: (model: Model) => boolean | void): boolean | undefined {\n        if (!model) {\n            return;\n        }\n\n        return this.operation(() => {\n            if (visitor(model) === false) {\n                return false;\n            }\n            const base = this.findBase(model);\n            this.visitInheritance(base, visitor);\n        });\n    }\n\n    /**\n     * If a model is not owned by a MatterModel, global resolution won't work.  This model acts as a fallback to work\n     * around this.\n     */\n    static fallbackScope: Model | undefined;\n\n    /**\n     * This is a cheap hack to optimize analysis of large static models.  It temporarily memoizes key operations.\n     *\n     * It's not a huge win but does speed up model validation by approximately 50%\n     */\n    static memoize(fn: () => void) {\n        if (memos) {\n            fn();\n            return;\n        }\n\n        try {\n            memos = { bases: new Map(), shadows: new Map(), types: new Map() };\n            fn();\n        } finally {\n            memos = undefined;\n        }\n    }\n}\n\nfunction parentOf(model?: Model) {\n    if (model?.parent === undefined && model?.tag !== ElementTag.Matter) {\n        return ModelTraversal.fallbackScope;\n    }\n    return model?.parent;\n}\n\ninterface Memos {\n    bases: Map<Model, Model | undefined>;\n    shadows: Map<Model, Model | undefined>;\n    types: Map<Model, Record<string, Model | undefined>>;\n}\n"],
  "mappings": "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",
  "names": ["model", "field", "memosForScope", "scope"]
}
