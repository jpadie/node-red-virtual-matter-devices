{
  "version": 3,
  "sources": ["../../../../src/model/definitions/Metatype.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport { isObject } from \"../../util/Type.js\";\n\nexport class UnsupportedCastError extends UnexpectedDataError {}\n\n/**\n * General groupings of Matter types.\n */\nexport enum Metatype {\n    any = \"any\",\n    boolean = \"boolean\",\n    bitmap = \"bitmap\",\n    enum = \"enum\",\n    integer = \"integer\",\n    float = \"float\",\n    bytes = \"bytes\",\n    array = \"array\",\n    object = \"object\",\n    string = \"string\",\n    date = \"date\",\n}\n\nexport namespace Metatype {\n    /**\n     * Does the specific type have children?\n     */\n    export function hasChildren(type: Metatype | undefined) {\n        switch (type) {\n            case Metatype.enum:\n            case Metatype.bitmap:\n            case Metatype.object:\n                return true;\n\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Determine the JS type for a metatype.\n     */\n    export function native(type: Metatype | undefined) {\n        switch (type) {\n            case Metatype.boolean:\n                return Boolean;\n\n            case Metatype.integer:\n                return BigInt;\n\n            case Metatype.bitmap:\n            case Metatype.enum:\n            case Metatype.float:\n                return Number;\n\n            case Metatype.bytes:\n                return ByteArray;\n\n            case Metatype.array:\n                return Array;\n\n            case Metatype.object:\n                return Object;\n\n            case Metatype.string:\n                return String;\n\n            case Metatype.date:\n                return Date;\n        }\n    }\n\n    /**\n     * Functions that perform conversion of arbitrary values to a metatype.\n     *\n     * This is a \"best effort\" that ensures the value is an appropriate JS type but cannot ensure semantic validity in\n     * all cases.\n     *\n     * @throws {@link UnsupportedCastError} if the cast is deemed impossible\n     */\n    export const cast: Record<Metatype, (value: any) => any> = {\n        any(value: any) {\n            return value;\n        },\n\n        boolean(value: any): boolean | null | undefined {\n            if (typeof value === \"boolean\" || value === null || value === undefined) {\n                return value;\n            }\n\n            if (typeof value === \"string\") {\n                const normalized = value.toLowerCase().trim();\n                switch (normalized) {\n                    case \"\":\n                    case \"0\":\n                    case \"off\":\n                    case \"no\":\n                    case \"false\":\n                        return false;\n\n                    case \"1\":\n                    case \"on\":\n                    case \"yes\":\n                    case \"true\":\n                        return true;\n                }\n            }\n\n            if (typeof value === \"number\" || typeof value === \"bigint\") {\n                return !!value;\n            }\n\n            if (ArrayBuffer.isView(value)) {\n                for (const byte of new ByteArray(value.buffer)) {\n                    if (byte) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to boolean`);\n        },\n\n        bitmap(value: any): number | bigint | Record<string, number> | null | undefined {\n            if (value === null || value === undefined) {\n                return value;\n            }\n\n            if (typeof value === \"string\") {\n                value = cast.integer(value);\n            }\n\n            if (typeof value === \"number\") {\n                if (Number.isFinite(value)) {\n                    return value;\n                }\n            } else if (typeof value === \"bigint\") {\n                return value;\n            } else if (isObject(value)) {\n                return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, cast.integer(v)])) as Record<\n                    string,\n                    number\n                >;\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to bitmap`);\n        },\n\n        enum(value: any): number | string | null | undefined {\n            if (typeof value === \"string\") {\n                if (value.trim().match(/^(?:[0-9]+|0x[0-9a-f]+|0b[01]+)$/)) {\n                    value = Number.parseInt(value);\n                } else {\n                    return value;\n                }\n            }\n\n            if (typeof value === \"number\" && !Number.isNaN(value) && Number.isFinite(value)) {\n                return value;\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to an enum value`);\n        },\n\n        integer(value: any): number | bigint | null | undefined {\n            if (value === null || value === undefined) {\n                return value;\n            }\n\n            switch (typeof value) {\n                case \"number\":\n                    return Math.floor(value);\n\n                case \"bigint\":\n                    return value;\n\n                case \"boolean\":\n                    return value ? 1 : 0;\n            }\n\n            if (value instanceof Date) {\n                return value.getTime();\n            }\n\n            if (typeof value === \"string\") {\n                try {\n                    const big = BigInt(value);\n                    const little = Number.parseInt(value);\n                    if (big === BigInt(little)) {\n                        return little;\n                    }\n                    return big;\n                } catch (e) {\n                    if (!(e instanceof SyntaxError)) {\n                        throw e;\n                    }\n                }\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to an integer`);\n        },\n\n        float(value: any): number | null | undefined {\n            if (typeof value === \"number\" || value === null || value === undefined) {\n                return value;\n            }\n\n            if (value instanceof Date) {\n                return value.getTime();\n            }\n\n            const number = Number(value);\n            if (!Number.isNaN(number) && Number.isFinite(value)) {\n                return number;\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to a float`);\n        },\n\n        bytes(value: any): ByteArray | null | undefined {\n            if (value === undefined || value === null || value instanceof ByteArray) {\n                return value;\n            }\n\n            if (typeof value === \"string\") {\n                return ByteArray.fromHex(value);\n            }\n\n            if (typeof value === \"boolean\") {\n                return new ByteArray([value ? 1 : 0]);\n            }\n\n            if (typeof value === \"number\" || typeof value === \"bigint\") {\n                return ByteArray.fromHex(value.toString(16));\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to bytes`);\n        },\n\n        array(value: any): Array<unknown> | null | undefined {\n            if (value === undefined || value === null || Array.isArray(value)) {\n                return value;\n            }\n\n            if (typeof value === \"string\") {\n                try {\n                    const parsed = JSON.parse(value);\n                    if (Array.isArray(parsed)) {\n                        return parsed;\n                    }\n                } catch (e) {\n                    if (!(e instanceof SyntaxError)) {\n                        throw e;\n                    }\n                }\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to array`);\n        },\n\n        object(value: any): Record<string, unknown> | null | undefined {\n            if (\n                value === undefined ||\n                (typeof value === \"object\" && !Array.isArray(value) && !(value instanceof Date))\n            ) {\n                return value;\n            }\n\n            if (typeof value === \"string\") {\n                try {\n                    const parsed = JSON.parse(value);\n                    return parsed;\n                } catch (e) {\n                    if (!(e instanceof SyntaxError)) {\n                        throw e;\n                    }\n                }\n            }\n\n            throw new UnsupportedCastError(`Cannot convert \"${value}\" to object`);\n        },\n\n        string(value: any): string | null | undefined {\n            if (value === undefined || value === null) {\n                return value;\n            }\n\n            if (typeof value === \"string\") {\n                return value;\n            }\n\n            if (value instanceof Date) {\n                return value.toISOString();\n            }\n\n            if (typeof value === \"object\" || Array.isArray(value)) {\n                return JSON.stringify(value);\n            }\n\n            return value.toString();\n        },\n\n        date(value: any): Date | null | undefined {\n            if (value === undefined || value === null || value instanceof Date) {\n                return value;\n            }\n\n            if (typeof value === \"number\" || typeof value === \"string\") {\n                const date = new Date(value);\n                if (!Number.isNaN(date.getTime())) {\n                    return date;\n                }\n            }\n\n            throw new UnexpectedDataError();\n        },\n    };\n\n    /**\n     * These are the native types used by this module.\n     */\n    export type NativeType =\n        | typeof Boolean\n        | typeof BigInt\n        | typeof Number\n        | typeof ByteArray\n        | typeof Array\n        | typeof Object\n        | typeof String\n        | typeof Date;\n}\n"],
  "mappings": "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",
  "names": ["Metatype"]
}
