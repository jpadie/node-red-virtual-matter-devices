{
  "version": 3,
  "sources": ["../../../../src/model/models/ClusterModel.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Mei } from \"../../datatype/ManufacturerExtensibleIdentifier.js\";\nimport { camelize, describeList } from \"../../util/String.js\";\nimport { Access } from \"../aspects/Access.js\";\nimport { Quality } from \"../aspects/Quality.js\";\nimport { SchemaImplementationError } from \"../definitions/errors.js\";\nimport { ElementTag, FeatureSet, Metatype } from \"../definitions/index.js\";\nimport { ClusterElement } from \"../elements/index.js\";\nimport { ModelTraversal } from \"../logic/ModelTraversal.js\";\nimport { ClusterRevision } from \"../standard/elements/ClusterRevision.js\";\nimport { FeatureMap } from \"../standard/elements/FeatureMap.js\";\nimport { Aspects } from \"./Aspects.js\";\nimport { AttributeModel } from \"./AttributeModel.js\";\nimport { Children } from \"./Children.js\";\nimport { CommandModel } from \"./CommandModel.js\";\nimport { DatatypeModel } from \"./DatatypeModel.js\";\nimport { EventModel } from \"./EventModel.js\";\nimport type { FieldModel } from \"./FieldModel.js\";\nimport { Model } from \"./Model.js\";\nimport { PropertyModel } from \"./PropertyModel.js\";\n\nconst QUALITY = Symbol(\"quality\");\n\nexport class ClusterModel extends Model implements ClusterElement {\n    override tag: ClusterElement.Tag = ClusterElement.Tag;\n    declare id: Mei;\n    declare classification?: ClusterElement.Classification;\n    declare pics?: string;\n    override isTypeScope = true;\n\n    get diagnostics() {\n        return this.effectiveQuality.diagnostics;\n    }\n\n    get quality(): Quality {\n        return Aspects.getAspect(this, QUALITY, Quality);\n    }\n    set quality(definition: Quality | Quality.Definition) {\n        Aspects.setAspect(this, QUALITY, Quality, definition);\n    }\n    get effectiveQuality(): Quality {\n        return Aspects.getEffectiveAspect(this, QUALITY, Quality);\n    }\n\n    get attributes() {\n        return this.all(AttributeModel);\n    }\n\n    get commands() {\n        return this.all(CommandModel);\n    }\n\n    get events() {\n        return this.all(EventModel);\n    }\n\n    get datatypes() {\n        return this.all(DatatypeModel);\n    }\n\n    get members(): PropertyModel[] {\n        const traversal = new ModelTraversal();\n\n        // Formally a field element cannot be a cluster child but we allow it for metadata control when a field should\n        // not be published\n        const members = traversal.findChildren(this, [ElementTag.Field, ElementTag.Attribute]) as PropertyModel[];\n\n        // We consider the standard set of \"global\" attributes members of all clusters\n        const missingGlobalIds = new Set(AttributeModel.globalIds);\n        for (const m of members) {\n            if (m instanceof AttributeModel && m.id) {\n                missingGlobalIds.delete(m.id);\n            }\n        }\n\n        if (missingGlobalIds.size) {\n            const root = traversal.findRoot(this);\n            if (root) {\n                for (const id of missingGlobalIds) {\n                    const global = root.get(AttributeModel, id);\n                    if (global) {\n                        members.push(global);\n                    }\n                }\n            }\n        }\n\n        return members;\n    }\n\n    get activeMembers() {\n        return new ModelTraversal().findActiveMembers(this, false, this);\n    }\n\n    get conformantMembers() {\n        return new ModelTraversal().findActiveMembers(this, true, this);\n    }\n\n    /**\n     * Get attributes, commands and events whether inherited or defined directly in this model.\n     */\n    get allAces() {\n        return new ModelTraversal().findChildren(this, [\n            ElementTag.Attribute,\n            ElementTag.Command,\n            ElementTag.Event,\n        ]) as (AttributeModel | CommandModel | EventModel)[];\n    }\n\n    get revision() {\n        let revision = 1;\n        const revisionAttr = this.get(AttributeModel, ClusterRevision.id);\n        if (typeof revisionAttr?.default === \"number\") {\n            revision = revisionAttr.default;\n        }\n        return revision;\n    }\n\n    get features() {\n        return this.featureMap.children ?? [];\n    }\n\n    get featureMap() {\n        return (this.member(FeatureMap.id, [ElementTag.Attribute]) as AttributeModel) ?? new AttributeModel(FeatureMap);\n    }\n\n    get featureNames(): FeatureSet {\n        return new FeatureSet(this.features.map(feature => feature.name));\n    }\n\n    get supportedFeatures(): FeatureSet {\n        const supported = {} as { [name: string]: boolean | undefined };\n        for (const feature of this.features) {\n            if (feature.default) {\n                supported[feature.name] = true;\n            }\n        }\n        return new FeatureSet(supported);\n    }\n\n    set supportedFeatures(features: FeatureSet.Definition | undefined) {\n        const featureSet = new FeatureSet(features);\n\n        let featureMap = this.featureMap;\n\n        if (featureMap.parent !== this) {\n            featureMap = featureMap.clone();\n            this.add(featureMap);\n        }\n\n        for (const feature of featureMap.children) {\n            const desc = feature.description && camelize(feature.description);\n            if (desc !== undefined && featureSet.has(desc)) {\n                feature.default = true;\n                featureSet.delete(desc);\n                continue;\n            }\n\n            if (featureSet.has(feature.name)) {\n                featureSet.delete(feature.name);\n                feature.default = true;\n                continue;\n            }\n\n            feature.default = undefined;\n        }\n\n        if (featureSet.size) {\n            throw new SchemaImplementationError(\n                this,\n                `Cannot set unknown feature${featureSet.size > 1 ? \"s\" : \"\"} ${describeList(\"and\", ...featureSet)}`,\n            );\n        }\n    }\n\n    override get children(): Children<ClusterModel.Child, ClusterElement.Child> {\n        return super.children as any;\n    }\n\n    override set children(children: (ClusterModel.Child | ClusterElement.Child)[]) {\n        super.children = children;\n    }\n\n    get effectiveMetatype() {\n        return Metatype.object;\n    }\n\n    get effectiveAccess() {\n        return Access.Default;\n    }\n\n    override valueOf() {\n        const result = super.valueOf() as any;\n        if (this.quality && !this.quality.empty) {\n            result.quality = this.quality.valueOf();\n        }\n        return result as ClusterElement;\n    }\n\n    override freeze() {\n        this.quality.freeze();\n        super.freeze();\n    }\n\n    constructor(definition: ClusterElement.Properties) {\n        super(definition);\n\n        if (definition instanceof Model) {\n            Aspects.cloneAspects(definition, this, QUALITY);\n        }\n    }\n\n    static Tag = ClusterElement.Tag;\n\n    static {\n        Model.types[this.Tag] = this;\n    }\n}\n\nexport namespace ClusterModel {\n    export type Child =\n        | DatatypeModel\n        | AttributeModel\n        | CommandModel\n        | EventModel\n\n        // Fields are not cluster children in canonical schema but we allow\n        // them as private values in operational schema\n        | FieldModel;\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,SAAS,UAAU,oBAAoB;AACvC,SAAS,cAAc;AACvB,SAAS,eAAe;AACxB,SAAS,iCAAiC;AAC1C,SAAS,YAAY,YAAY,gBAAgB;AACjD,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,uBAAuB;AAChC,SAAS,kBAAkB;AAC3B,SAAS,eAAe;AACxB,SAAS,sBAAsB;AAE/B,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAC9B,SAAS,kBAAkB;AAE3B,SAAS,aAAa;AAGtB,MAAM,UAAU,OAAO,SAAS;AAEzB,MAAM,qBAAqB,MAAgC;AAAA,EACrD,MAA0B,eAAe;AAAA,EAIzC,cAAc;AAAA,EAEvB,IAAI,cAAc;AACd,WAAO,KAAK,iBAAiB;AAAA,EACjC;AAAA,EAEA,IAAI,UAAmB;AACnB,WAAO,QAAQ,UAAU,MAAM,SAAS,OAAO;AAAA,EACnD;AAAA,EACA,IAAI,QAAQ,YAA0C;AAClD,YAAQ,UAAU,MAAM,SAAS,SAAS,UAAU;AAAA,EACxD;AAAA,EACA,IAAI,mBAA4B;AAC5B,WAAO,QAAQ,mBAAmB,MAAM,SAAS,OAAO;AAAA,EAC5D;AAAA,EAEA,IAAI,aAAa;AACb,WAAO,KAAK,IAAI,cAAc;AAAA,EAClC;AAAA,EAEA,IAAI,WAAW;AACX,WAAO,KAAK,IAAI,YAAY;AAAA,EAChC;AAAA,EAEA,IAAI,SAAS;AACT,WAAO,KAAK,IAAI,UAAU;AAAA,EAC9B;AAAA,EAEA,IAAI,YAAY;AACZ,WAAO,KAAK,IAAI,aAAa;AAAA,EACjC;AAAA,EAEA,IAAI,UAA2B;AAC3B,UAAM,YAAY,IAAI,eAAe;AAIrC,UAAM,UAAU,UAAU,aAAa,MAAM,CAAC,WAAW,OAAO,WAAW,SAAS,CAAC;AAGrF,UAAM,mBAAmB,IAAI,IAAI,eAAe,SAAS;AACzD,eAAW,KAAK,SAAS;AACrB,UAAI,aAAa,kBAAkB,EAAE,IAAI;AACrC,yBAAiB,OAAO,EAAE,EAAE;AAAA,MAChC;AAAA,IACJ;AAEA,QAAI,iBAAiB,MAAM;AACvB,YAAM,OAAO,UAAU,SAAS,IAAI;AACpC,UAAI,MAAM;AACN,mBAAW,MAAM,kBAAkB;AAC/B,gBAAM,SAAS,KAAK,IAAI,gBAAgB,EAAE;AAC1C,cAAI,QAAQ;AACR,oBAAQ,KAAK,MAAM;AAAA,UACvB;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,IAAI,gBAAgB;AAChB,WAAO,IAAI,eAAe,EAAE,kBAAkB,MAAM,OAAO,IAAI;AAAA,EACnE;AAAA,EAEA,IAAI,oBAAoB;AACpB,WAAO,IAAI,eAAe,EAAE,kBAAkB,MAAM,MAAM,IAAI;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACV,WAAO,IAAI,eAAe,EAAE,aAAa,MAAM;AAAA,MAC3C,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,IACf,CAAC;AAAA,EACL;AAAA,EAEA,IAAI,WAAW;AACX,QAAI,WAAW;AACf,UAAM,eAAe,KAAK,IAAI,gBAAgB,gBAAgB,EAAE;AAChE,QAAI,OAAO,cAAc,YAAY,UAAU;AAC3C,iBAAW,aAAa;AAAA,IAC5B;AACA,WAAO;AAAA,EACX;AAAA,EAEA,IAAI,WAAW;AACX,WAAO,KAAK,WAAW,YAAY,CAAC;AAAA,EACxC;AAAA,EAEA,IAAI,aAAa;AACb,WAAQ,KAAK,OAAO,WAAW,IAAI,CAAC,WAAW,SAAS,CAAC,KAAwB,IAAI,eAAe,UAAU;AAAA,EAClH;AAAA,EAEA,IAAI,eAA2B;AAC3B,WAAO,IAAI,WAAW,KAAK,SAAS,IAAI,aAAW,QAAQ,IAAI,CAAC;AAAA,EACpE;AAAA,EAEA,IAAI,oBAAgC;AAChC,UAAM,YAAY,CAAC;AACnB,eAAW,WAAW,KAAK,UAAU;AACjC,UAAI,QAAQ,SAAS;AACjB,kBAAU,QAAQ,IAAI,IAAI;AAAA,MAC9B;AAAA,IACJ;AACA,WAAO,IAAI,WAAW,SAAS;AAAA,EACnC;AAAA,EAEA,IAAI,kBAAkB,UAA6C;AAC/D,UAAM,aAAa,IAAI,WAAW,QAAQ;AAE1C,QAAI,aAAa,KAAK;AAEtB,QAAI,WAAW,WAAW,MAAM;AAC5B,mBAAa,WAAW,MAAM;AAC9B,WAAK,IAAI,UAAU;AAAA,IACvB;AAEA,eAAW,WAAW,WAAW,UAAU;AACvC,YAAM,OAAO,QAAQ,eAAe,SAAS,QAAQ,WAAW;AAChE,UAAI,SAAS,UAAa,WAAW,IAAI,IAAI,GAAG;AAC5C,gBAAQ,UAAU;AAClB,mBAAW,OAAO,IAAI;AACtB;AAAA,MACJ;AAEA,UAAI,WAAW,IAAI,QAAQ,IAAI,GAAG;AAC9B,mBAAW,OAAO,QAAQ,IAAI;AAC9B,gBAAQ,UAAU;AAClB;AAAA,MACJ;AAEA,cAAQ,UAAU;AAAA,IACtB;AAEA,QAAI,WAAW,MAAM;AACjB,YAAM,IAAI;AAAA,QACN;AAAA,QACA,6BAA6B,WAAW,OAAO,IAAI,MAAM,EAAE,IAAI,aAAa,OAAO,GAAG,UAAU,CAAC;AAAA,MACrG;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,IAAa,WAA+D;AACxE,WAAO,MAAM;AAAA,EACjB;AAAA,EAEA,IAAa,SAAS,UAAyD;AAC3E,UAAM,WAAW;AAAA,EACrB;AAAA,EAEA,IAAI,oBAAoB;AACpB,WAAO,SAAS;AAAA,EACpB;AAAA,EAEA,IAAI,kBAAkB;AAClB,WAAO,OAAO;AAAA,EAClB;AAAA,EAES,UAAU;AACf,UAAM,SAAS,MAAM,QAAQ;AAC7B,QAAI,KAAK,WAAW,CAAC,KAAK,QAAQ,OAAO;AACrC,aAAO,UAAU,KAAK,QAAQ,QAAQ;AAAA,IAC1C;AACA,WAAO;AAAA,EACX;AAAA,EAES,SAAS;AACd,SAAK,QAAQ,OAAO;AACpB,UAAM,OAAO;AAAA,EACjB;AAAA,EAEA,YAAY,YAAuC;AAC/C,UAAM,UAAU;AAEhB,QAAI,sBAAsB,OAAO;AAC7B,cAAQ,aAAa,YAAY,MAAM,OAAO;AAAA,IAClD;AAAA,EACJ;AAAA,EAEA,OAAO,MAAM,eAAe;AAAA,EAE5B,OAAO;AACH,UAAM,MAAM,KAAK,GAAG,IAAI;AAAA,EAC5B;AACJ;",
  "names": []
}
