{
  "version": 3,
  "sources": ["../../../../src/model/models/Model.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { camelize } from \"../../util/String.js\";\nimport { DefinitionError, ElementTag, Metatype, Specification } from \"../definitions/index.js\";\nimport { AnyElement, BaseElement } from \"../elements/index.js\";\nimport { ModelTraversal } from \"../logic/ModelTraversal.js\";\nimport { Children } from \"./Children.js\";\n\n/**\n * A \"model\" is a class that implements runtime functionality associated with the corresponding element type.\n */\nexport abstract class Model {\n    abstract readonly tag: ElementTag;\n    declare type?: string;\n    declare isSeed?: boolean;\n    declare description?: string;\n    declare details?: string;\n    declare xref?: Model.CrossReference;\n    declare errors?: DefinitionError[];\n    declare asOf?: Specification.Revision;\n    declare until?: Specification.Revision;\n    declare id?: number;\n    declare name: string;\n\n    #id?: number = undefined;\n    #name: string;\n\n    /**\n     * Indicates that an element may have type definitions as children.\n     */\n    isTypeScope?: boolean;\n\n    /**\n     * Indicates that an element defines a datatype.\n     */\n    isType?: boolean;\n\n    #children?: Children;\n    #parent?: Model;\n\n    /**\n     * Did validation find errors?\n     */\n    get valid() {\n        return !this.errors;\n    }\n\n    /**\n     * The path (\".\" delimited) in the Matter tree.\n     *\n     * This is informational and generally tries to adhere to JS API conventions.\n     */\n    get path(): string {\n        if (this.parent && this.parent.tag !== ElementTag.Matter) {\n            if (this.parent.tag === ElementTag.Field) {\n                return `${this.parent.path}.${camelize(this.name)}`;\n            }\n\n            if (this.parent.tag === ElementTag.Cluster) {\n                switch (this.tag) {\n                    case ElementTag.Attribute:\n                        return `${this.parent.path}.state.${camelize(this.name, false)}`;\n\n                    case ElementTag.Command:\n                        return `${this.parent.path}.${camelize(this.name, false)}`;\n\n                    case ElementTag.Event:\n                        return `${this.parent.path}.events.${camelize(this.name, false)}`;\n                }\n            }\n\n            const parent = this.parent;\n            if (parent.tag !== ElementTag.Cluster) {\n                const parentMetatype = (parent as { effectiveMetatype?: Metatype })?.effectiveMetatype;\n                if (parentMetatype === Metatype.object || parentMetatype === Metatype.array) {\n                    return `${parent.path}.${camelize(this.name, false)}`;\n                }\n            }\n\n            return `${parent.path}.${this.name}`;\n        } else {\n            return this.name;\n        }\n    }\n\n    /**\n     * Determine if this model resides in the global namespace.\n     */\n    get isGlobal() {\n        return this.tag === \"matter\" || this.parent?.tag === \"matter\";\n    }\n\n    /**\n     * The structural parent.  This is the model for the element that contains this element's definition.\n     */\n    get parent(): Model | undefined {\n        return this.#parent;\n    }\n\n    set parent(parent: Model | undefined) {\n        if (this.parent === parent) {\n            return;\n        }\n\n        if (this.parent) {\n            const index = this.parent.children.indexOf(this);\n            if (index !== -1) {\n                this.parent.children.splice(index, 1);\n            }\n        }\n\n        if (parent) {\n            parent.children.push(this);\n        }\n\n        // Note that parent updates this.#parent so don't touch that\n    }\n\n    /**\n     * Allows subclasses to pull a working ID from an alternate source.\n     */\n    get effectiveId() {\n        return this.id;\n    }\n\n    /**\n     * Get a string that uniquely identifies this model.  This is normally the effective ID but some models require a\n     * generated identifier.\n     */\n    get key() {\n        const key = this.effectiveId?.toString();\n        if (key === undefined) {\n            return key;\n        }\n        const discriminator = this.discriminator;\n        if (discriminator === undefined) {\n            return key;\n        }\n        return `${key}\u241C${discriminator}`;\n    }\n\n    /**\n     * Obtain a discriminator that differentiates different models with the same name\n     */\n    get discriminator(): string | undefined {\n        return;\n    }\n\n    /**\n     * Children of models are always models.\n     */\n    get children(): Children {\n        if (!this.#children) {\n            // Construct new Children instance via setter\n            this.children = [];\n        }\n        return this.#children as Children;\n    }\n\n    /**\n     * Children can be added as models or elements.\n     */\n    set children(children: (Model | AnyElement)[]) {\n        this.#children = Children(\n            children,\n\n            (child: Model) => {\n                if (child.#parent === this) {\n                    return;\n                }\n\n                if (child.#parent) {\n                    const position = child.#parent.children.indexOf(child);\n                    if (position !== -1) {\n                        child.#parent.children.splice(position, 1);\n                    }\n                    child.#parent = undefined;\n                }\n\n                child.#parent = this;\n            },\n\n            (child: Model) => {\n                if (child.#parent === this) {\n                    child.#parent = undefined;\n                    return true;\n                }\n                return false;\n            },\n        );\n    }\n\n    /**\n     * Factory support.  Populated by derivatives upon definition.\n     */\n    static types = {} as { [type: string]: new (definition: any) => Model };\n\n    /**\n     * In some circumstances the base type can be inferred.  This inference happens here.\n     *\n     * Does not recurse so only returns the direct base type.\n     */\n    get effectiveType() {\n        return this.type;\n    }\n\n    /**\n     * Get a Model for my base type, if any.\n     */\n    get base() {\n        return new ModelTraversal().findBase(this);\n    }\n\n    /**\n     * Get shadow model, if any.  A \"shadow\" is an element in my parent's inheritance hierarchy that I override.\n     */\n    get shadow() {\n        return new ModelTraversal().findShadow(this);\n    }\n\n    /**\n     * Get the first global base type.  This may have semantic meaning more specific than the base primitive type.\n     */\n    get globalBase() {\n        return new ModelTraversal().findGlobalBase(this);\n    }\n\n    /**\n     * A local or parent xref.\n     */\n    get effectiveXref() {\n        return new ModelTraversal().findXref(this);\n    }\n\n    /**\n     * The set of tags from which this model may derive.\n     */\n    get allowedBaseTags() {\n        return [this.tag];\n    }\n\n    /**\n     * Determine whether this element applies to a specific revision.\n     */\n    appliesTo(revision: Specification.Revision) {\n        // Stick to simple string comparison for now as it is efficient; update if versioning ever gets more complex\n        // (or Matter reaches version 10)\n        return (\n            (this.asOf === undefined || revision >= this.asOf) && (this.until === undefined || revision < this.until)\n        );\n    }\n\n    /**\n     * Add a child.  children.push works too but only accepts models.\n     */\n    add(...children: (Model | AnyElement)[]) {\n        this.children.push(...(children as any[]));\n    }\n\n    /**\n     * Create a model for an element.\n     */\n    static create(definition: AnyElement) {\n        if (typeof definition !== \"object\") {\n            throw new InternalError(`Model definition must be object, not ${typeof definition}`);\n        }\n        const t = definition[\"tag\"];\n        const constructor = Model.types[t];\n        if (!constructor) {\n            throw new InternalError(`Unknown element tag \"${t}\"`);\n        }\n        return new constructor(definition);\n    }\n\n    /**\n     * Retrieve all models of a specific element type from local scope.\n     *\n     * @param constructor model class or a predicate object\n     * @param key filters to models matching a specific type\n     */\n    all<T extends Model>(constructor: Model.Type<T>, key?: number | string) {\n        return this.children.all(constructor, key);\n    }\n\n    /**\n     * Retrieve a specific model by ID or name.\n     */\n    get<T extends Model>(type: Model.Type<T>, key: number | string): T | undefined {\n        return this.children.get(type, key);\n    }\n\n    /**\n     * Retrieve a model of a specific type from the ownership hierarchy.\n     */\n    owner<T extends Model>(constructor: Model.Type<T>) {\n        return new ModelTraversal().findOwner(constructor, this);\n    }\n\n    /**\n     * Record a validation error for this model.\n     */\n    error(code: string, message: string) {\n        if (!this.errors) {\n            this.errors = [];\n        }\n\n        this.errors.push({\n            code,\n            source: this.path,\n            message,\n            xref: this.effectiveXref?.toString(),\n        });\n    }\n\n    /**\n     * Convert model to JSON.\n     */\n    toJSON() {\n        return this.valueOf();\n    }\n\n    /**\n     * Convert to non-class structure.\n     */\n    valueOf(): AnyElement {\n        const result = {} as { [name: string]: any };\n\n        // Return all iterable properties minus metadata\n        for (const key in this) {\n            switch (key) {\n                case \"parent\":\n                case \"errors\":\n                case \"isTypeScope\":\n                case \"isType\":\n                    continue;\n\n                default:\n                    result[key] = this[key];\n            }\n        }\n\n        return result as AnyElement;\n    }\n\n    /**\n     * Apply a function to all tree elements.\n     */\n    visit(visitor: (model: Model) => boolean | void) {\n        return new ModelTraversal().visit(this, visitor);\n    }\n\n    /**\n     * Find all children that reference a specific type.\n     */\n    references(type: Model) {\n        return new ModelTraversal().findReferences(this, type);\n    }\n\n    /**\n     * Search the inheritance chain for a child property.\n     */\n    member(key: Children.Selector, allowedTags = [ElementTag.Field, ElementTag.Attribute]): Model | undefined {\n        return new ModelTraversal().findMember(this, key, allowedTags);\n    }\n\n    /**\n     * Does this model derive from another?\n     */\n    instanceOf(other: Model | AnyElement) {\n        return new ModelTraversal().instanceOf(this, other);\n    }\n\n    /**\n     * Clone the model.  This deep copies all descendant child models but not other properties.\n     */\n    clone<This extends Model>(this: This): This {\n        const Type = this.constructor as new (model: Model) => This;\n        return new Type(this);\n    }\n\n    constructor(definition: BaseElement) {\n        const isClone = definition instanceof Model;\n\n        this.#id = definition.id;\n\n        this.#name = definition.name;\n\n        // Copy all definition properties.  Types will be wrong for some of them but constructors correct this.\n        // Properties for which type is correct are suffixed with \"!\" to indicate no further initialization is necessary\n        for (const [k, v] of Object.entries(definition)) {\n            if (k === \"id\" || k === \"name\" || k === \"parent\" || k === \"isGlobal\") {\n                continue;\n            }\n\n            if (v !== undefined) {\n                (this as any)[k] = v;\n            }\n        }\n\n        if (this.xref) {\n            this.xref = Model.CrossReference.get(this.xref);\n        }\n\n        if (isClone) {\n            for (const child of definition.children as Children) {\n                this.children.push(child.clone());\n            }\n        }\n    }\n\n    /**\n     * Freeze the model hierarchy rooted at this model.\n     *\n     * When using a model as operational schema we implement various optimizations that assume the schema is immutable.\n     * This function enforces that assumption.\n     *\n     * To make changes to a frozen model use {@link clone}.\n     */\n    freeze() {\n        Object.freeze(this);\n        this.children.freeze();\n        this.base?.freeze();\n    }\n\n    toString() {\n        return `${this.tag}${this.type ? `<${this.type}>` : \"\"}#${this.path}`;\n    }\n\n    static {\n        // Obnoxious TS constraints prevent us from defining fields with accessors then overriding the type with simple\n        // types.  So we just declare id and name then install accessors onto the prototype manually.  Should be\n        // functionally identical (at JS level) to defining directly in the class.\n        //\n        // We do this in a static block so we have access to the corresponding private fields.\n        //\n        // We can't do the same with children because the setter and getter types are different.\n        Object.defineProperties(Model.prototype, {\n            id: {\n                get(this: Model): number | undefined {\n                    return this.#id;\n                },\n\n                set(this: Model, value: number | undefined) {\n                    const oldId = this.effectiveId;\n                    this.#id = value;\n                    this.#parent?.children.updateId(this, oldId);\n                },\n\n                enumerable: true,\n            },\n\n            name: {\n                get(this: Model): string {\n                    return this.#name;\n                },\n\n                set(this: Model, value: string) {\n                    const oldName = this.#name;\n                    this.#name = value;\n                    this.#parent?.children.updateName(this, oldName);\n                },\n\n                enumerable: true,\n            },\n        });\n    }\n}\n\nexport namespace Model {\n    export type Type<T extends Model = Model> = abstract new (...args: any) => T;\n\n    export type LookupPredicate<T extends Model> = Type<T> | { type: Type<T>; test: (model: Model) => boolean };\n\n    export type PropertyValidation = {\n        name: string;\n        type: string | (new (...args: any[]) => any) | { [key: string | number]: any } | undefined;\n        required?: boolean;\n        nullable?: boolean;\n        values?: { [name: string]: any };\n    };\n\n    export class CrossReference implements Specification.CrossReference {\n        document: Specification;\n        section: string;\n        private static instances = {} as { [key: string]: CrossReference };\n\n        private constructor({ document, section }: Specification.CrossReference) {\n            this.document = document as Specification;\n            this.section = section;\n        }\n\n        toString() {\n            return `${this.document}\u00A7${this.section}`;\n        }\n\n        static get(xref: Specification.CrossReference) {\n            const key = `${xref.document}:${xref.section}`;\n            const canonical = this.instances[key];\n            if (canonical) {\n                return canonical;\n            }\n            return (this.instances[key] = new CrossReference(xref));\n        }\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,qBAAqB;AAC9B,SAAS,gBAAgB;AACzB,SAA0B,YAAY,gBAA+B;AAErE,SAAS,sBAAsB;AAC/B,SAAS,gBAAgB;AAKlB,MAAe,MAAM;AAAA,EAaxB,MAAe;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA,EAEA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAAQ;AACR,WAAO,CAAC,KAAK;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAe;AACf,QAAI,KAAK,UAAU,KAAK,OAAO,QAAQ,WAAW,QAAQ;AACtD,UAAI,KAAK,OAAO,QAAQ,WAAW,OAAO;AACtC,eAAO,GAAG,KAAK,OAAO,IAAI,IAAI,SAAS,KAAK,IAAI,CAAC;AAAA,MACrD;AAEA,UAAI,KAAK,OAAO,QAAQ,WAAW,SAAS;AACxC,gBAAQ,KAAK,KAAK;AAAA,UACd,KAAK,WAAW;AACZ,mBAAO,GAAG,KAAK,OAAO,IAAI,UAAU,SAAS,KAAK,MAAM,KAAK,CAAC;AAAA,UAElE,KAAK,WAAW;AACZ,mBAAO,GAAG,KAAK,OAAO,IAAI,IAAI,SAAS,KAAK,MAAM,KAAK,CAAC;AAAA,UAE5D,KAAK,WAAW;AACZ,mBAAO,GAAG,KAAK,OAAO,IAAI,WAAW,SAAS,KAAK,MAAM,KAAK,CAAC;AAAA,QACvE;AAAA,MACJ;AAEA,YAAM,SAAS,KAAK;AACpB,UAAI,OAAO,QAAQ,WAAW,SAAS;AACnC,cAAM,iBAAkB,QAA6C;AACrE,YAAI,mBAAmB,SAAS,UAAU,mBAAmB,SAAS,OAAO;AACzE,iBAAO,GAAG,OAAO,IAAI,IAAI,SAAS,KAAK,MAAM,KAAK,CAAC;AAAA,QACvD;AAAA,MACJ;AAEA,aAAO,GAAG,OAAO,IAAI,IAAI,KAAK,IAAI;AAAA,IACtC,OAAO;AACH,aAAO,KAAK;AAAA,IAChB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAW;AACX,WAAO,KAAK,QAAQ,YAAY,KAAK,QAAQ,QAAQ;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAA4B;AAC5B,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,OAAO,QAA2B;AAClC,QAAI,KAAK,WAAW,QAAQ;AACxB;AAAA,IACJ;AAEA,QAAI,KAAK,QAAQ;AACb,YAAM,QAAQ,KAAK,OAAO,SAAS,QAAQ,IAAI;AAC/C,UAAI,UAAU,IAAI;AACd,aAAK,OAAO,SAAS,OAAO,OAAO,CAAC;AAAA,MACxC;AAAA,IACJ;AAEA,QAAI,QAAQ;AACR,aAAO,SAAS,KAAK,IAAI;AAAA,IAC7B;AAAA,EAGJ;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAAc;AACd,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,MAAM;AACN,UAAM,MAAM,KAAK,aAAa,SAAS;AACvC,QAAI,QAAQ,QAAW;AACnB,aAAO;AAAA,IACX;AACA,UAAM,gBAAgB,KAAK;AAC3B,QAAI,kBAAkB,QAAW;AAC7B,aAAO;AAAA,IACX;AACA,WAAO,GAAG,GAAG,SAAI,aAAa;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,gBAAoC;AACpC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAqB;AACrB,QAAI,CAAC,KAAK,WAAW;AAEjB,WAAK,WAAW,CAAC;AAAA,IACrB;AACA,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAS,UAAkC;AAC3C,SAAK,YAAY;AAAA,MACb;AAAA,MAEA,CAAC,UAAiB;AACd,YAAI,MAAM,YAAY,MAAM;AACxB;AAAA,QACJ;AAEA,YAAI,MAAM,SAAS;AACf,gBAAM,WAAW,MAAM,QAAQ,SAAS,QAAQ,KAAK;AACrD,cAAI,aAAa,IAAI;AACjB,kBAAM,QAAQ,SAAS,OAAO,UAAU,CAAC;AAAA,UAC7C;AACA,gBAAM,UAAU;AAAA,QACpB;AAEA,cAAM,UAAU;AAAA,MACpB;AAAA,MAEA,CAAC,UAAiB;AACd,YAAI,MAAM,YAAY,MAAM;AACxB,gBAAM,UAAU;AAChB,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,QAAQ,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOhB,IAAI,gBAAgB;AAChB,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAO;AACP,WAAO,IAAI,eAAe,EAAE,SAAS,IAAI;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAS;AACT,WAAO,IAAI,eAAe,EAAE,WAAW,IAAI;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,aAAa;AACb,WAAO,IAAI,eAAe,EAAE,eAAe,IAAI;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,gBAAgB;AAChB,WAAO,IAAI,eAAe,EAAE,SAAS,IAAI;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,kBAAkB;AAClB,WAAO,CAAC,KAAK,GAAG;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,UAAkC;AAGxC,YACK,KAAK,SAAS,UAAa,YAAY,KAAK,UAAU,KAAK,UAAU,UAAa,WAAW,KAAK;AAAA,EAE3G;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,UAAkC;AACrC,SAAK,SAAS,KAAK,GAAI,QAAkB;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,OAAO,YAAwB;AAClC,QAAI,OAAO,eAAe,UAAU;AAChC,YAAM,IAAI,cAAc,wCAAwC,OAAO,UAAU,EAAE;AAAA,IACvF;AACA,UAAM,IAAI,WAAW,KAAK;AAC1B,UAAM,cAAc,MAAM,MAAM,CAAC;AACjC,QAAI,CAAC,aAAa;AACd,YAAM,IAAI,cAAc,wBAAwB,CAAC,GAAG;AAAA,IACxD;AACA,WAAO,IAAI,YAAY,UAAU;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAqB,aAA4B,KAAuB;AACpE,WAAO,KAAK,SAAS,IAAI,aAAa,GAAG;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,IAAqB,MAAqB,KAAqC;AAC3E,WAAO,KAAK,SAAS,IAAI,MAAM,GAAG;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAuB,aAA4B;AAC/C,WAAO,IAAI,eAAe,EAAE,UAAU,aAAa,IAAI;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAc,SAAiB;AACjC,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,SAAS,CAAC;AAAA,IACnB;AAEA,SAAK,OAAO,KAAK;AAAA,MACb;AAAA,MACA,QAAQ,KAAK;AAAA,MACb;AAAA,MACA,MAAM,KAAK,eAAe,SAAS;AAAA,IACvC,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACL,WAAO,KAAK,QAAQ;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAsB;AAClB,UAAM,SAAS,CAAC;AAGhB,eAAW,OAAO,MAAM;AACpB,cAAQ,KAAK;AAAA,QACT,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD;AAAA,QAEJ;AACI,iBAAO,GAAG,IAAI,KAAK,GAAG;AAAA,MAC9B;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAA2C;AAC7C,WAAO,IAAI,eAAe,EAAE,MAAM,MAAM,OAAO;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,MAAa;AACpB,WAAO,IAAI,eAAe,EAAE,eAAe,MAAM,IAAI;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAwB,cAAc,CAAC,WAAW,OAAO,WAAW,SAAS,GAAsB;AACtG,WAAO,IAAI,eAAe,EAAE,WAAW,MAAM,KAAK,WAAW;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,OAA2B;AAClC,WAAO,IAAI,eAAe,EAAE,WAAW,MAAM,KAAK;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,QAA4C;AACxC,UAAM,OAAO,KAAK;AAClB,WAAO,IAAI,KAAK,IAAI;AAAA,EACxB;AAAA,EAEA,YAAY,YAAyB;AACjC,UAAM,UAAU,sBAAsB;AAEtC,SAAK,MAAM,WAAW;AAEtB,SAAK,QAAQ,WAAW;AAIxB,eAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,UAAU,GAAG;AAC7C,UAAI,MAAM,QAAQ,MAAM,UAAU,MAAM,YAAY,MAAM,YAAY;AAClE;AAAA,MACJ;AAEA,UAAI,MAAM,QAAW;AACjB,QAAC,KAAa,CAAC,IAAI;AAAA,MACvB;AAAA,IACJ;AAEA,QAAI,KAAK,MAAM;AACX,WAAK,OAAO,MAAM,eAAe,IAAI,KAAK,IAAI;AAAA,IAClD;AAEA,QAAI,SAAS;AACT,iBAAW,SAAS,WAAW,UAAsB;AACjD,aAAK,SAAS,KAAK,MAAM,MAAM,CAAC;AAAA,MACpC;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,SAAS;AACL,WAAO,OAAO,IAAI;AAClB,SAAK,SAAS,OAAO;AACrB,SAAK,MAAM,OAAO;AAAA,EACtB;AAAA,EAEA,WAAW;AACP,WAAO,GAAG,KAAK,GAAG,GAAG,KAAK,OAAO,IAAI,KAAK,IAAI,MAAM,EAAE,IAAI,KAAK,IAAI;AAAA,EACvE;AAAA,EAEA,OAAO;AAQH,WAAO,iBAAiB,MAAM,WAAW;AAAA,MACrC,IAAI;AAAA,QACA,MAAqC;AACjC,iBAAO,KAAK;AAAA,QAChB;AAAA,QAEA,IAAiB,OAA2B;AACxC,gBAAM,QAAQ,KAAK;AACnB,eAAK,MAAM;AACX,eAAK,SAAS,SAAS,SAAS,MAAM,KAAK;AAAA,QAC/C;AAAA,QAEA,YAAY;AAAA,MAChB;AAAA,MAEA,MAAM;AAAA,QACF,MAAyB;AACrB,iBAAO,KAAK;AAAA,QAChB;AAAA,QAEA,IAAiB,OAAe;AAC5B,gBAAM,UAAU,KAAK;AACrB,eAAK,QAAQ;AACb,eAAK,SAAS,SAAS,WAAW,MAAM,OAAO;AAAA,QACnD;AAAA,QAEA,YAAY;AAAA,MAChB;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AAAA,CAEO,CAAUA,WAAV;AAAA,EAaI,MAAM,eAAuD;AAAA,IAChE;AAAA,IACA;AAAA,IACA,OAAe,YAAY,CAAC;AAAA,IAEpB,YAAY,EAAE,UAAU,QAAQ,GAAiC;AACrE,WAAK,WAAW;AAChB,WAAK,UAAU;AAAA,IACnB;AAAA,IAEA,WAAW;AACP,aAAO,GAAG,KAAK,QAAQ,OAAI,KAAK,OAAO;AAAA,IAC3C;AAAA,IAEA,OAAO,IAAI,MAAoC;AAC3C,YAAM,MAAM,GAAG,KAAK,QAAQ,IAAI,KAAK,OAAO;AAC5C,YAAM,YAAY,KAAK,UAAU,GAAG;AACpC,UAAI,WAAW;AACX,eAAO;AAAA,MACX;AACA,aAAQ,KAAK,UAAU,GAAG,IAAI,IAAI,eAAe,IAAI;AAAA,IACzD;AAAA,EACJ;AAtBO,EAAAA,OAAM;AAAA,GAbA;",
  "names": ["Model"]
}
