{
  "version": 3,
  "sources": ["../../../../src/model/models/CommandModel.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Mei } from \"../../datatype/ManufacturerExtensibleIdentifier.js\";\nimport { CommandElement } from \"../elements/index.js\";\nimport { ModelTraversal } from \"../logic/ModelTraversal.js\";\nimport { Model } from \"./Model.js\";\nimport { ValueModel } from \"./ValueModel.js\";\n\nexport class CommandModel extends ValueModel implements CommandElement {\n    override tag: CommandElement.Tag = CommandElement.Tag;\n    declare id: Mei;\n    declare direction?: CommandElement.Direction;\n    declare response?: string;\n\n    get fabricScoped() {\n        return !!this.effectiveAccess.fabric;\n    }\n\n    get isRequest() {\n        return this.direction === CommandElement.Direction.Request;\n    }\n\n    get isResponse() {\n        return this.direction === CommandElement.Direction.Response;\n    }\n\n    get responseModel() {\n        return new ModelTraversal().findResponse(this) as ValueModel;\n    }\n\n    get effectiveDirection() {\n        return this.direction ?? (new ModelTraversal().findShadow(this) as CommandModel | undefined)?.direction;\n    }\n\n    /**\n     * Commands may re-use the ID for request and response so identification requires the ID in conjunction with the\n     * direction.\n     */\n    override get discriminator() {\n        // If direction is not present, rely on naming convention for discrimination.  This allows overrides to omit\n        // the direction without voiding matching\n        if (this.direction === undefined) {\n            if (this.name.endsWith(\"Response\")) {\n                return CommandElement.Direction.Response;\n            }\n            return CommandElement.Direction.Request;\n        }\n\n        return this.direction;\n    }\n\n    constructor(definition: CommandElement.Properties) {\n        super(definition);\n    }\n\n    static {\n        Model.types[CommandElement.Tag] = this;\n    }\n\n    static Tag = CommandElement.Tag;\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,aAAa;AACtB,SAAS,kBAAkB;AAEpB,MAAM,qBAAqB,WAAqC;AAAA,EAC1D,MAA0B,eAAe;AAAA,EAKlD,IAAI,eAAe;AACf,WAAO,CAAC,CAAC,KAAK,gBAAgB;AAAA,EAClC;AAAA,EAEA,IAAI,YAAY;AACZ,WAAO,KAAK,cAAc,eAAe,UAAU;AAAA,EACvD;AAAA,EAEA,IAAI,aAAa;AACb,WAAO,KAAK,cAAc,eAAe,UAAU;AAAA,EACvD;AAAA,EAEA,IAAI,gBAAgB;AAChB,WAAO,IAAI,eAAe,EAAE,aAAa,IAAI;AAAA,EACjD;AAAA,EAEA,IAAI,qBAAqB;AACrB,WAAO,KAAK,aAAc,IAAI,eAAe,EAAE,WAAW,IAAI,GAAgC;AAAA,EAClG;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAa,gBAAgB;AAGzB,QAAI,KAAK,cAAc,QAAW;AAC9B,UAAI,KAAK,KAAK,SAAS,UAAU,GAAG;AAChC,eAAO,eAAe,UAAU;AAAA,MACpC;AACA,aAAO,eAAe,UAAU;AAAA,IACpC;AAEA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,YAAY,YAAuC;AAC/C,UAAM,UAAU;AAAA,EACpB;AAAA,EAEA,OAAO;AACH,UAAM,MAAM,eAAe,GAAG,IAAI;AAAA,EACtC;AAAA,EAEA,OAAO,MAAM,eAAe;AAChC;",
  "names": []
}
