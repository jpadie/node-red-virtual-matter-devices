{
  "version": 3,
  "sources": ["../../../../src/model/aspects/Aspect.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { isDeepEqual } from \"../../util/DeepEqual.js\";\nimport { serialize } from \"../../util/String.js\";\nimport { DefinitionError } from \"../definitions/DefinitionError.js\";\n\n/**\n * An \"aspect\" is metadata about a Matter element that affects implementation behavior.  Aspects are mostly \"qualities\"\n * in the Matter specification except for \"constraint\" which is not formally described as a quality.\n */\nexport abstract class Aspect<D> {\n    definition: D;\n    declare errors?: DefinitionError[];\n\n    get valid() {\n        return !this.errors;\n    }\n\n    constructor(definition: D) {\n        this.definition = definition;\n    }\n\n    get empty() {\n        for (const [k, v] of Object.entries(this)) {\n            if (k !== \"definition\" && v !== undefined) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Test for logical equivalence.\n     */\n    equals(other: any) {\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        return isDeepEqual(this.valueOf(), other.valueOf());\n    }\n\n    valueOf() {\n        return this.toString();\n    }\n\n    // Ensure derivatives implement toString()\n    abstract toString(): string;\n\n    error(code: string, message: string) {\n        if (!this.errors) {\n            this.errors = [];\n        }\n        this.errors.push({\n            code,\n            source: `${this.constructor.name} ${serialize(this.definition)}`,\n            message,\n        });\n    }\n\n    extend<This extends Aspect<any>>(this: This, other: Exclude<D, \"string\">) {\n        const descriptors = [\n            ...Object.entries(Object.getOwnPropertyDescriptors(this)),\n            ...Object.entries(Object.getOwnPropertyDescriptors(other)),\n        ];\n\n        const definition = {} as { [name: string]: any };\n        for (const [name, descriptor] of descriptors) {\n            if (name === \"definition\" || name === \"errors\" || descriptor.value === undefined) {\n                continue;\n            }\n            definition[name] = descriptor.value;\n        }\n\n        const constructor = this.constructor as new (definition: any) => Aspect<D>;\n        return new constructor(definition) as This;\n    }\n\n    freeze() {\n        Object.freeze(this);\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,mBAAmB;AAC5B,SAAS,iBAAiB;AAOnB,MAAe,OAAU;AAAA,EAC5B;AAAA,EAGA,IAAI,QAAQ;AACR,WAAO,CAAC,KAAK;AAAA,EACjB;AAAA,EAEA,YAAY,YAAe;AACvB,SAAK,aAAa;AAAA,EACtB;AAAA,EAEA,IAAI,QAAQ;AACR,eAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,IAAI,GAAG;AACvC,UAAI,MAAM,gBAAgB,MAAM,QAAW;AACvC,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,OAAY;AACf,QAAI,EAAE,iBAAiB,KAAK,cAAc;AACtC,aAAO;AAAA,IACX;AACA,WAAO,YAAY,KAAK,QAAQ,GAAG,MAAM,QAAQ,CAAC;AAAA,EACtD;AAAA,EAEA,UAAU;AACN,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EAKA,MAAM,MAAc,SAAiB;AACjC,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,SAAS,CAAC;AAAA,IACnB;AACA,SAAK,OAAO,KAAK;AAAA,MACb;AAAA,MACA,QAAQ,GAAG,KAAK,YAAY,IAAI,IAAI,UAAU,KAAK,UAAU,CAAC;AAAA,MAC9D;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,OAA6C,OAA6B;AACtE,UAAM,cAAc;AAAA,MAChB,GAAG,OAAO,QAAQ,OAAO,0BAA0B,IAAI,CAAC;AAAA,MACxD,GAAG,OAAO,QAAQ,OAAO,0BAA0B,KAAK,CAAC;AAAA,IAC7D;AAEA,UAAM,aAAa,CAAC;AACpB,eAAW,CAAC,MAAM,UAAU,KAAK,aAAa;AAC1C,UAAI,SAAS,gBAAgB,SAAS,YAAY,WAAW,UAAU,QAAW;AAC9E;AAAA,MACJ;AACA,iBAAW,IAAI,IAAI,WAAW;AAAA,IAClC;AAEA,UAAM,cAAc,KAAK;AACzB,WAAO,IAAI,YAAY,UAAU;AAAA,EACrC;AAAA,EAEA,SAAS;AACL,WAAO,OAAO,IAAI;AAAA,EACtB;AACJ;",
  "names": []
}
