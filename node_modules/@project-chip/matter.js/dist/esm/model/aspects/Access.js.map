{
  "version": 3,
  "sources": ["../../../../src/model/aspects/Access.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AccessLevel } from \"../../cluster/Cluster.js\";\nimport { isObject } from \"../../util/Type.js\";\nimport { Aspect } from \"./Aspect.js\";\n\n/**\n * An operational representation of \"access\" as defined by the Matter\n * specification.\n *\n * \"Access\" controls the operations a remote party may perform on a data field\n * or cluster element.\n */\nexport class Access extends Aspect<Access.Definition> implements Access.Ast {\n    declare rw?: Access.Rw;\n    declare readPriv?: Access.Privilege;\n    declare writePriv?: Access.Privilege;\n    declare fabric?: Access.Fabric;\n    declare timed?: boolean;\n\n    get readable() {\n        return !this.rw || this.rw !== Access.Rw.Write;\n    }\n\n    get writable() {\n        return !!this.rw && this.rw !== Access.Rw.Read;\n    }\n\n    get fabricScoped() {\n        return this.fabric === Access.Fabric.Scoped;\n    }\n\n    get fabricSensitive() {\n        return this.fabric === Access.Fabric.Sensitive;\n    }\n\n    override get empty() {\n        return (\n            (!this.rw || this.rw === Access.Rw.Read) && !this.fabric && !this.readPriv && !this.writePriv && !this.timed\n        );\n    }\n\n    /**\n     * Determine whether this access is fully specified.  This means we know\n     * whether reads and/or writes are allowed and if so the required access\n     * levels.\n     */\n    get complete() {\n        return (\n            this.rw !== undefined &&\n            (!this.readable || this.rw !== undefined) &&\n            (!this.writable || this.rw !== undefined)\n        );\n    }\n\n    /**\n     * Initialize from an Access.Definition or the access control DSL defined\n     * by the Matter Specification.\n     */\n    constructor(definition: string | Access.Definition) {\n        super(definition);\n\n        if (Array.isArray(definition)) {\n            this.set(definition.flat());\n        } else if (isObject(definition)) {\n            Object.assign(this, definition);\n        } else if (definition !== undefined && definition !== null) {\n            this.set(Array.from(Access.parse(this, definition)));\n        }\n    }\n\n    /**\n     * Parses standard Matter access syntax into an AccessFlag set.  Extremely\n     * lenient.\n     */\n    static parse(access: Access, definition: string) {\n        definition = definition.toUpperCase();\n        if (definition === \"DERIVED\") {\n            return [];\n        }\n\n        const flags = [] as Access.Flags;\n        for (let i = 0; i < definition.length; i++) {\n            switch (definition[i]) {\n                case \"R\":\n                    flags.push(Access.Rw.Read);\n                    break;\n                case \"U\":\n                    flags.push(Access.Fabric.Unaware);\n                    break;\n                case \"F\":\n                    flags.push(Access.Fabric.Scoped);\n                    break;\n                case \"S\":\n                    flags.push(Access.Fabric.Sensitive);\n                    break;\n                case \"V\":\n                    flags.push(Access.Privilege.View);\n                    break;\n                case \"O\":\n                    flags.push(Access.Privilege.Operate);\n                    break;\n                case \"M\":\n                    flags.push(Access.Privilege.Manage);\n                    break;\n                case \"A\":\n                    flags.push(Access.Privilege.Administer);\n                    break;\n                case \"T\":\n                    flags.push(Access.Timed.Required);\n                    break;\n                case \"W\":\n                    flags.push(Access.Rw.Write);\n                    break;\n\n                case \"[\":\n                    // Optional write syntax.  Note only R[W] is legal but we\n                    // allow for bare [W]\n                    if (i < definition.length - 2 && definition[i + 1] === \"W\" && definition[i + 2] === \"]\") {\n                        flags.push(Access.Rw.ReadWriteOption);\n                        i += 2;\n                    }\n                    break;\n\n                case \"*\":\n                    // Deprecated syntax, again allow for *W when only R*W is\n                    // legal\n                    if (i < definition.length - 1 && definition[i + 1] === \"W\") {\n                        flags.push(Access.Rw.ReadWriteOption);\n                        i++;\n                    }\n                    break;\n\n                case \" \":\n                case \"\\t\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\f\":\n                case \"\\v\":\n                    break;\n\n                default:\n                    access.error(\"UNKNOWN_ACCESS_FLAG\", `Unknown flag \"${definition[i]}\"`);\n                    i++;\n                    break;\n            }\n        }\n        return flags;\n    }\n\n    /**\n     * Displays access using the standard Matter syntax.\n     */\n    override toString() {\n        const parts = [] as string[];\n\n        if (this.rw !== undefined) {\n            parts.push(this.rw);\n        }\n\n        if (this.fabric !== undefined) {\n            parts.push(this.fabric);\n        }\n\n        if (this.readPriv === this.writePriv) {\n            if (this.readPriv !== undefined) {\n                parts.push(this.readPriv);\n            }\n        } else if (this.readPriv) {\n            if (this.writePriv) {\n                parts.push(`${this.readPriv}${this.writePriv}`);\n            } else {\n                parts.push(this.readPriv);\n            }\n        } else if (this.writePriv) {\n            parts.push(this.writePriv);\n        }\n\n        if (this.timed) {\n            parts.push(Access.Timed.Required);\n        }\n\n        return parts.join(\" \");\n    }\n\n    private set(flags: Access.Flags) {\n        flags.forEach(f => {\n            switch (f) {\n                case Access.Rw.Read:\n                    if (!this.rw) {\n                        this.rw = f;\n                    }\n                    break;\n\n                case Access.Rw.Write:\n                    if (!this.rw) {\n                        this.rw = f;\n                    } else if (this.rw === Access.Rw.Read) {\n                        this.rw = Access.Rw.ReadWrite;\n                    }\n                    break;\n\n                case Access.Rw.ReadWrite:\n                    if (this.rw !== Access.Rw.ReadWriteOption) {\n                        this.rw = f;\n                    }\n                    break;\n\n                case Access.Rw.ReadWriteOption:\n                    this.rw = f;\n                    break;\n\n                case Access.Fabric.Unaware:\n                    this.fabric = Access.Fabric.Unaware;\n                    break;\n\n                case Access.Fabric.Scoped:\n                    if (this.fabric !== Access.Fabric.Sensitive) {\n                        this.fabric = f;\n                    }\n                    break;\n\n                case Access.Fabric.Sensitive:\n                    this.fabric = f;\n                    break;\n\n                case Access.Privilege.View:\n                    this.readPriv = f;\n                    break;\n\n                case Access.Privilege.Operate:\n                case Access.Privilege.Manage:\n                case Access.Privilege.Administer:\n                    if (!this.readPriv || Access.PrivilegeLevel[f] < Access.PrivilegeLevel[this.readPriv]) {\n                        this.readPriv = f;\n                    }\n                    if (!this.writePriv || Access.PrivilegeLevel[f] > Access.PrivilegeLevel[this.writePriv]) {\n                        this.writePriv = f;\n                    }\n                    break;\n\n                case Access.Timed.Required:\n                    this.timed = true;\n                    break;\n            }\n        });\n    }\n}\n\nexport namespace Access {\n    export type Ast = {\n        rw?: `${Rw}`;\n        fabric?: `${Fabric}`;\n        readPriv?: `${Privilege}`;\n        writePriv?: `${Privilege}`;\n        timed?: boolean;\n    };\n\n    /**\n     * Types of read/write access.\n     */\n    export enum Rw {\n        /**\n         * Read access.\n         */\n        Read = \"R\",\n\n        /**\n         * Write access.\n         */\n        Write = \"W\",\n\n        /**\n         * Read and mandatory write acess.\n         */\n        ReadWrite = \"RW\",\n\n        /**\n         * Read and optional write access.\n         */\n        ReadWriteOption = \"R[W]\",\n    }\n\n    /**\n     * Affect of fabric on access.\n     */\n    export enum Fabric {\n        /**\n         * Extension - allows for override of fabric specification.\n         */\n        Unaware = \"U\",\n\n        /**\n         * Writable only by scoped fabric.\n         */\n        Scoped = \"F\",\n\n        /**\n         * Readable and writable only by scoped fabric.\n         */\n        Sensitive = \"S\",\n    }\n\n    /**\n     * Privilege required for access.\n     */\n    export enum Privilege {\n        /**\n         * View privilege.\n         */\n        View = \"V\",\n\n        /**\n         * Operate privilege.\n         */\n        Operate = \"O\",\n\n        /**\n         * Manage privilege.\n         */\n        Manage = \"M\",\n\n        /**\n         * Administer privilege.\n         */\n        Administer = \"A\",\n    }\n\n    /**\n     * Reverse map of Privilege.\n     */\n    export enum PrivilegeName {\n        V = \"View\",\n        O = \"Operate\",\n        M = \"Manage\",\n        A = \"Administer\",\n    }\n\n    /**\n     * Relative ordering of privilege.\n     */\n    export const PrivilegeLevel = {\n        V: AccessLevel.View,\n        // 2 is ProxyView, seems not in use/model right now\n        O: AccessLevel.Operate,\n        M: AccessLevel.Manage,\n        A: AccessLevel.Administer,\n    };\n\n    /**\n     * Timed access requirement.\n     */\n    export enum Timed {\n        /**\n         * Timed access required.\n         */\n        Required = \"T\",\n    }\n\n    /**\n     * All atomic access control values.\n     */\n    export type Flag = Rw | Fabric | Privilege | Timed;\n\n    /**\n     * A defined set of access control values.\n     */\n    export type Flags = Flag[];\n\n    export const R = Rw.Read;\n    export const W = Rw.Write;\n    export const RW = Rw.ReadWrite;\n    export const RWo = Rw.ReadWriteOption;\n\n    export const U = Fabric.Unaware;\n    export const F = Fabric.Scoped;\n    export const S = Fabric.Sensitive;\n\n    export const V = Privilege.View;\n    export const O = [Privilege.Operate] as [Privilege.Operate];\n    export const M = [Privilege.Manage] as [Privilege.Manage];\n    export const A = [Privilege.Administer] as [Privilege.Administer];\n    export const VO = [Privilege.View, Privilege.Operate] as [Privilege.View, Privilege.Operate];\n    export const VM = [Privilege.View, Privilege.Manage] as [Privilege.View, Privilege.Manage];\n    export const VA = [Privilege.View, Privilege.Administer] as [Privilege.View, Privilege.Administer];\n    export const OM = [Privilege.Operate, Privilege.Manage] as [Privilege.Operate, Privilege.Manage];\n    export const OA = [Privilege.Operate, Privilege.Administer] as [Privilege.Operate, Privilege.Administer];\n    export const MA = [Privilege.Manage, Privilege.Administer] as [Privilege.Manage, Privilege.Administer];\n\n    export const T = Timed.Required;\n\n    /**\n     * All valid privilege tags.\n     */\n    export type Authorization =\n        | typeof V\n        | typeof VO\n        | typeof VM\n        | typeof VA\n        | typeof O\n        | typeof OM\n        | typeof OA\n        | typeof M\n        | typeof MA\n        | typeof A;\n\n    /**\n     * All valid timed tags.\n     */\n    export type TimedTag = typeof T;\n\n    /**\n     * Defines access as defined in the Matter 1.1 specification.\n     *\n     * In TypeScript and JavaScript, definitions adhering to this type look\n     * like `[ RW, VA ]` or `[ Access.Rw.W, Access.Privilege.Operate ]`.\n     */\n    export type Definition = Ast | (Flag | Authorization)[] | string | undefined;\n}\n\nexport namespace Access {\n    export const Default = new Access({\n        rw: Access.RW,\n        readPriv: Access.Privilege.View,\n        writePriv: Access.Privilege.Operate,\n    });\n}\n"],
  "mappings": "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",
  "names": ["Access", "Rw", "Fabric", "Privilege", "PrivilegeName", "Timed"]
}
