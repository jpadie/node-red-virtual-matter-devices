{
  "version": 3,
  "sources": ["../../../../src/model/aspects/Constraint.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { camelize } from \"../../util/String.js\";\nimport { isObject } from \"../../util/Type.js\";\nimport { FieldValue } from \"../definitions/index.js\";\nimport { Aspect } from \"./Aspect.js\";\n\n/**\n * An operational view of constraints as defined by the Matter specification.\n *\n * A \"constraint\" limits possible data values.\n *\n * Formally a constraint is not considered a quality by the specification. It is handled similarly to qualities, though,\n * so we keep it in the same section.\n */\nexport class Constraint extends Aspect<Constraint.Definition> implements Constraint.Ast {\n    declare desc?: boolean;\n    declare value?: FieldValue;\n    declare min?: FieldValue;\n    declare max?: FieldValue;\n    declare in?: FieldValue;\n    declare entry?: Constraint;\n    declare parts?: Constraint[];\n\n    /**\n     * Initialize from a Constraint.Definition or the constraint DSL defined by the Matter Specification.\n     */\n    constructor(definition: Constraint.Definition) {\n        super(definition);\n\n        let ast;\n        switch (typeof definition) {\n            case \"string\":\n                // The spec designates a \"0b000xxxxx\" syntax for specifying constraints as bitmasks.  Through 1.3 we\n                // only see this on bitmaps which constraint fine using the bit definitions.  So just ignore it. We also\n                // handle one invalid case where there is no \"0b\" or \"0x\" prefix on a mask\n                if (definition.match(/(?:0b[0x ]*x[0x ]*)|(?:0x[0x_]*x[0x_]*)|(?:00[0x]*x)/i)) {\n                    break;\n                }\n                ast = Constraint.parse(this, definition);\n                break;\n\n            case \"number\":\n                ast = { value: definition };\n                break;\n\n            default:\n                ast = definition;\n                if (ast?.definition) {\n                    this.definition = ast.definition;\n                }\n                break;\n        }\n\n        if (!ast) {\n            return;\n        }\n\n        if (ast.desc !== undefined) {\n            this.desc = ast.desc;\n        }\n        if (ast.value !== undefined) {\n            this.value = ast.value;\n        }\n        if (ast.min !== undefined) {\n            this.min = ast.min;\n        }\n        if (ast.max !== undefined) {\n            this.max = ast.max;\n        }\n        if (ast.in !== undefined) {\n            this.in = ast.in;\n        }\n        if (ast.entry !== undefined) {\n            this.entry = new Constraint(ast.entry);\n        }\n        if (ast.parts !== undefined) {\n            this.parts = ast.parts.map(p => new Constraint(p));\n        }\n    }\n\n    /**\n     * Test a value against a constraint.  Does not recurse into arrays.\n     */\n    test(value: FieldValue, properties?: Record<string, any>): boolean {\n        // Helper that looks up \"reference\" field values in properties.  This is for constraints such as \"min FieldName\"\n        function valueOf(value: unknown, raw = false) {\n            if (!raw && (typeof value === \"string\" || Array.isArray(value))) {\n                return value.length;\n            }\n            if (isObject(value)) {\n                const { type, name } = value;\n                if (type === FieldValue.reference && typeof name === \"string\") {\n                    value = valueOf(properties?.[camelize(name)], raw);\n                }\n            }\n\n            return value;\n        }\n\n        if (value === undefined) {\n            return false;\n        }\n\n        if (this.in) {\n            let set = valueOf(this.in, true);\n            if (!Array.isArray(set)) {\n                set = [set];\n            }\n            return (set as unknown[]).indexOf(value) !== -1;\n        }\n\n        const v = valueOf(this.value);\n        if (v === value) {\n            return true;\n        }\n\n        if (v !== undefined || value === null) {\n            return false;\n        }\n\n        if (this.min !== undefined && this.min !== null) {\n            const min = valueOf(this.min);\n            if (min !== undefined && min !== null && (min as typeof value) > value) {\n                return false;\n            }\n        }\n\n        if (this.max !== undefined && this.max !== null) {\n            const max = valueOf(this.max);\n            if (max !== undefined && max !== null && (max as typeof value) < value) {\n                return false;\n            }\n        }\n\n        if (this.parts?.every(part => part.test(value, properties) === false)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    override toString() {\n        if (!this.valid && this.definition) {\n            return this.definition.toString();\n        }\n        return Constraint.serialize(this);\n    }\n\n    override freeze() {\n        if (this.parts) {\n            Object.freeze(this.parts);\n        }\n        super.freeze();\n    }\n}\n\nexport namespace Constraint {\n    export type NumberOrIdentifier = number | string;\n\n    /**\n     * Parsed list structure.\n     */\n    export type Ast = {\n        /**\n         * Indicates constraint is defined in prose and cannot be enforced automatically.\n         */\n        desc?: boolean;\n\n        /**\n         * Constant value.\n         */\n        value?: FieldValue;\n\n        /**\n         * Lower bound on value or sequence length.\n         */\n        min?: FieldValue;\n\n        /**\n         * Upper bound on value or sequence length.\n         */\n        max?: FieldValue;\n\n        /**\n         * Require set membership for the value.\n         */\n        in?: FieldValue;\n\n        /**\n         * Constraint on list child element.\n         */\n        entry?: Ast;\n\n        /**\n         * List of sub-constraints in a sequence.\n         */\n        parts?: Ast[];\n    };\n\n    /**\n     * These are all ways to describe a constraint.\n     */\n    export type Definition = (Ast & { definition?: Definition }) | string | number | undefined;\n\n    function parseValue(numOrName: string): FieldValue {\n        let value;\n        if (numOrName.match(/^-?0[xb]/)) {\n            value = Number.parseInt(numOrName.replace(/[_ ]/g, \"\"));\n        } else {\n            value = Number.parseFloat(numOrName);\n        }\n        if (typeof numOrName === \"string\") {\n            const lower = numOrName.toLowerCase();\n            switch (lower) {\n                case \"true\":\n                    return true;\n\n                case \"false\":\n                    return false;\n            }\n        }\n        if (Number.isNaN(value)) {\n            return FieldValue.Reference(camelize(numOrName));\n        }\n        if (numOrName.endsWith(\"%\")) {\n            return FieldValue.Percent(value);\n        }\n        if (numOrName.endsWith(\"\u00B0C\")) {\n            return FieldValue.Celsius(value);\n        }\n        return value;\n    }\n\n    function parseAtom(constraint: Constraint, words: string[]): Ast | undefined {\n        switch (words.length) {\n            case 0:\n                return undefined;\n\n            case 1:\n                switch (words[0].toLowerCase()) {\n                    case \"desc\":\n                        return { desc: true };\n\n                    case \"all\":\n                    case \"any\":\n                        return {};\n                }\n                const value = parseValue(words[0]);\n                if (value === undefined || value === null) {\n                    return;\n                }\n                return { value };\n\n            case 2:\n                switch (words[0].toLowerCase()) {\n                    case \"min\":\n                        const min = parseValue(words[1]);\n                        if (min === undefined || min === null) {\n                            return;\n                        }\n                        return { min: min };\n\n                    case \"max\":\n                        const max = parseValue(words[1]);\n                        if (max === undefined || max === null) {\n                            return;\n                        }\n                        return { max: max };\n\n                    case \"in\":\n                        const ref = parseValue(words[1]);\n                        return { in: ref };\n\n                    default:\n                        constraint.error(\n                            \"INVALID_CONSTRAINT\",\n                            `Two word constraint \"${words.join(\" \")}\" does not start with \"min\" or \"max\"`,\n                        );\n                }\n                return;\n\n            case 3:\n                if (words[1].toLowerCase() === \"to\") {\n                    function parseBound(name: string, pos: number) {\n                        if (words[pos].toLowerCase() === name) {\n                            return undefined;\n                        }\n                        return parseValue(words[pos]);\n                    }\n\n                    const ast: Ast = {};\n\n                    const min = parseBound(\"min\", 0);\n                    if (min !== undefined && min !== null) {\n                        ast.min = min;\n                    }\n\n                    const max = parseBound(\"max\", 2);\n                    if (max !== undefined && max !== null) {\n                        ast.max = max;\n                    }\n\n                    if ((ast.min !== undefined && ast.min !== null) || (ast.max !== undefined && ast.max !== null)) {\n                        return ast;\n                    }\n                }\n                return;\n        }\n\n        constraint.error(\"INVALID_CONSTRAINT\", `Unrecognized value constraint \"${words.join(\" \")}\"`);\n    }\n\n    /**\n     * Parse constraint DSL.  Extremely lenient.\n     */\n    export function parse(constraint: Constraint, definition: string): Ast {\n        let pos = 2;\n        let current: string | undefined = definition[0];\n        let peeked: string | undefined = definition[1];\n\n        function next() {\n            current = peeked;\n            if (pos === definition.length) {\n                peeked = undefined;\n            } else {\n                peeked = definition[pos];\n                pos++;\n            }\n        }\n\n        function scan(depth: number): Ast {\n            const parts = Array<Ast>();\n            let words = Array<string>();\n            let word = \"\";\n\n            function parseWords() {\n                if (word) {\n                    words.push(word);\n                    word = \"\";\n                }\n\n                const atom = parseAtom(constraint, words);\n                words = Array<string>();\n                return atom;\n            }\n\n            function emit() {\n                const atom = parseWords();\n                if (atom !== undefined) {\n                    parts.push(atom);\n                }\n            }\n\n            while (current !== undefined) {\n                switch (current) {\n                    case \" \":\n                    case \"\\t\":\n                    case \"\\r\":\n                    case \"\\n\":\n                    case \"\\v\":\n                    case \"\\f\":\n                        if (word) {\n                            words.push(word);\n                            word = \"\";\n                        }\n                        break;\n\n                    case \"[\":\n                        next();\n                        let ast = parseWords();\n                        const entry = scan(depth + 1);\n                        if (entry) {\n                            if (!ast) {\n                                ast = {};\n                            }\n                            ast.entry = entry;\n                        }\n                        if (ast) {\n                            parts.push(ast);\n                        }\n                        break;\n\n                    case \"]\":\n                        if (!depth) {\n                            constraint.error(\"INVALID_CONSTRAINT\", 'Unexpected \"]\"');\n                            break;\n                        }\n                        emit();\n                        if (parts.length > 1) {\n                            return { parts: parts };\n                        }\n                        return parts[0];\n\n                    case \",\":\n                        emit();\n                        break;\n\n                    default:\n                        word += current;\n                        break;\n                }\n\n                next();\n            }\n\n            if (depth) {\n                constraint.error(\"INVALID_CONSTRAINT\", \"Unterminated sub-constraint\");\n            }\n\n            emit();\n\n            if (parts.length < 2) {\n                return parts[0];\n            }\n\n            return { parts: parts };\n        }\n\n        return scan(0);\n    }\n\n    function serializeAtom(ast: Ast) {\n        if (ast.desc) {\n            return \"desc\";\n        }\n\n        if (ast.value !== undefined && ast.value !== null) {\n            return `${FieldValue.serialize(ast.value)}`;\n        }\n\n        if (ast.min !== undefined && ast.min !== null) {\n            if (ast.max === undefined || ast.max === null) {\n                return `min ${FieldValue.serialize(ast.min)}`;\n            }\n            return `${FieldValue.serialize(ast.min)} to ${FieldValue.serialize(ast.max)}`;\n        }\n\n        if (ast.max !== undefined && ast.max !== null) {\n            return `max ${FieldValue.serialize(ast.max)}`;\n        }\n\n        if (ast.in !== undefined) {\n            return `in ${FieldValue.serialize(ast.in)}`;\n        }\n\n        return \"all\";\n    }\n\n    export function serialize(ast: Ast): string {\n        if (ast.parts) {\n            return ast.parts.map(serialize).join(\", \");\n        }\n        if (ast.entry) {\n            return `${serializeAtom(ast)}[${serialize(ast.entry)}]`;\n        }\n        return serializeAtom(ast);\n    }\n}\n"],
  "mappings": "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",
  "names": ["value", "Constraint", "parseBound"]
}
