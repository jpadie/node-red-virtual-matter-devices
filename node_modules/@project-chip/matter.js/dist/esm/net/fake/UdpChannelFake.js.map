{
  "version": 3,
  "sources": ["../../../../src/net/fake/UdpChannelFake.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Listener } from \"../../common/TransportInterface.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport { NetworkError } from \"../Network.js\";\nimport { MAX_UDP_MESSAGE_SIZE, UdpChannel, UdpChannelOptions } from \"../UdpChannel.js\";\nimport { NetworkFake } from \"./NetworkFake.js\";\nimport { FAKE_INTERFACE_NAME, SimulatedNetwork } from \"./SimulatedNetwork.js\";\n\nexport class UdpChannelFake implements UdpChannel {\n    static async create(\n        network: NetworkFake,\n        { listeningAddress, listeningPort, netInterface, type }: UdpChannelOptions,\n    ) {\n        const { ipV4, ipV6 } = network.getIpMac(netInterface ?? FAKE_INTERFACE_NAME);\n        const localAddress = type === \"udp4\" ? ipV4[0] : (ipV6[0] ?? ipV4[0]);\n        if (localAddress === undefined) {\n            throw new NetworkError(\"No matching IP on the specified interface\");\n        }\n        return new UdpChannelFake(localAddress, listeningAddress, listeningPort);\n    }\n\n    private readonly netListeners = new Array<Listener>();\n    private readonly simulatedNetwork = SimulatedNetwork.get();\n    private readonly listeningPort: number;\n    readonly maxPayloadSize = MAX_UDP_MESSAGE_SIZE;\n\n    constructor(\n        private readonly localAddress: string,\n        private readonly listeningAddress: string | undefined,\n        listeningPort?: number,\n    ) {\n        this.listeningPort = listeningPort ?? 1024 + Math.floor(Math.random() * 64511); // Random port 1024-65535\n    }\n\n    onData(listener: (netInterface: string, peerAddress: string, peerPort: number, data: ByteArray) => void) {\n        const netListener = this.simulatedNetwork.onUdpData(this.listeningAddress, this.listeningPort, listener);\n        this.netListeners.push(netListener);\n        return netListener;\n    }\n\n    async send(host: string, port: number, data: ByteArray) {\n        this.simulatedNetwork.sendUdp(this.localAddress, this.listeningPort, host, port, data);\n    }\n\n    async close() {\n        for (const netListener of this.netListeners) {\n            await netListener.close();\n        }\n        this.netListeners.length = 0;\n    }\n\n    async [Symbol.asyncDispose]() {\n        return this.close();\n    }\n\n    get port() {\n        return this.listeningPort;\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,SAAS,oBAAoB;AAC7B,SAAS,4BAA2D;AAEpE,SAAS,qBAAqB,wBAAwB;AAE/C,MAAM,eAAqC;AAAA,EAkB9C,YACqB,cACA,kBACjB,eACF;AAHmB;AACA;AAGjB,SAAK,gBAAgB,iBAAiB,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK;AAAA,EACjF;AAAA,EAvBA,aAAa,OACT,SACA,EAAE,kBAAkB,eAAe,cAAc,KAAK,GACxD;AACE,UAAM,EAAE,MAAM,KAAK,IAAI,QAAQ,SAAS,gBAAgB,mBAAmB;AAC3E,UAAM,eAAe,SAAS,SAAS,KAAK,CAAC,IAAK,KAAK,CAAC,KAAK,KAAK,CAAC;AACnE,QAAI,iBAAiB,QAAW;AAC5B,YAAM,IAAI,aAAa,2CAA2C;AAAA,IACtE;AACA,WAAO,IAAI,eAAe,cAAc,kBAAkB,aAAa;AAAA,EAC3E;AAAA,EAEiB,eAAe,IAAI,MAAgB;AAAA,EACnC,mBAAmB,iBAAiB,IAAI;AAAA,EACxC;AAAA,EACR,iBAAiB;AAAA,EAU1B,OAAO,UAAkG;AACrG,UAAM,cAAc,KAAK,iBAAiB,UAAU,KAAK,kBAAkB,KAAK,eAAe,QAAQ;AACvG,SAAK,aAAa,KAAK,WAAW;AAClC,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,KAAK,MAAc,MAAc,MAAiB;AACpD,SAAK,iBAAiB,QAAQ,KAAK,cAAc,KAAK,eAAe,MAAM,MAAM,IAAI;AAAA,EACzF;AAAA,EAEA,MAAM,QAAQ;AACV,eAAW,eAAe,KAAK,cAAc;AACzC,YAAM,YAAY,MAAM;AAAA,IAC5B;AACA,SAAK,aAAa,SAAS;AAAA,EAC/B;AAAA,EAEA,OAAO,OAAO,YAAY,IAAI;AAC1B,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EAEA,IAAI,OAAO;AACP,WAAO,KAAK;AAAA,EAChB;AACJ;",
  "names": []
}
