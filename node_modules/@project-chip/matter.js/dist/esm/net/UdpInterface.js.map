{
  "version": 3,
  "sources": ["../../../src/net/UdpInterface.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Channel, ChannelType } from \"../common/Channel.js\";\nimport { ServerAddress } from \"../common/ServerAddress.js\";\nimport { Listener } from \"../common/TransportInterface.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { NetInterface } from \"./NetInterface.js\";\nimport { Network, NetworkError } from \"./Network.js\";\nimport { UdpChannel } from \"./UdpChannel.js\";\n\nexport class UdpInterface implements NetInterface {\n    static async create(network: Network, type: \"udp4\" | \"udp6\", port?: number, host?: string, netInterface?: string) {\n        return new UdpInterface(\n            await network.createUdpChannel({ listeningPort: port, type, netInterface, listeningAddress: host }),\n        );\n    }\n\n    constructor(private readonly server: UdpChannel) {}\n\n    async openChannel(address: ServerAddress) {\n        if (address.type !== \"udp\") {\n            throw new NetworkError(`Unsupported address type ${address.type}`);\n        }\n        const { ip, port } = address;\n        return Promise.resolve(new UdpConnection(this.server, ip, port));\n    }\n\n    onData(listener: (channel: Channel<ByteArray>, messageBytes: ByteArray) => void): Listener {\n        return this.server.onData((_netInterface, peerHost, peerPort, data) =>\n            listener(new UdpConnection(this.server, peerHost, peerPort), data),\n        );\n    }\n\n    get port() {\n        return this.server.port;\n    }\n\n    async close() {\n        this.server.close();\n    }\n}\n\nclass UdpConnection implements Channel<ByteArray> {\n    readonly isReliable = false;\n    readonly type = ChannelType.UDP;\n\n    constructor(\n        private readonly server: UdpChannel,\n        private readonly peerAddress: string,\n        private readonly peerPort: number,\n    ) {}\n\n    get maxPayloadSize() {\n        return this.server.maxPayloadSize;\n    }\n\n    send(data: ByteArray) {\n        return this.server.send(this.peerAddress, this.peerPort, data);\n    }\n\n    get name() {\n        return `${this.type}://${this.peerAddress}:${this.peerPort}`;\n    }\n\n    async close() {\n        // UDP is connectionless, so nothing to do here\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAkB,mBAAmB;AAKrC,SAAkB,oBAAoB;AAG/B,MAAM,aAAqC;AAAA,EAO9C,YAA6B,QAAoB;AAApB;AAAA,EAAqB;AAAA,EANlD,aAAa,OAAO,SAAkB,MAAuB,MAAe,MAAe,cAAuB;AAC9G,WAAO,IAAI;AAAA,MACP,MAAM,QAAQ,iBAAiB,EAAE,eAAe,MAAM,MAAM,cAAc,kBAAkB,KAAK,CAAC;AAAA,IACtG;AAAA,EACJ;AAAA,EAIA,MAAM,YAAY,SAAwB;AACtC,QAAI,QAAQ,SAAS,OAAO;AACxB,YAAM,IAAI,aAAa,4BAA4B,QAAQ,IAAI,EAAE;AAAA,IACrE;AACA,UAAM,EAAE,IAAI,KAAK,IAAI;AACrB,WAAO,QAAQ,QAAQ,IAAI,cAAc,KAAK,QAAQ,IAAI,IAAI,CAAC;AAAA,EACnE;AAAA,EAEA,OAAO,UAAoF;AACvF,WAAO,KAAK,OAAO;AAAA,MAAO,CAAC,eAAe,UAAU,UAAU,SAC1D,SAAS,IAAI,cAAc,KAAK,QAAQ,UAAU,QAAQ,GAAG,IAAI;AAAA,IACrE;AAAA,EACJ;AAAA,EAEA,IAAI,OAAO;AACP,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EAEA,MAAM,QAAQ;AACV,SAAK,OAAO,MAAM;AAAA,EACtB;AACJ;AAEA,MAAM,cAA4C;AAAA,EAI9C,YACqB,QACA,aACA,UACnB;AAHmB;AACA;AACA;AAAA,EAClB;AAAA,EAPM,aAAa;AAAA,EACb,OAAO,YAAY;AAAA,EAQ5B,IAAI,iBAAiB;AACjB,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EAEA,KAAK,MAAiB;AAClB,WAAO,KAAK,OAAO,KAAK,KAAK,aAAa,KAAK,UAAU,IAAI;AAAA,EACjE;AAAA,EAEA,IAAI,OAAO;AACP,WAAO,GAAG,KAAK,IAAI,MAAM,KAAK,WAAW,IAAI,KAAK,QAAQ;AAAA,EAC9D;AAAA,EAEA,MAAM,QAAQ;AAAA,EAEd;AACJ;",
  "names": []
}
