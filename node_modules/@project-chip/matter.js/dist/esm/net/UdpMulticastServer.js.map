{
  "version": 3,
  "sources": ["../../../src/net/UdpMulticastServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Logger } from \"../log/Logger.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { Cache } from \"../util/Cache.js\";\nimport { isIPv4 } from \"../util/Ip.js\";\nimport { Network } from \"./Network.js\";\nimport { UdpChannel } from \"./UdpChannel.js\";\n\nconst logger = Logger.get(\"UdpMulticastServer\");\n\nexport interface UdpMulticastServerOptions {\n    network: Network;\n    listeningPort: number;\n    broadcastAddressIpv6: string;\n    broadcastAddressIpv4?: string;\n    netInterface?: string;\n}\n\nexport class UdpMulticastServer {\n    static async create({\n        netInterface,\n        broadcastAddressIpv4,\n        broadcastAddressIpv6,\n        listeningPort,\n        network,\n    }: UdpMulticastServerOptions) {\n        return new UdpMulticastServer(\n            network,\n            broadcastAddressIpv4,\n            broadcastAddressIpv6,\n            listeningPort,\n            broadcastAddressIpv4 === undefined\n                ? undefined\n                : await network.createUdpChannel({\n                      type: \"udp4\",\n                      netInterface,\n                      listeningPort,\n                      membershipAddresses: [broadcastAddressIpv4],\n                  }),\n            await network.createUdpChannel({\n                type: \"udp6\",\n                netInterface,\n                listeningPort,\n                membershipAddresses: [broadcastAddressIpv6],\n            }),\n            netInterface,\n        );\n    }\n\n    private readonly broadcastChannels = new Cache<Promise<UdpChannel>>(\n        \"UDP broadcast channel\",\n        (netInterface, iPv4) => this.createBroadcastChannel(netInterface, iPv4),\n        5 * 60 * 1000 /* 5mn */,\n        async (_netInterface, channel) => (await channel).close(),\n    );\n\n    private constructor(\n        private readonly network: Network,\n        private readonly broadcastAddressIpv4: string | undefined,\n        private readonly broadcastAddressIpv6: string,\n        private readonly broadcastPort: number,\n        private readonly serverIpv4: UdpChannel | undefined,\n        private readonly serverIpv6: UdpChannel,\n        private readonly netInterface: string | undefined,\n    ) {}\n\n    onMessage(listener: (message: ByteArray, peerAddress: string, netInterface: string) => void) {\n        this.serverIpv4?.onData((netInterface, peerAddress, _port, message) =>\n            listener(message, peerAddress, netInterface),\n        );\n        this.serverIpv6.onData((netInterface, peerAddress, _port, message) =>\n            listener(message, peerAddress, netInterface),\n        );\n    }\n\n    async send(message: ByteArray, netInterface?: string, uniCastTarget?: string) {\n        netInterface = netInterface ?? this.netInterface;\n\n        // When we know the network interface and the unicast target, we can send unicast\n        if (uniCastTarget !== undefined && netInterface !== undefined) {\n            try {\n                await (\n                    await this.broadcastChannels.get(netInterface, isIPv4(uniCastTarget))\n                ).send(uniCastTarget, this.broadcastPort, message);\n            } catch (error) {\n                logger.info(`${netInterface} ${uniCastTarget}: ${(error as Error).message}`);\n            }\n        } else {\n            const netInterfaces =\n                netInterface !== undefined ? [{ name: netInterface }] : await this.network.getNetInterfaces();\n            await Promise.all(\n                netInterfaces.map(async ({ name: netInterface }) => {\n                    const { ipV4, ipV6 } = (await this.network.getIpMac(netInterface)) ?? {\n                        mac: \"\",\n                        ipV4: [],\n                        ipV6: [],\n                    };\n                    const ips = [...ipV4, ...ipV6];\n                    await Promise.all(\n                        ips.map(async ip => {\n                            const iPv4 = ipV4.includes(ip);\n                            const broadcastTarget = iPv4 ? this.broadcastAddressIpv4 : this.broadcastAddressIpv6;\n                            if (broadcastTarget == undefined) {\n                                // IPv4 but disabled, so just resolve\n                                return;\n                            }\n                            try {\n                                await (\n                                    await this.broadcastChannels.get(netInterface, iPv4)\n                                ).send(broadcastTarget, this.broadcastPort, message);\n                            } catch (error) {\n                                logger.info(`${netInterface}: ${(error as Error).message}`);\n                            }\n                        }),\n                    );\n                }),\n            );\n        }\n    }\n\n    private async createBroadcastChannel(netInterface: string, iPv4: string): Promise<UdpChannel> {\n        return await this.network.createUdpChannel({\n            type: iPv4 ? \"udp4\" : \"udp6\",\n            listeningPort: this.broadcastPort,\n            netInterface,\n        });\n    }\n\n    async close() {\n        this.serverIpv4?.close();\n        this.serverIpv6.close();\n        await this.broadcastChannels.close();\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,cAAc;AAEvB,SAAS,aAAa;AACtB,SAAS,cAAc;AAIvB,MAAM,SAAS,OAAO,IAAI,oBAAoB;AAUvC,MAAM,mBAAmB;AAAA,EAsCpB,YACa,SACA,sBACA,sBACA,eACA,YACA,YACA,cACnB;AAPmB;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,EAClB;AAAA,EA7CH,aAAa,OAAO;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GAA8B;AAC1B,WAAO,IAAI;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,yBAAyB,SACnB,SACA,MAAM,QAAQ,iBAAiB;AAAA,QAC3B,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,qBAAqB,CAAC,oBAAoB;AAAA,MAC9C,CAAC;AAAA,MACP,MAAM,QAAQ,iBAAiB;AAAA,QAC3B,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,qBAAqB,CAAC,oBAAoB;AAAA,MAC9C,CAAC;AAAA,MACD;AAAA,IACJ;AAAA,EACJ;AAAA,EAEiB,oBAAoB,IAAI;AAAA,IACrC;AAAA,IACA,CAAC,cAAc,SAAS,KAAK,uBAAuB,cAAc,IAAI;AAAA,IACtE,IAAI,KAAK;AAAA,IACT,OAAO,eAAe,aAAa,MAAM,SAAS,MAAM;AAAA,EAC5D;AAAA,EAYA,UAAU,UAAmF;AACzF,SAAK,YAAY;AAAA,MAAO,CAAC,cAAc,aAAa,OAAO,YACvD,SAAS,SAAS,aAAa,YAAY;AAAA,IAC/C;AACA,SAAK,WAAW;AAAA,MAAO,CAAC,cAAc,aAAa,OAAO,YACtD,SAAS,SAAS,aAAa,YAAY;AAAA,IAC/C;AAAA,EACJ;AAAA,EAEA,MAAM,KAAK,SAAoB,cAAuB,eAAwB;AAC1E,mBAAe,gBAAgB,KAAK;AAGpC,QAAI,kBAAkB,UAAa,iBAAiB,QAAW;AAC3D,UAAI;AACA,eACI,MAAM,KAAK,kBAAkB,IAAI,cAAc,OAAO,aAAa,CAAC,GACtE,KAAK,eAAe,KAAK,eAAe,OAAO;AAAA,MACrD,SAAS,OAAO;AACZ,eAAO,KAAK,GAAG,YAAY,IAAI,aAAa,KAAM,MAAgB,OAAO,EAAE;AAAA,MAC/E;AAAA,IACJ,OAAO;AACH,YAAM,gBACF,iBAAiB,SAAY,CAAC,EAAE,MAAM,aAAa,CAAC,IAAI,MAAM,KAAK,QAAQ,iBAAiB;AAChG,YAAM,QAAQ;AAAA,QACV,cAAc,IAAI,OAAO,EAAE,MAAMA,cAAa,MAAM;AAChD,gBAAM,EAAE,MAAM,KAAK,IAAK,MAAM,KAAK,QAAQ,SAASA,aAAY,KAAM;AAAA,YAClE,KAAK;AAAA,YACL,MAAM,CAAC;AAAA,YACP,MAAM,CAAC;AAAA,UACX;AACA,gBAAM,MAAM,CAAC,GAAG,MAAM,GAAG,IAAI;AAC7B,gBAAM,QAAQ;AAAA,YACV,IAAI,IAAI,OAAM,OAAM;AAChB,oBAAM,OAAO,KAAK,SAAS,EAAE;AAC7B,oBAAM,kBAAkB,OAAO,KAAK,uBAAuB,KAAK;AAChE,kBAAI,mBAAmB,QAAW;AAE9B;AAAA,cACJ;AACA,kBAAI;AACA,uBACI,MAAM,KAAK,kBAAkB,IAAIA,eAAc,IAAI,GACrD,KAAK,iBAAiB,KAAK,eAAe,OAAO;AAAA,cACvD,SAAS,OAAO;AACZ,uBAAO,KAAK,GAAGA,aAAY,KAAM,MAAgB,OAAO,EAAE;AAAA,cAC9D;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAc,uBAAuB,cAAsB,MAAmC;AAC1F,WAAO,MAAM,KAAK,QAAQ,iBAAiB;AAAA,MACvC,MAAM,OAAO,SAAS;AAAA,MACtB,eAAe,KAAK;AAAA,MACpB;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,QAAQ;AACV,SAAK,YAAY,MAAM;AACvB,SAAK,WAAW,MAAM;AACtB,UAAM,KAAK,kBAAkB,MAAM;AAAA,EACvC;AACJ;",
  "names": ["netInterface"]
}
