{
  "version": 3,
  "sources": ["../../../src/log/Logger.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError, NotImplementedError } from \"../common/MatterError.js\";\nimport { Time } from \"../time/Time.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { Diagnostic } from \"./Diagnostic.js\";\nimport { Format } from \"./Format.js\";\nimport { Level } from \"./Level.js\";\n\n/**\n * Log messages to the console.  This is the default logging mechanism.\n */\nexport function consoleLogger(level: Level, formattedLog: string) {\n    const console = (<any>consoleLogger).console;\n    switch (level) {\n        case Level.DEBUG:\n            console.debug(formattedLog);\n            break;\n        case Level.INFO:\n            console.info(formattedLog);\n            break;\n        case Level.NOTICE:\n            console.info(formattedLog);\n            break;\n        case Level.WARN:\n            console.warn(formattedLog);\n            break;\n        case Level.ERROR:\n            console.error(formattedLog);\n            break;\n        case Level.FATAL:\n            console.error(formattedLog);\n            break;\n    }\n}\n\nconst globalConsole = console;\nexport namespace consoleLogger {\n    /**\n     * The target for consoleLogger.\n     */\n    // eslint-disable-next-line prefer-const\n    export let console = globalConsole;\n}\n\n/**\n * Create a log formatter for a given format.\n */\nfunction logFormatterFor(formatName: string): LoggerDefinition[\"logFormatter\"] {\n    const format = Format(formatName);\n\n    return (now, level, facility, prefix, ...values) =>\n        format(Diagnostic.message({ now, level, facility, prefix, values }));\n}\n\n/**\n * Definition of one registered Logger.\n */\ntype LoggerDefinition = {\n    logIdentifier: string;\n    logFormatter: (now: Date, level: Level, facility: string, prefix: string, ...values: any[]) => string;\n    log: (level: Level, formattedLog: string) => void;\n    defaultLogLevel: Level;\n    logLevels: { [facility: string]: Level };\n};\n\n/**\n * Logger that can be used to emit traces.\n *\n * The class supports adding multiple loggers for different targets. A default logger (identifier \"default\") is added on\n * startup which logs to \"console\".\n *\n * Usage:\n *\n *   const facility = Logger.get(\"loggerName\");\n *   facility.debug(\"My debug message\", \"my extra value to log\");\n *\n * The configuration of the default logger can be adjusted by using the static properties of the Logger class:\n *\n *   - Logger.defaultLogLevel sets the default log level for all the facility\n *   - Logger.logLevels = { loggerName: Level.DEBUG } can set the level for the specific loggers\n *   - Logger.format = Format.ANSI enables colorization via ANSI escape sequences in default formatter\n *\n * For additional loggers, use Logger.addLogger() to add a new logger with a specific identifier. Afterwards the\n * configuration of these can be adjusted using static methods with the identifier as first parameter:\n *\n *   - Logger.setFormatForLogger(\"loggerName\", Format.ANSI)\n *   - Logger.setLogLevelsForLogger(\"loggerName\", { loggerName: Level.DEBUG })\n *   - Logger.setDefaultLoglevelForLogger(\"loggerName\", Level.DEBUG)\n */\nexport class Logger {\n    static logger = new Array<LoggerDefinition>({\n        logIdentifier: \"default\",\n        logFormatter: Format.plain,\n        log: consoleLogger,\n        defaultLogLevel: Level.DEBUG,\n        logLevels: {},\n    });\n    static nestingLevel = 0;\n\n    /** Add additional logger to the list of loggers including the default configuration. */\n    public static addLogger(\n        identifier: string,\n        logger: (level: Level, formattedLog: string) => void,\n        options?: {\n            defaultLogLevel?: Level;\n            logLevels?: { [facility: string]: Level };\n            logFormat?: string;\n        },\n    ) {\n        if (Logger.logger.some(logger => logger.logIdentifier === identifier)) {\n            throw new NotImplementedError(`Logger \"${identifier}\" already exists`);\n        }\n        Logger.logger.push({\n            logIdentifier: identifier,\n            logFormatter: logFormatterFor(options?.logFormat ?? Format.PLAIN),\n            log: logger,\n            defaultLogLevel: options?.defaultLogLevel ?? Level.DEBUG,\n            logLevels: options?.logLevels ?? {},\n        });\n    }\n\n    public static removeLogger(identifier: string) {\n        const index = Logger.logger.findIndex(logger => logger.logIdentifier === identifier);\n        if (index === -1) {\n            throw new NotImplementedError(`Logger \"${identifier}\" does not exist`);\n        }\n        Logger.logger.splice(index, 1);\n    }\n\n    /**\n     * Get the logger with the matching identifier.\n     * @param identifier The identifier of the logger\n     */\n    public static getLoggerforIdentifier(identifier: string) {\n        const logger = Logger.logger.find(logger => logger.logIdentifier === identifier);\n        if (logger === undefined) {\n            throw new NotImplementedError(`Unknown logger \"${identifier}\"`);\n        }\n        return logger;\n    }\n\n    /**\n     * Set log level using configuration-style level name for the default logger.\n     */\n    static set level(level: number | string) {\n        if (level === undefined) {\n            level = Level.DEBUG;\n        }\n\n        let levelNum;\n        if (typeof level === \"string\") {\n            if (level.match(/^[0-9]+$/)) {\n                levelNum = Number.parseInt(level);\n            } else {\n                levelNum = (Level as unknown as Record<string, number | undefined>)[level.toUpperCase()];\n                if (levelNum === undefined) {\n                    throw new ImplementationError(`Unsupported log level \"${level}\"`);\n                }\n            }\n        } else {\n            levelNum = level;\n        }\n\n        if (Level[levelNum] === undefined) {\n            throw new ImplementationError(`Unsupported log level \"${level}\"`);\n        }\n\n        Logger.defaultLogLevel = levelNum;\n    }\n\n    /**\n     * Set logFormatter using configuration-style format name.\n     *\n     * @param format the name of the formatter (see Format enum)\n     */\n    static set format(format: string) {\n        Logger.setLogFormatterForLogger(\"default\", logFormatterFor(format));\n    }\n\n    /**\n     * Set facility loglevels for the default logger.\n     * @param levels The levels to set\n     */\n    public static set logLevels(levels: { [facility: string]: Level }) {\n        Logger.setLogLevelsForLogger(\"default\", levels);\n    }\n\n    /**\n     * Get facility loglevels for the default logger.\n     */\n    public static get logLevels() {\n        return Logger.getLoggerforIdentifier(\"default\").logLevels;\n    }\n\n    /**\n     * Set default loglevel for the default logger.\n     *\n     * @param level The level to set\n     */\n    public static set defaultLogLevel(level: Level) {\n        Logger.setDefaultLoglevelForLogger(\"default\", level);\n    }\n\n    /**\n     * Get default loglevel for the default logger.\n     */\n    public static get defaultLogLevel() {\n        return Logger.getLoggerforIdentifier(\"default\").defaultLogLevel;\n    }\n\n    /**\n     * Set the log function for the default logger.\n     *\n     * @param log The log function to set\n     */\n    public static set log(log: (level: Level, formattedLog: string) => void) {\n        Logger.setLogger(\"default\", log);\n    }\n\n    /**\n     * Get the log function for the default logger.\n     */\n    public static get log() {\n        return Logger.getLoggerforIdentifier(\"default\").log;\n    }\n\n    /**\n     * Set the log formatter for the default logger.\n     *\n     * @param logFormatter\n     */\n    public static set logFormatter(\n        logFormatter: (now: Date, level: Level, facility: string, nestingPrefix: string, values: any[]) => string,\n    ) {\n        Logger.setLogFormatterForLogger(\"default\", logFormatter);\n    }\n\n    /**\n     * Get the log formatter for the default logger.\n     */\n    public static get logFormatter() {\n        return Logger.getLoggerforIdentifier(\"default\").logFormatter;\n    }\n\n    /**\n     * Set logFormatter using configuration-style format name for the logger with the matching identifier.\n     *\n     * @param identifier The identifier of the logger\n     * @param format the name of the formatter (see Format enum)\n     */\n    public static setFormatForLogger(identifier: string, format: string) {\n        const logger = Logger.logger.find(logger => logger.logIdentifier === identifier);\n        if (logger) {\n            logger.logFormatter = logFormatterFor(format);\n        } else {\n            throw new NotImplementedError(`Unknown logger \"${identifier}\"`);\n        }\n    }\n\n    /**\n     * Set default loglevel for the logger with the matching identifier.\n     *\n     * @param identifier The identifier of the logger\n     * @param level The level to set\n     */\n    public static setDefaultLoglevelForLogger(identifier: string, level: Level) {\n        const logger = Logger.logger.find(logger => logger.logIdentifier === identifier);\n        if (logger) {\n            logger.defaultLogLevel = level;\n        } else {\n            throw new NotImplementedError(`Unknown logger \"${identifier}\"`);\n        }\n    }\n\n    /**\n     * Set facility loglevels for the logger with the matching identifier.\n     *\n     * @param identifier The identifier of the logger\n     * @param levels The levels to set\n     */\n    public static setLogLevelsForLogger(identifier: string, levels: { [facility: string]: Level }) {\n        const logger = Logger.logger.find(logger => logger.logIdentifier === identifier);\n        if (logger) {\n            logger.logLevels = levels;\n        } else {\n            throw new NotImplementedError(`Unknown logger \"${identifier}\"`);\n        }\n    }\n\n    /**\n     * Set the log function for the logger with the matching identifier.\n     *\n     * @param identifier The identifier of the logger\n     * @param log The log function to set\n     */\n    public static setLogger(identifier: string, log: (level: Level, formattedLog: string) => void) {\n        const logger = Logger.logger.find(logger => logger.logIdentifier === identifier);\n        if (logger) {\n            logger.log = log;\n        } else {\n            throw new NotImplementedError(`Unknown logger \"${identifier}\"`);\n        }\n    }\n\n    /**\n     * Set the log formatter for the logger with the matching identifier.\n     *\n     * @param identifier The identifier of the logger\n     * @param logFormatter The log formatter to set\n     */\n    static setLogFormatterForLogger(\n        identifier: string,\n        logFormatter: (now: Date, level: Level, facility: string, nestingPrefix: string, values: any[]) => string,\n    ) {\n        const logger = Logger.logger.find(logger => logger.logIdentifier === identifier);\n        if (logger) {\n            logger.logFormatter = logFormatter;\n        } else {\n            throw new NotImplementedError(`Unknown logger \"${identifier}\"`);\n        }\n    }\n\n    /**\n     * Create a new facility.\n     *\n     * @param name the name of the facility\n     * @returns a new facility\n     */\n    static get(name: string) {\n        return new Logger(name);\n    }\n\n    /**\n     * Stringify a value (BigInt aware) as JSON.\n     *\n     * @param data the value to stringify\n     * @returns the stringified value\n     */\n    static toJSON(data: any) {\n        return JSON.stringify(data, (_, value) => {\n            if (typeof value === \"bigint\") {\n                return value.toString();\n            }\n            if (value instanceof ByteArray) {\n                return value.toHex();\n            }\n            if (value === undefined) {\n                return \"undefined\";\n            }\n            return value;\n        });\n    }\n\n    /**\n     * Mask a string with a given character. If unmaskedLength is provided then these number of characters will be\n     * shown unmasked.\n     *\n     * @param str String to mask\n     * @param maskChar character to mask with\n     * @param unmaskedLength number of characters to show unmasked in the beginning\n     */\n    static maskString(str: string, maskChar = \"*\", unmaskedLength?: number) {\n        return str.substring(0, unmaskedLength ?? 0) + str.substring(unmaskedLength ?? 0).replace(/./g, maskChar);\n    }\n\n    /**\n     * Perform operations in a nested logging context.  Messages will be\n     * indented while the context executes.\n     */\n    static nest<T>(context: () => T): T {\n        this.nestingLevel++;\n        try {\n            return context();\n        } finally {\n            this.nestingLevel--;\n        }\n    }\n\n    /**\n     * Async version of nest().\n     */\n    static async nestAsync(context: () => Promise<any>) {\n        this.nestingLevel++;\n        try {\n            return await context();\n        } finally {\n            this.nestingLevel--;\n        }\n    }\n\n    /**\n     * Unhandled error reporter.\n     *\n     * Some environments do not report full error details such as {@link Error#cause} and {@link AggregateError#errors}.\n     *\n     * To ensure these details are always recorded somewhere, unhandled errors may be reported here.\n     *\n     * To disable this behavior replace this function.\n     */\n    static reportUnhandledError(error: Error) {\n        try {\n            Logger.get(\"Logger\").fatal(\"Unhandled error detected:\", error);\n        } catch (e) {\n            // We do not want to cause yet another error so if logging fails for any reason it goes unreported\n        }\n    }\n\n    constructor(private readonly name: string) {}\n\n    debug = (...values: any[]) => this.log(Level.DEBUG, values);\n    info = (...values: any[]) => this.log(Level.INFO, values);\n    notice = (...values: any[]) => this.log(Level.NOTICE, values);\n    warn = (...values: any[]) => this.log(Level.WARN, values);\n    error = (...values: any[]) => this.log(Level.ERROR, values);\n    fatal = (...values: any[]) => this.log(Level.FATAL, values);\n\n    private log(level: Level, values: any[]) {\n        Logger.logger.forEach(logger => {\n            if (level < (logger.logLevels[this.name] ?? logger.defaultLogLevel)) return;\n            logger.log(level, logger.logFormatter(Time.now(), level, this.name, nestingPrefix(), values));\n        });\n    }\n}\n\n// Hook for testing frameworks\nif (typeof MatterHooks !== \"undefined\") {\n    MatterHooks.loggerSetup?.(Logger);\n}\n\nfunction nestingPrefix() {\n    if (Logger.nestingLevel) {\n        return \"\u23B8\".padEnd(Logger.nestingLevel * 2);\n    }\n    return \"\";\n}\n"],
  "mappings": "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",
  "names": ["console", "consoleLogger", "logger"]
}
