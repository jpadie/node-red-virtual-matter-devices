{
  "version": 3,
  "sources": ["../../../src/ble/BtpSessionHandler.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BtpCodec } from \"../codec/BtpCodec.js\";\nimport { MatterError } from \"../common/MatterError.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { Time } from \"../time/Time.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataReader } from \"../util/DataReader.js\";\nimport {\n    BLE_MAXIMUM_BTP_MTU,\n    BLE_MINIMUM_ATT_MTU,\n    BTP_ACK_TIMEOUT_MS,\n    BTP_CONN_IDLE_TIMEOUT,\n    BTP_MAXIMUM_WINDOW_SIZE,\n    BTP_SEND_ACK_TIMEOUT_MS,\n} from \"./BleConsts.js\";\n\nexport class BtpMatterError extends MatterError {}\nexport class BtpProtocolError extends BtpMatterError {}\nexport class BtpFlowError extends BtpMatterError {}\n\nexport const BTP_SUPPORTED_VERSIONS = [4]; // needs to be sort in descending order!\nconst MAXIMUM_SEQUENCE_NUMBER = 255;\n\nconst logger = Logger.get(\"BtpSessionHandler\");\n\nexport class BtpSessionHandler {\n    private currentIncomingSegmentedMsgLength: number | undefined;\n    private currentIncomingSegmentedPayload: ByteArray | undefined;\n    private prevIncomingSequenceNumber = 255; // Incoming Sequence Number received. Set to 255 to start at 0\n    private prevIncomingAckNumber = -1; // Previous ackNumber received\n    private readonly ackReceiveTimer = Time.getTimer(\"BTP ack timeout\", BTP_ACK_TIMEOUT_MS, () =>\n        this.btpAckTimeoutTriggered(),\n    );\n\n    private sequenceNumber = 0; // Sequence number is set to 0 already for the handshake, next sequence number is 1\n    private prevAckedSequenceNumber = -1; // Previous (outgoing) Acked Sequence Number\n    private readonly queuedOutgoingMatterMessages = new Array<DataReader<Endian.Little>>();\n    private sendInProgress = false;\n    private readonly sendAckTimer = Time.getTimer(\"BTP send timeout\", BTP_SEND_ACK_TIMEOUT_MS, () =>\n        this.btpSendAckTimeoutTriggered(),\n    );\n    private isActive = true;\n    private idleTimeout = Time.getTimer(\"Central Device Idle Timer\", BTP_CONN_IDLE_TIMEOUT, async () => {\n        logger.info(\"Central Device Connection Idle Timer expired, closing BTP session\");\n        await this.close();\n    });\n\n    /** Factory method to create a new BTPSessionHandler from a received handshake request */\n    static async createFromHandshakeRequest(\n        maxDataSize: number | undefined,\n        handshakeRequestPayload: ByteArray,\n        writeBleCallback: (data: ByteArray) => Promise<void>,\n        disconnectBleCallback: () => Promise<void>,\n        handleMatterMessagePayload: (data: ByteArray) => Promise<void>,\n    ): Promise<BtpSessionHandler> {\n        // Decode handshake request\n        const handshakeRequest = BtpCodec.decodeBtpHandshakeRequest(handshakeRequestPayload);\n\n        const {\n            versions,\n            attMtu: handshakeMtu, // Number excluding 3 header bytes\n            clientWindowSize,\n        } = handshakeRequest;\n        logger.debug(`Received BTP handshake request:`, Diagnostic.dict({ maxDataSize, ...handshakeRequest }));\n\n        // Verify handshake request and choose the highest supported version for both parties\n        const version = BTP_SUPPORTED_VERSIONS.find(version => versions.includes(version));\n        if (version === undefined) {\n            await disconnectBleCallback();\n            throw new BtpProtocolError(`No supported BTP version found in ${versions}`);\n        }\n\n        let attMtu = BLE_MINIMUM_ATT_MTU;\n        if (maxDataSize !== undefined) {\n            if (maxDataSize > BLE_MINIMUM_ATT_MTU) {\n                if (handshakeMtu <= BLE_MINIMUM_ATT_MTU) {\n                    attMtu = Math.min(maxDataSize, BLE_MAXIMUM_BTP_MTU);\n                } else {\n                    attMtu = Math.min(handshakeMtu, maxDataSize, BLE_MAXIMUM_BTP_MTU);\n                }\n            }\n        }\n\n        const fragmentSize = attMtu; // The attMtu is the maximum size of a single ATT packet, so use as fragmentSize\n        const windowSize = Math.min(BTP_MAXIMUM_WINDOW_SIZE, clientWindowSize);\n\n        // Generate and send out handshake response\n        const handshakeResponse = BtpCodec.encodeBtpHandshakeResponse({\n            version,\n            attMtu,\n            windowSize,\n        });\n\n        logger.debug(\n            `Sending BTP handshake response:`,\n            Diagnostic.dict({\n                version,\n                attMtu,\n                windowSize,\n            }),\n        );\n\n        const btpSession = new BtpSessionHandler(\n            \"peripheral\",\n            version,\n            fragmentSize,\n            windowSize,\n            writeBleCallback,\n            disconnectBleCallback,\n            handleMatterMessagePayload,\n        );\n\n        await writeBleCallback(handshakeResponse);\n\n        return btpSession;\n    }\n\n    static async createAsCentral(\n        handshakeResponsePayload: ByteArray,\n        writeBleCallback: (data: ByteArray) => Promise<void>,\n        disconnectBleCallback: () => Promise<void>,\n        handleMatterMessagePayload: (data: ByteArray) => Promise<void>,\n    ) {\n        const handshakeRequest = BtpCodec.decodeBtpHandshakeResponsePayload(handshakeResponsePayload);\n\n        logger.debug(\"Handshake request\", Diagnostic.dict(handshakeRequest));\n\n        const { version, attMtu: handshakeMtu, windowSize } = handshakeRequest;\n        const fragmentSize = Math.min(handshakeMtu, BLE_MAXIMUM_BTP_MTU);\n\n        return new BtpSessionHandler(\n            \"central\",\n            version,\n            fragmentSize,\n            windowSize,\n            writeBleCallback,\n            disconnectBleCallback,\n            handleMatterMessagePayload,\n        );\n    }\n\n    /**\n     * Creates a new BTP session handler\n     *\n     * @param role The role of the BTP session handler\n     * @param btpVersion The BTP protocol version to use\n     * @param fragmentSize The fragment size to use for the messages\n     * @param clientWindowSize The client window size to use\n     * @param writeBleCallback Callback to write data to the BLE transport\n     * @param disconnectBleCallback Callback to disconnect the BLE transport\n     * @param handleMatterMessagePayload Callback to handle a Matter message payload\n     */\n    constructor(\n        private readonly role: \"central\" | \"peripheral\",\n        btpVersion: number,\n        private readonly fragmentSize: number,\n        private readonly clientWindowSize: number,\n        private readonly writeBleCallback: (data: ByteArray) => Promise<void>,\n        private readonly disconnectBleCallback: () => Promise<void>,\n        private readonly handleMatterMessagePayload: (data: ByteArray) => Promise<void>,\n    ) {\n        if (btpVersion !== 4) {\n            throw new BtpProtocolError(`Unsupported BTP version ${btpVersion}`);\n        }\n        if (role === \"peripheral\") {\n            this.ackReceiveTimer.start();\n        } else {\n            this.sendAckTimer.start();\n            this.prevIncomingSequenceNumber = 0;\n            this.prevIncomingAckNumber = -1;\n            this.sequenceNumber = -1; // First sequence number needs to be 0\n        }\n    }\n\n    /**\n     * Handle incoming data from the transport layer and hand over completely received matter messages to the\n     * ExchangeManager layer\n     *\n     * @param data ByteArray containing the data\n     */\n    public async handleIncomingBleData(data: ByteArray) {\n        if (!this.isActive) {\n            logger.debug(`BTP session is not active, ignoring incoming BLE data`);\n            return;\n        }\n        try {\n            if (data.length > this.fragmentSize) {\n                // Apple seems to interpret the ATT_MTU as the maximum size of a single ATT packet\n                if (data.length > this.fragmentSize + 3) {\n                    throw new BtpProtocolError(\n                        `Received data ${data.length} bytes exceeds fragment size of ${this.fragmentSize} bytes`,\n                    );\n                } else {\n                    logger.warn(\n                        `Received data ${data.length} bytes exceeds fragment size of ${this.fragmentSize} bytes, still accepting`,\n                    );\n                }\n            }\n            const btpPacket = BtpCodec.decodeBtpPacket(data);\n            logger.debug(`Received BTP packet: ${Logger.toJSON(btpPacket)}`);\n            const {\n                header: {\n                    hasAckNumber,\n                    isHandshakeRequest,\n                    hasManagementOpcode,\n                    isEndingSegment,\n                    isBeginningSegment,\n                    isContinuingSegment,\n                },\n                payload: { ackNumber, sequenceNumber, messageLength, segmentPayload },\n            } = btpPacket;\n\n            if (isHandshakeRequest || hasManagementOpcode) {\n                throw new BtpProtocolError(\"BTP packet must not be a handshake request or have a management opcode.\");\n            }\n            if (segmentPayload.length === 0 && !hasAckNumber) {\n                throw new BtpProtocolError(\"BTP packet must have a segment payload or an ack number.\");\n            }\n\n            if (sequenceNumber !== (this.prevIncomingSequenceNumber + 1) % 256) {\n                logger.debug(\n                    `sequenceNumber : ${sequenceNumber}, prevClientSequenceNumber : ${this.prevIncomingSequenceNumber}`,\n                );\n                throw new BtpProtocolError(\"Expected and actual BTP packets sequence number does not match\");\n            }\n            this.prevIncomingSequenceNumber = sequenceNumber;\n\n            if (!this.sendAckTimer.isRunning) {\n                this.sendAckTimer.start();\n            }\n\n            if (hasAckNumber && ackNumber !== undefined) {\n                // check that ack number is valid\n                if (ackNumber > this.sequenceNumber || this.exceedsWindowSize(this.prevIncomingAckNumber, ackNumber)) {\n                    throw new BtpProtocolError(\n                        `Invalid Ack Number, Ack Number: ${ackNumber}, Sequence Number: ${this.sequenceNumber}, Previous AckNumber: ${this.prevIncomingAckNumber}`,\n                    );\n                }\n\n                // for valid ack, stop timer and update prevIncomingAckNumber\n                this.ackReceiveTimer.stop();\n                this.prevIncomingAckNumber = ackNumber;\n\n                // if still waiting for ack for sequence number restart timer\n                if (ackNumber !== this.sequenceNumber) {\n                    this.ackReceiveTimer.start();\n                }\n            }\n\n            // Set or add the payload to the current incoming segmented payload\n            if (isBeginningSegment) {\n                if (this.currentIncomingSegmentedPayload !== undefined) {\n                    throw new BtpProtocolError(\n                        `BTP message flow error! New beginning packet was received without previous message being completed.`,\n                    );\n                }\n                this.currentIncomingSegmentedMsgLength = messageLength;\n                this.currentIncomingSegmentedPayload = segmentPayload;\n            } else if (isContinuingSegment || isEndingSegment) {\n                if (this.currentIncomingSegmentedPayload === undefined) {\n                    throw new BtpProtocolError(`BTP Continuing or ending packet received without beginning packet.`);\n                }\n                if (segmentPayload.length === 0) {\n                    throw new BtpProtocolError(`BTP Continuing or ending packet received without payload.`);\n                }\n                this.currentIncomingSegmentedPayload = ByteArray.concat(\n                    this.currentIncomingSegmentedPayload,\n                    segmentPayload,\n                );\n            }\n\n            if (isEndingSegment) {\n                if (\n                    this.currentIncomingSegmentedMsgLength === undefined ||\n                    this.currentIncomingSegmentedPayload === undefined\n                ) {\n                    throw new BtpProtocolError(\"BTP beginning packet missing but ending packet received.\");\n                }\n                if (this.currentIncomingSegmentedPayload.length !== this.currentIncomingSegmentedMsgLength) {\n                    throw new BtpProtocolError(\n                        `BTP packet payload length does not match message length: ${this.currentIncomingSegmentedPayload.length} !== ${this.currentIncomingSegmentedMsgLength}`,\n                    );\n                }\n\n                const payloadToProcess = this.currentIncomingSegmentedPayload;\n                this.currentIncomingSegmentedMsgLength = undefined;\n                this.currentIncomingSegmentedPayload = undefined; // resetting current segment Payload to empty byte array\n\n                // Hand over the resulting Matter message to ExchangeManager via the callback\n                await this.handleMatterMessagePayload(payloadToProcess);\n            }\n        } catch (error) {\n            logger.error(`Error while handling incoming BTP data: ${error}`);\n            await this.close();\n\n            // If no BTP protocol error, rethrow\n            BtpProtocolError.accept(error);\n        }\n    }\n\n    /**\n     * Send a Matter message to the transport layer, but before that encode it into a BTP packet and potentially split\n     * it into multiple segments. This Method is indirectly called by the ExchangeManager layer when a Matter message\n     * should be sent.\n     *\n     * @param data ByteArray containing the Matter message\n     */\n    public async sendMatterMessage(data: ByteArray) {\n        if (!this.isActive) {\n            throw new BtpFlowError(\"BTP session is not active\");\n        }\n        logger.debug(`Got Matter message to send via BLE transport: ${data.toHex()}`);\n\n        if (data.length === 0) {\n            throw new BtpFlowError(\"BTP packet must not be empty\");\n        }\n        const dataReader = new DataReader(data, Endian.Little);\n        this.queuedOutgoingMatterMessages.push(dataReader);\n        await this.processSendQueue();\n    }\n\n    private async processSendQueue() {\n        if (this.sendInProgress) return;\n\n        if (this.exceedsWindowSize(this.prevIncomingAckNumber, this.sequenceNumber)) return;\n\n        if (this.queuedOutgoingMatterMessages.length === 0) return;\n\n        this.sendInProgress = true;\n\n        while (this.queuedOutgoingMatterMessages.length > 0) {\n            const currentProcessedMessage = this.queuedOutgoingMatterMessages[0];\n            const remainingMessageLength = currentProcessedMessage.getRemainingBytesCount();\n\n            logger.debug(\n                \"Sending BTP fragment: \",\n                Diagnostic.dict({\n                    fullMessageLength: currentProcessedMessage.getLength(),\n                    remainingLengthInBytes: remainingMessageLength,\n                }),\n            );\n\n            //checks if last ack number sent < ack number to be sent\n            const hasAckNumber = this.prevIncomingSequenceNumber !== this.prevAckedSequenceNumber;\n            if (hasAckNumber) {\n                this.prevAckedSequenceNumber = this.prevIncomingSequenceNumber;\n                this.sendAckTimer.stop();\n            }\n\n            const isBeginningSegment = remainingMessageLength === currentProcessedMessage.getLength();\n\n            // Calculate Header Size - faster than encoding and checking length\n            const btpHeaderLength = 2 + (isBeginningSegment ? 2 : 0) + (hasAckNumber ? 1 : 0); // 2(flags, sequenceNumber) + 2(beginning) + 1(ackNumber)\n\n            const isEndingSegment = remainingMessageLength <= this.fragmentSize - btpHeaderLength;\n\n            const packetHeader = {\n                isHandshakeRequest: false,\n                hasManagementOpcode: false,\n                hasAckNumber,\n                isBeginningSegment,\n                isContinuingSegment: !isBeginningSegment,\n                isEndingSegment,\n            };\n\n            logger.debug(\n                `Take up to ${\n                    this.fragmentSize - btpHeaderLength\n                } bytes from Rest of message: ${remainingMessageLength}`,\n            );\n\n            const segmentPayload = currentProcessedMessage.readByteArray(this.fragmentSize - btpHeaderLength);\n\n            const btpPacket = {\n                header: packetHeader,\n                payload: {\n                    ackNumber: hasAckNumber ? this.prevIncomingSequenceNumber : undefined,\n                    sequenceNumber: this.getNextSequenceNumber(),\n                    messageLength: packetHeader.isBeginningSegment ? remainingMessageLength : undefined, // remainingMessageLength if the fill length on beginning packet\n                    segmentPayload,\n                },\n            };\n\n            logger.debug(`Sending BTP packet: ${Logger.toJSON(btpPacket)}`);\n            const packet = BtpCodec.encodeBtpPacket(btpPacket);\n            logger.debug(`Sending BTP packet raw: ${packet.toHex()}`);\n\n            await this.writeBleCallback(packet);\n\n            if (!this.ackReceiveTimer.isRunning) {\n                this.ackReceiveTimer.start(); // starts the timer\n            }\n            if (this.role === \"central\") {\n                // Restart idle timer when sending unique data\n                if (this.idleTimeout.isRunning) {\n                    this.idleTimeout.stop();\n                }\n                this.idleTimeout.start();\n            }\n\n            // Remove the message from the queue if it is the last segment\n            if (isEndingSegment) {\n                this.queuedOutgoingMatterMessages.shift();\n            }\n\n            // If the window is full, stop sending for now\n            if (this.exceedsWindowSize(this.prevIncomingAckNumber, this.sequenceNumber)) {\n                break;\n            }\n        }\n        this.sendInProgress = false;\n    }\n\n    /**\n     * Close the BTP session. This method is called when the BLE transport is disconnected and so the BTP session gets closed.\n     */\n    public async close() {\n        this.sendAckTimer.stop();\n        this.ackReceiveTimer.stop();\n        this.idleTimeout.stop();\n        if (this.isActive) {\n            logger.debug(`Closing BTP session`);\n            this.isActive = false;\n            await this.disconnectBleCallback();\n        }\n    }\n\n    /**\n     * If this timer expires and the peer has a pending acknowledgement, the peer SHALL immediately send that\n     * acknowledgement\n     */\n    private async btpSendAckTimeoutTriggered() {\n        if (this.prevIncomingSequenceNumber > this.prevAckedSequenceNumber) {\n            logger.debug(`Sending BTP ACK for sequence number ${this.prevIncomingSequenceNumber}`);\n            const btpPacket = {\n                header: {\n                    isHandshakeRequest: false,\n                    hasManagementOpcode: false,\n                    hasAckNumber: true,\n                    isBeginningSegment: false,\n                    isContinuingSegment: false,\n                    isEndingSegment: false,\n                },\n                payload: {\n                    ackNumber: this.prevIncomingSequenceNumber,\n                    sequenceNumber: this.getNextSequenceNumber(),\n                },\n            };\n            this.prevAckedSequenceNumber = this.prevIncomingSequenceNumber;\n            const packet = BtpCodec.encodeBtpPacket(btpPacket);\n            await this.writeBleCallback(packet);\n            if (!this.ackReceiveTimer.isRunning) {\n                this.ackReceiveTimer.start(); // starts the timer\n            }\n        }\n    }\n\n    /**\n     * If a peer\u2019s acknowledgement-received timer expires, or if a peer receives an invalid acknowledgement,\n     * the peer SHALL close the BTP session and report an error to the application.\n     */\n    private async btpAckTimeoutTriggered() {\n        if (this.prevIncomingAckNumber !== this.sequenceNumber) {\n            logger.warn(\"Acknowledgement for the sent sequence number was not received ... disconnect\");\n            await this.close();\n        }\n    }\n\n    /**\n     * Increments sequence number for the packets and round it off to 0 when it reaches the maximum limit.\n     */\n    getNextSequenceNumber() {\n        this.sequenceNumber++;\n        if (this.sequenceNumber > MAXIMUM_SEQUENCE_NUMBER) {\n            this.sequenceNumber = 0;\n        }\n        return this.sequenceNumber;\n    }\n\n    /**\n     * Checks if incoming ackNumber and sent sequence number exceeds the client window size or not.\n     */\n    private exceedsWindowSize(prevIncomingAckNumber: number, currentSequenceNumber: number): boolean {\n        if (prevIncomingAckNumber > currentSequenceNumber) {\n            prevIncomingAckNumber = (prevIncomingAckNumber % MAXIMUM_SEQUENCE_NUMBER) - 1;\n        }\n        return currentSequenceNumber - prevIncomingAckNumber > this.clientWindowSize - 1;\n    }\n}\n"],
  "mappings": "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",
  "names": ["version"]
}
