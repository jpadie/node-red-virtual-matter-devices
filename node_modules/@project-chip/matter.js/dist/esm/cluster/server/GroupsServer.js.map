{
  "version": 3,
  "sources": ["../../../../src/cluster/server/GroupsServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GroupId } from \"../../datatype/GroupId.js\";\nimport { Fabric } from \"../../fabric/Fabric.js\";\nimport { StatusCode } from \"../../protocol/interaction/StatusCode.js\";\nimport { assertSecureSession } from \"../../session/SecureSession.js\";\nimport { GroupsCluster } from \"../definitions/GroupsCluster.js\";\nimport { IdentifyCluster } from \"../definitions/IdentifyCluster.js\";\nimport { ClusterServer } from \"./ClusterServer.js\";\nimport { ClusterServerHandlers } from \"./ClusterServerTypes.js\";\n\n/*\nTODO: If the Scenes server cluster is implemented on the same endpoint, the following extension field SHALL\n      be added to the Scene Table:\n      * OnOff\n */\n\nexport class GroupsManager {\n    static async setGroup(fabric: Fabric, endpointId: number, groupId: GroupId, groupName: string) {\n        let endpointGroups = fabric.getScopedClusterDataValue<Map<GroupId, string>>(\n            GroupsCluster,\n            endpointId.toString(),\n        );\n        if (endpointGroups === undefined) {\n            endpointGroups = new Map<GroupId, string>();\n        }\n        endpointGroups.set(groupId, groupName || \"\");\n\n        await fabric.setScopedClusterDataValue(GroupsCluster, endpointId.toString(), endpointGroups);\n    }\n\n    static getGroupName(fabric: Fabric, endpointId: number, groupId: GroupId): string | undefined {\n        const endpointGroups = fabric.getScopedClusterDataValue<Map<GroupId, string>>(\n            GroupsCluster,\n            endpointId.toString(),\n        );\n        return endpointGroups?.get(groupId);\n    }\n\n    static hasGroup(fabric: Fabric, endpointId: number, groupId: GroupId): boolean {\n        const endpointGroups = fabric.getScopedClusterDataValue<Map<GroupId, string>>(\n            GroupsCluster,\n            endpointId.toString(),\n        );\n        return endpointGroups?.has(groupId) ?? false;\n    }\n\n    static getGroups(fabric: Fabric, endpointId: number): Map<GroupId, string> {\n        return (\n            fabric.getScopedClusterDataValue<Map<GroupId, string>>(GroupsCluster, endpointId.toString()) ??\n            new Map<GroupId, string>()\n        );\n    }\n\n    static async removeGroup(fabric: Fabric, endpointId: number, groupId: GroupId): Promise<boolean> {\n        const endpointGroups = fabric.getScopedClusterDataValue<Map<GroupId, string>>(\n            GroupsCluster,\n            endpointId.toString(),\n        );\n        if (endpointGroups !== undefined) {\n            if (endpointGroups.delete(groupId)) {\n                await fabric.persist(false); // persist scoped cluster data changes\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static async removeAllGroups(fabric: Fabric, endpointId: number) {\n        await fabric.deleteScopedClusterDataValue(GroupsCluster, endpointId.toString());\n    }\n}\n\nexport const GroupsClusterHandler: () => ClusterServerHandlers<typeof GroupsCluster> = () => {\n    const addGroupLogic = async (groupId: GroupId, groupName: string, fabric: Fabric, endpointId: number) => {\n        if (groupId < 1) {\n            return { status: StatusCode.ConstraintError, groupId };\n        }\n        if (groupName.length > 16) {\n            return { status: StatusCode.ConstraintError, groupId };\n        }\n\n        await GroupsManager.setGroup(fabric, endpointId, groupId, groupName);\n\n        return { status: StatusCode.Success, groupId };\n    };\n\n    return {\n        addGroup: async ({ request: { groupId, groupName }, session, endpoint }) => {\n            assertSecureSession(session);\n            return addGroupLogic(groupId, groupName, session.associatedFabric, endpoint.getNumber());\n        },\n\n        viewGroup: async ({ request: { groupId }, session, endpoint }) => {\n            if (groupId < 1) {\n                return { status: StatusCode.ConstraintError, groupId, groupName: \"\" };\n            }\n\n            assertSecureSession(session);\n            const groupName = GroupsManager.getGroupName(session.associatedFabric, endpoint.getNumber(), groupId);\n            if (groupName !== undefined) {\n                return { status: StatusCode.Success, groupId, groupName: groupName };\n            }\n            return { status: StatusCode.NotFound, groupId, groupName: \"\" };\n        },\n\n        getGroupMembership: async ({ request: { groupList }, session, endpoint }) => {\n            // TODO Later:\n            //  Zigbee: If the total number of groups will cause the maximum payload length of a frame to be exceeded,\n            //  then the GroupList field SHALL contain only as many groups as will fit.\n\n            assertSecureSession(session);\n            const endpointGroups = GroupsManager.getGroups(session.associatedFabric, endpoint.getNumber());\n            const fabricGroupsList = Array.from(endpointGroups.keys());\n            const capacity = fabricGroupsList.length < 0xff ? 0xfe - fabricGroupsList.length : 0;\n            if (groupList.length === 0) {\n                return { capacity, groupList: fabricGroupsList };\n            }\n            const filteredGroupsList = groupList.filter(groupId => endpointGroups.get(groupId));\n            if (filteredGroupsList.length === 0) {\n                return { capacity, groupList: [] };\n            }\n            return { capacity, groupList: filteredGroupsList };\n        },\n\n        removeGroup: async ({ request: { groupId }, session, endpoint }) => {\n            if (groupId < 1) {\n                return { status: StatusCode.ConstraintError, groupId };\n            }\n\n            assertSecureSession(session);\n            if (await GroupsManager.removeGroup(session.associatedFabric, endpoint.getNumber(), groupId)) {\n                return { status: StatusCode.Success, groupId };\n            }\n            return { status: StatusCode.NotFound, groupId };\n        },\n\n        removeAllGroups: async ({ session, endpoint }) => {\n            assertSecureSession(session);\n            const fabric = session.associatedFabric;\n            await GroupsManager.removeAllGroups(fabric, endpoint.getNumber());\n\n            return;\n        },\n\n        addGroupIfIdentifying: async ({ request: { groupId, groupName }, session, endpoint }) => {\n            const identifyCluster = endpoint.getClusterServer(IdentifyCluster);\n            if (identifyCluster) {\n                if (identifyCluster.attributes.identifyTime.getLocal() > 0) {\n                    // We identify ourselves currently\n                    assertSecureSession(session);\n                    await addGroupLogic(groupId, groupName, session.associatedFabric, endpoint.getNumber());\n                }\n            }\n\n            // TODO If the AddGroupIfIdentifying command was received as unicast and the evaluated status is not SUCCESS, or\n            //      if the AddGroupIfIdentifying command was received as unicast and the evaluated status is SUCCESS and a\n            //      response is not suppressed, the server SHALL generate a response with the Status field set to the\n            //      evaluated status.\n        },\n    };\n};\n\nexport const createDefaultGroupsClusterServer = () =>\n    ClusterServer(\n        GroupsCluster,\n        {\n            nameSupport: {\n                nameSupport: true,\n            },\n        },\n        GroupsClusterHandler(),\n    );\n"],
  "mappings": "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",
  "names": []
}
