{
  "version": 3,
  "sources": ["../../../../src/cluster/server/LevelControlServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NotImplementedError } from \"../../common/MatterError.js\";\nimport { WrapCommandHandler } from \"../../device/Device.js\";\nimport { NamedHandler } from \"../../util/NamedHandler.js\";\nimport { LevelControl } from \"../definitions/LevelControlCluster.js\";\nimport { ClusterServer } from \"./ClusterServer.js\";\nimport { AttributeInitialValues, ClusterServerHandlers } from \"./ClusterServerTypes.js\";\n\nexport const LevelControlDefaultClusterHandler: () => ClusterServerHandlers<typeof LevelControl.Complete> = () => ({\n    moveToLevel: async ({ request: { level }, attributes: { currentLevel } }) => {\n        currentLevel.setLocal(level);\n    },\n\n    // TODO: How much this capability should be in the library vs. in the caller of the library? Doing the\n    // move/step/stop (withOnOff) in the library would be making assumptions about the capabilities of the\n    // underlying hardware. But how to expose these parameters to the caller of the library? Callback with\n    // temporary options?\n    move: async () => {\n        throw new NotImplementedError(\"Not implemented\");\n    },\n\n    step: async () => {\n        throw new NotImplementedError(\"Not implemented\");\n    },\n\n    stop: async () => {\n        throw new NotImplementedError(\"Not implemented\");\n    },\n\n    moveToLevelWithOnOff: async function ({ request: { level }, attributes: { currentLevel } }) {\n        /* TODO: Need to be able to access or check existence of optional attributes\n        if ( level <= minLevel.get() && associated onOff device on){\n           // turn associated onOff device off\n        } else if associated onOff device off {\n           // turn associated onOff device on\n        }\n        */\n\n        currentLevel.setLocal(level);\n    },\n\n    moveWithOnOff: async () => {\n        throw new NotImplementedError(\"Not implemented\");\n    },\n\n    stepWithOnOff: async () => {\n        throw new NotImplementedError(\"Not implemented\");\n    },\n\n    stopWithOnOff: async () => {\n        throw new NotImplementedError(\"Not implemented\");\n    },\n});\n\nexport const createDefaultLevelControlClusterServer = (\n    commandHandler: NamedHandler<any>,\n    attributeInitialValues?: AttributeInitialValues<typeof LevelControl.Cluster.attributes>,\n) =>\n    ClusterServer(\n        LevelControl.Cluster,\n        attributeInitialValues ?? {\n            currentLevel: 0,\n            onLevel: 0,\n            options: {\n                executeIfOff: false,\n                coupleColorTempToLevel: false,\n            },\n        },\n        WrapCommandHandler(LevelControlDefaultClusterHandler(), commandHandler),\n    );\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,2BAA2B;AACpC,SAAS,0BAA0B;AAEnC,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAGvB,MAAM,oCAA+F,OAAO;AAAA,EAC/G,aAAa,OAAO,EAAE,SAAS,EAAE,MAAM,GAAG,YAAY,EAAE,aAAa,EAAE,MAAM;AACzE,iBAAa,SAAS,KAAK;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,YAAY;AACd,UAAM,IAAI,oBAAoB,iBAAiB;AAAA,EACnD;AAAA,EAEA,MAAM,YAAY;AACd,UAAM,IAAI,oBAAoB,iBAAiB;AAAA,EACnD;AAAA,EAEA,MAAM,YAAY;AACd,UAAM,IAAI,oBAAoB,iBAAiB;AAAA,EACnD;AAAA,EAEA,sBAAsB,eAAgB,EAAE,SAAS,EAAE,MAAM,GAAG,YAAY,EAAE,aAAa,EAAE,GAAG;AASxF,iBAAa,SAAS,KAAK;AAAA,EAC/B;AAAA,EAEA,eAAe,YAAY;AACvB,UAAM,IAAI,oBAAoB,iBAAiB;AAAA,EACnD;AAAA,EAEA,eAAe,YAAY;AACvB,UAAM,IAAI,oBAAoB,iBAAiB;AAAA,EACnD;AAAA,EAEA,eAAe,YAAY;AACvB,UAAM,IAAI,oBAAoB,iBAAiB;AAAA,EACnD;AACJ;AAEO,MAAM,yCAAyC,CAClD,gBACA,2BAEA;AAAA,EACI,aAAa;AAAA,EACb,0BAA0B;AAAA,IACtB,cAAc;AAAA,IACd,SAAS;AAAA,IACT,SAAS;AAAA,MACL,cAAc;AAAA,MACd,wBAAwB;AAAA,IAC5B;AAAA,EACJ;AAAA,EACA,mBAAmB,kCAAkC,GAAG,cAAc;AAC1E;",
  "names": []
}
