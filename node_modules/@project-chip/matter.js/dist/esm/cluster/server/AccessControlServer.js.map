{
  "version": 3,
  "sources": ["../../../../src/cluster/server/AccessControlServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { CaseAuthenticatedTag } from \"../../datatype/CaseAuthenticatedTag.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { DeviceTypeId } from \"../../datatype/DeviceTypeId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { GroupId } from \"../../datatype/GroupId.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { AclExtensionEntry } from \"../../protocol/interaction/AccessControlManager.js\";\nimport { StatusCode, StatusResponseError } from \"../../protocol/interaction/StatusCode.js\";\nimport { TypeFromBitmapSchema } from \"../../schema/BitmapSchema.js\";\nimport { assertSecureSession } from \"../../session/SecureSession.js\";\nimport { SyncStorage } from \"../../storage/Storage.js\";\nimport { TlvType } from \"../../tlv/TlvCodec.js\";\nimport { TlvTaggedList } from \"../../tlv/TlvObject.js\";\nimport { isDeepEqual } from \"../../util/DeepEqual.js\";\nimport { AccessControl, AccessControlCluster } from \"../definitions/AccessControlCluster.js\";\nimport {\n    genericFabricScopedAttributeGetter,\n    genericFabricScopedAttributeGetterFromFabric,\n    genericFabricScopedAttributeSetterForFabric,\n} from \"./AttributeServer.js\";\nimport { ClusterServer } from \"./ClusterServer.js\";\nimport { ClusterServerHandlers } from \"./ClusterServerTypes.js\";\nimport { FabricSensitiveEventServer } from \"./EventServer.js\";\n\nconst logger = Logger.get(\"AccessControlClusterServer\");\n\nexport const AccessControlClusterHandler: () => ClusterServerHandlers<typeof AccessControlCluster> = () => {\n    let accessControlEntryChangedEvent:\n        | FabricSensitiveEventServer<AccessControl.AccessControlEntryChangedEvent, SyncStorage>\n        | undefined = undefined;\n    let accessControlExtensionChangedEvent:\n        | FabricSensitiveEventServer<AccessControl.AccessControlExtensionChangedEvent, SyncStorage>\n        | undefined = undefined;\n\n    return {\n        initializeClusterServer: ({ events: { accessControlEntryChanged, accessControlExtensionChanged } }) => {\n            if (accessControlEntryChanged !== undefined) {\n                accessControlEntryChangedEvent = accessControlEntryChanged;\n            }\n            if (accessControlExtensionChanged !== undefined) {\n                accessControlExtensionChangedEvent = accessControlExtensionChanged;\n            }\n        },\n\n        aclAttributeGetter: ({ session, isFabricFiltered }) => {\n            return genericFabricScopedAttributeGetter(\n                session,\n                !!isFabricFiltered,\n                AccessControlCluster,\n                \"acl\",\n                new Array<TypeFromBitmapSchema<typeof AccessControl.TlvAccessControlEntry>>(),\n            );\n        },\n\n        aclAttributeValidator: (\n            value,\n            {\n                attributes: {\n                    accessControlEntriesPerFabric,\n                    subjectsPerAccessControlEntry,\n                    targetsPerAccessControlEntry,\n                },\n            },\n        ) => {\n            if (value.length > accessControlEntriesPerFabric.getLocal()) {\n                throw new StatusResponseError(\"AccessControlEntriesPerFabric exceeded\", StatusCode.ResourceExhausted);\n            }\n\n            for (const entry of value) {\n                const { subjects, targets, privilege, authMode } = entry;\n                if (privilege < 1 || privilege > 5) {\n                    throw new StatusResponseError(\n                        \"Privilege must be a valid enum value between 1 and 5\",\n                        StatusCode.ConstraintError,\n                    );\n                }\n                if (authMode < 1 || authMode > 3) {\n                    throw new StatusResponseError(\n                        \"AuthMode must be a valid enum value between 1 and 3\",\n                        StatusCode.ConstraintError,\n                    );\n                }\n\n                if (subjects !== null && subjects.length > subjectsPerAccessControlEntry.getLocal()) {\n                    throw new StatusResponseError(\n                        \"SubjectsPerAccessControlEntry exceeded\",\n                        StatusCode.ResourceExhausted,\n                    );\n                }\n\n                if (targets !== null && targets.length > targetsPerAccessControlEntry.getLocal()) {\n                    throw new StatusResponseError(\n                        \"TargetsPerAccessControlEntry exceeded\",\n                        StatusCode.ResourceExhausted,\n                    );\n                }\n\n                if (authMode === AccessControl.AccessControlEntryAuthMode.Pase) {\n                    throw new StatusResponseError(\"AuthMode for ACL must not be PASE\", StatusCode.ConstraintError);\n                } else if (authMode === AccessControl.AccessControlEntryAuthMode.Case) {\n                    if (subjects !== null) {\n                        for (const subject of subjects) {\n                            if (NodeId.isCaseAuthenticatedTag(subject)) {\n                                const cat = NodeId.extractAsCaseAuthenticatedTag(subject);\n                                if (CaseAuthenticatedTag.getVersion(cat) === 0) {\n                                    throw new StatusResponseError(\n                                        \"CaseAuthenticatedTag version 0 is not allowed\",\n                                        StatusCode.ConstraintError,\n                                    );\n                                }\n                            } else if (!NodeId.isOperationalNodeId(subject)) {\n                                throw new StatusResponseError(\n                                    \"Subject must be a valid OperationalNodeId or CaseAuthenticatedTag\",\n                                    StatusCode.ConstraintError,\n                                );\n                            }\n                        }\n                    }\n                } else if (authMode === AccessControl.AccessControlEntryAuthMode.Group) {\n                    if (privilege === AccessControl.AccessControlEntryPrivilege.Administer) {\n                        throw new StatusResponseError(\n                            \"Group ACLs must not have Administer privilege\",\n                            StatusCode.ConstraintError,\n                        );\n                    }\n\n                    if (subjects !== null) {\n                        for (const subject of subjects) {\n                            if (GroupId(subject) === GroupId.UNSPECIFIED_GROUP_ID) {\n                                throw new StatusResponseError(\n                                    \"Subject must be a valid GroupId for Group ACLs\",\n                                    StatusCode.ConstraintError,\n                                );\n                            }\n                        }\n                    }\n                    // TODO For Group authentication, the Group ID identifies the required group, as defined in the Group Key Management Cluster.\n                }\n\n                if (targets !== null) {\n                    for (const target of targets) {\n                        const { deviceType, endpoint, cluster } = target;\n                        if (deviceType !== null && endpoint !== null) {\n                            throw new StatusResponseError(\n                                \"DeviceType and Endpoint are mutually exclusive\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                        if (cluster === null && endpoint === null && deviceType === null) {\n                            throw new StatusResponseError(\n                                \"At least one field must be present\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                        if (cluster !== null && !ClusterId.isValid(cluster)) {\n                            throw new StatusResponseError(\n                                \"Cluster must be a valid ClusterId\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                        if (endpoint !== null && !EndpointNumber.isValid(endpoint)) {\n                            throw new StatusResponseError(\n                                \"Endpoint must be a valid OperationalNodeId\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                        if (deviceType !== null && !DeviceTypeId.isValid(deviceType)) {\n                            throw new StatusResponseError(\n                                \"DeviceType must be a valid DeviceType\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                    }\n                }\n            }\n        },\n\n        aclAttributeSetter: (value, { session }) => {\n            assertSecureSession(session!);\n            // it can happen internally that we set a value for another fabricIndex, so handle this here\n            const fabric = session.context.getFabricByIndex(\n                value[0]?.fabricIndex ?? session.associatedFabric.fabricIndex,\n            );\n            if (fabric === undefined) {\n                throw new InternalError(\"Fabric not found. SHould never happen\");\n            }\n            const oldValue =\n                genericFabricScopedAttributeGetterFromFabric(\n                    fabric,\n                    AccessControlCluster,\n                    \"acl\",\n                    new Array<TypeFromBitmapSchema<typeof AccessControl.TlvAccessControlEntry>>(),\n                ) ?? [];\n\n            const changed = genericFabricScopedAttributeSetterForFabric(fabric, AccessControlCluster, \"acl\", value, []);\n\n            if (changed && accessControlEntryChangedEvent !== undefined) {\n                const adminPasscodeId = session.isPase ? 0 : null;\n                const adminNodeId = adminPasscodeId === null ? session.associatedFabric.rootNodeId : null;\n\n                let i = 0;\n                for (; i < value.length; i++) {\n                    if (!isDeepEqual(value[i], oldValue[i])) {\n                        const changeType =\n                            oldValue[i] === undefined\n                                ? AccessControl.ChangeType.Added\n                                : value[i] === undefined\n                                  ? AccessControl.ChangeType.Removed\n                                  : AccessControl.ChangeType.Changed;\n                        accessControlEntryChangedEvent.triggerEvent({\n                            changeType,\n                            adminNodeId,\n                            adminPasscodeId,\n                            latestValue:\n                                (changeType === AccessControl.ChangeType.Removed ? oldValue[i] : value[i]) ?? null,\n                            fabricIndex: session.associatedFabric.fabricIndex,\n                        });\n                    }\n                }\n                if (oldValue.length > i) {\n                    for (let j = oldValue.length - 1; j >= i; j--) {\n                        accessControlEntryChangedEvent.triggerEvent({\n                            changeType: AccessControl.ChangeType.Removed,\n                            adminNodeId,\n                            adminPasscodeId,\n                            latestValue: oldValue[j],\n                            fabricIndex: session.associatedFabric.fabricIndex,\n                        });\n                    }\n                }\n            }\n            return changed;\n        },\n\n        extensionAttributeGetter: ({ session }) => {\n            return genericFabricScopedAttributeGetter(\n                session,\n                true,\n                AccessControlCluster,\n                \"extension\",\n                new Array<AclExtensionEntry>(),\n            );\n        },\n\n        extensionAttributeValidator: value => {\n            if (value.length === 0) {\n                return;\n            }\n            if (value.length > 1) {\n                throw new StatusResponseError(\"Extension list must contain a single entry\", StatusCode.ConstraintError);\n            }\n\n            // we have exactly one entry\n            const { data } = value[0];\n            if (data.length < 2 || data[0] !== TlvType.List || data[data.length - 1] !== TlvType.EndOfContainer) {\n                // Easier to check that way that it is an Listen without any tags in general\n                throw new StatusResponseError(\"Extension must be a valid TLV\", StatusCode.ConstraintError);\n            }\n            try {\n                const decoded = TlvTaggedList({}, true).decode(data);\n                logger.info(`Extension TLV decoded:`, decoded);\n            } catch (error) {\n                logger.debug(`Extension TLV decoding failed:`, error);\n                throw new StatusResponseError(\"Extension must be a valid TLV\", StatusCode.ConstraintError);\n            }\n        },\n\n        extensionAttributeSetter: (value, { session }) => {\n            assertSecureSession(session!);\n            // it can happen internally that we set a value for another fabricIndex, so handle this here\n            const fabric = session.context.getFabricByIndex(\n                value[0]?.fabricIndex ?? session.associatedFabric.fabricIndex,\n            );\n            if (fabric === undefined) {\n                throw new InternalError(\"Fabric not found. SHould never happen\");\n            }\n            const oldValue =\n                genericFabricScopedAttributeGetterFromFabric(\n                    fabric,\n                    AccessControlCluster,\n                    \"extension\",\n                    new Array<AclExtensionEntry>(),\n                ) ?? [];\n\n            const changed = genericFabricScopedAttributeSetterForFabric(\n                fabric,\n                AccessControlCluster,\n                \"extension\",\n                value,\n                [],\n            );\n\n            if (changed && accessControlExtensionChangedEvent !== undefined) {\n                const changeType =\n                    value.length > oldValue.length\n                        ? AccessControl.ChangeType.Added\n                        : value.length < oldValue.length\n                          ? AccessControl.ChangeType.Removed\n                          : AccessControl.ChangeType.Changed;\n                const adminPasscodeId = session.isPase ? 0 : null;\n                const adminNodeId = adminPasscodeId === null ? session.associatedFabric.rootNodeId : null;\n                accessControlExtensionChangedEvent.triggerEvent({\n                    changeType,\n                    adminNodeId,\n                    adminPasscodeId,\n                    latestValue: (changeType === AccessControl.ChangeType.Removed ? oldValue[0] : value[0]) ?? null,\n                    fabricIndex: session.associatedFabric.fabricIndex,\n                });\n            }\n\n            return changed;\n        },\n    };\n};\n\nexport const createDefaultAccessControlClusterServer = () =>\n    ClusterServer(\n        AccessControlCluster,\n        {\n            acl: [],\n            extension: [],\n            subjectsPerAccessControlEntry: 4,\n            targetsPerAccessControlEntry: 4,\n            accessControlEntriesPerFabric: 4,\n        },\n        AccessControlClusterHandler(),\n        {\n            accessControlEntryChanged: true,\n            accessControlExtensionChanged: true,\n        },\n    );\n"],
  "mappings": "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",
  "names": []
}
