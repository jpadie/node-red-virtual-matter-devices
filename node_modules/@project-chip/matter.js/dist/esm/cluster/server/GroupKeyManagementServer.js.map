{
  "version": 3,
  "sources": ["../../../../src/cluster/server/GroupKeyManagementServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"../../common/MatterError.js\";\nimport { StatusCode, StatusResponseError } from \"../../protocol/interaction/StatusCode.js\";\nimport { assertSecureSession } from \"../../session/SecureSession.js\";\nimport { GroupKeyManagement } from \"../definitions/GroupKeyManagementCluster.js\";\nimport { ClusterServerHandlers } from \"./ClusterServerTypes.js\";\n\nexport const GroupKeyManagementClusterHandler: () => ClusterServerHandlers<typeof GroupKeyManagement.Cluster> = () => ({\n    initializeClusterServer: ({ attributes: { maxGroupKeysPerFabric, maxGroupsPerFabric } }) => {\n        if (maxGroupKeysPerFabric.getLocal() !== 1) {\n            throw new ImplementationError(\"maxGroupKeysPerFabric must be 1 for now.\");\n        }\n        if (maxGroupsPerFabric.getLocal() !== 0) {\n            throw new ImplementationError(\"maxGroupsPerFabric must be 0 for now.\");\n        }\n    },\n\n    groupTableAttributeGetter: () => {\n        return []; // List is always empty because only IPK exists\n    },\n\n    keySetWrite: async () => {\n        throw new StatusResponseError(\n            \"We do not support and additional groups then the IPK\",\n            StatusCode.ResourceExhausted,\n        );\n    },\n\n    keySetRead: async ({ request: { groupKeySetId }, session }) => {\n        assertSecureSession(session);\n        const fabric = session.associatedFabric;\n\n        const groupKeySet = fabric.getGroupKeySet(groupKeySetId);\n        if (groupKeySet === undefined) {\n            throw new StatusResponseError(`GroupKeySet ${groupKeySetId} not found`, StatusCode.NotFound);\n        }\n\n        return {\n            groupKeySet: {\n                ...groupKeySet,\n                epochKey0: null,\n                epochKey1: null,\n                epochKey2: null,\n            },\n        };\n    },\n\n    keySetRemove: async ({ request: { groupKeySetId } }) => {\n        if (groupKeySetId === 0) {\n            throw new StatusResponseError(`GroupKeySet ${groupKeySetId} cannot be removed`, StatusCode.InvalidCommand);\n        }\n\n        // We only have key 0, so we can't remove it\n        throw new StatusResponseError(`GroupKeySet ${groupKeySetId} not found`, StatusCode.NotFound);\n    },\n\n    keySetReadAllIndices: async ({ session }) => {\n        assertSecureSession(session);\n        const fabric = session.associatedFabric;\n\n        const groupKeySetIDs = fabric.getAllGroupKeySets().map(({ groupKeySetId }) => groupKeySetId);\n\n        return {\n            groupKeySetIDs,\n        };\n    },\n});\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,2BAA2B;AACpC,SAAS,YAAY,2BAA2B;AAChD,SAAS,2BAA2B;AAI7B,MAAM,mCAAmG,OAAO;AAAA,EACnH,yBAAyB,CAAC,EAAE,YAAY,EAAE,uBAAuB,mBAAmB,EAAE,MAAM;AACxF,QAAI,sBAAsB,SAAS,MAAM,GAAG;AACxC,YAAM,IAAI,oBAAoB,0CAA0C;AAAA,IAC5E;AACA,QAAI,mBAAmB,SAAS,MAAM,GAAG;AACrC,YAAM,IAAI,oBAAoB,uCAAuC;AAAA,IACzE;AAAA,EACJ;AAAA,EAEA,2BAA2B,MAAM;AAC7B,WAAO,CAAC;AAAA,EACZ;AAAA,EAEA,aAAa,YAAY;AACrB,UAAM,IAAI;AAAA,MACN;AAAA,MACA,WAAW;AAAA,IACf;AAAA,EACJ;AAAA,EAEA,YAAY,OAAO,EAAE,SAAS,EAAE,cAAc,GAAG,QAAQ,MAAM;AAC3D,wBAAoB,OAAO;AAC3B,UAAM,SAAS,QAAQ;AAEvB,UAAM,cAAc,OAAO,eAAe,aAAa;AACvD,QAAI,gBAAgB,QAAW;AAC3B,YAAM,IAAI,oBAAoB,eAAe,aAAa,cAAc,WAAW,QAAQ;AAAA,IAC/F;AAEA,WAAO;AAAA,MACH,aAAa;AAAA,QACT,GAAG;AAAA,QACH,WAAW;AAAA,QACX,WAAW;AAAA,QACX,WAAW;AAAA,MACf;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,cAAc,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM;AACpD,QAAI,kBAAkB,GAAG;AACrB,YAAM,IAAI,oBAAoB,eAAe,aAAa,sBAAsB,WAAW,cAAc;AAAA,IAC7G;AAGA,UAAM,IAAI,oBAAoB,eAAe,aAAa,cAAc,WAAW,QAAQ;AAAA,EAC/F;AAAA,EAEA,sBAAsB,OAAO,EAAE,QAAQ,MAAM;AACzC,wBAAoB,OAAO;AAC3B,UAAM,SAAS,QAAQ;AAEvB,UAAM,iBAAiB,OAAO,mBAAmB,EAAE,IAAI,CAAC,EAAE,cAAc,MAAM,aAAa;AAE3F,WAAO;AAAA,MACH;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
