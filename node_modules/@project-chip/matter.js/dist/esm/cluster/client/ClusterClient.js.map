{
  "version": 3,
  "sources": ["../../../../src/cluster/client/ClusterClient.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { DecodedEventData } from \"../../protocol/interaction/EventDataDecoder.js\";\nimport { InteractionClient } from \"../../protocol/interaction/InteractionClient.js\";\nimport { TlvEventFilter } from \"../../protocol/interaction/InteractionProtocol.js\";\nimport { StatusCode, StatusResponseError } from \"../../protocol/interaction/StatusCode.js\";\nimport { TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { capitalize } from \"../../util/String.js\";\nimport { Merge } from \"../../util/Type.js\";\nimport { Attribute, Command, Event, GlobalAttributes, UnknownAttribute, UnknownEvent } from \"../Cluster.js\";\nimport { ClusterType } from \"../ClusterType.js\";\nimport { AttributeServerValues } from \"../server/ClusterServerTypes.js\";\nimport { createAttributeClient } from \"./AttributeClient.js\";\nimport { AttributeClients, ClusterClientObj, EventClients, SignatureFromCommandSpec } from \"./ClusterClientTypes.js\";\nimport { createEventClient } from \"./EventClient.js\";\n\nconst logger = Logger.get(\"ClusterClient\");\n\nexport function ClusterClient<const T extends ClusterType>(\n    clusterDef: T,\n    endpointId: EndpointNumber,\n    interactionClient: InteractionClient,\n    globalAttributeValues: Partial<AttributeServerValues<GlobalAttributes<T[\"features\"]>>> = {},\n): ClusterClientObj<T> {\n    function addAttributeToResult(attribute: Attribute<any, any>, attributeName: string) {\n        (attributes as any)[attributeName] = createAttributeClient(\n            attribute,\n            attributeName,\n            endpointId,\n            clusterId,\n            interactionClient,\n            !!globalAttributeValues?.attributeList?.includes(attribute.id),\n        );\n        attributeToId[attribute.id] = attributeName;\n        const capitalizedAttributeName = capitalize(attributeName);\n        result[`get${capitalizedAttributeName}Attribute`] = async (\n            alwaysRequestFromRemote?: boolean,\n            isFabricFiltered = true,\n        ) => {\n            try {\n                return await (attributes as any)[attributeName].get(alwaysRequestFromRemote, isFabricFiltered);\n            } catch (e) {\n                if (StatusResponseError.is(e, StatusCode.UnsupportedAttribute)) {\n                    return undefined;\n                }\n                throw e;\n            }\n        };\n        result[`set${capitalizedAttributeName}Attribute`] = async <T>(value: T, dataVersion?: number) =>\n            (attributes as any)[attributeName].set(value, dataVersion);\n        result[`subscribe${capitalizedAttributeName}Attribute`] = async <T>(\n            listener: (value: T) => void,\n            minIntervalS: number,\n            maxIntervalS: number,\n            knownDataVersion?: number,\n            isFabricFiltered?: boolean,\n        ) => {\n            (attributes as any)[attributeName].addListener(listener);\n            return (attributes as any)[attributeName].subscribe(\n                minIntervalS,\n                maxIntervalS,\n                knownDataVersion,\n                isFabricFiltered,\n            );\n        };\n        result[`add${capitalizedAttributeName}AttributeListener`] = <T>(listener: (value: T) => void) => {\n            (attributes as any)[attributeName].addListener(listener);\n        };\n    }\n\n    function addEventToResult(event: Event<any, any>, eventName: string) {\n        (events as any)[eventName] = createEventClient(\n            event,\n            eventName,\n            endpointId,\n            clusterId,\n            interactionClient,\n            !!globalAttributeValues?.eventList?.includes(event.id),\n        );\n        eventToId[event.id] = eventName;\n        const capitalizedEventName = capitalize(eventName);\n        result[`get${capitalizedEventName}Event`] = async (\n            minimumEventNumber?: number | bigint,\n            isFabricFiltered?: boolean,\n        ) => {\n            try {\n                return await (events as any)[eventName].get(minimumEventNumber, isFabricFiltered);\n            } catch (e) {\n                if (StatusResponseError.is(e, StatusCode.UnsupportedEvent)) {\n                    return undefined;\n                }\n                throw e;\n            }\n        };\n        result[`subscribe${capitalizedEventName}Event`] = async <T>(\n            listener: (value: DecodedEventData<T>) => void,\n            minIntervalS: number,\n            maxIntervalS: number,\n            isUrgent?: boolean,\n            minimumEventNumber?: number | bigint,\n            isFabricFiltered?: boolean,\n        ) => {\n            (events as any)[eventName].addListener(listener);\n            return (events as any)[eventName].subscribe(\n                minIntervalS,\n                maxIntervalS,\n                isUrgent,\n                minimumEventNumber,\n                isFabricFiltered,\n            );\n        };\n        result[`add${capitalizedEventName}EventListener`] = <T>(listener: (value: DecodedEventData<T>) => void) => {\n            (events as any)[eventName].addListener(listener);\n        };\n    }\n\n    const {\n        id: clusterId,\n        name,\n        commands: commandDef,\n        attributes: attributeDef,\n        events: eventDef,\n        features,\n        supportedFeatures,\n        revision,\n        unknown,\n    } = clusterDef;\n    const attributes = <AttributeClients<T[\"features\"], T[\"attributes\"]>>{};\n    const events = <EventClients<T[\"events\"]>>{};\n    const commands = <{ [P in keyof T[\"commands\"]]: SignatureFromCommandSpec<T[\"commands\"][P]> }>{};\n\n    let reportedFeatures: TypeFromPartialBitSchema<T[\"features\"]> | undefined = undefined;\n    // If we have global attribute values we use them to modify\n    if (globalAttributeValues !== undefined) {\n        if (globalAttributeValues.featureMap !== undefined) {\n            reportedFeatures = globalAttributeValues.featureMap;\n        }\n    }\n\n    const result: any = {\n        id: clusterId,\n        name,\n        revision: globalAttributeValues?.clusterRevision ?? revision,\n        _type: \"ClusterClient\",\n        supportedFeatures: reportedFeatures ?? supportedFeatures ?? {},\n        isUnknown: unknown,\n        endpointId,\n        attributes,\n        events,\n        commands,\n        subscribeAllAttributes: async (options: {\n            minIntervalFloorSeconds: number;\n            maxIntervalCeilingSeconds: number;\n            keepSubscriptions?: boolean;\n            isFabricFiltered?: boolean;\n            eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n            dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n        }) => {\n            const {\n                minIntervalFloorSeconds,\n                maxIntervalCeilingSeconds,\n                keepSubscriptions,\n                isFabricFiltered,\n                eventFilters,\n                dataVersionFilters,\n            } = options;\n\n            return interactionClient.subscribeMultipleAttributesAndEvents({\n                attributes: [{ endpointId: endpointId, clusterId: clusterId }],\n                events: [{ endpointId: endpointId, clusterId: clusterId }],\n                minIntervalFloorSeconds,\n                maxIntervalCeilingSeconds,\n                keepSubscriptions,\n                isFabricFiltered,\n                eventFilters,\n                dataVersionFilters,\n                attributeListener: attributeData => {\n                    const { path, value } = attributeData;\n                    result._triggerAttributeUpdate(path.attributeId, value);\n                },\n                eventListener: eventData => {\n                    const { path, events: newEvents } = eventData;\n                    result._triggerEventUpdate(path.eventId, newEvents);\n                },\n            });\n        },\n\n        /** Trigger a value change for an Attributed, used by subscriptions. */\n        _triggerAttributeUpdate(attributeId: AttributeId, value: any) {\n            const attributeName = attributeToId[attributeId];\n            if (attributeName === undefined) {\n                logger.warn(\"Unknown attribute id\", attributeId);\n                return;\n            }\n            if ((attributes as any)[attributeName] !== undefined) {\n                (attributes as any)[attributeName].update(value);\n            } else {\n                logger.warn(\"Attribute not found\", attributeName, \"in list\", Object.keys(attributes));\n            }\n        },\n\n        /** Trigger a value change for an Event, used by subscriptions. */\n        _triggerEventUpdate(eventId: EventId, eventData: DecodedEventData<any>[]) {\n            const eventName = eventToId[eventId];\n            if (eventName === undefined) {\n                logger.warn(\"Unknown event id\", eventId);\n                return;\n            }\n            if ((events as any)[eventName] !== undefined) {\n                const event = (events as any)[eventName];\n                eventData.forEach(data => event.update(data));\n            } else {\n                logger.warn(\"Event not found\", eventName, \"in list\", Object.keys(events));\n            }\n        },\n\n        isAttributeSupported: (attributeId: AttributeId) => {\n            return !!globalAttributeValues?.attributeList?.includes(attributeId);\n        },\n\n        isAttributeSupportedByName: (attributeName: string) => {\n            const attribute = (attributes as any)[attributeName];\n            if (attribute === undefined) {\n                return false;\n            }\n            return !!globalAttributeValues?.attributeList?.includes(attribute.id);\n        },\n\n        isEventSupported: (eventId: EventId) => {\n            return !!globalAttributeValues?.eventList?.includes(eventId);\n        },\n\n        isEventSupportedByName: (eventName: string) => {\n            const event = (events as any)[eventName];\n            if (event === undefined) {\n                return false;\n            }\n            return !!globalAttributeValues?.eventList?.includes(event.id);\n        },\n\n        isCommandSupported: (commandId: CommandId) => {\n            return !!globalAttributeValues?.acceptedCommandList?.includes(commandId);\n        },\n\n        isCommandSupportedByName: (commandName: string) => {\n            const command = commandDef[commandName];\n            if (command === undefined) {\n                return false;\n            }\n            return !!globalAttributeValues?.acceptedCommandList?.includes(command.requestId);\n        },\n    };\n\n    const attributeToId = <{ [key: AttributeId]: string }>{};\n\n    const allAttributeDefs = Merge<T[\"attributes\"], GlobalAttributes<T[\"features\"]>>(\n        attributeDef,\n        GlobalAttributes(features),\n    );\n\n    // Add accessors from definition\n    for (const attributeName in allAttributeDefs) {\n        addAttributeToResult(allAttributeDefs[attributeName], attributeName);\n    }\n    if (globalAttributeValues?.attributeList !== undefined) {\n        // Add accessors for potential unknown data\n        for (const attributeId of globalAttributeValues.attributeList) {\n            if (attributeToId[attributeId] === undefined) {\n                const attribute = UnknownAttribute(attributeId);\n                addAttributeToResult(attribute, `unknownAttribute_${Diagnostic.hex(attributeId)}`);\n                logger.info(\n                    `Added unknown attribute ${Diagnostic.hex(attributeId)} to cluster ${Diagnostic.hex(clusterId)}`,\n                );\n            }\n        }\n    }\n\n    const eventToId = <{ [key: EventId]: string }>{};\n\n    // add events\n    for (const eventName in eventDef) {\n        addEventToResult(eventDef[eventName], eventName);\n    }\n    if (globalAttributeValues?.eventList !== undefined) {\n        // Add accessors for potential unknown data\n        for (const eventId of globalAttributeValues.eventList) {\n            if (eventToId[eventId] === undefined) {\n                const event = UnknownEvent(eventId);\n                addEventToResult(event, `unknownEvent_${Diagnostic.hex(eventId)}`);\n                logger.info(`Added unknown event ${Diagnostic.hex(eventId)} to cluster ${Diagnostic.hex(clusterId)}.`);\n            }\n        }\n    }\n\n    const commandToId = <{ [key: CommandId]: string }>{};\n\n    // Add command calls\n    for (const commandName in commandDef) {\n        const { requestId } = commandDef[commandName];\n\n        commandToId[requestId] = commandName;\n        commands[commandName as keyof T[\"commands\"]] = async <RequestT, ResponseT>(\n            request: RequestT,\n            options: {\n                asTimedRequest?: boolean;\n                timedRequestTimeoutMs?: number;\n                useExtendedFailSafeMessageResponseTimeout?: boolean;\n            } = {},\n        ) => {\n            const { asTimedRequest, timedRequestTimeoutMs, useExtendedFailSafeMessageResponseTimeout } = options;\n            return interactionClient.invoke<Command<RequestT, ResponseT, any>>({\n                endpointId,\n                clusterId,\n                command: commandDef[commandName],\n                request,\n                asTimedRequest,\n                timedRequestTimeoutMs,\n                useExtendedFailSafeMessageResponseTimeout,\n            });\n        };\n        result[commandName] = result.commands[commandName];\n    }\n    if (globalAttributeValues?.acceptedCommandList !== undefined) {\n        for (const requestId of globalAttributeValues.acceptedCommandList) {\n            if (commandToId[requestId] === undefined) {\n                logger.info(`Ignoring unknown command ${requestId} at cluster ${Diagnostic.hex(clusterId)}`);\n            }\n        }\n    }\n\n    return result as ClusterClientObj<T>;\n}\n"],
  "mappings": "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",
  "names": []
}
