{
  "version": 3,
  "sources": ["../../../../src/cluster/mutation/ClusterComposer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterError } from \"../../common/MatterError.js\";\nimport { BitFlags } from \"../../schema/BitmapSchema.js\";\nimport { isDeepEqual } from \"../../util/DeepEqual.js\";\nimport { camelize, serialize } from \"../../util/String.js\";\nimport { ClusterType } from \"../ClusterType.js\";\n\nexport class IllegalClusterError extends MatterError {}\n\n/**\n * A \"cluster composer\" manages cluster configuration based on feature selection.\n */\nexport class ClusterComposer<const T extends ClusterType> {\n    constructor(public cluster: T) {}\n\n    /**\n     * Build a cluster using selected feature flags.\n     *\n     * @param selection the name(s) of optional features to support\n     * @throws {IllegalClusterError} if the feature combination is disallowed by the Matter specification\n     */\n    compose<const SelectionT extends ClusterComposer.FeatureSelection<T>>(selection: SelectionT) {\n        this.validateFeatureSelection(selection);\n\n        const extensions = this.cluster.extensions;\n        let cluster: ClusterType;\n\n        if (extensions) {\n            const base = this.cluster.base ?? this.cluster;\n\n            const baseElements = (type: \"attributes\" | \"commands\" | \"events\") => {\n                const elements = {} as Record<string, any>;\n                const clusterElements = this.cluster[type];\n                for (const name in base[type]) {\n                    elements[name] = clusterElements[name] ?? base[type][name];\n                }\n                return elements;\n            };\n\n            cluster = ClusterType({\n                ...base,\n                attributes: baseElements(\"attributes\"),\n                commands: baseElements(\"commands\"),\n                events: baseElements(\"events\"),\n                supportedFeatures: BitFlags(this.cluster.features, ...selection),\n                base,\n            });\n\n            for (const selector of extensions) {\n                if (selector.component) {\n                    this.accept(cluster, selector.component, this.cluster, selector.flags);\n                } else {\n                    this.reject(cluster, selector.flags);\n                }\n            }\n        } else {\n            const supportedFeatures = BitFlags(this.cluster.features, ...selection);\n            if (isDeepEqual(supportedFeatures, this.cluster.supportedFeatures)) {\n                cluster = this.cluster;\n            } else {\n                cluster = ClusterType({\n                    ...this.cluster,\n                    supportedFeatures,\n                    base: this.cluster.base ?? this.cluster,\n                });\n            }\n        }\n\n        return cluster as ClusterComposer.Of<T, SelectionT>;\n    }\n\n    /**\n     * Validates a set of feature flags against the features supported by a cluster.\n     */\n    private validateFeatureSelection(features: ClusterComposer.FeatureSelection<any>) {\n        for (const f of features) {\n            if (!this.cluster.features[camelize(f)]) {\n                throw new IllegalClusterError(`\"${f}\" is not a valid feature identifier`);\n            }\n        }\n    }\n\n    /**\n     * Injects a component into a cluster if the cluster supports the specified features.  Uses matching element from\n     * \"original\" if present.  This allows for component insertion without overwrite of other changes to the named\n     * element.\n     */\n    private accept(\n        definition: ClusterComposer.WritableDefinition,\n        component: Partial<ClusterType.Elements>,\n        original: Partial<ClusterType> | undefined,\n        flags: ClusterComposer.FeatureFlags,\n    ) {\n        for (const k in flags) {\n            if (!!definition.supportedFeatures[k] !== !!flags[k]) {\n                return;\n            }\n        }\n\n        ClusterComposer.injectElements(definition, component, original);\n    }\n\n    static injectElements(\n        definition: Partial<ClusterType.Options>,\n        component: Partial<ClusterType.Options>,\n        original?: Partial<ClusterType>,\n    ) {\n        function installElements(name: \"attributes\" | \"commands\" | \"events\") {\n            const src = component[name];\n            if (!src) {\n                return;\n            }\n\n            let dest = definition[name] as Record<string, unknown> | undefined;\n            if (dest) {\n                dest = { ...dest } as Record<string, unknown>;\n            } else {\n                dest = {};\n            }\n            (definition as Record<string, unknown>)[name] = dest;\n\n            for (const key in src) {\n                const orig = original?.[name]?.[key];\n                if (orig) {\n                    dest[key] = orig;\n                } else {\n                    dest[key] = src[key];\n                }\n            }\n        }\n\n        installElements(\"attributes\");\n        installElements(\"commands\");\n        installElements(\"events\");\n    }\n\n    /**\n     * Throws an error if a feature combination is illegal per the Matter specification.\n     */\n    private reject(definition: ClusterType, flags: ClusterComposer.FeatureFlags) {\n        for (const k in flags) {\n            if (!!definition.supportedFeatures[k] !== !!flags[k]) {\n                return;\n            }\n        }\n        throw new IllegalClusterError(\n            `Feature combination ${serialize(flags)} is disallowed by the Matter specification`,\n        );\n    }\n}\n\nexport namespace ClusterComposer {\n    export type Component = Partial<ClusterType.Elements>;\n\n    /**\n     * An array of names indicating features to be injected.\n     */\n    export type FeatureSelection<T extends ClusterType> = readonly Capitalize<string & keyof T[\"features\"]>[];\n\n    /**\n     * A set of boolean values indicating whether a feature is enabled.\n     */\n    export type FeatureFlags = Record<string, boolean | undefined>;\n\n    /**\n     * Describes the output of {@link ClusterComposer.compose}.\n     */\n    export type Of<ClusterT extends ClusterType, FeaturesT extends FeatureSelection<ClusterT>> = WithFeatures<\n        ClusterT,\n        FeaturesT\n    >;\n\n    /**\n     * The base of a cluster.\n     */\n    export type BaseOf<T extends ClusterType> = T[\"base\"] extends ClusterType ? T[\"base\"] : T;\n\n    /**\n     * The result of composition.\n     */\n    export type WithFeatures<ClusterT extends ClusterType, FeaturesT extends FeatureSelection<BaseOf<ClusterT>>> = Omit<\n        BaseOf<ClusterT>,\n        \"supportedFeatures\" | \"base\" | ElementType\n    > & {\n        supportedFeatures: FeaturesAsFlags<BaseOf<ClusterT>, FeaturesT>;\n        base: BaseOf<ClusterT>;\n    } & ExtendedElements<\n            ClusterT,\n            SelectedElements<\n                FeaturesAsFlags<ClusterT, FeaturesT>,\n                ClusterT[\"extensions\"] extends object ? ClusterT[\"extensions\"] : []\n            >\n        >;\n\n    /**\n     * Convert a {@link FeatureSelection} array into a {@link FeatureFlags} object.\n     */\n    export type FeaturesAsFlags<ClusterT extends ClusterType, FlagsT extends FeatureSelection<ClusterT>> = {\n        [K in keyof ClusterT[\"features\"]]: K extends string\n            ? Capitalize<K> extends `${FlagsT[number]}`\n                ? true\n                : false\n            : never;\n\n        // Formerly we used this.  TS bugs (as of 5.4) caused this to fail to match in specific circumstances.  See\n        // ClusterComposerTest \"extends with default components\"\n        //[K in keyof ClusterT[\"features\"]]: K extends Uncapitalize<FlagsT[number]> ? true : false;\n    };\n\n    /**\n     * Choose elements from applicable extensions.\n     */\n    export type SelectedElements<\n        FlagsT extends FeatureFlags,\n        extensionsT extends readonly ClusterType.Extension[],\n    > = extensionsT extends readonly [\n        infer S extends ClusterType.Extension,\n        ...infer R extends readonly ClusterType.Extension[],\n    ]\n        ? SelectorContribution<FlagsT, S> & SelectedElements<FlagsT, R>\n        : {};\n\n    /**\n     * Determine the type contributed to feature selection by a specific selector.\n     */\n    export type SelectorContribution<\n        FlagsT extends FeatureFlags,\n        SelectorT extends ClusterType.Extension,\n    > = FlagsT extends SelectorT[\"flags\"]\n        ? SelectorT[\"component\"] extends false\n            ? never\n            : SelectorT[\"component\"] & { attributes: {}; commands: {}; events: {} }\n        : { attributes: {}; commands: {}; events: {} };\n\n    /**\n     * Cluster elements extended with .\n     *\n     * Note that we have to track the base separate from the originating cluster.  If we are removing features, we want\n     * to maintain only those features present in the base or selected components.\n     */\n    export type ExtendedElements<ClusterT extends ClusterType, ComponentT extends Component> = [ComponentT] extends [\n        never,\n    ]\n        ? never\n        : {\n              [TypeT in ElementType]: Pick<\n                  // Include elements in current cluster if valid according to base and extensions\n                  ClusterT[TypeT],\n                  keyof ClusterT[TypeT] & (keyof BaseOf<ClusterT>[TypeT] | keyof ComponentT[TypeT])\n              > &\n                  // Include extension elements if not present in current cluster\n                  Omit<ComponentT[TypeT], keyof ClusterT[TypeT]> &\n                  // Include base elements if not present in current cluster or extensions\n                  Omit<BaseOf<ClusterT>[TypeT], keyof ClusterT[TypeT] | keyof ComponentT[TypeT]>;\n          };\n\n    /**\n     * A cluster extended by multiple components.\n     */\n    export type WithComponents<ClusterT extends ClusterType, RestT extends Component[]> = RestT extends [\n        infer ComponentT extends Component,\n        ...infer RestT extends Component[],\n    ]\n        ? WithComponents<Omit<ClusterT, ElementType> & ExtendedElements<ClusterT, ComponentT>, RestT>\n        : ClusterT;\n\n    /**\n     * A \"WritableDefinition\" is a Cluster with fields that may be modified.\n     */\n    export type WritableDefinition = {\n        -readonly [Key in keyof ClusterType]: ClusterType[Key];\n    };\n\n    export type ElementType = \"attributes\" | \"commands\" | \"events\";\n}\n"],
  "mappings": "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",
  "names": []
}
