{
  "version": 3,
  "sources": ["../../../../src/cluster/mutation/MutableCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { ConditionalFeatureList } from \"../Cluster.js\";\nimport { ClusterType } from \"../ClusterType.js\";\nimport { ClusterComposer } from \"./ClusterComposer.js\";\nimport { ElementModifier } from \"./ElementModifier.js\";\n\n/**\n * A \"mutable cluster\" is a {@link ClusterType} with builder methods that support a limited number of modifications as\n * defined by the Matter specification.\n */\nexport type MutableCluster<\n    T extends ClusterType.Options,\n    C extends ClusterComposer.Component[] = [],\n> = ClusterComposer.WithComponents<ClusterType.Of<T>, C> & MutableCluster.Methods<ClusterType.Of<T>>;\n\n/**\n * Define a new {@link MutableCluster}.\n */\nexport function MutableCluster<const T extends ClusterType.Options, const C extends ClusterComposer.Component[]>(\n    options: T,\n    ...components: C\n) {\n    const cluster = ClusterType(options);\n\n    for (const component of components) {\n        ClusterComposer.injectElements(cluster, component);\n    }\n\n    Object.assign(cluster, {\n        with(...features: ClusterComposer.FeatureSelection<typeof cluster>) {\n            return new ClusterComposer(cluster).compose(features);\n        },\n\n        alter(alterations: ElementModifier.Alterations<typeof cluster>) {\n            return new ElementModifier(cluster).alter(alterations);\n        },\n\n        set(values: ClusterType.InputAttributeValues<typeof cluster>) {\n            return new ElementModifier(cluster).set(values);\n        },\n\n        enable(flags: ElementModifier.ElementFlags<typeof cluster>) {\n            return new ElementModifier(cluster).enable(flags);\n        },\n    });\n\n    return cluster as MutableCluster<T, C>;\n}\n\nexport namespace MutableCluster {\n    /**\n     * Define a component.\n     */\n    export function Component<const T extends Partial<ClusterType.Options>>(elements: T) {\n        return elements;\n    }\n\n    /**\n     * Define a cluster's extension set.\n     */\n    export function Extensions<const T extends readonly ClusterType.Extension[]>(...extensions: T) {\n        return extensions;\n    }\n\n    export interface Methods<T extends ClusterType> {\n        /**\n         * Select features using {@link ClusterComposer.compose}.\n         */\n        with<const SelectionT extends ClusterComposer.FeatureSelection<T>>(\n            ...selection: SelectionT\n        ): ClusterComposer.Of<T, SelectionT>;\n\n        /**\n         * Modify elements using {@link ElementModifier.alter}.\n         */\n        alter<const AlterationsT extends ElementModifier.Alterations<T>>(\n            alterations: AlterationsT,\n        ): ElementModifier.WithAlterations<T, AlterationsT>;\n\n        /**\n         * Modify elements using {@link ElementModifier.set}.\n         */\n        set<const ValuesT extends ClusterType.InputAttributeValues<T>>(\n            values: ValuesT,\n        ): ElementModifier.WithValues<T, ValuesT>;\n\n        /**\n         * Modify elements using {@link ElementModifier.enable}.\n         */\n        enable<const FlagsT extends ElementModifier.ElementFlags<T>>(\n            flags: FlagsT,\n        ): ElementModifier.WithFlags<T, FlagsT>;\n    }\n\n    /**\n     * ExtensibleOnly creates a factory that produces a {@link MutableCluster} when the user selects features.\n     *\n     * We define clusters this way if the Matter specification defines a cluster with a set of features, one of which is\n     * required, but none of which is required if others are enabled.\n     */\n    export interface ExtensibleOnly<T extends ClusterType.Options> {\n        id: ClusterId;\n        name: string;\n\n        with: Methods<ClusterType.Of<T>>[\"with\"];\n    }\n\n    /**\n     * Create a factory for clusters that require extension.\n     */\n    export function ExtensibleOnly<const T extends ClusterType.Options>(options: T) {\n        return {\n            id: options.id,\n            name: options.name,\n\n            with(...features: ClusterComposer.FeatureSelection<ClusterType.Of<T>>) {\n                return new ClusterComposer(ClusterType(options)).compose(features);\n            },\n        } as ExtensibleOnly<T>;\n    }\n\n    /**\n     * Create a conditional version of an unconditional element definition.\n     */\n    export function AsConditional<\n        const ClusterT extends ClusterType,\n        const E extends ClusterType.Attribute | ClusterType.Command | ClusterType.Event,\n        const OI extends ConditionalFeatureList<ClusterT[\"features\"]>,\n        const MI extends ConditionalFeatureList<ClusterT[\"features\"]>,\n    >(element: E, { optionalIf, mandatoryIf }: { optionalIf?: OI; mandatoryIf?: MI }) {\n        return {\n            ...element,\n            optional: true,\n            isConditional: true,\n            optionalIf: optionalIf ?? [],\n            mandatoryIf: mandatoryIf ?? [],\n        } as const;\n    }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,SAAS,mBAAmB;AAC5B,SAAS,uBAAuB;AAChC,SAAS,uBAAuB;AAczB,SAAS,eACZ,YACG,YACL;AACE,QAAM,UAAU,YAAY,OAAO;AAEnC,aAAW,aAAa,YAAY;AAChC,oBAAgB,eAAe,SAAS,SAAS;AAAA,EACrD;AAEA,SAAO,OAAO,SAAS;AAAA,IACnB,QAAQ,UAA4D;AAChE,aAAO,IAAI,gBAAgB,OAAO,EAAE,QAAQ,QAAQ;AAAA,IACxD;AAAA,IAEA,MAAM,aAA0D;AAC5D,aAAO,IAAI,gBAAgB,OAAO,EAAE,MAAM,WAAW;AAAA,IACzD;AAAA,IAEA,IAAI,QAA0D;AAC1D,aAAO,IAAI,gBAAgB,OAAO,EAAE,IAAI,MAAM;AAAA,IAClD;AAAA,IAEA,OAAO,OAAqD;AACxD,aAAO,IAAI,gBAAgB,OAAO,EAAE,OAAO,KAAK;AAAA,IACpD;AAAA,EACJ,CAAC;AAED,SAAO;AACX;AAAA,CAEO,CAAUA,oBAAV;AAII,WAAS,UAAwD,UAAa;AACjF,WAAO;AAAA,EACX;AAFO,EAAAA,gBAAS;AAOT,WAAS,cAAgE,YAAe;AAC3F,WAAO;AAAA,EACX;AAFO,EAAAA,gBAAS;AAkDT,WAAS,eAAoD,SAAY;AAC5E,WAAO;AAAA,MACH,IAAI,QAAQ;AAAA,MACZ,MAAM,QAAQ;AAAA,MAEd,QAAQ,UAA+D;AACnE,eAAO,IAAI,gBAAgB,YAAY,OAAO,CAAC,EAAE,QAAQ,QAAQ;AAAA,MACrE;AAAA,IACJ;AAAA,EACJ;AATO,EAAAA,gBAAS;AAcT,WAAS,cAKd,SAAY,EAAE,YAAY,YAAY,GAA0C;AAC9E,WAAO;AAAA,MACH,GAAG;AAAA,MACH,UAAU;AAAA,MACV,eAAe;AAAA,MACf,YAAY,cAAc,CAAC;AAAA,MAC3B,aAAa,eAAe,CAAC;AAAA,IACjC;AAAA,EACJ;AAbO,EAAAA,gBAAS;AAAA,GA3EH;",
  "names": ["MutableCluster"]
}
