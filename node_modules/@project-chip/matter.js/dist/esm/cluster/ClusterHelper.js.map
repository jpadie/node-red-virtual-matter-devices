{
  "version": 3,
  "sources": ["../../../src/cluster/ClusterHelper.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AttributeId } from \"../datatype/AttributeId.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { CommandId } from \"../datatype/CommandId.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { EventId } from \"../datatype/EventId.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { TlvAttributePath, TlvCommandPath, TlvEventPath } from \"../protocol/interaction/InteractionProtocol.js\";\nimport { TypeFromSchema } from \"../tlv/TlvSchema.js\";\nimport { Attribute, Cluster, Command, Event } from \"./Cluster.js\";\nimport { ClusterRegistry } from \"./ClusterRegistry.js\";\n\n// Ensure all clusters register\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport \"./definitions/index.js\";\n\nconst logger = Logger.get(\"ClusterHelper\");\n\ninterface CachedAttributeInfo {\n    attribute: Attribute<any, any>;\n    name: string;\n}\ninterface CachedEventInfo {\n    event: Event<any, any>;\n    name: string;\n}\ninterface CachedCommandInfo {\n    command: Command<any, any, any>;\n    name: string;\n}\nconst clusterAttributeCache = new Map<ClusterId, Map<AttributeId, CachedAttributeInfo>>();\nconst clusterEventCache = new Map<ClusterId, Map<EventId, CachedEventInfo>>();\nconst clusterCommandCache = new Map<ClusterId, Map<CommandId, CachedCommandInfo>>();\n\nexport const UnknownCluster = (clusterId: ClusterId) =>\n    Cluster({\n        id: clusterId,\n        name: `Unknown cluster ${toHex(clusterId)}`,\n        revision: 0,\n        unknown: true,\n    });\n\nexport function getClusterNameById(clusterId: ClusterId): string {\n    return ClusterRegistry.get(clusterId)?.name ?? `Unknown cluster ${Diagnostic.hex(clusterId)}`;\n}\n\nexport function getClusterById(clusterId: ClusterId): Cluster<any, any, any, any, any> {\n    let cluster = ClusterRegistry.get(clusterId);\n    if (cluster === undefined) {\n        logger.info(`Unknown cluster ${toHex(clusterId)} requested: UnknownCluster instance added.`);\n        cluster = UnknownCluster(clusterId);\n        ClusterRegistry.register(cluster);\n    }\n    return cluster;\n}\n\nexport function getClusterAttributeById(\n    clusterDef: Cluster<any, any, any, any, any>,\n    attributeId: AttributeId,\n): CachedAttributeInfo | undefined {\n    if (!clusterAttributeCache.has(clusterDef.id)) {\n        const attributeMap = new Map<AttributeId, CachedAttributeInfo>();\n\n        const { attributes } = clusterDef;\n\n        // Add accessors\n        for (const attributeName in attributes) {\n            const attribute = attributes[attributeName];\n            attributeMap.set(attribute.id, { attribute, name: attributeName });\n        }\n\n        clusterAttributeCache.set(clusterDef.id, attributeMap);\n        return attributeMap.get(attributeId);\n    }\n    const attributeMap = clusterAttributeCache.get(clusterDef.id);\n    if (attributeMap === undefined) {\n        return undefined;\n    }\n    return attributeMap.get(attributeId);\n}\n\nexport function getClusterEventById(\n    clusterDef: Cluster<any, any, any, any, any>,\n    eventId: EventId,\n): CachedEventInfo | undefined {\n    if (!clusterEventCache.has(clusterDef.id)) {\n        const eventMap = new Map<EventId, CachedEventInfo>();\n\n        const { events } = clusterDef;\n\n        // Add accessors\n        for (const eventName in events) {\n            const event = events[eventName];\n            eventMap.set(event.id, { event, name: eventName });\n        }\n\n        clusterEventCache.set(clusterDef.id, eventMap);\n        return eventMap.get(eventId);\n    }\n    const eventMap = clusterEventCache.get(clusterDef.id);\n    if (eventMap === undefined) {\n        return undefined;\n    }\n    return eventMap.get(eventId);\n}\n\nexport function getClusterCommandById(\n    clusterDef: Cluster<any, any, any, any, any>,\n    commandId: CommandId,\n): CachedCommandInfo | undefined {\n    if (!clusterCommandCache.has(clusterDef.id)) {\n        const commandMap = new Map<CommandId, CachedCommandInfo>();\n\n        const { commands } = clusterDef;\n\n        // Add accessors\n        for (const commandName in commands) {\n            const command = commands[commandName];\n            commandMap.set(command.requestId, { command, name: commandName });\n        }\n\n        clusterCommandCache.set(clusterDef.id, commandMap);\n        return commandMap.get(commandId);\n    }\n    const commandMap = clusterCommandCache.get(clusterDef.id);\n    if (commandMap === undefined) {\n        return undefined;\n    }\n    return commandMap.get(commandId);\n}\n\nfunction toHex(value: number | bigint | undefined) {\n    return value === undefined ? \"*\" : `0x${value.toString(16)}`;\n}\n\nfunction resolveEndpointClusterName(\n    nodeId: NodeId | undefined,\n    endpointId: EndpointNumber | undefined,\n    clusterId: ClusterId | undefined,\n) {\n    let elementName = nodeId === undefined ? \"\" : `${toHex(nodeId)}/`;\n    if (endpointId === undefined) {\n        elementName += \"*\";\n    } else {\n        elementName += `${toHex(endpointId)}`;\n    }\n\n    if (clusterId === undefined) {\n        return `${elementName}/*`;\n    }\n    const cluster = getClusterById(clusterId);\n    if (cluster.unknown) {\n        return `${elementName}/unknown(${toHex(clusterId)})`;\n    }\n    return `${elementName}/${cluster.name}(${toHex(clusterId)})`;\n}\n\nexport function resolveAttributeName({\n    nodeId,\n    endpointId,\n    clusterId,\n    attributeId,\n}: TypeFromSchema<typeof TlvAttributePath>) {\n    const endpointClusterName = resolveEndpointClusterName(nodeId, endpointId, clusterId);\n    if (endpointId === undefined || clusterId === undefined || attributeId === undefined) {\n        return `${endpointClusterName}/${toHex(attributeId)}`;\n    }\n    const cluster = getClusterById(clusterId);\n    const attribute = getClusterAttributeById(cluster, attributeId);\n    if (attribute === undefined) {\n        return `${endpointClusterName}/unknown(${toHex(attributeId)})`;\n    }\n    return `${endpointClusterName}/${attribute.name}(${toHex(attributeId)})`;\n}\n\nexport function resolveEventName({\n    nodeId,\n    endpointId,\n    clusterId,\n    eventId,\n    isUrgent,\n}: TypeFromSchema<typeof TlvEventPath>) {\n    const isUrgentStr = isUrgent ? \"!\" : \"\";\n    const endpointClusterName = resolveEndpointClusterName(nodeId, endpointId, clusterId);\n    if (endpointId === undefined || clusterId === undefined || eventId === undefined) {\n        return `${isUrgentStr}${endpointClusterName}/${toHex(eventId)}`;\n    }\n    const event = getClusterEventById(getClusterById(clusterId), eventId);\n    if (event === undefined) {\n        return `${isUrgentStr}${endpointClusterName}/unknown(${toHex(eventId)})`;\n    }\n    return `${isUrgentStr}${endpointClusterName}/${event.name}(${toHex(eventId)})`;\n}\n\nexport function resolveCommandName({ endpointId, clusterId, commandId }: TypeFromSchema<typeof TlvCommandPath>) {\n    const endpointClusterName = resolveEndpointClusterName(undefined, endpointId, clusterId);\n    if (endpointId === undefined || clusterId === undefined || commandId === undefined) {\n        return `${endpointClusterName}/${toHex(commandId)}`;\n    }\n    const command = getClusterCommandById(getClusterById(clusterId), commandId);\n    if (command === undefined) {\n        return `${endpointClusterName}/unknown(${toHex(commandId)})`;\n    }\n    return `${endpointClusterName}/${command.name}(${toHex(commandId)})`;\n}\n"],
  "mappings": "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",
  "names": ["attributeMap", "eventMap", "commandMap"]
}
