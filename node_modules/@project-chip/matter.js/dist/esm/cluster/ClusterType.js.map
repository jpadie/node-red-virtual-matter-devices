{
  "version": 3,
  "sources": ["../../../src/cluster/ClusterType.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../schema/BitmapSchema.js\";\nimport { TlvSchema } from \"../tlv/TlvSchema.js\";\nimport { Branded, Merge } from \"../util/Type.js\";\n\n// ClusterType is duplicative of Cluster.  At some point we may migrate away from Cluster entirely but until we do we\n// use Cluster definitions where feasible to ease compatibility\nimport {\n    Attribute as ClusterAttribute,\n    Command as ClusterCommand,\n    Event as ClusterEvent,\n    GlobalAttributes,\n} from \"./Cluster.js\";\n\n/**\n * A \"cluster\" is a grouping of related functionality that a Matter endpoint supports.\n *\n * ClusterType describes the functionality of a specific type of cluster.\n */\nexport interface ClusterType extends ClusterType.Identity, ClusterType.Features<BitSchema>, ClusterType.Elements {}\n\n/**\n * Define a cluster.\n */\nexport function ClusterType<const T extends ClusterType.Options>(options: T) {\n    const cluster = {\n        id: ClusterId(options.id),\n        name: options.name,\n        revision: options.revision,\n\n        features: options.features ?? {},\n        supportedFeatures: options.supportedFeatures ?? {},\n\n        attributes: {\n            ...options.attributes,\n            ...GlobalAttributes(options.features ?? {}),\n        },\n        commands: options.commands ?? {},\n        events: options.events ?? {},\n\n        unknown: false,\n    } as ClusterType.Of<T>;\n\n    if (options.base) {\n        cluster.base = options.base as ClusterType.Of<T>[\"base\"];\n    }\n\n    if (options.extensions) {\n        cluster.extensions = options.extensions as ClusterType.Of<T>[\"extensions\"];\n    }\n\n    return cluster;\n}\n\nexport namespace ClusterType {\n    /**\n     * Definition of a cluster attribute.\n     */\n    export type Attribute = ClusterAttribute<any, any>;\n\n    /**\n     * Definition of a cluster command.\n     */\n    export type Command = ClusterCommand<any, any, any>;\n\n    /**\n     * Definition of a cluster event.\n     */\n    export type Event = ClusterEvent<any, any>;\n\n    /**\n     * A fully typed {@link ClusterType} for an {@link Options} type.\n     */\n    export interface Of<T extends Options> {\n        id: Branded<T[\"id\"], \"ClusterId\">;\n        name: T[\"name\"];\n        revision: T[\"revision\"];\n        features: T[\"features\"] extends {} ? T[\"features\"] : {};\n        supportedFeatures: T[\"supportedFeatures\"] extends {} ? T[\"supportedFeatures\"] : {};\n        attributes: T[\"attributes\"] extends infer A extends {}\n            ? Merge<A, GlobalAttributes<T[\"features\"] extends {} ? T[\"features\"] : {}>>\n            : {};\n        commands: T[\"commands\"] extends {} ? T[\"commands\"] : {};\n        events: T[\"events\"] extends {} ? T[\"events\"] : {};\n        unknown: T[\"unknown\"] extends boolean ? T[\"unknown\"] : false;\n        base: T[\"base\"] extends {} ? T[\"base\"] : undefined;\n        extensions: T[\"extensions\"] extends {} ? T[\"extensions\"] : undefined;\n    }\n\n    /**\n     * Input to {@link ClusterType} function.  This is a relaxed extension of\n     * {@link ClusterType} with empty objects optional.\n     */\n    export type Options<F extends BitSchema = {}> = { id: number } & Omit<ClusterType.Identity, \"id\"> &\n        Partial<ClusterType.Features<F>> & {\n            attributes?: ClusterType.ElementSet<ClusterType.Attribute>;\n            commands?: ClusterType.ElementSet<ClusterType.Command>;\n            events?: ClusterType.ElementSet<ClusterType.Event>;\n        };\n\n    /**\n     * Fields that uniquely identify a cluster.\n     */\n    export interface Identity {\n        readonly id: ClusterId;\n        readonly name: string;\n        readonly revision: number;\n    }\n\n    /**\n     * An \"element set\" defines the set of elements (commands, attributes or events) of a cluster.\n     */\n    export type ElementSet<T> = Record<string, T>;\n\n    /**\n     * Cluster \"elements\" are attributes, commands and events that may comprise a cluster.\n     */\n    export interface Elements {\n        /**\n         * Attributes supported by the cluster.\n         */\n        readonly attributes: ElementSet<Attribute>;\n\n        /**\n         * Commands supported by the cluster.\n         */\n        readonly commands: ElementSet<Command>;\n\n        /**\n         * Events supported by the cluster.\n         */\n        readonly events: ElementSet<Event>;\n    }\n\n    /**\n     * Cluster \"features\" describe the features supported by a cluster.\n     */\n    export interface Features<F extends BitSchema = {}> {\n        /**\n         * Features the cluster may support.\n         */\n        readonly features: F;\n\n        /**\n         * Features the cluster does support.\n         */\n        readonly supportedFeatures: TypeFromPartialBitSchema<F>;\n\n        /**\n         * Metadata controlling how enabled features affect cluster structure.\n         */\n        readonly extensions?: readonly Extension<F>[];\n\n        /**\n         * If you enable features, this property tracks the shape of the cluster with no features enabled.\n         */\n        readonly base?: ClusterType;\n\n        /**\n         * If true, this flag indicates that the cluster is not known to matter.js.  This implies a cluster ID for which\n         * we do not have a cluster definition.\n         *\n         * Some functionality is available for unknown clusters but an official Matter definition is generally required\n         * for full functionality.\n         */\n        readonly unknown: boolean;\n    }\n\n    /**\n     * Extract the type of a cluster's attributes (excluding global attributes).\n     */\n    export type AttributesOf<C> = C extends { attributes: infer E extends { [K in string]: ClusterType.Attribute } }\n        ? {\n              -readonly [K in keyof E as string extends K\n                  ? never\n                  : K extends keyof GlobalAttributes<any>\n                    ? never\n                    : K]: C[\"attributes\"][K];\n          }\n        : EmptyElementSet<Attribute>;\n\n    /**\n     * Extract the type of a cluster's commands.\n     */\n    export type CommandsOf<C> = C extends { commands: infer E extends { [K in string]: ClusterType.Command } }\n        ? {\n              -readonly [K in keyof E as string extends K ? never : K]: E[K];\n          }\n        : EmptyElementSet<Command>;\n\n    /**\n     * Extract the type of a cluster's events.\n     */\n    export type EventsOf<C> = C extends { events: infer E extends { [K in string]: ClusterType.Event } }\n        ? {\n              -readonly [K in keyof E as string extends K ? never : K]: E[K];\n          }\n        : EmptyElementSet<Event>;\n\n    /**\n     * This bit of hackery describes a set that has no elements but for which typescript thinks it knows the type if you\n     * index generically by string.\n     */\n    export type EmptyElementSet<T> = Record<string, never> & Record<string, T>;\n\n    /**\n     * The collective object type of the cluster's attributes.\n     */\n    export type AttributeValues<T> = ValuesOfAttributes<ClusterType.AttributesOf<T>>;\n\n    export type ValuesOfAttributes<AttrsT extends { [K: string]: Attribute }> = {\n        [K in keyof AttrsT as [AttrsT[K]] extends [{ optional: true }] ? never : K]: AttrsT[K] extends {\n            schema: TlvSchema<infer T>;\n        }\n            ? T\n            : never;\n    } & {\n        [K in keyof AttrsT as [AttrsT[K]] extends [{ optional: true }] ? K : never]?: AttrsT[K] extends {\n            schema: TlvSchema<infer T>;\n        }\n            ? T\n            : never;\n    };\n\n    export type RelaxTypes<V> = V extends number\n        ? number\n        : V extends bigint\n          ? bigint\n          : V extends object\n            ? V extends (...args: any[]) => any\n                ? V\n                : {\n                      [K in keyof V]: RelaxTypes<V[K]>;\n                  }\n            : V;\n\n    export type PatchType<V> = V extends (infer E)[]\n        ? Record<`${number}`, PatchType<E>> | PatchType<E>[]\n        : V extends number\n          ? number\n          : V extends bigint\n            ? bigint\n            : V extends object\n              ? V extends (...args: any[]) => any\n                  ? never\n                  : {\n                        [K in keyof V]?: PatchType<V[K]>;\n                    }\n              : V;\n\n    /**\n     * A slightly relaxed version of AttributeValues for input.\n     */\n    export type InputAttributeValues<T extends ClusterType> = RelaxTypes<AttributeValues<T>>;\n\n    /**\n     * Matter clusters support named \"features\" that enable sets of optional functionality.\n     *\n     * There is not a 1:1 mapping between features and cluster elements.  Some elements are enabled only when specific\n     * features are enabled or disabled in combination.\n     *\n     * Further, some features are mutually exclusive and thus do not generate a valid cluster when used in combination.\n     *\n     * This type describes a feature combination and how it alters a cluster. ClusterComposer uses this metadata to\n     * generate clusters based on selected features.\n     */\n    export interface Extension<F extends BitSchema = {}> {\n        /**\n         * Flags indicating the features for which this extension applies.\n         *\n         * For each feature the flag is a tri-state component:\n         *\n         *   - true = feature is required to enable extension\n         *\n         *   - false = extension cannot be enabled if feature is enabled\n         *\n         *   - undefined = feature is not irrelevant for the extension\n         */\n        flags: TypeFromPartialBitSchema<F>;\n\n        /**\n         * The elements to inject if the flags match active features.  If the component is \"false\" the cluster cannot be\n         * instantiated with the feature combination.\n         */\n        component: false | Partial<Elements>;\n    }\n\n    /**\n     * A placeholder cluster.\n     */\n    export const Unknown = ClusterType({\n        id: 0,\n        revision: 0,\n        name: \"Unknown\",\n\n        attributes: {},\n        commands: {},\n        events: {},\n    });\n    export type Unknown = typeof Unknown;\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,SAAS,iBAAiB;AAO1B;AAAA,EAII;AAAA,OACG;AAYA,SAAS,YAAiD,SAAY;AACzE,QAAM,UAAU;AAAA,IACZ,IAAI,UAAU,QAAQ,EAAE;AAAA,IACxB,MAAM,QAAQ;AAAA,IACd,UAAU,QAAQ;AAAA,IAElB,UAAU,QAAQ,YAAY,CAAC;AAAA,IAC/B,mBAAmB,QAAQ,qBAAqB,CAAC;AAAA,IAEjD,YAAY;AAAA,MACR,GAAG,QAAQ;AAAA,MACX,GAAG,iBAAiB,QAAQ,YAAY,CAAC,CAAC;AAAA,IAC9C;AAAA,IACA,UAAU,QAAQ,YAAY,CAAC;AAAA,IAC/B,QAAQ,QAAQ,UAAU,CAAC;AAAA,IAE3B,SAAS;AAAA,EACb;AAEA,MAAI,QAAQ,MAAM;AACd,YAAQ,OAAO,QAAQ;AAAA,EAC3B;AAEA,MAAI,QAAQ,YAAY;AACpB,YAAQ,aAAa,QAAQ;AAAA,EACjC;AAEA,SAAO;AACX;AAAA,CAEO,CAAUA,iBAAV;AA4OI,EAAMA,aAAA,UAAUA,aAAY;AAAA,IAC/B,IAAI;AAAA,IACJ,UAAU;AAAA,IACV,MAAM;AAAA,IAEN,YAAY,CAAC;AAAA,IACb,UAAU,CAAC;AAAA,IACX,QAAQ,CAAC;AAAA,EACb,CAAC;AAAA,GApPY;",
  "names": ["ClusterType"]
}
