{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/GeneralDiagnosticsCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport {\n    Command,\n    AccessLevel,\n    Attribute,\n    OptionalAttribute,\n    TlvNoResponse,\n    OptionalEvent,\n    EventPriority,\n    Event\n} from \"../Cluster.js\";\nimport { TlvField, TlvObject } from \"../../tlv/TlvObject.js\";\nimport { TlvByteString, TlvString } from \"../../tlv/TlvString.js\";\nimport { TlvUInt8, TlvUInt16, TlvEnum, TlvUInt64, TlvUInt32, TlvSysTimeMS, TlvPosixMs } from \"../../tlv/TlvNumber.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { BitFlag } from \"../../schema/BitmapSchema.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvBoolean } from \"../../tlv/TlvBoolean.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { TlvNoArguments } from \"../../tlv/TlvNoArguments.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace GeneralDiagnostics {\n    /**\n     * These are optional features supported by GeneralDiagnosticsCluster.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.4\n     */\n    export enum Feature {\n        /**\n         * DataModelTest (DMTEST)\n         *\n         * This feature indicates support for extended Data Model testing commands, which are required in some\n         * situations.\n         *\n         * This feature shall be supported if the MaxPathsPerInvoke attribute of the Basic Information Cluster has a\n         * value > 1.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.4.1\n         */\n        DataModelTest = \"DataModelTest\"\n    }\n\n    /**\n     * Input to the GeneralDiagnostics payloadTestRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.4\n     */\n    export const TlvPayloadTestRequest = TlvObject({\n        /**\n         * This field shall have the same meaning and usage as the TestEventTrigger EnableKey field.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.4.1\n         */\n        enableKey: TlvField(0, TlvByteString.bound({ length: 16 })),\n\n        /**\n         * This field shall indicate the value to use in every byte of the PayloadTestResponse\u2019s Payload field.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.4.2\n         */\n        value: TlvField(1, TlvUInt8),\n\n        /**\n         * This field shall indicate the number of times to repeat the Value in the PayloadTestResponse\u2019s Payload field.\n         *\n         * Effect upon receipt\n         *\n         * This command shall respond with a response status of CONSTRAINT_ERROR if either:\n         *\n         *   \u2022 The EnableKey field does not match the a-priori value configured on the device.\n         *\n         *   \u2022 The TestEventTriggersEnabled field is currently false.\n         *\n         * Otherwise, the server shall respond with a PayloadTestResponse command with a Payload field value containing\n         * Count instances of the Value byte. If the response is too large to send, the server shall fail the command\n         * and respond with a response status of RESOURCE_EXHAUSTED.\n         *\n         * For example:\n         *\n         *   \u2022 If Value is 0x55 and the Count is zero, then the PayloadTestResponse would have the Payload field set to\n         *     an empty octet string.\n         *\n         *   \u2022 If Value is 0xA5 and the Count is 10, the PayloadTestResponse would have the Payload field set to a\n         *     content whose hexadecimal representation would be A5A5A5A5A5A5A5A5A5A5, and base64 representation would\n         *     be paWlpaWlpaWlpQ==.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.4.3\n         */\n        count: TlvField(2, TlvUInt16.bound({ max: 2048 }))\n    });\n\n    /**\n     * Input to the GeneralDiagnostics payloadTestRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.4\n     */\n    export interface PayloadTestRequest extends TypeFromSchema<typeof TlvPayloadTestRequest> {}\n\n    /**\n     * This command is sent by the server on receipt of the PayloadTestRequest command.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.5\n     */\n    export const TlvPayloadTestResponse = TlvObject({\n        /**\n         * This field shall contain the computed response of the PayloadTestRequest command.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.5.1\n         */\n        payload: TlvField(0, TlvByteString.bound({ maxLength: 2048 }))\n    });\n\n    /**\n     * This command is sent by the server on receipt of the PayloadTestRequest command.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.5\n     */\n    export interface PayloadTestResponse extends TypeFromSchema<typeof TlvPayloadTestResponse> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.4\n     */\n    export enum InterfaceType {\n        /**\n         * Indicates an interface of an unspecified type.\n         */\n        Unspecified = 0,\n\n        /**\n         * Indicates a Wi-Fi interface.\n         */\n        WiFi = 1,\n\n        /**\n         * Indicates a Ethernet interface.\n         */\n        Ethernet = 2,\n\n        /**\n         * Indicates a Cellular interface.\n         */\n        Cellular = 3,\n\n        /**\n         * Indicates a Thread interface.\n         */\n        Thread = 4\n    }\n\n    /**\n     * This structure describes a network interface supported by the Node, as provided in the NetworkInterfaces\n     * attribute.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6\n     */\n    export const TlvNetworkInterface = TlvObject({\n        /**\n         * This field shall indicate a human-readable (displayable) name for the network interface, that is different\n         * from all other interfaces.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.1\n         */\n        name: TlvField(0, TlvString.bound({ maxLength: 32 })),\n\n        /**\n         * This field shall indicate if the Node is currently advertising itself operationally on this network\n         * interface and is capable of successfully receiving incoming traffic from other Nodes.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.2\n         */\n        isOperational: TlvField(1, TlvBoolean),\n\n        /**\n         * This field shall indicate whether the Node is currently able to reach off-premise services it uses by\n         * utilizing IPv4. The value shall be null if the Node does not use such services or does not know whether it\n         * can reach them.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.3\n         */\n        offPremiseServicesReachableIPv4: TlvField(2, TlvNullable(TlvBoolean)),\n\n        /**\n         * This field shall indicate whether the Node is currently able to reach off-premise services it uses by\n         * utilizing IPv6. The value shall be null if the Node does not use such services or does not know whether it\n         * can reach them.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.4\n         */\n        offPremiseServicesReachableIPv6: TlvField(3, TlvNullable(TlvBoolean)),\n\n        /**\n         * This field shall contain the current link-layer address for a 802.3 or IEEE 802.11-2020 network interface\n         * and contain the current extended MAC address for a 802.15.4 interface. The byte order of the octstr shall be\n         * in wire byte order. For addresses values less than 64 bits, the first two bytes shall be zero.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.5\n         */\n        hardwareAddress: TlvField(4, TlvByteString),\n\n        /**\n         * This field shall provide a list of the IPv4 addresses that are currently assigned to the network interface.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.6\n         */\n        iPv4Addresses: TlvField(5, TlvArray(TlvByteString, { maxLength: 4 })),\n\n        /**\n         * This field shall provide a list of the unicast IPv6 addresses that are currently assigned to the network\n         * interface. This list shall include the Node\u2019s link-local address and SHOULD include any assigned GUA and ULA\n         * addresses. This list shall NOT include any multicast group addresses to which the Node is subscribed.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.7\n         */\n        iPv6Addresses: TlvField(6, TlvArray(TlvByteString, { maxLength: 8 })),\n\n        /**\n         * This field shall indicate the type of the interface using the InterfaceTypeEnum.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6.8\n         */\n        type: TlvField(7, TlvEnum<InterfaceType>())\n    });\n\n    /**\n     * This structure describes a network interface supported by the Node, as provided in the NetworkInterfaces\n     * attribute.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.6\n     */\n    export interface NetworkInterface extends TypeFromSchema<typeof TlvNetworkInterface> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.5\n     */\n    export enum BootReason {\n        /**\n         * The Node is unable to identify the Power-On reason as one of the other provided enumeration values.\n         */\n        Unspecified = 0,\n\n        /**\n         * The Node has booted as the result of physical interaction with the device resulting in a reboot.\n         */\n        PowerOnReboot = 1,\n\n        /**\n         * The Node has rebooted as the result of a brown-out of the Node\u2019s power supply.\n         */\n        BrownOutReset = 2,\n\n        /**\n         * The Node has rebooted as the result of a software watchdog timer.\n         */\n        SoftwareWatchdogReset = 3,\n\n        /**\n         * The Node has rebooted as the result of a hardware watchdog timer.\n         */\n        HardwareWatchdogReset = 4,\n\n        /**\n         * The Node has rebooted as the result of a completed software update.\n         */\n        SoftwareUpdateCompleted = 5,\n\n        /**\n         * The Node has rebooted as the result of a software initiated reboot.\n         */\n        SoftwareReset = 6\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.1\n     */\n    export enum HardwareFault {\n        /**\n         * The Node has encountered an unspecified fault.\n         */\n        Unspecified = 0,\n\n        /**\n         * The Node has encountered a fault with at least one of its radios.\n         */\n        Radio = 1,\n\n        /**\n         * The Node has encountered a fault with at least one of its sensors.\n         */\n        Sensor = 2,\n\n        /**\n         * The Node has encountered an over-temperature fault that is resettable.\n         */\n        ResettableOverTemp = 3,\n\n        /**\n         * The Node has encountered an over-temperature fault that is not resettable.\n         */\n        NonResettableOverTemp = 4,\n\n        /**\n         * The Node has encountered a fault with at least one of its power sources.\n         */\n        PowerSource = 5,\n\n        /**\n         * The Node has encountered a fault with at least one of its visual displays.\n         */\n        VisualDisplayFault = 6,\n\n        /**\n         * The Node has encountered a fault with at least one of its audio outputs.\n         */\n        AudioOutputFault = 7,\n\n        /**\n         * The Node has encountered a fault with at least one of its user interfaces.\n         */\n        UserInterfaceFault = 8,\n\n        /**\n         * The Node has encountered a fault with its non-volatile memory.\n         */\n        NonVolatileMemoryError = 9,\n\n        /**\n         * The Node has encountered disallowed physical tampering.\n         */\n        TamperDetected = 10\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.2\n     */\n    export enum RadioFault {\n        /**\n         * The Node has encountered an unspecified radio fault.\n         */\n        Unspecified = 0,\n\n        /**\n         * The Node has encountered a fault with its Wi-Fi radio.\n         */\n        WiFiFault = 1,\n\n        /**\n         * The Node has encountered a fault with its cellular radio.\n         */\n        CellularFault = 2,\n\n        /**\n         * The Node has encountered a fault with its802.15.4 radio.\n         */\n        ThreadFault = 3,\n\n        /**\n         * The Node has encountered a fault with its NFC radio.\n         */\n        NfcFault = 4,\n\n        /**\n         * The Node has encountered a fault with its BLE radio.\n         */\n        BleFault = 5,\n\n        /**\n         * The Node has encountered a fault with its Ethernet controller.\n         */\n        EthernetFault = 6\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.5.3\n     */\n    export enum NetworkFault {\n        /**\n         * The Node has encountered an unspecified fault.\n         */\n        Unspecified = 0,\n\n        /**\n         * The Node has encountered a network fault as a result of a hardware failure.\n         */\n        HardwareFailure = 1,\n\n        /**\n         * The Node has encountered a network fault as a result of a jammed network.\n         */\n        NetworkJammed = 2,\n\n        /**\n         * The Node has encountered a network fault as a result of a failure to establish a connection.\n         */\n        ConnectionFailed = 3\n    }\n\n    /**\n     * Input to the GeneralDiagnostics testEventTrigger command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.1\n     */\n    export const TlvTestEventTriggerRequest = TlvObject({\n        /**\n         * The EnableKey is a 128 bit value provided by the client in this command, which needs to match a value chosen\n         * by the manufacturer and configured on the server using manufacturer-specific means, such as\n         * pre-provisioning. The value of all zeroes is reserved to indicate that no EnableKey is set. Therefore, if\n         * the EnableKey field is received with all zeroes, this command shall FAIL with a response status of\n         * CONSTRAINT_ERROR.\n         *\n         * The EnableKey SHOULD be unique per exact set of devices going to a certification test.\n         *\n         * Devices not targeted towards going to a certification test event shall NOT have a non-zero EnableKey value\n         * configured, so that only devices in test environments are responsive to this command.\n         *\n         * In order to prevent unwittingly actuating a particular trigger, this command shall respond with a response\n         * status of CONSTRAINT_ERROR if the EnableKey field does not match the a-priori value configured on the device.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.1.1\n         */\n        enableKey: TlvField(0, TlvByteString.bound({ length: 16 })),\n\n        /**\n         * This field shall indicate the test or test mode which the client wants to trigger.\n         *\n         * The expected side-effects of EventTrigger values are out of scope of this specification and will be\n         * described within appropriate certification test literature provided to manufacturers by the Connectivity\n         * Standards Alliance, in conjunction with certification test cases documentation.\n         *\n         * Values of EventTrigger in the range 0xFFFF_FFFF_0000_0000 through 0xFFFF_FFFF_FFFF_FFFF are reserved for\n         * testing use by manufacturers and will not appear in CSA certification test literature.\n         *\n         * If the value of EventTrigger received is not supported by the receiving Node, this command shall fail with a\n         * status code of INVALID_COMMAND.\n         *\n         * Otherwise, if the EnableKey value matches the configured internal value for a particular Node, and the\n         * EventTrigger value matches a supported test event trigger value, the command shall succeed and execute the\n         * expected trigger action.\n         *\n         * If no specific test event triggers are required to be supported by certification test requirements for the\n         * features that a given product will be certified against, this command may always fail with the\n         * INVALID_COMMAND status, equivalent to the situation of receiving an unknown EventTrigger, for all possible\n         * EventTrigger values.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.1.2\n         */\n        eventTrigger: TlvField(1, TlvUInt64)\n    });\n\n    /**\n     * Input to the GeneralDiagnostics testEventTrigger command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.1\n     */\n    export interface TestEventTriggerRequest extends TypeFromSchema<typeof TlvTestEventTriggerRequest> {}\n\n    /**\n     * This command shall be generated in response to a TimeSnapshot command.\n     *\n     * When generating this response, all fields shall be gathered as close together in time as possible, so that the\n     * time jitter between the values is minimized.\n     *\n     * If the Time Synchronization cluster is supported by the node, the PosixTimeMs field shall NOT be null unless the\n     * UTCTime attribute in the Time Synchronization cluster is also null.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.3\n     */\n    export const TlvTimeSnapshotResponse = TlvObject({\n        /**\n         * This shall indicate the current System Time in milliseconds (type system-ms), with the value taken at the\n         * time of processing of the TimeSnapshot command that generated this response.\n         *\n         * The value shall be taken from the same clock which populates the Timestamp field in events when using System\n         * Time for the field.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.3.1\n         */\n        systemTimeMs: TlvField(0, TlvSysTimeMS),\n\n        /**\n         * This shall indicate the current time in POSIX Time in milliseconds, with the value taken from the same\n         * source that could populate the Timestamp field of events. This value shall only be null when any the\n         * following are true:\n         *\n         *   \u2022 The node doesn\u2019t support the Time Synchronization cluster.\n         *\n         *   \u2022 The node\u2019s Time Synchronization cluster instance\u2019s UTCTime attribute is null.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.3.2\n         */\n        posixTimeMs: TlvField(1, TlvNullable(TlvPosixMs))\n    });\n\n    /**\n     * This command shall be generated in response to a TimeSnapshot command.\n     *\n     * When generating this response, all fields shall be gathered as close together in time as possible, so that the\n     * time jitter between the values is minimized.\n     *\n     * If the Time Synchronization cluster is supported by the node, the PosixTimeMs field shall NOT be null unless the\n     * UTCTime attribute in the Time Synchronization cluster is also null.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.3\n     */\n    export interface TimeSnapshotResponse extends TypeFromSchema<typeof TlvTimeSnapshotResponse> {}\n\n    /**\n     * Body of the GeneralDiagnostics hardwareFaultChange event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.1\n     */\n    export const TlvHardwareFaultChangeEvent = TlvObject({\n        /**\n         * This field shall represent the set of faults currently detected, as per Section 11.12.5.1,\n         * \u201CHardwareFaultEnum Type\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.1.1\n         */\n        current: TlvField(0, TlvArray(TlvEnum<HardwareFault>(), { maxLength: 11 })),\n\n        /**\n         * This field shall represent the set of faults detected prior to this change event, as per Section 11.12.5.1,\n         * \u201CHardwareFaultEnum Type\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.1.2\n         */\n        previous: TlvField(1, TlvArray(TlvEnum<HardwareFault>(), { maxLength: 11 }))\n    });\n\n    /**\n     * Body of the GeneralDiagnostics hardwareFaultChange event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.1\n     */\n    export interface HardwareFaultChangeEvent extends TypeFromSchema<typeof TlvHardwareFaultChangeEvent> {}\n\n    /**\n     * Body of the GeneralDiagnostics radioFaultChange event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.2\n     */\n    export const TlvRadioFaultChangeEvent = TlvObject({\n        /**\n         * This field shall represent the set of faults currently detected, as per Section 11.12.5.2, \u201CRadioFaultEnum\n         * Type\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.2.1\n         */\n        current: TlvField(0, TlvArray(TlvEnum<RadioFault>(), { maxLength: 7 })),\n\n        /**\n         * This field shall represent the set of faults detected prior to this change event, as per Section 11.12.5.2,\n         * \u201CRadioFaultEnum Type\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.2.2\n         */\n        previous: TlvField(1, TlvArray(TlvEnum<RadioFault>(), { maxLength: 7 }))\n    });\n\n    /**\n     * Body of the GeneralDiagnostics radioFaultChange event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.2\n     */\n    export interface RadioFaultChangeEvent extends TypeFromSchema<typeof TlvRadioFaultChangeEvent> {}\n\n    /**\n     * Body of the GeneralDiagnostics networkFaultChange event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.3\n     */\n    export const TlvNetworkFaultChangeEvent = TlvObject({\n        /**\n         * This field shall represent the set of faults currently detected, as per Section 11.12.5.3, \u201CNetworkFaultEnum\n         * Type\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.3.1\n         */\n        current: TlvField(0, TlvArray(TlvEnum<NetworkFault>(), { maxLength: 4 })),\n\n        /**\n         * This field shall represent the set of faults detected prior to this change event, as per Section 11.12.5.3,\n         * \u201CNetworkFaultEnum Type\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.3.2\n         */\n        previous: TlvField(1, TlvArray(TlvEnum<NetworkFault>(), { maxLength: 4 }))\n    });\n\n    /**\n     * Body of the GeneralDiagnostics networkFaultChange event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.3\n     */\n    export interface NetworkFaultChangeEvent extends TypeFromSchema<typeof TlvNetworkFaultChangeEvent> {}\n\n    /**\n     * Body of the GeneralDiagnostics bootReason event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.4\n     */\n    export const TlvBootReasonEvent = TlvObject({\n        /**\n         * This field shall contain the reason for this BootReason event.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.4.1\n         */\n        bootReason: TlvField(0, TlvEnum<BootReason>())\n    });\n\n    /**\n     * Body of the GeneralDiagnostics bootReason event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.4\n     */\n    export interface BootReasonEvent extends TypeFromSchema<typeof TlvBootReasonEvent> {}\n\n    /**\n     * A GeneralDiagnosticsCluster supports these elements if it supports feature DataModelTest.\n     */\n    export const DataModelTestComponent = MutableCluster.Component({\n        commands: {\n            /**\n             * This command provides a means for certification tests or manufacturer\u2019s internal tests to validate\n             * particular command handling and encoding constraints by generating a response of a given size.\n             *\n             * This command shall use the same EnableKey behavior as the TestEventTrigger command, whereby processing\n             * of the command is only enabled when the TestEventTriggersEnabled field is true, which shall NOT be true\n             * outside of certification testing or manufacturer\u2019s internal tests.\n             *\n             * The fields for the PayloadTestRequest command are as follows:\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.4\n             */\n            payloadTestRequest: Command(\n                0x3,\n                TlvPayloadTestRequest,\n                0x4,\n                TlvPayloadTestResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        }\n    });\n\n    /**\n     * These elements and properties are present in all GeneralDiagnostics clusters.\n     */\n    export const Base = MutableCluster.Component({\n        id: 0x33,\n        name: \"GeneralDiagnostics\",\n        revision: 2,\n\n        features: {\n            /**\n             * DataModelTest\n             *\n             * This feature indicates support for extended Data Model testing commands, which are required in some\n             * situations.\n             *\n             * This feature shall be supported if the MaxPathsPerInvoke attribute of the Basic Information Cluster has\n             * a value > 1.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.4.1\n             */\n            dataModelTest: BitFlag(0)\n        },\n\n        attributes: {\n            /**\n             * The NetworkInterfaces attribute shall be a list of NetworkInterface structs. Each logical network\n             * interface on the Node shall be represented by a single entry within the NetworkInterfaces attribute.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.1\n             */\n            networkInterfaces: Attribute(0x0, TlvArray(TlvNetworkInterface, { maxLength: 8 }), { default: [] }),\n\n            /**\n             * The RebootCount attribute shall indicate a best-effort count of the number of times the Node has\n             * rebooted. The RebootCount attribute SHOULD be incremented each time the Node reboots. The RebootCount\n             * attribute shall NOT be incremented when a Node wakes from a low-power or sleep state. The RebootCount\n             * attribute shall only be reset to 0 upon a factory reset of the Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.2\n             */\n            rebootCount: Attribute(0x1, TlvUInt16, { persistent: true }),\n\n            /**\n             * The UpTime attribute shall indicate a best-effort assessment of the length of time, in seconds, since\n             * the Node\u2019s last reboot. This attribute SHOULD be incremented to account for the periods of time that a\n             * Node is in a low-power or sleep state. This attribute shall only be reset upon a device reboot. This\n             * attribute shall be based on the same System Time source as those used to fulfill any usage of the\n             * system-us and system-ms data types within the server.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.3\n             */\n            upTime: Attribute(0x2, TlvUInt64, { omitChanges: true }),\n\n            /**\n             * The TotalOperationalHours attribute shall indicate a best-effort attempt at tracking the length of time,\n             * in hours, that the Node has been operational. The TotalOperationalHours attribute SHOULD be incremented\n             * to account for the periods of time that a Node is in a low-power or sleep state. The\n             * TotalOperationalHours attribute shall only be reset upon a factory reset of the Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.4\n             */\n            totalOperationalHours: OptionalAttribute(0x3, TlvUInt32, { persistent: true, omitChanges: true }),\n\n            /**\n             * The BootReason attribute shall indicate the reason for the Node\u2019s most recent boot.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.5\n             */\n            bootReason: OptionalAttribute(0x4, TlvEnum<BootReason>()),\n\n            /**\n             * The ActiveHardwareFaults attribute shall indicate the set of faults currently detected by the Node. When\n             * the Node detects a fault has been raised, the appropriate HardwareFaultEnum value shall be added to this\n             * list. This list shall NOT contain more than one instance of a specific HardwareFaultEnum value. When the\n             * Node detects that all conditions contributing to a fault has been cleared, the corresponding\n             * HardwareFaultEnum value shall be removed from this list. An empty list shall indicate there are\n             * currently no active faults. The order of this list SHOULD have no significance. Clients interested in\n             * monitoring changes in active faults may subscribe to this attribute, or they may subscribe to\n             * HardwareFaultChange.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.6\n             */\n            activeHardwareFaults: OptionalAttribute(\n                0x5,\n                TlvArray(TlvEnum<HardwareFault>(), { maxLength: 11 }),\n                { default: [] }\n            ),\n\n            /**\n             * The ActiveRadioFaults attribute shall indicate the set of faults currently detected by the Node. When\n             * the Node detects a fault has been raised, the appropriate RadioFaultEnum value shall be added to this\n             * list. This list shall NOT contain more than one instance of a specific RadioFaultEnum value. When the\n             * Node detects that all conditions contributing to a fault has been cleared, the corresponding\n             * RadioFaultEnum value shall be removed from this list. An empty list shall indicate there are currently\n             * no active faults. The order of this list SHOULD have no significance. Clients interested in monitoring\n             * changes in active faults may subscribe to this attribute, or they may subscribe to RadioFaultChange.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.7\n             */\n            activeRadioFaults: OptionalAttribute(\n                0x6,\n                TlvArray(TlvEnum<RadioFault>(), { maxLength: 7 }),\n                { default: [] }\n            ),\n\n            /**\n             * The ActiveNetworkFaults attribute shall indicate the set of faults currently detected by the Node. When\n             * the Node detects a fault has been raised, the appropriate NetworkFaultEnum value shall be added to this\n             * list. This list shall NOT contain more than one instance of a specific NetworkFaultEnum value. When the\n             * Node detects that all conditions contributing to a fault has been cleared, the corresponding\n             * NetworkFaultEnum value shall be removed from this list. An empty list shall indicate there are currently\n             * no active faults. The order of this list SHOULD have no significance. Clients interested in monitoring\n             * changes in active faults may subscribe to this attribute, or they may subscribe to NetworkFaultChange.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.8\n             */\n            activeNetworkFaults: OptionalAttribute(\n                0x7,\n                TlvArray(TlvEnum<NetworkFault>(), { maxLength: 4 }),\n                { default: [] }\n            ),\n\n            /**\n             * The TestEventTriggersEnabled attribute shall indicate whether the Node has any TestEventTrigger\n             * configured. When this attribute is true, the Node has been configured with one or more test event\n             * triggers by virtue of the internally programmed EnableKey value (see Section 11.12.7.1,\n             * \u201CTestEventTrigger Command\u201D) being set to a non-zero value. This attribute can be used by Administrators\n             * to detect if a device was inadvertently commissioned with test event trigger mode enabled, and take\n             * appropriate action (e.g. warn the user and/or offer to remove all fabrics on the Node).\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.6.9\n             */\n            testEventTriggersEnabled: Attribute(0x8, TlvBoolean)\n        },\n\n        commands: {\n            /**\n             * This command shall be supported to provide a means for certification tests to trigger some test-\n             * plan-specific events, necessary to assist in automation of device interactions for some certification\n             * test cases. This command shall NOT cause any changes to the state of the device that persist after the\n             * last fabric is removed.\n             *\n             * The fields for the TestEventTrigger command are as follows:\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.1\n             */\n            testEventTrigger: Command(\n                0x0,\n                TlvTestEventTriggerRequest,\n                0x0,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * This command may be used by a client to obtain a correlated view of both System Time, and, if currently\n             * synchronized and supported, \"wall clock time\" of the server. This can help clients establish\n             *\n             * time correlation between their concept of time and the server\u2019s concept of time. This is especially\n             * useful when processing event histories where some events only contain System Time.\n             *\n             * Upon command invocation, the server shall respond with a TimeSnapshotResponse.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.7.2\n             */\n            timeSnapshot: Command(0x1, TlvNoArguments, 0x2, TlvTimeSnapshotResponse)\n        },\n\n        events: {\n            /**\n             * The HardwareFaultChange Event shall indicate a change in the set of hardware faults currently detected\n             * by the Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.1\n             */\n            hardwareFaultChange: OptionalEvent(0x0, EventPriority.Critical, TlvHardwareFaultChangeEvent),\n\n            /**\n             * The RadioFaultChange Event shall indicate a change in the set of radio faults currently detected by the\n             * Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.2\n             */\n            radioFaultChange: OptionalEvent(0x1, EventPriority.Critical, TlvRadioFaultChangeEvent),\n\n            /**\n             * The NetworkFaultChange Event shall indicate a change in the set of network faults currently detected by\n             * the Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.3\n             */\n            networkFaultChange: OptionalEvent(0x2, EventPriority.Critical, TlvNetworkFaultChangeEvent),\n\n            /**\n             * The BootReason Event shall indicate the reason that caused the device to start-up.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.12.8.4\n             */\n            bootReason: Event(0x3, EventPriority.Critical, TlvBootReasonEvent)\n        },\n\n        /**\n         * This metadata controls which GeneralDiagnosticsCluster elements matter.js activates for specific feature\n         * combinations.\n         */\n        extensions: MutableCluster.Extensions({ flags: { dataModelTest: true }, component: DataModelTestComponent })\n    });\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster(Base);\n\n    /**\n     * The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized\n     * diagnostics metrics that may be used by a Node to assist a user or Administrator in diagnosing potential\n     * problems. The General Diagnostics Cluster attempts to centralize all metrics that are broadly relevant to the\n     * majority of Nodes.\n     *\n     * GeneralDiagnosticsCluster supports optional features that you can enable with the\n     * GeneralDiagnosticsCluster.with() factory method.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.12\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    const DMTEST = { dataModelTest: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster({\n        id: Cluster.id,\n        name: Cluster.name,\n        revision: Cluster.revision,\n        features: Cluster.features,\n        attributes: Cluster.attributes,\n\n        commands: {\n            ...Cluster.commands,\n            payloadTestRequest: MutableCluster.AsConditional(\n                DataModelTestComponent.commands.payloadTestRequest,\n                { mandatoryIf: [DMTEST] }\n            )\n        },\n\n        events: Cluster.events\n    });\n\n    /**\n     * This cluster supports all GeneralDiagnostics features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n\nexport type GeneralDiagnosticsCluster = GeneralDiagnostics.Cluster;\nexport const GeneralDiagnosticsCluster = GeneralDiagnostics.Cluster;\nClusterRegistry.register(GeneralDiagnostics.Complete);\n"],
  "mappings": "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",
  "names": ["GeneralDiagnostics", "Feature", "InterfaceType", "BootReason", "HardwareFault", "RadioFault", "NetworkFault"]
}
