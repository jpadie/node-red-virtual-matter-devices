{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/ModeSelectCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport {\n    WritableAttribute,\n    FixedAttribute,\n    Attribute,\n    OptionalWritableAttribute,\n    Command,\n    TlvNoResponse\n} from \"../Cluster.js\";\nimport { TlvUInt8, TlvUInt16 } from \"../../tlv/TlvNumber.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { BitFlag } from \"../../schema/BitmapSchema.js\";\nimport { TlvString } from \"../../tlv/TlvString.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvField, TlvObject } from \"../../tlv/TlvObject.js\";\nimport { TlvVendorId } from \"../../datatype/VendorId.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace ModeSelect {\n    /**\n     * These are optional features supported by ModeSelectCluster.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.4\n     */\n    export enum Feature {\n        /**\n         * OnOff (DEPONOFF)\n         *\n         * This feature creates a dependency between an OnOff cluster instance and this cluster instance on the same\n         * endpoint. See OnMode for more information.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.4.1\n         */\n        OnOff = \"OnOff\"\n    }\n\n    /**\n     * A Semantic Tag is meant to be interpreted by the client for the purpose the cluster serves.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.1\n     */\n    export const TlvSemanticTag = TlvObject({\n        /**\n         * This field shall indicate a manufacturer code (Vendor ID), and the Value field shall indicate a semantic tag\n         * defined by the manufacturer. Each manufacturer code supports a single namespace of values. The same\n         * manufacturer code and semantic tag value in separate cluster instances are part of the same namespace and\n         * have the same meaning. For example: a manufacturer tag meaning \"pinch\", has the same meaning in a cluster\n         * whose purpose is to choose the amount of sugar, or amount of salt.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.1.2\n         */\n        mfgCode: TlvField(0, TlvVendorId),\n\n        /**\n         * This field shall indicate the semantic tag within a semantic tag namespace which is either manufacturer\n         * specific or standard. For semantic tags in a standard namespace, see Standard Namespace.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.1.1\n         */\n        value: TlvField(1, TlvUInt16)\n    });\n\n    /**\n     * A Semantic Tag is meant to be interpreted by the client for the purpose the cluster serves.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.1\n     */\n    export interface SemanticTag extends TypeFromSchema<typeof TlvSemanticTag> {}\n\n    /**\n     * This is a struct representing a possible mode of the server.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.2\n     */\n    export const TlvModeOption = TlvObject({\n        /**\n         * This field is readable text that describes the mode option that can be used by a client to indicate to the\n         * user what this option means. This field is meant to be readable and understandable by the user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.2.1\n         */\n        label: TlvField(0, TlvString.bound({ maxLength: 64 })),\n\n        /**\n         * The Mode field is used to identify the mode option. The value shall be unique for every item in the\n         * SupportedModes attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.2.2\n         */\n        mode: TlvField(1, TlvUInt8),\n\n        /**\n         * This field is a list of semantic tags that map to the mode option. This may be used by clients to determine\n         * the meaning of the mode option as defined in a standard or manufacturer specific namespace. Semantic tags\n         * can help clients look for options that meet certain criteria. A semantic tag shall be either a standard tag\n         * or manufacturer specific tag as defined in each SemanticTagStruct list entry.\n         *\n         * A mode option may have more than one semantic tag. A mode option may be mapped to a mixture of standard and\n         * manufacturer specific semantic tags.\n         *\n         * All standard semantic tags are from a single namespace indicated by the StandardNamespace attribute.\n         *\n         * For example: A mode labeled \"100%\" can have both the HIGH (MS) and MAX (standard) semantic tag. Clients\n         * seeking the option for either HIGH or MAX will find the same option in this case.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.2.3\n         */\n        semanticTags: TlvField(2, TlvArray(TlvSemanticTag, { maxLength: 64 }))\n    });\n\n    /**\n     * This is a struct representing a possible mode of the server.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.5.2\n     */\n    export interface ModeOption extends TypeFromSchema<typeof TlvModeOption> {}\n\n    /**\n     * Input to the ModeSelect changeToMode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.7.1\n     */\n    export const TlvChangeToModeRequest = TlvObject({ newMode: TlvField(0, TlvUInt8) });\n\n    /**\n     * Input to the ModeSelect changeToMode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.7.1\n     */\n    export interface ChangeToModeRequest extends TypeFromSchema<typeof TlvChangeToModeRequest> {}\n\n    /**\n     * A ModeSelectCluster supports these elements if it supports feature OnOff.\n     */\n    export const OnOffComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the value of CurrentMode that depends on the state of the On/Off cluster on the same endpoint.\n             * If this attribute is not present or is set to null, it shall NOT have an effect, otherwise the\n             * CurrentMode attribute shall depend on the OnOff attribute of the On/Off cluster\n             *\n             * The value of this field shall match the Mode field of one of the entries in the SupportedModes attribute.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.6.7\n             */\n            onMode: WritableAttribute(0x5, TlvNullable(TlvUInt8), { persistent: true, default: null })\n        }\n    });\n\n    /**\n     * These elements and properties are present in all ModeSelect clusters.\n     */\n    export const Base = MutableCluster.Component({\n        id: 0x50,\n        name: \"ModeSelect\",\n        revision: 2,\n\n        features: {\n            /**\n             * OnOff\n             *\n             * This feature creates a dependency between an OnOff cluster instance and this cluster instance on the\n             * same endpoint. See OnMode for more information.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.4.1\n             */\n            onOff: BitFlag(0)\n        },\n\n        attributes: {\n            /**\n             * This attribute describes the purpose of the server, in readable text.\n             *\n             * For example, a coffee machine may have a Mode Select cluster for the amount of milk to add, and another\n             * Mode Select cluster for the amount of sugar to add. In this case, the first instance can have the\n             * description Milk and the second instance can have the description Sugar. This allows the user to tell\n             * the purpose of each of the instances.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.6.2\n             */\n            description: FixedAttribute(0x0, TlvString.bound({ maxLength: 64 })),\n\n            /**\n             * This attribute, when not null, shall indicate a single standard namespace for any standard semantic tag\n             * value supported in this or any other cluster instance with the same value of this attribute. A\n             *\n             * null value indicates no standard namespace, and therefore, no standard semantic tags are provided in\n             * this cluster instance. Each standard namespace and corresponding values and value meanings shall be\n             * defined in another document.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.6.3\n             */\n            standardNamespace: FixedAttribute(0x1, TlvNullable(TlvUInt16), { default: null }),\n\n            /**\n             * This attribute is the list of supported modes that may be selected for the CurrentMode attribute. Each\n             * item in this list represents a unique mode as indicated by the Mode field of the ModeOptionStruct. Each\n             * entry in this list shall have a unique value for the Mode field.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.6.4\n             */\n            supportedModes: FixedAttribute(0x2, TlvArray(TlvModeOption, { maxLength: 255 }), { default: [] }),\n\n            /**\n             * This attribute represents the current mode of the server.\n             *\n             * The value of this field must match the Mode field of one of the entries in the SupportedModes\n             *\n             * attribute.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.6.5\n             */\n            currentMode: Attribute(0x3, TlvUInt8, { scene: true, persistent: true }),\n\n            /**\n             * The StartUpMode attribute value indicates the desired startup mode for the server when it is supplied\n             * with power.\n             *\n             * If this attribute is not null, the CurrentMode attribute shall be set to the StartUpMode value, when the\n             * server is powered up, except in the case when the OnMode attribute overrides the StartUpMode attribute\n             * (see OnModeWithPowerUp).\n             *\n             * This behavior does not apply to reboots associated with OTA. After an OTA restart, the CurrentMode\n             * attribute shall return to its value prior to the restart.\n             *\n             * The value of this field shall match the Mode field of one of the entries in the SupportedModes\n             *\n             * attribute.\n             *\n             * If this attribute is not implemented, or is set to the null value, it shall have no effect.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.6.6\n             */\n            startUpMode: OptionalWritableAttribute(0x4, TlvNullable(TlvUInt8), { persistent: true })\n        },\n\n        commands: {\n            /**\n             * On receipt of this command, if the NewMode field indicates a valid mode transition within the supported\n             * list, the server shall set the CurrentMode attribute to the NewMode value, otherwise, the server shall\n             * respond with an INVALID_COMMAND status response.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9.7.1\n             */\n            changeToMode: Command(0x0, TlvChangeToModeRequest, 0x0, TlvNoResponse)\n        },\n\n        /**\n         * This metadata controls which ModeSelectCluster elements matter.js activates for specific feature\n         * combinations.\n         */\n        extensions: MutableCluster.Extensions({ flags: { onOff: true }, component: OnOffComponent })\n    });\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster(Base);\n\n    /**\n     * This cluster provides an interface for controlling a characteristic of a device that can be set to one of\n     * several predefined values. For example, the light pattern of a disco ball, the mode of a massage chair, or the\n     * wash cycle of a laundry machine.\n     *\n     * The server allows the client to set a mode on the server. A mode is one of a list of options that may be\n     * presented by a client for a user choice, or understood by the client, via the semantic tags on the mode.\n     *\n     * A semantic tag is either a standard tag within a standard category namespace, or a manufacturer specific tag,\n     * within the namespace of the vendor ID of the manufacturer. If there is no semantic tag, the mode is anonymous,\n     * and the selection is made by the user solely based on the Label string.\n     *\n     * Each cluster ID that indicates this specification shall define a distinct purpose for the cluster instance. For\n     * example: A LightBlinking cluster ID supports blinking modes for a light (and is described that way).\n     *\n     * An anonymous mode shall support the derived cluster purpose. A manufacturer specific semantic tag shall support\n     * the derived cluster purpose. An anonymous mode shall NOT replace the meaning of a standard semantic tag, when\n     * one exists, for the cluster purpose.\n     *\n     * ModeSelectCluster supports optional features that you can enable with the ModeSelectCluster.with() factory\n     * method.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.9\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    const DEPONOFF = { onOff: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster({\n        id: Cluster.id,\n        name: Cluster.name,\n        revision: Cluster.revision,\n        features: Cluster.features,\n        attributes: {\n            ...Cluster.attributes,\n            onMode: MutableCluster.AsConditional(OnOffComponent.attributes.onMode, { mandatoryIf: [DEPONOFF] })\n        },\n        commands: Cluster.commands\n    });\n\n    /**\n     * This cluster supports all ModeSelect features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n\nexport type ModeSelectCluster = ModeSelect.Cluster;\nexport const ModeSelectCluster = ModeSelect.Cluster;\nClusterRegistry.register(ModeSelect.Complete);\n"],
  "mappings": "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",
  "names": ["ModeSelect", "Feature"]
}
