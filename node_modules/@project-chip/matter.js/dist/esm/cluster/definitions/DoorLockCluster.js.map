{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/DoorLockCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport {\n    Attribute,\n    OptionalWritableAttribute,\n    AccessLevel,\n    Event,\n    EventPriority,\n    FixedAttribute,\n    WritableAttribute,\n    Command,\n    TlvNoResponse,\n    OptionalCommand,\n    OptionalAttribute\n} from \"../Cluster.js\";\nimport { TlvEnum, TlvUInt32, TlvUInt16, TlvEpochS, TlvUInt8, TlvBitmap } from \"../../tlv/TlvNumber.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { TlvField, TlvObject, TlvOptionalField } from \"../../tlv/TlvObject.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvBoolean } from \"../../tlv/TlvBoolean.js\";\nimport { TlvByteString, TlvString } from \"../../tlv/TlvString.js\";\nimport { BitFlag, BitsFromPartial } from \"../../schema/BitmapSchema.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvFabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { StatusCode as GlobalStatusCode } from \"../../protocol/interaction/StatusCode.js\";\nimport { TlvNodeId } from \"../../datatype/NodeId.js\";\nimport { TlvNoArguments } from \"../../tlv/TlvNoArguments.js\";\nimport { ClusterType } from \"../ClusterType.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace DoorLock {\n    /**\n     * These are optional features supported by DoorLockCluster.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4\n     */\n    export enum Feature {\n        /**\n         * PinCredential (PIN)\n         *\n         * If the User Feature is also supported then any PIN Code stored in the lock shall be associated with a User.\n         *\n         * A lock may support multiple credential types so if the User feature is supported the UserType, UserStatus\n         * and Schedules are all associated with a User index and not directly with a PIN index. A User index may have\n         * several credentials associated with it.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.1\n         */\n        PinCredential = \"PinCredential\",\n\n        /**\n         * RfidCredential (RID)\n         *\n         * If the User Feature is also supported then any RFID credential stored in the lock shall be associated with a\n         * User.\n         *\n         * A lock may support multiple credential types so if the User feature is supported the UserType, UserStatus\n         * and Schedules are all associated with a User index and not directly with a RFID index. A User\n         *\n         * Index may have several credentials associated with it.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.2\n         */\n        RfidCredential = \"RfidCredential\",\n\n        /**\n         * FingerCredentials (FGP)\n         *\n         * Currently the cluster only defines the metadata format for notifications when a fingerprint/ finger vein\n         * credential is used to access the lock and doesn\u2019t describe how to create fingerprint/finger vein\n         * credentials. If the Users feature is also supported then the User that a fingerprint/finger vein is\n         * associated with can also have its UserType, UserStatus and Schedule modified.\n         *\n         * A lock may support multiple credential types so if the User feature is supported the UserType, UserStatus\n         * and Schedules are all associated with a User index and not directly with a Finger index. A User Index may\n         * have several credentials associated with it.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.3\n         */\n        FingerCredentials = \"FingerCredentials\",\n\n        /**\n         * Logging (LOG)\n         *\n         * If Events are not supported the logging feature shall replace the Event reporting structure. If Events are\n         * supported the logging feature shall NOT be supported.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.4\n         */\n        Logging = \"Logging\",\n\n        /**\n         * WeekDayAccessSchedules (WDSCH)\n         *\n         * If the User feature is supported then Week Day Schedules are applied to a User and not a credential.\n         *\n         * Week Day Schedules are used to restrict access to a specified time window on certain days of the week. The\n         * schedule is repeated each week. When a schedule is cleared this clears the access restrictions and grants\n         * unrestricted access to the user. The lock may automatically adjust the UserType when a schedule is created\n         * or cleared.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.5\n         */\n        WeekDayAccessSchedules = \"WeekDayAccessSchedules\",\n\n        /**\n         * DoorPositionSensor (DPS)\n         *\n         * If this feature is supported this indicates that the lock has the ability to determine the position of the\n         * door which is separate from the state of the lock.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.6\n         */\n        DoorPositionSensor = \"DoorPositionSensor\",\n\n        /**\n         * FaceCredentials (FACE)\n         *\n         * Currently the cluster only defines the metadata format for notifications when a face recognition, iris, or\n         * retina credential is used to access the lock and doesn\u2019t describe how to create face recognition, iris, or\n         * retina credentials. If the Users feature is also supported then the User that a face recognition, iris, or\n         * retina credential is associated with can also have its UserType, UserStatus and Schedule modified.\n         *\n         * A lock may support multiple credential types so if the User feature is supported the UserType, UserStatus\n         * and Schedules are all associated with a User and not directly with a credential.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.7\n         */\n        FaceCredentials = \"FaceCredentials\",\n\n        /**\n         * CredentialOverTheAirAccess (COTA)\n         *\n         * If this feature is supported then the lock supports the ability to verify a credential provided in a\n         * lock/unlock command. Currently the cluster only supports providing the PIN credential to the lock/unlock\n         * commands. If this feature is supported then the PIN Credential feature shall also be supported.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.8\n         */\n        CredentialOverTheAirAccess = \"CredentialOverTheAirAccess\",\n\n        /**\n         * User (USR)\n         *\n         * If the User Feature is supported then a lock employs a User database. A User within the User database is\n         * used to associate credentials and schedules to single user record within the lock. This also means the\n         * UserType and UserStatus fields are associated with a User and not a credential.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.9\n         */\n        User = \"User\",\n\n        /**\n         * Notification (NOT)\n         *\n         * This is a feature used before support of events. This feature supports notification commands and masks used\n         * to filter these notifications.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.10\n         */\n        Notification = \"Notification\",\n\n        /**\n         * YearDayAccessSchedules (YDSCH)\n         *\n         * If the User feature is supported then Year Day Schedules are applied to a User and not a credential.\n         *\n         * Year Day Schedules are used to restrict access to a specified date and time window. When a schedule is\n         * cleared this clears the access restrictions and grants unrestricted access to the user. The lock may\n         * automatically adjust the UserType when a schedule is created or cleared.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.11\n         */\n        YearDayAccessSchedules = \"YearDayAccessSchedules\",\n\n        /**\n         * HolidaySchedules (HDSCH)\n         *\n         * This feature is used to setup Holiday Schedule in the lock device. A Holiday Schedule sets a start and stop\n         * end date/time for the lock to use the specified operating mode set by the Holiday Schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.12\n         */\n        HolidaySchedules = \"HolidaySchedules\",\n\n        /**\n         * Unbolting (UBOLT)\n         *\n         * Locks that support this feature differentiate between unbolting and unlocking. The Unbolt Door command\n         * retracts the bolt without pulling the latch. The Unlock Door command fully unlocks the door by retracting\n         * the bolt and briefly pulling the latch. While the latch is pulled, the lock state changes to Unlatched.\n         * Locks without unbolting support don\u2019t differentiate between unbolting and unlocking and perform the same\n         * operation for both commands.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.13\n         */\n        Unbolting = \"Unbolting\"\n    }\n\n    /**\n     * This enumeration shall indicate the current door state.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.12\n     */\n    export enum DoorState {\n        /**\n         * Door state is open\n         */\n        DoorOpen = 0,\n\n        /**\n         * Door state is closed\n         */\n        DoorClosed = 1,\n\n        /**\n         * Door state is jammed\n         */\n        DoorJammed = 2,\n\n        /**\n         * Door state is currently forced open\n         */\n        DoorForcedOpen = 3,\n\n        /**\n         * Door state is invalid for unspecified reason\n         */\n        DoorUnspecifiedError = 4,\n\n        /**\n         * Door state is ajar\n         */\n        DoorAjar = 5\n    }\n\n    /**\n     * Body of the DoorLock doorStateChange event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.2\n     */\n    export const TlvDoorStateChangeEvent = TlvObject({\n        /**\n         * This field shall indicate the new door state for this door event.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.2.1\n         */\n        doorState: TlvField(0, TlvEnum<DoorState>())\n    });\n\n    /**\n     * Body of the DoorLock doorStateChange event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.2\n     */\n    export interface DoorStateChangeEvent extends TypeFromSchema<typeof TlvDoorStateChangeEvent> {}\n\n    /**\n     * Input to the DoorLock getLogRecord command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.4\n     */\n    export const TlvGetLogRecordRequest = TlvObject({ logIndex: TlvField(0, TlvUInt16) });\n\n    /**\n     * Input to the DoorLock getLogRecord command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.4\n     */\n    export interface GetLogRecordRequest extends TypeFromSchema<typeof TlvGetLogRecordRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.24\n     */\n    export enum EventType {\n        /**\n         * Event type is operation\n         */\n        Operation = 0,\n\n        /**\n         * Event type is programming\n         */\n        Programming = 1,\n\n        /**\n         * Event type is alarm\n         */\n        Alarm = 2\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.25\n     */\n    export enum EventSource {\n        /**\n         * Event source is keypad\n         */\n        Keypad = 0,\n\n        /**\n         * Event source is remote\n         */\n        Remote = 1,\n\n        /**\n         * Event source is manual\n         */\n        Manual = 2,\n\n        /**\n         * Event source is RFID\n         */\n        Rfid = 3,\n\n        /**\n         * Event source is unknown\n         */\n        Indeterminate = 255\n    }\n\n    /**\n     * Returns the specified log record. If an invalid log entry ID was requested, it is set to 0 and the most recent\n     * log entry will be returned.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5\n     */\n    export const TlvGetLogRecordResponse = TlvObject({\n        /**\n         * This field shall indicate the index into the log table where this log entry is stored. If the log entry\n         * requested is 0, the most recent log is returned with the appropriate log entry ID.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.1\n         */\n        logEntryId: TlvField(0, TlvUInt16),\n\n        /**\n         * This field shall indicate the timestamp for all events and alarms on the door lock in Epoch Time in Seconds\n         * with local time offset based on the local timezone and DST offset on the day of the event.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.2\n         */\n        timestamp: TlvField(1, TlvEpochS),\n\n        /**\n         * This field shall indicate the type of event that took place on the door lock, as defined in EventTypeEnum.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.3\n         */\n        eventType: TlvField(2, TlvEnum<EventType>()),\n\n        /**\n         * This field shall indicate the source value as defined in EventSourceEnum.\n         *\n         * If the EventType is 2 (Alarm) then the source SHOULD be, but does not have to be 255 (Indeterminate).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.4\n         */\n        source: TlvField(3, TlvEnum<EventSource>()),\n\n        /**\n         * This field shall indicate the type of event that took place on the door lock depending on the event code\n         * table provided for a given event type and source. See Operation Event Codes.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.5\n         */\n        eventId: TlvField(4, TlvUInt8),\n\n        /**\n         * This field shall indicate the ID of the user who generated the event on the door lock if one is available.\n         * Otherwise, the value is 0xFFFF.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.6\n         */\n        userId: TlvField(5, TlvUInt16),\n\n        /**\n         * This field shall indicate the PIN code or RFID code that was used to create the event on the door lock if\n         * one is available.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5.7\n         */\n        pin: TlvField(6, TlvByteString)\n    });\n\n    /**\n     * Returns the specified log record. If an invalid log entry ID was requested, it is set to 0 and the most recent\n     * log entry will be returned.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.5\n     */\n    export interface GetLogRecordResponse extends TypeFromSchema<typeof TlvGetLogRecordResponse> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.2\n     */\n    export const CredentialRules = {\n        /**\n         * Only one credential is required for lock operation\n         */\n        single: BitFlag(0),\n\n        /**\n         * Any two credentials are required for lock operation\n         */\n        dual: BitFlag(1),\n\n        /**\n         * Any three credentials are required for lock operation\n         */\n        tri: BitFlag(2)\n    };\n\n    /**\n     * This enumeration shall indicate the data operation performed.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.11\n     */\n    export enum DataOperationType {\n        /**\n         * Data is being added or was added\n         */\n        Add = 0,\n\n        /**\n         * Data is being cleared or was cleared\n         */\n        Clear = 1,\n\n        /**\n         * Data is being modified or was modified\n         */\n        Modify = 2\n    }\n\n    /**\n     * This enumeration shall indicate what the status is for a specific user ID.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.18\n     */\n    export enum UserStatus {\n        /**\n         * The user ID is available\n         */\n        Available = 0,\n\n        /**\n         * The user ID is occupied and enabled\n         */\n        OccupiedEnabled = 1,\n\n        /**\n         * The user ID is occupied and disabled\n         */\n        OccupiedDisabled = 3\n    }\n\n    /**\n     * This enumeration shall indicate what the type is for a specific user ID.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19\n     */\n    export enum UserType {\n        /**\n         * The user ID type is unrestricted\n         *\n         * This value shall indicate the user has access 24/7 provided proper PIN or RFID is supplied (e.g., owner).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.1\n         */\n        UnrestrictedUser = 0,\n\n        /**\n         * The user ID type is schedule\n         *\n         * This value shall indicate the user has the ability to open lock within a specific time period (e.g., guest).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.2\n         */\n        YearDayScheduleUser = 1,\n\n        /**\n         * The user ID type is schedule\n         *\n         * This value shall indicate the user has the ability to open lock based on specific time period within a\n         * reoccurring weekly schedule (e.g., cleaning worker).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.3\n         */\n        WeekDayScheduleUser = 2,\n\n        /**\n         * The user ID type is programming\n         *\n         * This value shall indicate the user has the ability to both program and operate the door lock. This user can\n         * manage the users and user schedules. In all other respects this user matches the unrestricted (default)\n         * user. ProgrammingUser is the only user that can disable the user interface (keypad, remote, etc\u2026).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.4\n         */\n        ProgrammingUser = 3,\n\n        /**\n         * The user ID type is non access\n         *\n         * This value shall indicate the user is recognized by the lock but does not have the ability to open the lock.\n         * This user will only cause the lock to generate the appropriate event notification to any bound devices.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.5\n         */\n        NonAccessUser = 4,\n\n        /**\n         * The user ID type is forced\n         *\n         * This value shall indicate the user has the ability to open lock but a ForcedUser LockOperationType and\n         * ForcedUser silent alarm will be emitted to allow a notified Node to alert emergency services or contacts on\n         * the user account when used.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.6\n         */\n        ForcedUser = 5,\n\n        /**\n         * The user ID type is disposable\n         *\n         * This value shall indicate the user has the ability to open lock once after which the lock shall change the\n         * corresponding user record UserStatus value to OccupiedDisabled automatically.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.7\n         */\n        DisposableUser = 6,\n\n        /**\n         * The user ID type is expiring\n         *\n         * This value shall indicate the user has the ability to open lock for ExpiringUserTimeout attribute minutes\n         * after the first use of the PIN code, RFID code, Fingerprint, or other credential. After ExpiringUserTimeout\n         * minutes the corresponding user record UserStatus value shall be set to OccupiedDisabled automatically by the\n         * lock. The lock shall persist the timeout across reboots such that the ExpiringUserTimeout is honored.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.8\n         */\n        ExpiringUser = 7,\n\n        /**\n         * The user ID type is schedule restricted\n         *\n         * This value shall indicate the user access is restricted by Week Day and/or Year Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.9\n         */\n        ScheduleRestrictedUser = 8,\n\n        /**\n         * The user ID type is remote only\n         *\n         * This value shall indicate the user access and PIN code is restricted to remote lock/unlock commands only.\n         * This type of user might be useful for regular delivery services or voice assistant unlocking operations to\n         * prevent a PIN code credential created for them from being used at the keypad. The PIN code credential would\n         * only be provided over-the-air for the lock/unlock commands.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.19.10\n         */\n        RemoteOnlyUser = 9\n    }\n\n    /**\n     * This enumeration shall indicate the credential rule that can be applied to a particular user.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.9\n     */\n    export enum CredentialRule {\n        /**\n         * Only one credential is required for lock operation\n         */\n        Single = 0,\n\n        /**\n         * Any two credentials are required for lock operation\n         */\n        Dual = 1,\n\n        /**\n         * Any three credentials are required for lock operation\n         */\n        Tri = 2\n    }\n\n    /**\n     * Input to the DoorLock setUser command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34\n     */\n    export const TlvSetUserRequest = TlvObject({\n        /**\n         * This field shall indicate the type of operation.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.1\n         */\n        operationType: TlvField(0, TlvEnum<DataOperationType>()),\n\n        /**\n         * This field shall indicate the user ID.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.2\n         */\n        userIndex: TlvField(1, TlvUInt16.bound({ min: 1 })),\n\n        /**\n         * This field shall contain a string to use as a human readable identifier for the user. If UserName is null\n         * then:\n         *\n         *   \u2022 If the OperationType is Add, the UserName in the resulting user record shall be set to an empty string.\n         *\n         *   \u2022 If the OperationType is Modify, the UserName in the user record shall NOT be changed from the current\n         *     value.\n         *\n         * If UserName is not null, the UserName in the user record shall be set to the provided value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.3\n         */\n        userName: TlvField(2, TlvNullable(TlvString.bound({ maxLength: 10 }))),\n\n        /**\n         * This field shall indicate the fabric assigned number to use for connecting this user to other users on other\n         * devices from the fabric\u2019s perspective.\n         *\n         * If UserUniqueID is null then:\n         *\n         *   \u2022 If the OperationType is Add, the UserUniqueID in the resulting user record shall be set to default value\n         *     specified above.\n         *\n         *   \u2022 If the OperationType is Modify, the UserUniqueID in the user record shall NOT be changed from the\n         *     current value.\n         *\n         * If UserUniqueID is not null, the UserUniqueID in the user record shall be set to the provided value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.4\n         */\n        userUniqueId: TlvField(3, TlvNullable(TlvUInt32)),\n\n        /**\n         * This field shall indicate the UserStatus to assign to this user when created or modified. If UserStatus is\n         * null then:\n         *\n         *   \u2022 If the OperationType is Add, the UserStatus in the resulting user record shall be set to default value\n         *     specified above.\n         *\n         *   \u2022 If the OperationType is Modify, the UserStatus in the user record shall NOT be changed from the current\n         *     value.\n         *\n         * If UserStatus is not null, the UserStatus in the user record shall be set to the provided value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.5\n         */\n        userStatus: TlvField(4, TlvNullable(TlvEnum<UserStatus>())),\n\n        /**\n         * This field shall indicate the UserType to assign to this user when created or modified. If UserType is null\n         * then:\n         *\n         *   \u2022 If the OperationType is Add, the UserType in the resulting user record shall be set to default value\n         *     specified above.\n         *\n         *   \u2022 If the OperationType is Modify, the UserType in the user record shall NOT be changed from the current\n         *     value.\n         *\n         * If UserType is not null, the UserType in the user record shall be set to the provided value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.6\n         */\n        userType: TlvField(5, TlvNullable(TlvEnum<UserType>())),\n\n        /**\n         * This field shall indicate the CredentialRule to use for this user.\n         *\n         * The valid CredentialRule enumeration values depends on the bits in the CredentialRulesBitmap map. Each bit\n         * in the map identifies a valid CredentialRule that can be used.\n         *\n         * If CredentialRule is null then:\n         *\n         *   \u2022 If the OperationType is Add, the CredentialRule in the resulting user record shall be set to default\n         *     value specified above.\n         *\n         *   \u2022 If the OperationType is Modify, the CredentialRule in the user record shall NOT be changed from the\n         *     current value.\n         *\n         * If CredentialRule is not null, the CredentialRule in the user record shall be set to the provided value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34.7\n         */\n        credentialRule: TlvField(6, TlvNullable(TlvEnum<CredentialRule>()))\n    });\n\n    /**\n     * Input to the DoorLock setUser command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34\n     */\n    export interface SetUserRequest extends TypeFromSchema<typeof TlvSetUserRequest> {}\n\n    /**\n     * Input to the DoorLock getUser command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.35\n     */\n    export const TlvGetUserRequest = TlvObject({ userIndex: TlvField(0, TlvUInt16.bound({ min: 1 })) });\n\n    /**\n     * Input to the DoorLock getUser command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.35\n     */\n    export interface GetUserRequest extends TypeFromSchema<typeof TlvGetUserRequest> {}\n\n    /**\n     * This enumeration shall indicate the credential type.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.10\n     */\n    export enum CredentialType {\n        /**\n         * Programming PIN code credential type\n         */\n        ProgrammingPin = 0,\n\n        /**\n         * PIN code credential type\n         */\n        Pin = 1,\n\n        /**\n         * RFID identifier credential type\n         */\n        Rfid = 2,\n\n        /**\n         * Fingerprint identifier credential type\n         */\n        Fingerprint = 3,\n\n        /**\n         * Finger vein identifier credential type\n         */\n        FingerVein = 4,\n\n        /**\n         * Face identifier credential type\n         */\n        Face = 5\n    }\n\n    /**\n     * This struct shall indicate the credential types and their corresponding indices (if any) for the event or user\n     * record.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.26\n     */\n    export const TlvCredential = TlvObject({\n        /**\n         * This field shall indicate the credential field used to authorize the lock operation.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.26.1\n         */\n        credentialType: TlvField(0, TlvEnum<CredentialType>()),\n\n        /**\n         * This field shall indicate the index of the specific credential used to authorize the lock operation in the\n         * list of credentials identified by CredentialType (e.g. PIN, RFID, etc.). This field shall be set to 0 if\n         * CredentialType is ProgrammingPIN or does not correspond to a list that can be indexed into.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.26.2\n         */\n        credentialIndex: TlvField(1, TlvUInt16)\n    });\n\n    /**\n     * This struct shall indicate the credential types and their corresponding indices (if any) for the event or user\n     * record.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.26\n     */\n    export interface Credential extends TypeFromSchema<typeof TlvCredential> {}\n\n    /**\n     * Returns the user for the specified UserIndex.\n     *\n     * If the requested UserIndex is valid and the UserStatus is Available for the requested UserIndex then UserName,\n     * UserUniqueID, UserStatus, UserType, CredentialRule, Credentials, CreatorFabricIndex, and LastModifiedFabricIndex\n     * shall all be null in the response.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36\n     */\n    export const TlvGetUserResponse = TlvObject({\n        /**\n         * This field shall indicate the user ID.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.1\n         */\n        userIndex: TlvField(0, TlvUInt16.bound({ min: 1 })),\n\n        /**\n         * This field shall contain a string to use as a human readable identifier for the user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.2\n         */\n        userName: TlvField(1, TlvNullable(TlvString.bound({ maxLength: 10 }))),\n\n        /**\n         * See UserUniqueID field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.3\n         */\n        userUniqueId: TlvField(2, TlvNullable(TlvUInt32)),\n\n        /**\n         * This field shall indicate the UserStatus assigned to the user when created or modified.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.4\n         */\n        userStatus: TlvField(3, TlvNullable(TlvEnum<UserStatus>())),\n\n        /**\n         * This field shall indicate the UserType assigned to this user when created or modified.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.5\n         */\n        userType: TlvField(4, TlvNullable(TlvEnum<UserType>())),\n\n        /**\n         * This field shall indicate the CredentialRule set for this user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.6\n         */\n        credentialRule: TlvField(5, TlvNullable(TlvEnum<CredentialRule>())),\n\n        /**\n         * This field shall contain a list of credentials for this user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.7\n         */\n        credentials: TlvField(6, TlvNullable(TlvArray(TlvCredential, { minLength: 0 }))),\n\n        /**\n         * This field shall indicate the user\u2019s creator fabric index. CreatorFabricIndex shall be null if UserStatus is\n         * set to Available or when the creator fabric cannot be determined (for example, when user was created outside\n         * the Interaction Model) and shall NOT be null otherwise. This value shall be set to 0 if the original creator\n         * fabric was deleted.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.8\n         */\n        creatorFabricIndex: TlvField(7, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the user\u2019s last modifier fabric index. LastModifiedFabricIndex shall be null if\n         * UserStatus is set to Available or when the modifier fabric cannot be determined (for example, when user was\n         * modified outside the Interaction Model) and shall NOT be null otherwise. This value shall be set to 0 if the\n         * last modifier fabric was deleted.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.9\n         */\n        lastModifiedFabricIndex: TlvField(8, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the next occupied UserIndex in the database which is useful for quickly\n         * identifying occupied user slots in the database. This shall NOT be null if there is at least one occupied\n         * entry after the requested UserIndex in the User database and shall be null if there are no more occupied\n         * entries.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36.10\n         */\n        nextUserIndex: TlvField(9, TlvNullable(TlvUInt16.bound({ min: 1 })))\n    });\n\n    /**\n     * Returns the user for the specified UserIndex.\n     *\n     * If the requested UserIndex is valid and the UserStatus is Available for the requested UserIndex then UserName,\n     * UserUniqueID, UserStatus, UserType, CredentialRule, Credentials, CreatorFabricIndex, and LastModifiedFabricIndex\n     * shall all be null in the response.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.36\n     */\n    export interface GetUserResponse extends TypeFromSchema<typeof TlvGetUserResponse> {}\n\n    /**\n     * Input to the DoorLock clearUser command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.37\n     */\n    export const TlvClearUserRequest = TlvObject({\n        /**\n         * This field shall specify a valid User index or 0xFFFE to indicate all user slots shall be cleared.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.37.1\n         */\n        userIndex: TlvField(0, TlvUInt16)\n    });\n\n    /**\n     * Input to the DoorLock clearUser command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.37\n     */\n    export interface ClearUserRequest extends TypeFromSchema<typeof TlvClearUserRequest> {}\n\n    /**\n     * Input to the DoorLock setCredential command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40\n     */\n    export const TlvSetCredentialRequest = TlvObject({\n        /**\n         * This field shall indicate the set credential operation type requested.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40.1\n         */\n        operationType: TlvField(0, TlvEnum<DataOperationType>()),\n\n        /**\n         * This field shall contain a credential structure that contains the CredentialTypeEnum and the credential\n         * index (if applicable or 0 if not) to set.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40.2\n         */\n        credential: TlvField(1, TlvCredential),\n\n        /**\n         * This field shall indicate the credential data to set for the credential being added or modified. The length\n         * of the credential data shall conform to the limits of the CredentialType specified in the Credential\n         * structure otherwise an INVALID_COMMAND status shall be returned in the SetCredentialResponse command.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40.3\n         */\n        credentialData: TlvField(2, TlvByteString),\n\n        /**\n         * This field shall indicate the user index to the user record that corresponds to the credential being added\n         * or modified. This shall be null if OperationType is add and a new credential and user is being added at the\n         * same time.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40.4\n         */\n        userIndex: TlvField(3, TlvNullable(TlvUInt16.bound({ min: 1 }))),\n\n        /**\n         * This field shall indicate the user status to use in the new user record if a new user is being created. This\n         * shall be null if OperationType is Modify. This may be null when adding a new credential and user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40.5\n         */\n        userStatus: TlvField(4, TlvNullable(TlvEnum<UserStatus>())),\n\n        /**\n         * This field shall indicate the user type to use in the new user record if a new user is being created. This\n         * shall be null if OperationType is Modify. This may be null when adding a new credential and user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40.6\n         */\n        userType: TlvField(5, TlvNullable(TlvEnum<UserType>()))\n    });\n\n    /**\n     * Input to the DoorLock setCredential command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40\n     */\n    export interface SetCredentialRequest extends TypeFromSchema<typeof TlvSetCredentialRequest> {}\n\n    /**\n     * Returns the status for setting the specified credential.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.41\n     */\n    export const TlvSetCredentialResponse = TlvObject({\n        /**\n         * Status comes from the Status Codes table and shall be one of the following values:\n         *\n         *   \u2022 SUCCESS, if setting user credential was successful.\n         *\n         *   \u2022 FAILURE, if some unexpected internal error occurred setting user credential.\n         *\n         *   \u2022 OCCUPIED, if OperationType is Add and CredentialIndex in Credential structure points to an occupied slot.\n         *\n         *   \u2022 OCCUPIED, if OperationType is Modify and CredentialIndex in Credential structure does not match the\n         *     CredentialIndex that is already associated with the provided UserIndex.\n         *\n         *   \u2022 DUPLICATE, if CredentialData provided is a duplicate of another credential with the same CredentialType\n         *     (e.g. duplicate PIN code).\n         *\n         *   \u2022 RESOURCE_EXHAUSTED, if OperationType is Add and the user referred to by UserIndex already has\n         *     NumberOfCredentialsSupportedPerUser credentials associated.\n         *\n         *   \u2022 INVALID_COMMAND, if one or more fields violate constraints or are invalid.\n         *\n         *   \u2022 INVALID_COMMAND, if the CredentialIndex in the Credential provided exceeds the number of credentials of\n         *     the provided CredentialType supported by the lock.\n         *\n         *   \u2022 INVALID_COMMAND, if OperationType is Modify and UserIndex points to an available slot.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.41.1\n         */\n        status: TlvField(0, TlvEnum<GlobalStatusCode>()),\n\n        /**\n         * This field shall indicate the user index that was created with the new credential. If the status being\n         * returned is not success then this shall be null. This shall be null if OperationType was Modify; if the\n         * OperationType was Add and a new User was created this shall NOT be null and shall provide the UserIndex\n         * created. If the OperationType was Add and an existing User was associated with the new credential then this\n         * shall be null.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.41.2\n         */\n        userIndex: TlvField(1, TlvNullable(TlvUInt16.bound({ min: 1 }))),\n\n        /**\n         * This field shall indicate the next available index in the database for the credential type set, which is\n         * useful for quickly identifying available credential slots in the database. This shall NOT be null if there\n         * is at least one available entry after the requested credential index in the corresponding database and shall\n         * be null if there are no more available entries. The NextCredentialIndex reported shall NOT exceed the\n         * maximum number of credentials for a particular credential type.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.41.3\n         */\n        nextCredentialIndex: TlvOptionalField(2, TlvNullable(TlvUInt16))\n    });\n\n    /**\n     * Returns the status for setting the specified credential.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.41\n     */\n    export interface SetCredentialResponse extends TypeFromSchema<typeof TlvSetCredentialResponse> {}\n\n    /**\n     * Input to the DoorLock getCredentialStatus command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.42\n     */\n    export const TlvGetCredentialStatusRequest = TlvObject({\n        /**\n         * This field shall contain a credential structure that contains the CredentialTypeEnum and the credential\n         * index (if applicable or 0 if not) to retrieve the status for.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.42.1\n         */\n        credential: TlvField(0, TlvCredential)\n    });\n\n    /**\n     * Input to the DoorLock getCredentialStatus command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.42\n     */\n    export interface GetCredentialStatusRequest extends TypeFromSchema<typeof TlvGetCredentialStatusRequest> {}\n\n    /**\n     * Returns the status for the specified credential.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43\n     */\n    export const TlvGetCredentialStatusResponse = TlvObject({\n        /**\n         * This field shall indicate if the requested credential type and index exists and is populated for the\n         * requested user index.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43.1\n         */\n        credentialExists: TlvField(0, TlvBoolean),\n\n        /**\n         * This field shall indicate the credential\u2019s corresponding user index value if the credential exists. If\n         * CredentialType requested was ProgrammingPIN then UserIndex shall be null; otherwise, UserIndex shall be null\n         * if CredentialExists is set to False and shall NOT be null if CredentialExists is set to True.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43.2\n         */\n        userIndex: TlvField(1, TlvNullable(TlvUInt16.bound({ min: 1 }))),\n\n        /**\n         * This field shall indicate the credential\u2019s creator fabric index. CreatorFabricIndex shall be null if\n         * CredentialExists is set to False or when the creator fabric cannot be determined (for example, when\n         * credential was created outside the Interaction Model) and shall NOT be null otherwise. This value shall be\n         * set to 0 if the original creator fabric was deleted.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43.3\n         */\n        creatorFabricIndex: TlvField(2, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the credential\u2019s last modifier fabric index. LastModifiedFabricIndex shall be null\n         * if CredentialExists is set to False or when the modifier fabric cannot be determined (for example, when\n         * credential was modified outside the Interaction Model) and shall NOT be null otherwise. This value shall be\n         * set to 0 if the last modifier fabric was deleted.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43.4\n         */\n        lastModifiedFabricIndex: TlvField(3, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the next occupied index in the database for the credential type requested, which\n         * is useful for quickly identifying occupied credential slots in the database. This shall NOT be null if there\n         * is at least one occupied entry after the requested credential index in the corresponding database and shall\n         * be null if there are no more occupied entries. The NextCredentialIndex reported shall NOT exceed the maximum\n         * number of credentials for a particular credential type.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43.5\n         */\n        nextCredentialIndex: TlvOptionalField(4, TlvNullable(TlvUInt16))\n    });\n\n    /**\n     * Returns the status for the specified credential.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.43\n     */\n    export interface GetCredentialStatusResponse extends TypeFromSchema<typeof TlvGetCredentialStatusResponse> {}\n\n    /**\n     * Input to the DoorLock clearCredential command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.44\n     */\n    export const TlvClearCredentialRequest = TlvObject({\n        /**\n         * This field shall contain a credential structure that contains the CredentialTypeEnum and the credential\n         * index (0xFFFE for all credentials or 0 if not applicable) to clear. This shall be null if clearing all\n         * credential types otherwise it shall NOT be null.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.44.1\n         */\n        credential: TlvField(0, TlvNullable(TlvCredential))\n    });\n\n    /**\n     * Input to the DoorLock clearCredential command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.44\n     */\n    export interface ClearCredentialRequest extends TypeFromSchema<typeof TlvClearCredentialRequest> {}\n\n    /**\n     * This enumeration shall indicate the data type that is being or has changed.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.13\n     */\n    export enum LockDataType {\n        /**\n         * Unspecified or manufacturer specific lock user data added, cleared, or modified.\n         */\n        Unspecified = 0,\n\n        /**\n         * Lock programming PIN code was added, cleared, or modified.\n         */\n        ProgrammingCode = 1,\n\n        /**\n         * Lock user index was added, cleared, or modified.\n         */\n        UserIndex = 2,\n\n        /**\n         * Lock user week day schedule was added, cleared, or modified.\n         */\n        WeekDaySchedule = 3,\n\n        /**\n         * Lock user year day schedule was added, cleared, or modified.\n         */\n        YearDaySchedule = 4,\n\n        /**\n         * Lock holiday schedule was added, cleared, or modified.\n         */\n        HolidaySchedule = 5,\n\n        /**\n         * Lock user PIN code was added, cleared, or modified.\n         */\n        Pin = 6,\n\n        /**\n         * Lock user RFID code was added, cleared, or modified.\n         */\n        Rfid = 7,\n\n        /**\n         * Lock user fingerprint was added, cleared, or modified.\n         */\n        Fingerprint = 8,\n\n        /**\n         * Lock user finger-vein information was added, cleared, or modified.\n         */\n        FingerVein = 9,\n\n        /**\n         * Lock user face information was added, cleared, or modified.\n         */\n        Face = 10\n    }\n\n    /**\n     * This enumeration shall indicate the source of the Lock/Unlock or user change operation performed.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.17\n     */\n    export enum OperationSource {\n        /**\n         * Lock/unlock operation came from unspecified source\n         */\n        Unspecified = 0,\n\n        /**\n         * Lock/unlock operation came from manual operation (key, thumbturn, handle, etc).\n         */\n        Manual = 1,\n\n        /**\n         * Lock/unlock operation came from proprietary remote source (e.g. vendor app/cloud)\n         */\n        ProprietaryRemote = 2,\n\n        /**\n         * Lock/unlock operation came from keypad\n         */\n        Keypad = 3,\n\n        /**\n         * Lock/unlock operation came from lock automatically (e.g. relock timer)\n         */\n        Auto = 4,\n\n        /**\n         * Lock/unlock operation came from lock button (e.g. one touch or button)\n         */\n        Button = 5,\n\n        /**\n         * Lock/unlock operation came from lock due to a schedule\n         */\n        Schedule = 6,\n\n        /**\n         * Lock/unlock operation came from remote node\n         */\n        Remote = 7,\n\n        /**\n         * Lock/unlock operation came from RFID card\n         */\n        Rfid = 8,\n\n        /**\n         * Lock/unlock operation came from biometric source (e.g. face, fingerprint/fingervein)\n         */\n        Biometric = 9\n    }\n\n    /**\n     * Body of the DoorLock lockUserChange event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5\n     */\n    export const TlvLockUserChangeEvent = TlvObject({\n        /**\n         * This field shall indicate the lock data type that was changed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.1\n         */\n        lockDataType: TlvField(0, TlvEnum<LockDataType>()),\n\n        /**\n         * This field shall indicate the data operation performed on the lock data type changed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.2\n         */\n        dataOperationType: TlvField(1, TlvEnum<DataOperationType>()),\n\n        /**\n         * This field shall indicate the source of the user data change.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.3\n         */\n        operationSource: TlvField(2, TlvEnum<OperationSource>()),\n\n        /**\n         * This field shall indicate the lock UserIndex associated with the change (if any). This shall be null if\n         * there is no specific user associated with the data operation. This shall be 0xFFFE if all users are affected\n         * (e.g. Clear Users).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.4\n         */\n        userIndex: TlvField(3, TlvNullable(TlvUInt16)),\n\n        /**\n         * This field shall indicate the fabric index of the fabric that performed the change (if any). This shall be\n         * null if there is no fabric that can be determined to have caused the change. This shall NOT be null if the\n         * operation source is \"Remote\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.5\n         */\n        fabricIndex: TlvField(4, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the Node ID that performed the change (if any). The Node ID of the node that\n         * performed the change. This shall be null if there was no Node involved in the change. This shall NOT be null\n         * if the operation source is \"Remote\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.6\n         */\n        sourceNode: TlvField(5, TlvNullable(TlvNodeId)),\n\n        /**\n         * This field shall indicate the index of the specific item that was changed (e.g. schedule, PIN, RFID, etc.)\n         * in the list of items identified by LockDataType. This shall be null if the LockDataType does not correspond\n         * to a list that can be indexed into (e.g. ProgrammingUser). This shall be 0xFFFE if all indices are affected\n         * (e.g. ClearPINCode, ClearRFIDCode, ClearWeekDaySchedule, ClearYearDaySchedule, etc.).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5.7\n         */\n        dataIndex: TlvField(6, TlvNullable(TlvUInt16))\n    });\n\n    /**\n     * Body of the DoorLock lockUserChange event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5\n     */\n    export interface LockUserChangeEvent extends TypeFromSchema<typeof TlvLockUserChangeEvent> {}\n\n    /**\n     * This bitmap shall indicate the days of the week the Week Day schedule applies for.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.1\n     */\n    export const DaysMask = {\n        /**\n         * Schedule is applied on Sunday\n         */\n        sunday: BitFlag(0),\n\n        /**\n         * Schedule is applied on Monday\n         */\n        monday: BitFlag(1),\n\n        /**\n         * Schedule is applied on Tuesday\n         */\n        tuesday: BitFlag(2),\n\n        /**\n         * Schedule is applied on Wednesday\n         */\n        wednesday: BitFlag(3),\n\n        /**\n         * Schedule is applied on Thursday\n         */\n        thursday: BitFlag(4),\n\n        /**\n         * Schedule is applied on Friday\n         */\n        friday: BitFlag(5),\n\n        /**\n         * Schedule is applied on Saturday\n         */\n        saturday: BitFlag(6)\n    };\n\n    /**\n     * Input to the DoorLock setWeekDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14\n     */\n    export const TlvSetWeekDayScheduleRequest = TlvObject({\n        /**\n         * This field shall indicate the index of the Week Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14.1\n         */\n        weekDayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 })),\n\n        /**\n         * This field shall indicate which week days the schedule is active.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14.3\n         */\n        daysMask: TlvField(2, TlvBitmap(TlvUInt8, DaysMask)),\n\n        /**\n         * This field shall indicate the starting hour for the Week Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14.4\n         */\n        startHour: TlvField(3, TlvUInt8.bound({ max: 23 })),\n\n        /**\n         * This field shall indicate the starting minute for the Week Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14.5\n         */\n        startMinute: TlvField(4, TlvUInt8.bound({ max: 59 })),\n\n        /**\n         * This field shall indicate the ending hour for the Week Day schedule. EndHour shall be equal to or greater\n         * than StartHour.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14.6\n         */\n        endHour: TlvField(5, TlvUInt8.bound({ max: 23 })),\n\n        /**\n         * This field shall indicate the ending minute for the Week Day schedule. If EndHour is equal to StartHour then\n         * EndMinute shall be greater than StartMinute.\n         *\n         * If the EndHour is equal to 23 and the EndMinute is equal to 59 the Lock shall grant access to the user up\n         * until 23:59:59.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14.7\n         */\n        endMinute: TlvField(6, TlvUInt8.bound({ max: 59 }))\n    });\n\n    /**\n     * Input to the DoorLock setWeekDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14\n     */\n    export interface SetWeekDayScheduleRequest extends TypeFromSchema<typeof TlvSetWeekDayScheduleRequest> {}\n\n    /**\n     * Input to the DoorLock getWeekDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.15\n     */\n    export const TlvGetWeekDayScheduleRequest = TlvObject({\n        weekDayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 }))\n    });\n\n    /**\n     * Input to the DoorLock getWeekDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.15\n     */\n    export interface GetWeekDayScheduleRequest extends TypeFromSchema<typeof TlvGetWeekDayScheduleRequest> {}\n\n    /**\n     * Returns the weekly repeating schedule data for the specified schedule index.\n     *\n     * \u2020 The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead, respectively.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16\n     */\n    export const TlvGetWeekDayScheduleResponse = TlvObject({\n        /**\n         * This field shall indicate the index of the Week Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16.1\n         */\n        weekDayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 })),\n\n        /**\n         * Status shall be one of the following values:\n         *\n         *   \u2022 SUCCESS if both WeekDayIndex and UserIndex are valid and there is a corresponding schedule entry.\n         *\n         *   \u2022 INVALID_COMMAND if either WeekDayIndex and/or UserIndex values are not within valid range\n         *\n         *   \u2022 NOT_FOUND if no corresponding schedule entry found for WeekDayIndex.\n         *\n         *   \u2022 NOT_FOUND if no corresponding user entry found for UserIndex.\n         *\n         * If this field is SUCCESS, the optional fields for this command shall be present. For other (error) status\n         * values, only the fields up to the status field shall be present.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16.3\n         */\n        status: TlvField(2, TlvEnum<GlobalStatusCode>()),\n\n        daysMask: TlvOptionalField(3, TlvBitmap(TlvUInt8, DaysMask)),\n\n        /**\n         * This field shall indicate the starting hour for the Week Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16.4\n         */\n        startHour: TlvOptionalField(4, TlvUInt8.bound({ max: 23 })),\n\n        /**\n         * This field shall indicate the starting minute for the Week Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16.5\n         */\n        startMinute: TlvOptionalField(5, TlvUInt8.bound({ max: 59 })),\n\n        /**\n         * This field shall indicate the ending hour for the Week Day schedule. EndHour shall be equal to or greater\n         * than StartHour.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16.6\n         */\n        endHour: TlvOptionalField(6, TlvUInt8.bound({ max: 23 })),\n\n        /**\n         * This field shall indicate the ending minute for the Week Day schedule. If EndHour is equal to StartHour then\n         * EndMinute shall be greater than StartMinute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16.7\n         */\n        endMinute: TlvOptionalField(7, TlvUInt8.bound({ max: 59 }))\n    });\n\n    /**\n     * Returns the weekly repeating schedule data for the specified schedule index.\n     *\n     * \u2020 The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead, respectively.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.16\n     */\n    export interface GetWeekDayScheduleResponse extends TypeFromSchema<typeof TlvGetWeekDayScheduleResponse> {}\n\n    /**\n     * Input to the DoorLock clearWeekDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.17\n     */\n    export const TlvClearWeekDayScheduleRequest = TlvObject({\n        /**\n         * This field shall indicate the Week Day schedule index to clear or 0xFE to clear all Week Day schedules for\n         * the specified user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.17.1\n         */\n        weekDayIndex: TlvField(0, TlvUInt8),\n\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 }))\n    });\n\n    /**\n     * Input to the DoorLock clearWeekDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.17\n     */\n    export interface ClearWeekDayScheduleRequest extends TypeFromSchema<typeof TlvClearWeekDayScheduleRequest> {}\n\n    /**\n     * Input to the DoorLock setYearDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.18\n     */\n    export const TlvSetYearDayScheduleRequest = TlvObject({\n        /**\n         * This field shall indicate the index of the Year Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.18.1\n         */\n        yearDayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 })),\n\n        /**\n         * This field shall indicate the starting time for the Year Day schedule in Epoch Time in Seconds with local\n         * time offset based on the local timezone and DST offset on the day represented by the value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.18.3\n         */\n        localStartTime: TlvField(2, TlvEpochS),\n\n        /**\n         * This field shall indicate the ending time for the Year Day schedule in Epoch Time in Seconds with local time\n         * offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime shall be\n         * greater than LocalStartTime.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.18.4\n         */\n        localEndTime: TlvField(3, TlvEpochS)\n    });\n\n    /**\n     * Input to the DoorLock setYearDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.18\n     */\n    export interface SetYearDayScheduleRequest extends TypeFromSchema<typeof TlvSetYearDayScheduleRequest> {}\n\n    /**\n     * Input to the DoorLock getYearDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.19\n     */\n    export const TlvGetYearDayScheduleRequest = TlvObject({\n        yearDayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 }))\n    });\n\n    /**\n     * Input to the DoorLock getYearDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.19\n     */\n    export interface GetYearDayScheduleRequest extends TypeFromSchema<typeof TlvGetYearDayScheduleRequest> {}\n\n    /**\n     * Returns the year day schedule data for the specified schedule and user indexes.\n     *\n     * \u2020 The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead, respectively.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.20\n     */\n    export const TlvGetYearDayScheduleResponse = TlvObject({\n        /**\n         * This field shall indicate the index of the Year Day schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.20.1\n         */\n        yearDayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 })),\n\n        /**\n         * Status shall be one of the following values:\n         *\n         *   \u2022 SUCCESS if both YearDayIndex and UserIndex are valid and there is a corresponding schedule entry.\n         *\n         *   \u2022 INVALID_COMMAND if either YearDayIndex and/or UserIndex values are not within valid range\n         *\n         *   \u2022 NOT_FOUND if no corresponding schedule entry found for YearDayIndex.\n         *\n         *   \u2022 NOT_FOUND if no corresponding user entry found for UserIndex.\n         *\n         * If this field is SUCCESS, the optional fields for this command shall be present. For other (error) status\n         * values, only the fields up to the status field shall be present.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.20.3\n         */\n        status: TlvField(2, TlvEnum<GlobalStatusCode>()),\n\n        /**\n         * This field shall indicate the starting time for the Year Day schedule in Epoch Time in Seconds with local\n         * time offset based on the local timezone and DST offset on the day represented by the value. This shall be\n         * null if the schedule is not set for the YearDayIndex and UserIndex provided.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.20.4\n         */\n        localStartTime: TlvOptionalField(2, TlvEpochS),\n\n        /**\n         * This field shall indicate the ending time for the Year Day schedule in Epoch Time in Seconds with local time\n         * offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime shall be\n         * greater than LocalStartTime. This shall be null if the schedule is not set for the YearDayIndex and\n         * UserIndex provided.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.20.5\n         */\n        localEndTime: TlvOptionalField(3, TlvEpochS)\n    });\n\n    /**\n     * Returns the year day schedule data for the specified schedule and user indexes.\n     *\n     * \u2020 The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead, respectively.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.20\n     */\n    export interface GetYearDayScheduleResponse extends TypeFromSchema<typeof TlvGetYearDayScheduleResponse> {}\n\n    /**\n     * Input to the DoorLock clearYearDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.21\n     */\n    export const TlvClearYearDayScheduleRequest = TlvObject({\n        /**\n         * This field shall indicate the Year Day schedule index to clear or 0xFE to clear all Year Day schedules for\n         * the specified user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.21.1\n         */\n        yearDayIndex: TlvField(0, TlvUInt8),\n\n        userIndexUserId: TlvField(1, TlvUInt16.bound({ min: 1 }))\n    });\n\n    /**\n     * Input to the DoorLock clearYearDaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.21\n     */\n    export interface ClearYearDayScheduleRequest extends TypeFromSchema<typeof TlvClearYearDayScheduleRequest> {}\n\n    /**\n     * This enumeration shall indicate the lock operating mode.\n     *\n     * The table below shows the operating mode and which interfaces are enabled, if supported, for each mode.\n     *\n     * * Interface Operational: Yes, No or N/A\n     *\n     * NOTE\n     *\n     * For modes that disable the remote interface, the door lock shall respond to Lock, Unlock, Toggle, and Unlock\n     * with Timeout commands with a response status Failure and not take the action requested by those commands. The\n     * door lock shall NOT disable the radio or otherwise unbind or leave the network. It shall still respond to all\n     * other commands and requests.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.16\n     */\n    export enum OperatingMode {\n        /**\n         * The lock operates normally. All interfaces are enabled.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.16.1\n         */\n        Normal = 0,\n\n        /**\n         * Only remote interaction is enabled. The keypad shall only be operable by the master user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.16.2\n         */\n        Vacation = 1,\n\n        /**\n         * This mode is only possible if the door is locked. Manual unlocking changes the mode to Normal operating\n         * mode. All external interaction with the door lock is disabled. This mode is intended to be used so that\n         * users, presumably inside the property, will have control over the entrance.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.16.3\n         */\n        Privacy = 2,\n\n        /**\n         * This mode only disables remote interaction with the lock. This does not apply to any remote proprietary\n         * means of communication. It specifically applies to the Lock, Unlock, Toggle, and Unlock with Timeout\n         * Commands.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.16.4\n         */\n        NoRemoteLockUnlock = 3,\n\n        /**\n         * The lock is open or can be opened or closed at will without the use of a Keypad or other means of user\n         * validation (e.g. a lock for a business during work hours).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.16.5\n         */\n        Passage = 4\n    }\n\n    /**\n     * Input to the DoorLock setHolidaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22\n     */\n    export const TlvSetHolidayScheduleRequest = TlvObject({\n        /**\n         * This field shall indicate the index of the Holiday schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22.1\n         */\n        holidayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n\n        /**\n         * This field shall indicate the starting time for the Holiday Day schedule in Epoch Time in Seconds with local\n         * time offset based on the local timezone and DST offset on the day represented by the value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22.2\n         */\n        localStartTime: TlvField(1, TlvEpochS),\n\n        /**\n         * This field shall indicate the ending time for the Holiday Day schedule in Epoch Time in Seconds with local\n         * time offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime\n         * shall be greater than LocalStartTime.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22.3\n         */\n        localEndTime: TlvField(2, TlvEpochS),\n\n        /**\n         * This field shall indicate the operating mode to use during this Holiday schedule start/end time.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22.4\n         */\n        operatingMode: TlvField(3, TlvEnum<OperatingMode>())\n    });\n\n    /**\n     * Input to the DoorLock setHolidaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22\n     */\n    export interface SetHolidayScheduleRequest extends TypeFromSchema<typeof TlvSetHolidayScheduleRequest> {}\n\n    /**\n     * Input to the DoorLock getHolidaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.23\n     */\n    export const TlvGetHolidayScheduleRequest = TlvObject({ holidayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })) });\n\n    /**\n     * Input to the DoorLock getHolidaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.23\n     */\n    export interface GetHolidayScheduleRequest extends TypeFromSchema<typeof TlvGetHolidayScheduleRequest> {}\n\n    /**\n     * Returns the Holiday Schedule Entry for the specified Holiday ID.\n     *\n     * \u2020 The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24\n     */\n    export const TlvGetHolidayScheduleResponse = TlvObject({\n        /**\n         * This field shall indicate the index of the Holiday schedule.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24.1\n         */\n        holidayIndex: TlvField(0, TlvUInt8.bound({ min: 1 })),\n\n        /**\n         * Status shall be one of the following values:\n         *\n         *   \u2022 FAILURE if the attribute NumberOfHolidaySchedulesSupported is zero.\n         *\n         *   \u2022 SUCCESS if the HolidayIndex is valid and there is a corresponding schedule entry.\n         *\n         *   \u2022 INVALID_COMMAND if the HolidayIndex is not within valid range\n         *\n         *   \u2022 NOT_FOUND if the HolidayIndex is within the valid range, however, there is not corresponding schedule\n         *     entry found.\n         *\n         * If this field is SUCCESS, the optional fields for this command shall be present. For other (error) status\n         * values, only the fields up to the status field shall be present.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24.2\n         */\n        status: TlvField(1, TlvEnum<GlobalStatusCode>()),\n\n        /**\n         * This field shall indicate the starting time for the Holiday schedule in Epoch Time in Seconds with local\n         * time offset based on the local timezone and DST offset on the day represented by the value. This shall be\n         * null if the schedule is not set for the HolidayIndex provided.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24.3\n         */\n        localStartTime: TlvOptionalField(2, TlvNullable(TlvEpochS)),\n\n        /**\n         * This field shall indicate the ending time for the Holiday schedule in Epoch Time in Seconds with local time\n         * offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime shall be\n         * greater than LocalStartTime. This shall be null if the schedule is not set for the HolidayIndex provided.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24.4\n         */\n        localEndTime: TlvOptionalField(3, TlvNullable(TlvEpochS)),\n\n        /**\n         * This field shall indicate the operating mode to use during this Holiday schedule start/end time. This shall\n         * be null if the schedule is not set for the HolidayIndex provided.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24.5\n         */\n        operatingMode: TlvOptionalField(4, TlvNullable(TlvEnum<OperatingMode>()))\n    });\n\n    /**\n     * Returns the Holiday Schedule Entry for the specified Holiday ID.\n     *\n     * \u2020 The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.24\n     */\n    export interface GetHolidayScheduleResponse extends TypeFromSchema<typeof TlvGetHolidayScheduleResponse> {}\n\n    /**\n     * Input to the DoorLock clearHolidaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.25\n     */\n    export const TlvClearHolidayScheduleRequest = TlvObject({\n        /**\n         * This field shall indicate the Holiday schedule index to clear or 0xFE to clear all Holiday schedules.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.25.1\n         */\n        holidayIndex: TlvField(0, TlvUInt8)\n    });\n\n    /**\n     * Input to the DoorLock clearHolidaySchedule command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.25\n     */\n    export interface ClearHolidayScheduleRequest extends TypeFromSchema<typeof TlvClearHolidayScheduleRequest> {}\n\n    /**\n     * Input to the DoorLock setPinCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.6\n     */\n    export const TlvSetPinCodeRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the\n         * NumberOfPINUsersSupported attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.6.1\n         */\n        userId: TlvField(0, TlvUInt16),\n\n        /**\n         * This field shall indicate the user status. Only the values 1 (Occupied/Enabled) and 3 (Occupied/Disabled)\n         * are allowed for UserStatus.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.6.2\n         */\n        userStatus: TlvField(1, TlvNullable(TlvEnum<UserStatus>())),\n\n        userType: TlvField(2, TlvNullable(TlvEnum<UserType>())),\n        pin: TlvField(3, TlvByteString)\n    });\n\n    /**\n     * Input to the DoorLock setPinCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.6\n     */\n    export interface SetPinCodeRequest extends TypeFromSchema<typeof TlvSetPinCodeRequest> {}\n\n    /**\n     * Input to the DoorLock getPinCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.7\n     */\n    export const TlvGetPinCodeRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the\n         * NumberOfPINUsersSupported attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.7.1\n         */\n        userId: TlvField(0, TlvUInt16)\n    });\n\n    /**\n     * Input to the DoorLock getPinCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.7\n     */\n    export interface GetPinCodeRequest extends TypeFromSchema<typeof TlvGetPinCodeRequest> {}\n\n    /**\n     * Returns the PIN for the specified user ID.\n     *\n     * If the requested UserID is valid and the Code doesn\u2019t exist, Get RFID Code Response shall have the following\n     * format:\n     *\n     * UserID = requested User ID UserStatus = 0 (Available) UserType = Null (Not supported) PINCode = 0 (zero length)\n     *\n     * If the requested UserID is invalid, send Default Response with an error status. The error status shall be equal\n     * to CONSTRAINT_ERROR when User_ID is less than the max number of users supported, and NOT_FOUND if greater than\n     * or equal to the max number of users supported.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.8\n     */\n    export const TlvGetPinCodeResponse = TlvObject({\n        userId: TlvField(0, TlvUInt16),\n        userStatus: TlvField(1, TlvNullable(TlvEnum<UserStatus>())),\n        userType: TlvField(2, TlvNullable(TlvEnum<UserType>())),\n        pinCode: TlvField(3, TlvNullable(TlvByteString))\n    });\n\n    /**\n     * Returns the PIN for the specified user ID.\n     *\n     * If the requested UserID is valid and the Code doesn\u2019t exist, Get RFID Code Response shall have the following\n     * format:\n     *\n     * UserID = requested User ID UserStatus = 0 (Available) UserType = Null (Not supported) PINCode = 0 (zero length)\n     *\n     * If the requested UserID is invalid, send Default Response with an error status. The error status shall be equal\n     * to CONSTRAINT_ERROR when User_ID is less than the max number of users supported, and NOT_FOUND if greater than\n     * or equal to the max number of users supported.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.8\n     */\n    export interface GetPinCodeResponse extends TypeFromSchema<typeof TlvGetPinCodeResponse> {}\n\n    /**\n     * Input to the DoorLock clearPinCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.9\n     */\n    export const TlvClearPinCodeRequest = TlvObject({\n        /**\n         * This field shall specify a valid PIN code slot index or 0xFFFE to indicate all PIN code slots shall be\n         * cleared.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.9.1\n         */\n        pinSlotIndex: TlvField(0, TlvUInt16)\n    });\n\n    /**\n     * Input to the DoorLock clearPinCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.9\n     */\n    export interface ClearPinCodeRequest extends TypeFromSchema<typeof TlvClearPinCodeRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.7\n     */\n    export const EventMask = {\n        /**\n         * State of bit 0\n         */\n        bit0: BitFlag(0),\n\n        /**\n         * State of bit 1\n         */\n        bit1: BitFlag(1),\n\n        /**\n         * State of bit 2\n         */\n        bit2: BitFlag(2),\n\n        /**\n         * State of bit 3\n         */\n        bit3: BitFlag(3),\n\n        /**\n         * State of bit 4\n         */\n        bit4: BitFlag(4),\n\n        /**\n         * State of bit 5\n         */\n        bit5: BitFlag(5),\n\n        /**\n         * State of bit 6\n         */\n        bit6: BitFlag(6),\n\n        /**\n         * State of bit 7\n         */\n        bit7: BitFlag(7),\n\n        /**\n         * State of bit 8\n         */\n        bit8: BitFlag(8),\n\n        /**\n         * State of bit 9\n         */\n        bit9: BitFlag(9),\n\n        /**\n         * State of bit 10\n         */\n        bit10: BitFlag(10),\n\n        /**\n         * State of bit 11\n         */\n        bit11: BitFlag(11),\n\n        /**\n         * State of bit 12\n         */\n        bit12: BitFlag(12),\n\n        /**\n         * State of bit 13\n         */\n        bit13: BitFlag(13),\n\n        /**\n         * State of bit 14\n         */\n        bit14: BitFlag(14),\n\n        /**\n         * State of bit 15\n         */\n        bit15: BitFlag(15)\n    };\n\n    /**\n     * The value of the DoorLock keypadProgrammingEventMask attribute\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.45\n     */\n    export const KeypadProgrammingEventMask = {\n        unknown: BitFlag(0),\n        pinCodeChanged: BitFlag(1),\n        pinAdded: BitFlag(2),\n        pinCleared: BitFlag(3),\n        pinChanged: BitFlag(4)\n    };\n\n    /**\n     * The value of the DoorLock remoteProgrammingEventMask attribute\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.46\n     */\n    export const RemoteProgrammingEventMask = {\n        unknown: BitFlag(0),\n        pinAdded: BitFlag(2),\n        pinCleared: BitFlag(3),\n        pinChanged: BitFlag(4),\n        rfidCodeAdded: BitFlag(5),\n        rfidCodeCleared: BitFlag(6)\n    };\n\n    /**\n     * The value of the DoorLock rfidProgrammingEventMask attribute\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.47\n     */\n    export const RfidProgrammingEventMask = { unknown: BitFlag(0), idAdded: BitFlag(5), idCleared: BitFlag(6) };\n\n    /**\n     * Input to the DoorLock setUserStatus command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.11\n     */\n    export const TlvSetUserStatusRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the\n         * NumberOfPINUsersSupported attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.11.1\n         */\n        userId: TlvField(0, TlvUInt16),\n\n        /**\n         * UserStatus value of Available is not allowed. In order to clear a user id, the ClearUser Command shall be\n         * used. For user status value please refer to UserStatusEnum.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.11.2\n         */\n        userStatus: TlvField(1, TlvEnum<UserStatus>())\n    });\n\n    /**\n     * Input to the DoorLock setUserStatus command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.11\n     */\n    export interface SetUserStatusRequest extends TypeFromSchema<typeof TlvSetUserStatusRequest> {}\n\n    /**\n     * Input to the DoorLock getUserStatus command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.12\n     */\n    export const TlvGetUserStatusRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the\n         * NumberOfPINUsersSupported attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.12.1\n         */\n        userId: TlvField(0, TlvUInt16)\n    });\n\n    /**\n     * Input to the DoorLock getUserStatus command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.12\n     */\n    export interface GetUserStatusRequest extends TypeFromSchema<typeof TlvGetUserStatusRequest> {}\n\n    /**\n     * Returns the user status for the specified user ID.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.13\n     */\n    export const TlvGetUserStatusResponse = TlvObject({\n        /**\n         * This field shall indicate the user ID provided in the request.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.13.1\n         */\n        userId: TlvField(0, TlvUInt16),\n\n        /**\n         * This field shall indicate the current status of the requested user ID.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.13.2\n         */\n        userStatus: TlvField(1, TlvEnum<UserStatus>())\n    });\n\n    /**\n     * Returns the user status for the specified user ID.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.13\n     */\n    export interface GetUserStatusResponse extends TypeFromSchema<typeof TlvGetUserStatusResponse> {}\n\n    /**\n     * Input to the DoorLock setUserType command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.26\n     */\n    export const TlvSetUserTypeRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.26.1\n         */\n        userId: TlvField(0, TlvUInt16),\n\n        /**\n         * This field shall indicate the user type.\n         *\n         * If UserType is currently YearDayScheduleUser, WeekDayScheduleUser, or ScheduleRestrictedUser and the new\n         * UserType is UnrestrictedUser then all existing Year Day and/or Week Day schedules shall be ignored or\n         * disabled (if this transition is supported by the door lock). If UserType is ScheduleRestrictedUser and the\n         * new UserType is ScheduleRestrictedUser then all existing Year Day and/or Week Day schedules shall be applied\n         * or enabled.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.26.2\n         */\n        userType: TlvField(1, TlvEnum<UserType>())\n    });\n\n    /**\n     * Input to the DoorLock setUserType command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.26\n     */\n    export interface SetUserTypeRequest extends TypeFromSchema<typeof TlvSetUserTypeRequest> {}\n\n    /**\n     * Input to the DoorLock getUserType command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.27\n     */\n    export const TlvGetUserTypeRequest = TlvObject({ userId: TlvField(0, TlvUInt16) });\n\n    /**\n     * Input to the DoorLock getUserType command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.27\n     */\n    export interface GetUserTypeRequest extends TypeFromSchema<typeof TlvGetUserTypeRequest> {}\n\n    /**\n     * Returns the user type for the specified user ID. If the requested User ID is invalid, send Default Response with\n     * an error status equal to FAILURE.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.28\n     */\n    export const TlvGetUserTypeResponse = TlvObject({\n        userId: TlvField(0, TlvUInt16),\n        userType: TlvField(1, TlvEnum<UserType>())\n    });\n\n    /**\n     * Returns the user type for the specified user ID. If the requested User ID is invalid, send Default Response with\n     * an error status equal to FAILURE.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.28\n     */\n    export interface GetUserTypeResponse extends TypeFromSchema<typeof TlvGetUserTypeResponse> {}\n\n    /**\n     * Input to the DoorLock setRfidCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.29\n     */\n    export const TlvSetRfidCodeRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID.\n         *\n         * The value of the UserID field shall be between 0 and the value of the NumberOfRFIDUsersSupported attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.29.1\n         */\n        userId: TlvField(0, TlvUInt16),\n\n        /**\n         * This field shall indicate what the status is for a specific user ID. The values are according to \u201CSet PIN\u201D\n         * while not all are supported.\n         *\n         * Only the values 1 (Occupied/Enabled) and 3 (Occupied/Disabled) are allowed for UserStatus.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.29.2\n         */\n        userStatus: TlvField(1, TlvNullable(TlvEnum<UserStatus>())),\n\n        /**\n         * The values are the same as used for SetPINCode command.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.29.3\n         */\n        userType: TlvField(2, TlvNullable(TlvEnum<UserType>())),\n\n        rfidCode: TlvField(3, TlvByteString)\n    });\n\n    /**\n     * Input to the DoorLock setRfidCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.29\n     */\n    export interface SetRfidCodeRequest extends TypeFromSchema<typeof TlvSetRfidCodeRequest> {}\n\n    /**\n     * Input to the DoorLock getRfidCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.30\n     */\n    export const TlvGetRfidCodeRequest = TlvObject({\n        /**\n         * This field shall indicate the user ID.\n         *\n         * The value of the UserID field shall be between 0 and the value of the NumberOfRFIDUsersSupported attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.30.1\n         */\n        userId: TlvField(0, TlvUInt16)\n    });\n\n    /**\n     * Input to the DoorLock getRfidCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.30\n     */\n    export interface GetRfidCodeRequest extends TypeFromSchema<typeof TlvGetRfidCodeRequest> {}\n\n    /**\n     * Returns the RFID code for the specified user ID.\n     *\n     * If the requested User ID is valid and the Code doesn\u2019t exist, Get RFID Code Response shall have the following\n     * format:\n     *\n     * User ID = requested User ID UserStatus = 0 (available) UserType = 0xFF (not supported) RFID Code = 0 (zero\n     * length)\n     *\n     * If requested User ID is invalid, send Default Response with an error status. The error status shall be equal to\n     * CONSTRAINT_ERROR when User_ID is less than the max number of users supported, and NOT_FOUND if greater than or\n     * equal to the max number of users supported.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.31\n     */\n    export const TlvGetRfidCodeResponse = TlvObject({\n        userId: TlvField(0, TlvUInt16),\n        userStatus: TlvField(1, TlvNullable(TlvEnum<UserStatus>())),\n        userType: TlvField(2, TlvNullable(TlvEnum<UserType>())),\n        rfidCode: TlvField(3, TlvNullable(TlvByteString))\n    });\n\n    /**\n     * Returns the RFID code for the specified user ID.\n     *\n     * If the requested User ID is valid and the Code doesn\u2019t exist, Get RFID Code Response shall have the following\n     * format:\n     *\n     * User ID = requested User ID UserStatus = 0 (available) UserType = 0xFF (not supported) RFID Code = 0 (zero\n     * length)\n     *\n     * If requested User ID is invalid, send Default Response with an error status. The error status shall be equal to\n     * CONSTRAINT_ERROR when User_ID is less than the max number of users supported, and NOT_FOUND if greater than or\n     * equal to the max number of users supported.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.31\n     */\n    export interface GetRfidCodeResponse extends TypeFromSchema<typeof TlvGetRfidCodeResponse> {}\n\n    /**\n     * Input to the DoorLock clearRfidCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.32\n     */\n    export const TlvClearRfidCodeRequest = TlvObject({\n        /**\n         * This field shall indicate a valid RFID code slot index or 0xFFFE to indicate all RFID code slots shall be\n         * cleared.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.32.1\n         */\n        rfidSlotIndex: TlvField(0, TlvUInt16)\n    });\n\n    /**\n     * Input to the DoorLock clearRfidCode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.32\n     */\n    export interface ClearRfidCodeRequest extends TypeFromSchema<typeof TlvClearRfidCodeRequest> {}\n\n    /**\n     * Input to the DoorLock unboltDoor command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.45\n     */\n    export const TlvUnboltDoorRequest = TlvObject({\n        /**\n         * See PINCode field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.45.1\n         */\n        pinCode: TlvOptionalField(0, TlvByteString)\n    });\n\n    /**\n     * Input to the DoorLock unboltDoor command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.45\n     */\n    export interface UnboltDoorRequest extends TypeFromSchema<typeof TlvUnboltDoorRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.20\n     */\n    export enum LockState {\n        /**\n         * Lock state is not fully locked\n         */\n        NotFullyLocked = 0,\n\n        /**\n         * Lock state is fully locked\n         */\n        Locked = 1,\n\n        /**\n         * Lock state is fully unlocked\n         */\n        Unlocked = 2,\n\n        /**\n         * Lock state is fully unlocked and the latch is pulled\n         */\n        Unlatched = 3\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.21\n     */\n    export enum LockType {\n        /**\n         * Physical lock type is dead bolt\n         */\n        DeadBolt = 0,\n\n        /**\n         * Physical lock type is magnetic\n         */\n        Magnetic = 1,\n\n        /**\n         * Physical lock type is other\n         */\n        Other = 2,\n\n        /**\n         * Physical lock type is mortise\n         */\n        Mortise = 3,\n\n        /**\n         * Physical lock type is rim\n         */\n        Rim = 4,\n\n        /**\n         * Physical lock type is latch bolt\n         */\n        LatchBolt = 5,\n\n        /**\n         * Physical lock type is cylindrical lock\n         */\n        CylindricalLock = 6,\n\n        /**\n         * Physical lock type is tubular lock\n         */\n        TubularLock = 7,\n\n        /**\n         * Physical lock type is interconnected lock\n         */\n        InterconnectedLock = 8,\n\n        /**\n         * Physical lock type is dead latch\n         */\n        DeadLatch = 9,\n\n        /**\n         * Physical lock type is door furniture\n         */\n        DoorFurniture = 10,\n\n        /**\n         * Physical lock type is euro cylinder\n         */\n        Eurocylinder = 11\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.22\n     */\n    export enum LedSetting {\n        /**\n         * Never use LED for signalization\n         */\n        NoLedSignal = 0,\n\n        /**\n         * Use LED signalization except for access allowed events\n         */\n        NoLedSignalAccessAllowed = 1,\n\n        /**\n         * Use LED signalization for all events\n         */\n        LedSignalAll = 2\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.23\n     */\n    export enum SoundVolume {\n        /**\n         * Silent Mode\n         */\n        Silent = 0,\n\n        /**\n         * Low Volume\n         */\n        Low = 1,\n\n        /**\n         * High Volume\n         */\n        High = 2,\n\n        /**\n         * Medium Volume\n         */\n        Medium = 3\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.3\n     */\n    export const OperatingModes = {\n        /**\n         * Normal operation mode\n         */\n        normal: BitFlag(0),\n\n        /**\n         * Vacation operation mode\n         */\n        vacation: BitFlag(1),\n\n        /**\n         * Privacy operation mode\n         */\n        privacy: BitFlag(2),\n\n        /**\n         * No remote lock and unlock operation mode\n         */\n        noRemoteLockUnlock: BitFlag(3),\n\n        /**\n         * Passage operation mode\n         */\n        passage: BitFlag(4)\n    };\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4\n     */\n    export const ConfigurationRegister = {\n        /**\n         * The state of local programming functionality\n         *\n         * This bit shall indicate the state related to local programming:\n         *\n         *   \u2022 0 = Local programming is disabled\n         *\n         *   \u2022 1 = Local programming is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4.1\n         */\n        localProgramming: BitFlag(0),\n\n        /**\n         * The state of the keypad interface\n         *\n         * This bit shall indicate the state related to keypad interface:\n         *\n         *   \u2022 0 = Keypad interface is disabled\n         *\n         *   \u2022 1 = Keypad interface is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4.2\n         */\n        keypadInterface: BitFlag(1),\n\n        /**\n         * The state of the remote interface\n         *\n         * This bit shall indicate the state related to remote interface:\n         *\n         *   \u2022 0 = Remote interface is disabled\n         *\n         *   \u2022 1 = Remote interface is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4.3\n         */\n        remoteInterface: BitFlag(2),\n\n        /**\n         * Sound volume is set to Silent value\n         *\n         * This bit shall indicate the state related to sound volume:\n         *\n         *   \u2022 0 = Sound volume value is 0 (Silent)\n         *\n         *   \u2022 1 = Sound volume value is equal to something other than 0\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4.4\n         */\n        soundVolume: BitFlag(5),\n\n        /**\n         * Auto relock time it set to 0\n         *\n         * This bit shall indicate the state related to auto relock time:\n         *\n         *   \u2022 0 = Auto relock time value is 0\n         *\n         *   \u2022 1 = Auto relock time value is equal to something other than 0\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4.5\n         */\n        autoRelockTime: BitFlag(6),\n\n        /**\n         * LEDs is disabled\n         *\n         * This bit shall indicate the state related to LED settings:\n         *\n         *   \u2022 0 = LED settings value is 0 (NoLEDSignal)\n         *\n         *   \u2022 1 = LED settings value is equal to something other than 0\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.4.6\n         */\n        ledSettings: BitFlag(7)\n    };\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.5\n     */\n    export const LocalProgrammingFeatures = {\n        /**\n         * The state of the ability to add users, credentials or schedules on the device\n         *\n         * This bit shall indicate whether the door lock is able to add Users/Credentials/Schedules locally:\n         *\n         *   \u2022 0 = This ability is disabled\n         *\n         *   \u2022 1 = This ability is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.5.1\n         */\n        addUsersCredentialsSchedules: BitFlag(0),\n\n        /**\n         * The state of the ability to modify users, credentials or schedules on the device\n         *\n         * This bit shall indicate whether the door lock is able to modify Users/Credentials/Schedules locally:\n         *\n         *   \u2022 0 = This ability is disabled\n         *\n         *   \u2022 1 = This ability is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.5.2\n         */\n        modifyUsersCredentialsSchedules: BitFlag(1),\n\n        /**\n         * The state of the ability to clear users, credentials or schedules on the device\n         *\n         * This bit shall indicate whether the door lock is able to clear Users/Credentials/Schedules locally:\n         *\n         *   \u2022 0 = This ability is disabled\n         *\n         *   \u2022 1 = This ability is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.5.3\n         */\n        clearUsersCredentialsSchedules: BitFlag(2),\n\n        /**\n         * The state of the ability to adjust settings on the device\n         *\n         * This bit shall indicate whether the door lock is able to adjust lock settings locally:\n         *\n         *   \u2022 0 = This ability is disabled\n         *\n         *   \u2022 1 = This ability is enabled\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.5.4\n         */\n        adjustSettings: BitFlag(3)\n    };\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.6\n     */\n    export const AlarmMask = {\n        /**\n         * Locking Mechanism Jammed\n         */\n        lockJammed: BitFlag(0),\n\n        /**\n         * Lock Reset to Factory Defaults\n         */\n        lockFactoryReset: BitFlag(1),\n\n        /**\n         * Reserved\n         */\n        na: BitFlag(2),\n\n        /**\n         * RF Module Power Cycled\n         */\n        lockRadioPowerCycled: BitFlag(3),\n\n        /**\n         * Tamper Alarm - wrong code entry limit\n         */\n        wrongCodeEntryLimit: BitFlag(4),\n\n        /**\n         * Tamper Alarm - front escutcheon removed from main\n         */\n        frontEscutcheonRemoved: BitFlag(5),\n\n        /**\n         * Forced Door Open under Door Locked Condition\n         */\n        doorForcedOpen: BitFlag(6)\n    };\n\n    /**\n     * Input to the DoorLock lockDoor command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.1\n     */\n    export const TlvLockDoorRequest = TlvObject({\n        /**\n         * If the RequirePINforRemoteOperation attribute is True then PINCode field shall be provided and the door lock\n         * shall NOT grant access if it is not provided.\n         *\n         * If the PINCode field is provided, the door lock shall verify PINCode before granting access regardless of\n         * the value of RequirePINForRemoteOperation attribute.\n         *\n         * When the PINCode field is provided an invalid PIN will count towards the WrongCodeEntryLimit and the\n         * UserCodeTemporaryDisableTime will be triggered if the WrongCodeEntryLimit is exceeded. The lock shall ignore\n         * any attempts to lock/unlock the door until the UserCodeTemporaryDisableTime expires.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.1.1\n         */\n        pinCode: TlvOptionalField(0, TlvByteString)\n    });\n\n    /**\n     * Input to the DoorLock lockDoor command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.1\n     */\n    export interface LockDoorRequest extends TypeFromSchema<typeof TlvLockDoorRequest> {}\n\n    /**\n     * Input to the DoorLock unlockDoor command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.2\n     */\n    export const TlvUnlockDoorRequest = TlvObject({\n        /**\n         * See PINCode field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.2.1\n         */\n        pinCode: TlvOptionalField(0, TlvByteString)\n    });\n\n    /**\n     * Input to the DoorLock unlockDoor command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.2\n     */\n    export interface UnlockDoorRequest extends TypeFromSchema<typeof TlvUnlockDoorRequest> {}\n\n    /**\n     * Input to the DoorLock unlockWithTimeout command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.3\n     */\n    export const TlvUnlockWithTimeoutRequest = TlvObject({\n        /**\n         * This field shall indicate the timeout in seconds to wait before relocking the door lock. This value is\n         * independent of the AutoRelockTime attribute value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.3.1\n         */\n        timeout: TlvField(0, TlvUInt16),\n\n        /**\n         * See PINCode field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.3.2\n         */\n        pinCode: TlvOptionalField(1, TlvByteString)\n    });\n\n    /**\n     * Input to the DoorLock unlockWithTimeout command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.3\n     */\n    export interface UnlockWithTimeoutRequest extends TypeFromSchema<typeof TlvUnlockWithTimeoutRequest> {}\n\n    /**\n     * This enumeration shall indicate the alarm type.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.8\n     */\n    export enum AlarmCode {\n        /**\n         * Locking Mechanism Jammed\n         */\n        LockJammed = 0,\n\n        /**\n         * Lock Reset to Factory Defaults\n         */\n        LockFactoryReset = 1,\n\n        /**\n         * Lock Radio Power Cycled\n         */\n        LockRadioPowerCycled = 3,\n\n        /**\n         * Tamper Alarm - wrong code entry limit\n         */\n        WrongCodeEntryLimit = 4,\n\n        /**\n         * Tamper Alarm - front escutcheon removed from main\n         */\n        FrontEsceutcheonRemoved = 5,\n\n        /**\n         * Forced Door Open under Door Locked Condition\n         */\n        DoorForcedOpen = 6,\n\n        /**\n         * Door ajar\n         */\n        DoorAjar = 7,\n\n        /**\n         * Force User SOS alarm\n         */\n        ForcedUser = 8\n    }\n\n    /**\n     * Body of the DoorLock doorLockAlarm event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.1\n     */\n    export const TlvDoorLockAlarmEvent = TlvObject({\n        /**\n         * This field shall indicate the alarm code of the event that has happened.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.1.1\n         */\n        alarmCode: TlvField(0, TlvEnum<AlarmCode>())\n    });\n\n    /**\n     * Body of the DoorLock doorLockAlarm event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.1\n     */\n    export interface DoorLockAlarmEvent extends TypeFromSchema<typeof TlvDoorLockAlarmEvent> {}\n\n    /**\n     * This enumeration shall indicate the type of Lock operation performed.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.14\n     */\n    export enum LockOperationType {\n        /**\n         * Lock operation\n         */\n        Lock = 0,\n\n        /**\n         * Unlock operation\n         */\n        Unlock = 1,\n\n        /**\n         * Triggered by keypad entry for user with User Type set to Non Access User\n         */\n        NonAccessUserEvent = 2,\n\n        /**\n         * Triggered by using a user with UserType set to Forced User\n         */\n        ForcedUserEvent = 3,\n\n        /**\n         * Unlatch operation\n         */\n        Unlatch = 4\n    }\n\n    /**\n     * Body of the DoorLock lockOperation event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3\n     */\n    export const TlvLockOperationEvent = TlvObject({\n        /**\n         * This field shall indicate the type of the lock operation that was performed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3.1\n         */\n        lockOperationType: TlvField(0, TlvEnum<LockOperationType>()),\n\n        /**\n         * This field shall indicate the source of the lock operation that was performed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3.2\n         */\n        operationSource: TlvField(1, TlvEnum<OperationSource>()),\n\n        /**\n         * This field shall indicate the UserIndex who performed the lock operation. This shall be null if there is no\n         * user index that can be determined for the given operation source. This shall NOT be null if a user index can\n         * be determined. In particular, this shall NOT be null if the operation was associated with a valid credential.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3.3\n         */\n        userIndex: TlvField(2, TlvNullable(TlvUInt16)),\n\n        /**\n         * This field shall indicate the fabric index of the fabric that performed the lock operation. This shall be\n         * null if there is no fabric that can be determined for the given operation source. This shall NOT be null if\n         * the operation source is \"Remote\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3.4\n         */\n        fabricIndex: TlvField(3, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the Node ID of the node that performed the lock operation. This shall be null if\n         * there is no Node associated with the given operation source. This shall NOT be null if the operation source\n         * is \"Remote\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3.5\n         */\n        sourceNode: TlvField(4, TlvNullable(TlvNodeId)),\n\n        /**\n         * This field shall indicate the list of credentials used in performing the lock operation. This shall be null\n         * if no credentials were involved.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3.6\n         */\n        credentials: TlvOptionalField(5, TlvNullable(TlvArray(TlvCredential, { minLength: 1 })))\n    });\n\n    /**\n     * Body of the DoorLock lockOperation event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3\n     */\n    export interface LockOperationEvent extends TypeFromSchema<typeof TlvLockOperationEvent> {}\n\n    /**\n     * This enumeration shall indicate the error cause of the Lock/Unlock operation performed.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.15\n     */\n    export enum OperationError {\n        /**\n         * Lock/unlock error caused by unknown or unspecified source\n         */\n        Unspecified = 0,\n\n        /**\n         * Lock/unlock error caused by invalid PIN, RFID, fingerprint or other credential\n         */\n        InvalidCredential = 1,\n\n        /**\n         * Lock/unlock error caused by disabled USER or credential\n         */\n        DisabledUserDenied = 2,\n\n        /**\n         * Lock/unlock error caused by schedule restriction\n         */\n        Restricted = 3,\n\n        /**\n         * Lock/unlock error caused by insufficient battery power left to safely actuate the lock\n         */\n        InsufficientBattery = 4\n    }\n\n    /**\n     * Body of the DoorLock lockOperationError event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4\n     */\n    export const TlvLockOperationErrorEvent = TlvObject({\n        /**\n         * This field shall indicate the type of the lock operation that was performed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.1\n         */\n        lockOperationType: TlvField(0, TlvEnum<LockOperationType>()),\n\n        /**\n         * This field shall indicate the source of the lock operation that was performed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.2\n         */\n        operationSource: TlvField(1, TlvEnum<OperationSource>()),\n\n        /**\n         * This field shall indicate the lock operation error triggered when the operation was performed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.3\n         */\n        operationError: TlvField(2, TlvEnum<OperationError>()),\n\n        /**\n         * This field shall indicate the lock UserIndex who performed the lock operation. This shall be null if there\n         * is no user id that can be determined for the given operation source.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.4\n         */\n        userIndex: TlvField(3, TlvNullable(TlvUInt16)),\n\n        /**\n         * This field shall indicate the fabric index of the fabric that performed the lock operation. This shall be\n         * null if there is no fabric that can be determined for the given operation source. This shall NOT be null if\n         * the operation source is \"Remote\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.5\n         */\n        fabricIndex: TlvField(4, TlvNullable(TlvFabricIndex)),\n\n        /**\n         * This field shall indicate the Node ID of the node that performed the lock operation. This shall be null if\n         * there is no Node associated with the given operation source. This shall NOT be null if the operation source\n         * is \"Remote\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.6\n         */\n        sourceNode: TlvField(5, TlvNullable(TlvNodeId)),\n\n        /**\n         * This field shall indicate the list of credentials used in performing the lock operation. This shall be null\n         * if no credentials were involved.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4.7\n         */\n        credentials: TlvOptionalField(6, TlvNullable(TlvArray(TlvCredential, { minLength: 1 })))\n    });\n\n    /**\n     * Body of the DoorLock lockOperationError event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4\n     */\n    export interface LockOperationErrorEvent extends TypeFromSchema<typeof TlvLockOperationErrorEvent> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.25.1\n     */\n    export enum OperationEventCode {\n        /**\n         * Event code is unknown\n         */\n        UnknownOrMfgSpecific = 0,\n\n        /**\n         * Event code is lock\n         */\n        Lock = 1,\n\n        /**\n         * Event code is unlock\n         */\n        Unlock = 2,\n\n        /**\n         * Event code is lock failure due to invalid PIN or RFID\n         */\n        LockFailureInvalidPiNorRfid = 3,\n\n        /**\n         * Event code is lock failure due to invalid schedule\n         */\n        LockFailureInvalidSchedule = 4,\n\n        /**\n         * Event code is unlock failure due to invalid PIN or RFID\n         */\n        UnlockFailureInvalidPiNorRfid = 5,\n\n        /**\n         * Event code is unlock failure due to invalid schedule\n         */\n        UnlockFailureInvalidSchedule = 6,\n\n        /**\n         * Event code is one touch lock\n         */\n        OneTouchLock = 7,\n\n        /**\n         * Event code is key lock\n         */\n        KeyLock = 8,\n\n        /**\n         * Event code is key unlock\n         */\n        KeyUnlock = 9,\n\n        /**\n         * Event code is auto lock\n         */\n        AutoLock = 10,\n\n        /**\n         * Event code is schedule lock\n         */\n        ScheduleLock = 11,\n\n        /**\n         * Event code is schedule unlock\n         */\n        ScheduleUnlock = 12,\n\n        /**\n         * Event code is manual lock (Key or Thumbturn)\n         */\n        ManualLock = 13,\n\n        /**\n         * Event code is manual unlock (Key or Thumbturn)\n         */\n        ManualUnlock = 14,\n\n        /**\n         * Event code is non access user operation\n         */\n        NonAccessUserOperationEvent = 15\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.6.25.2\n     */\n    export enum ProgrammingEventCode {\n        /**\n         * Event code is unknown\n         */\n        UnknownOrMfgSpecific = 0,\n\n        /**\n         * Event code is code changed\n         */\n        ProgrammingCodeChanged = 1,\n\n        /**\n         * Event code is PIN added\n         */\n        PinCodeAdded = 2,\n\n        /**\n         * Event code is PIN cleared\n         */\n        PinCodeCleared = 3,\n\n        /**\n         * Event code is PIN changed\n         */\n        PinCodeChanged = 4,\n\n        /**\n         * Event code is RFID added\n         */\n        RfidCodeAdded = 5,\n\n        /**\n         * Event code is RFID cleared\n         */\n        RfidCodeCleared = 6\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.7.1\n     */\n    export enum StatusCode {\n        /**\n         * Entry would cause a duplicate credential/ID.\n         */\n        Duplicate = 2,\n\n        /**\n         * Entry would replace an occupied slot.\n         */\n        Occupied = 3\n    }\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature DoorPositionSensor.\n     */\n    export const DoorPositionSensorComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the current door state as defined in DoorStateEnum.\n             *\n             * Null only if an internal error prevents the retrieval of the current door state.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.5\n             */\n            doorState: Attribute(0x3, TlvNullable(TlvEnum<DoorState>())),\n\n            /**\n             * This attribute shall hold the number of door open events that have occurred since it was last zeroed.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.6\n             */\n            doorOpenEvents: OptionalWritableAttribute(0x4, TlvUInt32, { writeAcl: AccessLevel.Manage }),\n\n            /**\n             * This attribute shall hold the number of door closed events that have occurred since it was last zeroed.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.7\n             */\n            doorClosedEvents: OptionalWritableAttribute(0x5, TlvUInt32, { writeAcl: AccessLevel.Manage }),\n\n            /**\n             * This attribute shall hold the number of minutes the door has been open since the last time it\n             * transitioned from closed to open.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.8\n             */\n            openPeriod: OptionalWritableAttribute(0x6, TlvUInt16, { writeAcl: AccessLevel.Manage })\n        },\n\n        events: {\n            /**\n             * The door lock server sends out a DoorStateChange event when the door lock door state changes.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.2\n             */\n            doorStateChange: Event(0x1, EventPriority.Critical, TlvDoorStateChangeEvent)\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature Logging.\n     */\n    export const LoggingComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of available log records.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.9\n             */\n            numberOfLogRecordsSupported: FixedAttribute(0x10, TlvUInt16, { default: 0 }),\n\n            /**\n             * This attribute shall enable/disable event logging.\n             *\n             * When event logging is enabled, all event messages are stored on the lock for retrieval. Logging events\n             * can be, but are not limited to, Tamper Alarm, Lock, Unlock, AutoRelock, User Code Added, User Code\n             * Cleared, Schedule Added, and Schedule Cleared. For a full detail of all the possible alarms and events,\n             * please refer to the full list in the Alarm and Event Masks Attribute Set.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.22\n             */\n            enableLogging: WritableAttribute(0x20, TlvBoolean, { default: true, writeAcl: AccessLevel.Administer })\n        },\n\n        commands: {\n            /**\n             * Request a log record. Log number is between 1 \u2013 [Number of Log Records Supported attribute]. If log\n             * number 0 is requested then the most recent log entry is returned.\n             *\n             * Log record format: The log record format is defined in the description of the GetLogRecordResponse\n             * command.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.4\n             */\n            getLogRecord: Command(\n                0x4,\n                TlvGetLogRecordRequest,\n                0x4,\n                TlvGetLogRecordResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature User.\n     */\n    export const UserComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of total users supported by the lock.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.10\n             */\n            numberOfTotalUsersSupported: FixedAttribute(0x11, TlvUInt16, { default: 0 }),\n\n            /**\n             * This attribute shall contain a bitmap with the bits set for the values of CredentialRuleEnum supported\n             * on this device.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.20\n             */\n            credentialRulesSupport: FixedAttribute(\n                0x1b,\n                TlvBitmap(TlvUInt8, CredentialRules),\n                { default: BitsFromPartial(CredentialRules, { single: true }) }\n            ),\n\n            /**\n             * Indicates the number of credentials that could be assigned for each user.\n             *\n             * Depending on the value of NumberOfRFIDUsersSupported and NumberOfPINUsersSupported it may not be\n             * possible to assign that number of credentials for a user.\n             *\n             * For example, if the device supports only PIN and RFID credential types,\n             * NumberOfCredentialsSupportedPerUser is set to 10, NumberOfPINUsersSupported is set to 5 and\n             * NumberOfRFIDUsersSupported is set to 3, it will not be possible to actually assign 10 credentials for a\n             * user because maximum number of credentials in the database is 8.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.21\n             */\n            numberOfCredentialsSupportedPerUser: FixedAttribute(0x1c, TlvUInt8, { default: 0 }),\n\n            /**\n             * Indicates the number of minutes a PIN, RFID, Fingerprint, or other credential associated with a user of\n             * type ExpiringUser shall remain valid after its first use before expiring. When the credential expires\n             * the UserStatus for the corresponding user record shall be set to OccupiedDisabled.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.39\n             */\n            expiringUserTimeout: OptionalWritableAttribute(\n                0x35,\n                TlvUInt16.bound({ min: 1, max: 2880 }),\n                { writeAcl: AccessLevel.Administer }\n            )\n        },\n\n        commands: {\n            /**\n             * Set user into the lock.\n             *\n             * Fields used for different use cases:\n             *\n             * Return status is a global status code or a cluster-specific status code from the Status Codes table and\n             *\n             * shall be one of the following values:\n             *\n             *   \u2022 SUCCESS, if setting User was successful.\n             *\n             *   \u2022 FAILURE, if some unexpected internal error occurred setting User.\n             *\n             *   \u2022 OCCUPIED, if OperationType is Add and UserIndex points to an occupied slot.\n             *\n             *   \u2022 INVALID_COMMAND, if one or more fields violate constraints or are invalid or if OperationType is\n             *     Modify and UserIndex points to an available slot.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.34\n             */\n            setUser: Command(\n                0x1a,\n                TlvSetUserRequest,\n                0x1a,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Retrieve user.\n             *\n             * An InvokeResponse command shall be sent with an appropriate error\n             *\n             * COMMAND, etc.) as needed otherwise the GetUserResponse Command shall be sent implying a status of\n             * SUCCESS.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.35\n             */\n            getUser: Command(0x1b, TlvGetUserRequest, 0x1c, TlvGetUserResponse, { invokeAcl: AccessLevel.Administer }),\n\n            /**\n             * Clears a user or all Users.\n             *\n             * For each user to clear, all associated credentials (e.g. PIN, RFID, fingerprint, etc.) shall be cleared\n             * and the user entry values shall be reset to their default values (e.g. UserStatus shall be Available,\n             * UserType shall be UnrestrictedUser) and all associated schedules shall be cleared.\n             *\n             * A LockUserChange event with the provided UserIndex shall be generated after successfully clearing users.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.37\n             */\n            clearUser: Command(\n                0x1d,\n                TlvClearUserRequest,\n                0x1d,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or\n             * ProgrammingUser.\n             *\n             * Fields used for different use cases:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.40\n             */\n            setCredential: Command(\n                0x22,\n                TlvSetCredentialRequest,\n                0x23,\n                TlvSetCredentialResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index.\n             *\n             * An InvokeResponse command shall be sent with an appropriate error (e.g. FAILURE, INVALID_COMMAND, etc.)\n             * as needed otherwise the GetCredentialStatusResponse command shall be sent implying a status of SUCCESS.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.42\n             */\n            getCredentialStatus: Command(\n                0x24,\n                TlvGetCredentialStatusRequest,\n                0x25,\n                TlvGetCredentialStatusResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Clear one, one type, or all credentials except ProgrammingPIN credential.\n             *\n             * Fields used for different use cases:\n             *\n             * For each credential cleared whose user doesn\u2019t have another valid credential, the corresponding user\n             * record shall be reset back to default values and its UserStatus value shall be set to Available and\n             * UserType value shall be set to UnrestrictedUser and all schedules shall be cleared. In\n             *\n             * this case a LockUserChange event shall be generated for the user being cleared. Return status shall be\n             * one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.44\n             */\n            clearCredential: Command(\n                0x26,\n                TlvClearCredentialRequest,\n                0x26,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            )\n        },\n\n        events: {\n            /**\n             * The door lock server sends out a LockUserChange event when a lock user, schedule, or credential change\n             * has occurred.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.5\n             */\n            lockUserChange: Event(0x4, EventPriority.Info, TlvLockUserChangeEvent)\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature PinCredential.\n     */\n    export const PinCredentialComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of PIN users supported.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.11\n             */\n            numberOfPinUsersSupported: FixedAttribute(0x12, TlvUInt16, { default: 0 }),\n\n            /**\n             * Indicates the maximum length in bytes of a PIN Code on this device.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.16\n             */\n            maxPinCodeLength: FixedAttribute(0x17, TlvUInt8),\n\n            /**\n             * Indicates the minimum length in bytes of a PIN Code on this device.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.17\n             */\n            minPinCodeLength: FixedAttribute(0x18, TlvUInt8)\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature RfidCredential.\n     */\n    export const RfidCredentialComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of RFID users supported.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.12\n             */\n            numberOfRfidUsersSupported: FixedAttribute(0x13, TlvUInt16, { default: 0 }),\n\n            /**\n             * Indicates the maximum length in bytes of a RFID Code on this device. The value depends on the RFID code\n             * range specified by the manufacturer, if media anti-collision identifiers (UID) are used as RFID code, a\n             * value of 20 (equals 10 Byte ISO 14443A UID) is recommended.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.18\n             */\n            maxRfidCodeLength: FixedAttribute(0x19, TlvUInt8),\n\n            /**\n             * Indicates the minimum length in bytes of a RFID Code on this device. The value depends on the RFID code\n             * range specified by the manufacturer, if media anti-collision identifiers (UID) are used as RFID code, a\n             * value of 8 (equals 4 Byte ISO 14443A UID) is recommended.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.19\n             */\n            minRfidCodeLength: FixedAttribute(0x1a, TlvUInt8)\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature WeekDayAccessSchedules.\n     */\n    export const WeekDayAccessSchedulesComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of configurable week day schedule supported per user.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.13\n             */\n            numberOfWeekDaySchedulesSupportedPerUser: FixedAttribute(0x14, TlvUInt8, { default: 0 })\n        },\n\n        commands: {\n            /**\n             * Set a weekly repeating schedule for a specified user.\n             *\n             * \u2020 The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead,\n             * respectively.\n             *\n             * The associated UserType may be changed to ScheduleRestrictedUser by the lock when a Week Day schedule is\n             * set.\n             *\n             * Return status shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.14\n             */\n            setWeekDaySchedule: Command(\n                0xb,\n                TlvSetWeekDayScheduleRequest,\n                0xb,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Retrieve the specific weekly schedule for the specific user.\n             *\n             * \u2020 The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead,\n             * respectively.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.15\n             */\n            getWeekDaySchedule: Command(\n                0xc,\n                TlvGetWeekDayScheduleRequest,\n                0xc,\n                TlvGetWeekDayScheduleResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Clear the specific weekly schedule or all weekly schedules for the specific user.\n             *\n             * \u2020 The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead,\n             * respectively.\n             *\n             * Return status shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.17\n             */\n            clearWeekDaySchedule: Command(\n                0xd,\n                TlvClearWeekDayScheduleRequest,\n                0xd,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature YearDayAccessSchedules.\n     */\n    export const YearDayAccessSchedulesComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of configurable year day schedule supported per user.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.14\n             */\n            numberOfYearDaySchedulesSupportedPerUser: FixedAttribute(0x15, TlvUInt8, { default: 0 })\n        },\n\n        commands: {\n            /**\n             * Set a time-specific schedule ID for a specified user.\n             *\n             * \u2020 The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead,\n             * respectively.\n             *\n             * The associated UserType may be changed to ScheduleRestrictedUser by the lock when a Year Day schedule is\n             * set.\n             *\n             * Return status shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.18\n             */\n            setYearDaySchedule: Command(\n                0xe,\n                TlvSetYearDayScheduleRequest,\n                0xe,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Retrieve the specific year day schedule for the specific schedule and user indexes.\n             *\n             * \u2020 The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead,\n             * respectively.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.19\n             */\n            getYearDaySchedule: Command(\n                0xf,\n                TlvGetYearDayScheduleRequest,\n                0xf,\n                TlvGetYearDayScheduleResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Clears the specific year day schedule or all year day schedules for the specific user.\n             *\n             * \u2020 The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead,\n             * respectively.\n             *\n             * Return status shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.21\n             */\n            clearYearDaySchedule: Command(\n                0x10,\n                TlvClearYearDayScheduleRequest,\n                0x10,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature HolidaySchedules.\n     */\n    export const HolidaySchedulesComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of holiday schedules supported for the entire door lock device.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.15\n             */\n            numberOfHolidaySchedulesSupported: FixedAttribute(0x16, TlvUInt8, { default: 0 })\n        },\n\n        commands: {\n            /**\n             * Set the holiday Schedule by specifying local start time and local end time with respect to any Lock\n             * Operating Mode.\n             *\n             * \u2020 The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead. Return status shall be\n             * one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.22\n             */\n            setHolidaySchedule: Command(\n                0x11,\n                TlvSetHolidayScheduleRequest,\n                0x11,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Get the holiday schedule for the specified index.\n             *\n             * \u2020 The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.23\n             */\n            getHolidaySchedule: Command(\n                0x12,\n                TlvGetHolidayScheduleRequest,\n                0x12,\n                TlvGetHolidayScheduleResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Clears the holiday schedule or all holiday schedules.\n             *\n             * \u2020 The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.25\n             */\n            clearHolidaySchedule: Command(\n                0x13,\n                TlvClearHolidayScheduleRequest,\n                0x13,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports features PinCredential or RfidCredential.\n     */\n    export const PinCredentialOrRfidCredentialComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the number of incorrect Pin codes or RFID presentment attempts a user is allowed to enter\n             * before the lock will enter a lockout state. The value of this attribute is compared to all failing forms\n             * of credential presentation, including Pin codes used in an Unlock Command when\n             * RequirePINforRemoteOperation is set to true. Valid range is 1-255 incorrect attempts. The lockout state\n             * will be for the duration of UserCodeTemporaryDisableTime. If the attribute accepts writes and an attempt\n             * to write the value 0 is made, the device shall respond with CONSTRAINT_ERROR.\n             *\n             * The lock may reset the counter used to track incorrect credential presentations as required by internal\n             * logic, environmental events, or other reasons. The lock shall reset the counter if a valid credential is\n             * presented.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.35\n             */\n            wrongCodeEntryLimit: WritableAttribute(\n                0x30,\n                TlvUInt8.bound({ min: 1 }),\n                { writeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Indicates the number of seconds that the lock shuts down following wrong code entry. Valid range is\n             * 1-255 seconds. Device can shut down to lock user out for specified amount of time. (Makes it difficult\n             * to try and guess a PIN for the device.) If the attribute accepts writes and an attempt to write the\n             * attribute to 0 is made, the device shall respond with CONSTRAINT_ERROR.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.36\n             */\n            userCodeTemporaryDisableTime: WritableAttribute(\n                0x31,\n                TlvUInt8.bound({ min: 1 }),\n                { writeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature PinCredential and it doesn't support feature\n     * USR.\n     */\n    export const PinCredentialNotUserComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the door locks ability to send PINs over the air. If the attribute is True it is ok for the\n             * door lock server to send PINs over the air. This attribute determines the behavior of the server\u2019s TX\n             * operation. If it is false, then it is not ok for the device to send PIN in any messages over the air.\n             *\n             * The PIN field within any door lock cluster message shall keep the first octet unchanged and masks the\n             * actual code by replacing with 0xFF. For example (PIN \"1234\" ): If the attribute value is True, 0x04 0x31\n             * 0x32 0x33 0x34 shall be used in the PIN field in any door lock cluster message payload. If the attribute\n             * value is False, 0x04 0xFF 0xFF 0xFF 0xFF shall be used.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.37\n             */\n            sendPinOverTheAir: OptionalWritableAttribute(\n                0x32,\n                TlvBoolean,\n                { default: true, writeAcl: AccessLevel.Administer }\n            )\n        },\n\n        commands: {\n            /**\n             * Set a PIN Code into the lock.\n             *\n             * Return status is a global status code or a cluster-specific status code from the Status Codes table and\n             * shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.6\n             */\n            setPinCode: Command(\n                0x5,\n                TlvSetPinCodeRequest,\n                0x5,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Retrieve a PIN Code.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.7\n             */\n            getPinCode: Command(\n                0x6,\n                TlvGetPinCodeRequest,\n                0x6,\n                TlvGetPinCodeResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Clear a PIN code or all PIN codes.\n             *\n             * \u2020 The User ID is an obsolete field name, use PINSlotIndex instead.\n             *\n             * For each PIN Code cleared whose user doesn\u2019t have a RFID Code or other credential type, then\n             * corresponding user record\u2019s UserStatus value shall be set to Available, and UserType value shall be set\n             * to UnrestrictedUser and all schedules shall be cleared.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.9\n             */\n            clearPinCode: Command(\n                0x7,\n                TlvClearPinCodeRequest,\n                0x7,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Clear out all PINs on the lock.\n             *\n             * NOTE\n             *\n             * On the server, the clear all PIN codes command SHOULD have the same effect as the ClearPINCode command\n             * with respect to the setting of user status, user type and schedules.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.10\n             */\n            clearAllPinCodes: Command(\n                0x8,\n                TlvNoArguments,\n                0x8,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports features CredentialOverTheAirAccess and PinCredential.\n     */\n    export const CredentialOverTheAirAccessAndPinCredentialComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates if the door lock requires an optional PIN. If this attribute is set to True, the door lock\n             * server requires that an optional PINs be included in the payload of remote lock operation events like\n             * Lock, Unlock, Unlock with Timeout and Toggle in order to function.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.38\n             */\n            requirePinForRemoteOperation: WritableAttribute(\n                0x33,\n                TlvBoolean,\n                { default: true, writeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports features Notification and PinCredential.\n     */\n    export const NotificationAndPinCredentialComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Event mask used to turn on and off the transmission of keypad operation events. This mask DOES NOT apply\n             * to the storing of events in the event log. This mask only applies to the Operation Event Notification\n             * Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.41\n             */\n            keypadOperationEventMask: OptionalWritableAttribute(\n                0x41,\n                TlvBitmap(TlvUInt16, EventMask),\n                {\n                    default: BitsFromPartial(EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            ),\n\n            /**\n             * Event mask used to turn on and off keypad programming events. This mask DOES NOT apply to the storing of\n             * events in the event log. This mask only applies to the Programming Event Notification Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.45\n             */\n            keypadProgrammingEventMask: OptionalWritableAttribute(\n                0x45,\n                TlvBitmap(TlvUInt16, KeypadProgrammingEventMask),\n                {\n                    default: BitsFromPartial(KeypadProgrammingEventMask, { unknown: true, pinCodeChanged: true, pinAdded: true, pinCleared: true, pinChanged: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature Notification.\n     */\n    export const NotificationComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Event mask used to turn on and off the transmission of remote operation events. This mask DOES NOT apply\n             * to the storing of events in the event log. This mask only applies to the Operation Event Notification\n             * Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.42\n             */\n            remoteOperationEventMask: OptionalWritableAttribute(\n                0x42,\n                TlvBitmap(TlvUInt16, EventMask),\n                {\n                    default: BitsFromPartial(EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            ),\n\n            /**\n             * Event mask used to turn on and off manual operation events. This mask DOES NOT apply to the storing of\n             * events in the event log. This mask only applies to the Operation Event Notification Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.43\n             */\n            manualOperationEventMask: OptionalWritableAttribute(\n                0x43,\n                TlvBitmap(TlvUInt16, EventMask),\n                {\n                    default: BitsFromPartial(EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            ),\n\n            /**\n             * Event mask used to turn on and off remote programming events. This mask DOES NOT apply to the storing of\n             * events in the event log. This mask only applies to the Programming Event Notification Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.46\n             */\n            remoteProgrammingEventMask: OptionalWritableAttribute(\n                0x46,\n                TlvBitmap(TlvUInt16, RemoteProgrammingEventMask),\n                {\n                    default: BitsFromPartial(RemoteProgrammingEventMask, { unknown: true, bit1: true, pinAdded: true, pinCleared: true, pinChanged: true, rfidCodeAdded: true, rfidCodeCleared: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports features Notification and RfidCredential.\n     */\n    export const NotificationAndRfidCredentialComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to the storing of\n             * events in the event log. This mask only applies to the Operation Event Notification Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.44\n             */\n            rfidOperationEventMask: OptionalWritableAttribute(\n                0x44,\n                TlvBitmap(TlvUInt16, EventMask),\n                {\n                    default: BitsFromPartial(EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            ),\n\n            /**\n             * Event mask used to turn on and off RFID programming events. This mask DOES NOT apply to the storing of\n             * events in the event log. This mask only applies to the Programming Event Notification Command.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.47\n             */\n            rfidProgrammingEventMask: OptionalWritableAttribute(\n                0x47,\n                TlvBitmap(TlvUInt16, RfidProgrammingEventMask),\n                {\n                    default: BitsFromPartial(RfidProgrammingEventMask, { unknown: true, bit1: true, bit2: true, bit3: true, bit4: true, idAdded: true, idCleared: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports features PinCredential, RfidCredential and\n     * FingerCredentials and it doesn't support feature USR.\n     */\n    export const PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent = MutableCluster.Component({\n        commands: {\n            /**\n             * Set the status of a user ID.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.11\n             */\n            setUserStatus: OptionalCommand(\n                0x9,\n                TlvSetUserStatusRequest,\n                0x9,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Get the status of a user.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.12\n             */\n            getUserStatus: OptionalCommand(\n                0xa,\n                TlvGetUserStatusRequest,\n                0xa,\n                TlvGetUserStatusResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Set the user type for a specified user.\n             *\n             * For user type value please refer to User Type Value.\n             *\n             * Return status shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.26\n             */\n            setUserType: OptionalCommand(\n                0x14,\n                TlvSetUserTypeRequest,\n                0x14,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Retrieve the user type for a specific user.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.27\n             */\n            getUserType: OptionalCommand(\n                0x15,\n                TlvGetUserTypeRequest,\n                0x15,\n                TlvGetUserTypeResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if doesn't support feature USR.\n     */\n    export const NotUserComponent = MutableCluster.Component({});\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature RfidCredential and it doesn't support feature\n     * USR.\n     */\n    export const RfidCredentialNotUserComponent = MutableCluster.Component({\n        commands: {\n            /**\n             * Set an ID for RFID access into the lock.\n             *\n             * Return status is a global status code or a cluster-specific status code from the Status Codes table and\n             * shall be one of the following values:\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.29\n             */\n            setRfidCode: Command(\n                0x16,\n                TlvSetRfidCodeRequest,\n                0x16,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Retrieve an RFID code.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.30\n             */\n            getRfidCode: Command(\n                0x17,\n                TlvGetRfidCodeRequest,\n                0x17,\n                TlvGetRfidCodeResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * Clear an RFID code or all RFID codes.\n             *\n             * \u2020 The User ID is an obsolete field name, use RFIDSlotIndex instead.\n             *\n             * For each RFID Code cleared whose user doesn\u2019t have a PIN Code or other credential type, then the\n             * corresponding user record\u2019s UserStatus value shall be set to Available, and UserType value shall be set\n             * to UnrestrictedUser and all schedules shall be cleared.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.32\n             */\n            clearRfidCode: Command(\n                0x18,\n                TlvClearRfidCodeRequest,\n                0x18,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            ),\n\n            /**\n             * Clear out all RFIDs on the lock. If you clear all RFID codes and this user didn\u2019t have a PIN code, the\n             * user status has to be set to \"0 Available\", the user type has to be set to the default value, and all\n             * schedules which are supported have to be set to the default values.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.33\n             */\n            clearAllRfidCodes: Command(\n                0x19,\n                TlvNoArguments,\n                0x19,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            )\n        }\n    });\n\n    /**\n     * A DoorLockCluster supports these elements if it supports feature Unbolting.\n     */\n    export const UnboltingComponent = MutableCluster.Component({\n        commands: {\n            /**\n             * This command causes the lock device to unlock the door without pulling the latch. This command includes\n             * an optional code for the lock. The door lock may require a code depending on the value of the\n             * RequirePINForRemoteOperation attribute.\n             *\n             * NOTE\n             *\n             * If the attribute AutoRelockTime is supported, the lock will transition to the locked state when the auto\n             * relock time has expired.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.45\n             */\n            unboltDoor: Command(0x27, TlvUnboltDoorRequest, 0x27, TlvNoResponse, { timed: true })\n        }\n    });\n\n    /**\n     * These elements and properties are present in all DoorLock clusters.\n     */\n    export const Base = MutableCluster.Component({\n        id: 0x101,\n        name: \"DoorLock\",\n        revision: 7,\n\n        features: {\n            /**\n             * PinCredential\n             *\n             * If the User Feature is also supported then any PIN Code stored in the lock shall be associated with a\n             * User.\n             *\n             * A lock may support multiple credential types so if the User feature is supported the UserType,\n             * UserStatus and Schedules are all associated with a User index and not directly with a PIN index. A User\n             * index may have several credentials associated with it.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.1\n             */\n            pinCredential: BitFlag(0),\n\n            /**\n             * RfidCredential\n             *\n             * If the User Feature is also supported then any RFID credential stored in the lock shall be associated\n             * with a User.\n             *\n             * A lock may support multiple credential types so if the User feature is supported the UserType,\n             * UserStatus and Schedules are all associated with a User index and not directly with a RFID index. A User\n             *\n             * Index may have several credentials associated with it.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.2\n             */\n            rfidCredential: BitFlag(1),\n\n            /**\n             * FingerCredentials\n             *\n             * Currently the cluster only defines the metadata format for notifications when a fingerprint/ finger vein\n             * credential is used to access the lock and doesn\u2019t describe how to create fingerprint/finger vein\n             * credentials. If the Users feature is also supported then the User that a fingerprint/finger vein is\n             * associated with can also have its UserType, UserStatus and Schedule modified.\n             *\n             * A lock may support multiple credential types so if the User feature is supported the UserType,\n             * UserStatus and Schedules are all associated with a User index and not directly with a Finger index. A\n             * User Index may have several credentials associated with it.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.3\n             */\n            fingerCredentials: BitFlag(2),\n\n            /**\n             * Logging\n             *\n             * If Events are not supported the logging feature shall replace the Event reporting structure. If Events\n             * are supported the logging feature shall NOT be supported.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.4\n             */\n            logging: BitFlag(3),\n\n            /**\n             * WeekDayAccessSchedules\n             *\n             * If the User feature is supported then Week Day Schedules are applied to a User and not a credential.\n             *\n             * Week Day Schedules are used to restrict access to a specified time window on certain days of the week.\n             * The schedule is repeated each week. When a schedule is cleared this clears the access restrictions and\n             * grants unrestricted access to the user. The lock may automatically adjust the UserType when a schedule\n             * is created or cleared.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.5\n             */\n            weekDayAccessSchedules: BitFlag(4),\n\n            /**\n             * DoorPositionSensor\n             *\n             * If this feature is supported this indicates that the lock has the ability to determine the position of\n             * the door which is separate from the state of the lock.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.6\n             */\n            doorPositionSensor: BitFlag(5),\n\n            /**\n             * FaceCredentials\n             *\n             * Currently the cluster only defines the metadata format for notifications when a face recognition, iris,\n             * or retina credential is used to access the lock and doesn\u2019t describe how to create face recognition,\n             * iris, or retina credentials. If the Users feature is also supported then the User that a face\n             * recognition, iris, or retina credential is associated with can also have its UserType, UserStatus and\n             * Schedule modified.\n             *\n             * A lock may support multiple credential types so if the User feature is supported the UserType,\n             * UserStatus and Schedules are all associated with a User and not directly with a credential.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.7\n             */\n            faceCredentials: BitFlag(6),\n\n            /**\n             * CredentialOverTheAirAccess\n             *\n             * If this feature is supported then the lock supports the ability to verify a credential provided in a\n             * lock/unlock command. Currently the cluster only supports providing the PIN credential to the lock/unlock\n             * commands. If this feature is supported then the PIN Credential feature shall also be supported.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.8\n             */\n            credentialOverTheAirAccess: BitFlag(7),\n\n            /**\n             * User\n             *\n             * If the User Feature is supported then a lock employs a User database. A User within the User database is\n             * used to associate credentials and schedules to single user record within the lock. This also means the\n             * UserType and UserStatus fields are associated with a User and not a credential.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.9\n             */\n            user: BitFlag(8),\n\n            /**\n             * Notification\n             *\n             * This is a feature used before support of events. This feature supports notification commands and masks\n             * used to filter these notifications.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.10\n             */\n            notification: BitFlag(9),\n\n            /**\n             * YearDayAccessSchedules\n             *\n             * If the User feature is supported then Year Day Schedules are applied to a User and not a credential.\n             *\n             * Year Day Schedules are used to restrict access to a specified date and time window. When a schedule is\n             * cleared this clears the access restrictions and grants unrestricted access to the user. The lock may\n             * automatically adjust the UserType when a schedule is created or cleared.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.11\n             */\n            yearDayAccessSchedules: BitFlag(10),\n\n            /**\n             * HolidaySchedules\n             *\n             * This feature is used to setup Holiday Schedule in the lock device. A Holiday Schedule sets a start and\n             * stop end date/time for the lock to use the specified operating mode set by the Holiday Schedule.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.12\n             */\n            holidaySchedules: BitFlag(11),\n\n            /**\n             * Unbolting\n             *\n             * Locks that support this feature differentiate between unbolting and unlocking. The Unbolt Door command\n             * retracts the bolt without pulling the latch. The Unlock Door command fully unlocks the door by\n             * retracting the bolt and briefly pulling the latch. While the latch is pulled, the lock state changes to\n             * Unlatched. Locks without unbolting support don\u2019t differentiate between unbolting and unlocking and\n             * perform the same operation for both commands.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.4.13\n             */\n            unbolting: BitFlag(12)\n        },\n\n        attributes: {\n            /**\n             * This attribute may be NULL if the lock hardware does not currently know the status of the locking\n             * mechanism. For example, a lock may not know the LockState status after a power cycle until the first\n             * lock actuation is completed.\n             *\n             * The Not Fully Locked value is used by a lock to indicate that the state of the lock is somewhere between\n             * Locked and Unlocked so it is only partially secured. For example, a deadbolt could be partially extended\n             * and not in a dead latched state.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.2\n             */\n            lockState: Attribute(0x0, TlvNullable(TlvEnum<LockState>()), { scene: true }),\n\n            /**\n             * Indicates the type of door lock as defined in LockTypeEnum.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.3\n             */\n            lockType: Attribute(0x1, TlvEnum<LockType>()),\n\n            /**\n             * Indicates if the lock is currently able to (Enabled) or not able to (Disabled) process remote Lock,\n             * Unlock, or Unlock with Timeout commands.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.4\n             */\n            actuatorEnabled: Attribute(0x2, TlvBoolean),\n\n            /**\n             * Indicates the language for the on-screen or audible user interface using a 2- byte language code from\n             * ISO-639-1.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.23\n             */\n            language: OptionalWritableAttribute(\n                0x21,\n                TlvString.bound({ maxLength: 3 }),\n                { writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * Indicates the settings for the LED support, as defined by LEDSettingEnum.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.24\n             */\n            ledSettings: OptionalWritableAttribute(\n                0x22,\n                TlvEnum<LedSetting>(),\n                { default: LedSetting.NoLedSignal, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * Indicates the number of seconds to wait after unlocking a lock before it automatically locks again.\n             * 0=disabled. If set, unlock operations from any source will be timed. For one time unlock with timeout\n             * use the specific command.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.25\n             */\n            autoRelockTime: OptionalWritableAttribute(0x23, TlvUInt32, { writeAcl: AccessLevel.Manage }),\n\n            /**\n             * Indicates the sound volume on a door lock as defined by SoundVolumeEnum.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.26\n             */\n            soundVolume: OptionalWritableAttribute(\n                0x24,\n                TlvEnum<SoundVolume>(),\n                { default: SoundVolume.Silent, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * Indicates the current operating mode of the lock as defined in OperatingModeEnum.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.27\n             */\n            operatingMode: WritableAttribute(\n                0x25,\n                TlvEnum<OperatingMode>(),\n                { default: OperatingMode.Normal, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * This attribute shall contain a bitmap with all operating bits of the OperatingMode attribute supported\n             * by the lock. All operating modes NOT supported by a lock shall be set to one. The value of the\n             * OperatingMode enumeration defines the related bit to be set.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.28\n             */\n            supportedOperatingModes: FixedAttribute(\n                0x26,\n                TlvBitmap(TlvUInt16, OperatingModes),\n                { default: BitsFromPartial(OperatingModes, { vacation: true, privacy: true, passage: true }) }\n            ),\n\n            /**\n             * Indicates the default configurations as they are physically set on the device (example: hardware dip\n             * switch setting, etc\u2026) and represents the default setting for some of the attributes within this cluster\n             * (for example: LED, Auto Lock, Sound Volume, and Operating Mode attributes).\n             *\n             * This is a read-only attribute and is intended to allow clients to determine what changes may need to be\n             * made without having to query all the included attributes. It may be beneficial for the clients to know\n             * what the device\u2019s original settings were in the event that the device needs to be restored to factory\n             * default settings.\n             *\n             * If the Client device would like to query and modify the door lock server\u2019s operating settings, it SHOULD\n             * send read and write attribute requests to the specific attributes.\n             *\n             * For example, the Sound Volume attribute default value is Silent Mode. However, it is possible that the\n             * current Sound Volume is High Volume. Therefore, if the client wants to query/modify the current Sound\n             * Volume setting on the server, the client SHOULD read/write to the Sound Volume attribute.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.29\n             */\n            defaultConfigurationRegister: OptionalAttribute(0x27, TlvBitmap(TlvUInt16, ConfigurationRegister)),\n\n            /**\n             * This attribute shall enable/disable local programming on the door lock of certain features (see\n             * LocalProgrammingFeatures attribute). If this value is set to TRUE then local programming is enabled on\n             * the door lock for all features. If it is set to FALSE then local programming is disabled on the door\n             * lock for those features whose bit is set to 0 in the LocalProgrammingFeatures attribute. Local\n             * programming shall be enabled by default.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.30\n             */\n            enableLocalProgramming: OptionalWritableAttribute(\n                0x28,\n                TlvBoolean,\n                { default: true, writeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * This attribute shall enable/disable the ability to lock the door lock with a single touch on the door\n             * lock.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.31\n             */\n            enableOneTouchLocking: OptionalWritableAttribute(\n                0x29,\n                TlvBoolean,\n                { default: true, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * This attribute shall enable/disable an inside LED that allows the user to see at a glance if the door is\n             * locked.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.32\n             */\n            enableInsideStatusLed: OptionalWritableAttribute(\n                0x2a,\n                TlvBoolean,\n                { default: true, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * This attribute shall enable/disable a button inside the door that is used to put the lock into privacy\n             * mode. When the lock is in privacy mode it cannot be manipulated from the outside.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.33\n             */\n            enablePrivacyModeButton: OptionalWritableAttribute(\n                0x2b,\n                TlvBoolean,\n                { default: true, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * Indicates the local programming features that will be disabled when EnableLocalProgramming attribute is\n             * set to False. If a door lock doesn\u2019t support disabling one aspect of local programming it shall return\n             * CONSTRAINT_ERROR during a write operation of this attribute. If the EnableLocalProgramming attribute is\n             * set to True then all local programming features shall be enabled regardless of the bits set to 0 in this\n             * attribute.\n             *\n             * The features that can be disabled from local programming are defined in LocalProgrammingFeaturesBitmap.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.34\n             */\n            localProgrammingFeatures: OptionalWritableAttribute(\n                0x2c,\n                TlvBitmap(TlvUInt8, LocalProgrammingFeatures),\n                { writeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * This attribute is only supported if the Alarms cluster is on the same endpoint. The alarm mask is used\n             * to turn on/off alarms for particular functions. Alarms for an alarm group are enabled if the associated\n             * alarm mask bit is set. Each bit represents a group of alarms. Entire alarm groups can be turned on or\n             * off by setting or clearing the associated bit in the alarm mask.\n             *\n             * This mask DOES NOT apply to the Events mechanism of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.9.40\n             */\n            alarmMask: OptionalWritableAttribute(\n                0x40,\n                TlvBitmap(TlvUInt16, AlarmMask),\n                {\n                    default: BitsFromPartial(AlarmMask, { lockJammed: true, lockFactoryReset: true, na: true, lockRadioPowerCycled: true, wrongCodeEntryLimit: true, frontEscutcheonRemoved: true, doorForcedOpen: true }),\n                    writeAcl: AccessLevel.Administer\n                }\n            )\n        },\n\n        commands: {\n            /**\n             * This command causes the lock device to lock the door. This command includes an optional code for the\n             * lock. The door lock may require a PIN depending on the value of the RequirePINForRemoteOperation\n             * attribute.\n             *\n             * \u2020 The PIN/RFID Code is an obsolete field name, use PINCode instead.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.1\n             */\n            lockDoor: Command(0x0, TlvLockDoorRequest, 0x0, TlvNoResponse, { timed: true }),\n\n            /**\n             * This command causes the lock device to unlock the door. This command includes an optional code for the\n             * lock. The door lock may require a code depending on the value of the RequirePINForRemoteOperation\n             * attribute.\n             *\n             * NOTE\n             *\n             * If the attribute AutoRelockTime is supported the lock will transition to the locked state when the auto\n             * relock time has expired.\n             *\n             * \u2020 The PIN/RFID Code is an obsolete field name, use PINCode instead.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.2\n             */\n            unlockDoor: Command(0x1, TlvUnlockDoorRequest, 0x1, TlvNoResponse, { timed: true }),\n\n            /**\n             * This command causes the lock device to unlock the door with a timeout parameter. After the time in\n             * seconds specified in the timeout field, the lock device will relock itself automatically. This timeout\n             * parameter is only temporary for this message transition and overrides the default relock time\n             *\n             * as specified in the AutoRelockTime attribute. If the door lock device is not capable of or does not want\n             * to support temporary Relock Timeout, it SHOULD NOT support this optional command.\n             *\n             * \u2020 The PIN/RFID Code is an obsolete field name, use PINCode instead.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.10.3\n             */\n            unlockWithTimeout: OptionalCommand(0x3, TlvUnlockWithTimeoutRequest, 0x3, TlvNoResponse, { timed: true })\n        },\n\n        events: {\n            /**\n             * The door lock server provides several alarms which can be sent when there is a critical state on the\n             * door lock. The alarms available for the door lock server are listed in AlarmCodeEnum.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.1\n             */\n            doorLockAlarm: Event(0x0, EventPriority.Critical, TlvDoorLockAlarmEvent),\n\n            /**\n             * The door lock server sends out a LockOperation event when the event is triggered by the various lock\n             * operation sources.\n             *\n             *   \u2022 If the door lock server supports the Unbolt Door command, it shall generate a LockOperation event\n             *     with LockOperationType set to Unlock after an Unbolt Door command succeeds.\n             *\n             *   \u2022 If the door lock server supports the Unbolting feature and an Unlock Door command is performed, it\n             *     shall generate a LockOperation event with LockOperationType set to Unlatch when the unlatched state\n             *     is reached and a LockOperation event with LockOperationType set to Unlock when the lock successfully\n             *     completes the unlock \u2192 hold latch \u2192 release latch and return to unlock state operation.\n             *\n             *   \u2022 If the command fails during holding or releasing the latch but after passing the unlocked state, the\n             *     door lock server shall generate a LockOperationError event with LockOperationType set to Unlatch and\n             *     a LockOperation event with LockOperationType set to Unlock.\n             *\n             *     \u25E6 If it fails before reaching the unlocked state, the door lock server shall generate only a\n             *       LockOperationError event with LockOperationType set to Unlock.\n             *\n             *   \u2022 Upon manual actuation, a door lock server that supports the Unbolting feature:\n             *\n             *     \u25E6 shall generate a LockOperation event of LockOperationType Unlatch when it is actuated from the\n             *       outside.\n             *\n             *     \u25E6 may generate a LockOperation event of LockOperationType Unlatch when it is actuated from the\n             *       inside.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.3\n             */\n            lockOperation: Event(0x2, EventPriority.Critical, TlvLockOperationEvent),\n\n            /**\n             * The door lock server sends out a LockOperationError event when a lock operation fails for various\n             * reasons.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2.11.4\n             */\n            lockOperationError: Event(0x3, EventPriority.Critical, TlvLockOperationErrorEvent)\n        },\n\n        /**\n         * This metadata controls which DoorLockCluster elements matter.js activates for specific feature combinations.\n         */\n        extensions: MutableCluster.Extensions(\n            { flags: { doorPositionSensor: true }, component: DoorPositionSensorComponent },\n            { flags: { logging: true }, component: LoggingComponent },\n            { flags: { user: true }, component: UserComponent },\n            { flags: { pinCredential: true }, component: PinCredentialComponent },\n            { flags: { rfidCredential: true }, component: RfidCredentialComponent },\n            { flags: { weekDayAccessSchedules: true }, component: WeekDayAccessSchedulesComponent },\n            { flags: { yearDayAccessSchedules: true }, component: YearDayAccessSchedulesComponent },\n            { flags: { holidaySchedules: true }, component: HolidaySchedulesComponent },\n            { flags: { pinCredential: true }, component: PinCredentialOrRfidCredentialComponent },\n            { flags: { rfidCredential: true }, component: PinCredentialOrRfidCredentialComponent },\n            { flags: { pinCredential: true, user: false }, component: PinCredentialNotUserComponent },\n            {\n                flags: { credentialOverTheAirAccess: true, pinCredential: true },\n                component: CredentialOverTheAirAccessAndPinCredentialComponent\n            },\n            { flags: { notification: true, pinCredential: true }, component: NotificationAndPinCredentialComponent },\n            { flags: { notification: true }, component: NotificationComponent },\n            { flags: { notification: true, rfidCredential: true }, component: NotificationAndRfidCredentialComponent },\n            {\n                flags: { pinCredential: true, rfidCredential: true, fingerCredentials: true, user: false },\n                component: PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent\n            },\n            { flags: { user: false }, component: NotUserComponent },\n            { flags: { rfidCredential: true, user: false }, component: RfidCredentialNotUserComponent },\n            { flags: { unbolting: true }, component: UnboltingComponent },\n\n            {\n                flags: {\n                    user: true,\n                    pinCredential: true,\n                    rfidCredential: true,\n                    fingerCredentials: true,\n                    faceCredentials: true\n                },\n\n                component: false\n            }\n        )\n    });\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster({ ...Base, base: ClusterType(Base) }, NotUserComponent);\n\n    /**\n     * The door lock cluster provides an interface to a generic way to secure a door. The physical object that provides\n     * the locking functionality is abstracted from the cluster. The cluster has a small list of mandatory attributes\n     * and functions and a list of optional features.\n     *\n     * DoorLockCluster supports optional features that you can enable with the DoorLockCluster.with() factory method.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 5.2\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    const DPS = { doorPositionSensor: true };\n    const LOG = { logging: true };\n    const USR = { user: true };\n    const PIN = { pinCredential: true };\n    const RID = { rfidCredential: true };\n    const WDSCH = { weekDayAccessSchedules: true };\n    const YDSCH = { yearDayAccessSchedules: true };\n    const HDSCH = { holidaySchedules: true };\n    const PIN_NOT_USR = { pinCredential: true, user: false };\n    const COTA_PIN = { credentialOverTheAirAccess: true, pinCredential: true };\n    const NOT_PIN = { notification: true, pinCredential: true };\n    const NOT = { notification: true };\n    const NOT_RID = { notification: true, rfidCredential: true };\n    const PIN_RID_FGP_NOT_USR = { pinCredential: true, rfidCredential: true, fingerCredentials: true, user: false };\n    const RID_NOT_USR = { rfidCredential: true, user: false };\n    const UBOLT = { unbolting: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster({\n        id: Cluster.id,\n        name: Cluster.name,\n        revision: Cluster.revision,\n        features: Cluster.features,\n\n        attributes: {\n            ...Cluster.attributes,\n            doorState: MutableCluster.AsConditional(\n                DoorPositionSensorComponent.attributes.doorState,\n                { mandatoryIf: [DPS] }\n            ),\n            doorOpenEvents: MutableCluster.AsConditional(\n                DoorPositionSensorComponent.attributes.doorOpenEvents,\n                { optionalIf: [DPS] }\n            ),\n            doorClosedEvents: MutableCluster.AsConditional(\n                DoorPositionSensorComponent.attributes.doorClosedEvents,\n                { optionalIf: [DPS] }\n            ),\n            openPeriod: MutableCluster.AsConditional(\n                DoorPositionSensorComponent.attributes.openPeriod,\n                { optionalIf: [DPS] }\n            ),\n            numberOfLogRecordsSupported: MutableCluster.AsConditional(\n                LoggingComponent.attributes.numberOfLogRecordsSupported,\n                { mandatoryIf: [LOG] }\n            ),\n            numberOfTotalUsersSupported: MutableCluster.AsConditional(\n                UserComponent.attributes.numberOfTotalUsersSupported,\n                { mandatoryIf: [USR] }\n            ),\n            numberOfPinUsersSupported: MutableCluster.AsConditional(\n                PinCredentialComponent.attributes.numberOfPinUsersSupported,\n                { mandatoryIf: [PIN] }\n            ),\n            numberOfRfidUsersSupported: MutableCluster.AsConditional(\n                RfidCredentialComponent.attributes.numberOfRfidUsersSupported,\n                { mandatoryIf: [RID] }\n            ),\n            numberOfWeekDaySchedulesSupportedPerUser: MutableCluster.AsConditional(\n                WeekDayAccessSchedulesComponent.attributes.numberOfWeekDaySchedulesSupportedPerUser,\n                { mandatoryIf: [WDSCH] }\n            ),\n            numberOfYearDaySchedulesSupportedPerUser: MutableCluster.AsConditional(\n                YearDayAccessSchedulesComponent.attributes.numberOfYearDaySchedulesSupportedPerUser,\n                { mandatoryIf: [YDSCH] }\n            ),\n            numberOfHolidaySchedulesSupported: MutableCluster.AsConditional(\n                HolidaySchedulesComponent.attributes.numberOfHolidaySchedulesSupported,\n                { mandatoryIf: [HDSCH] }\n            ),\n            maxPinCodeLength: MutableCluster.AsConditional(\n                PinCredentialComponent.attributes.maxPinCodeLength,\n                { mandatoryIf: [PIN] }\n            ),\n            minPinCodeLength: MutableCluster.AsConditional(\n                PinCredentialComponent.attributes.minPinCodeLength,\n                { mandatoryIf: [PIN] }\n            ),\n            maxRfidCodeLength: MutableCluster.AsConditional(\n                RfidCredentialComponent.attributes.maxRfidCodeLength,\n                { mandatoryIf: [RID] }\n            ),\n            minRfidCodeLength: MutableCluster.AsConditional(\n                RfidCredentialComponent.attributes.minRfidCodeLength,\n                { mandatoryIf: [RID] }\n            ),\n            credentialRulesSupport: MutableCluster.AsConditional(\n                UserComponent.attributes.credentialRulesSupport,\n                { mandatoryIf: [USR] }\n            ),\n            numberOfCredentialsSupportedPerUser: MutableCluster.AsConditional(\n                UserComponent.attributes.numberOfCredentialsSupportedPerUser,\n                { mandatoryIf: [USR] }\n            ),\n            enableLogging: MutableCluster.AsConditional(\n                LoggingComponent.attributes.enableLogging,\n                { mandatoryIf: [LOG] }\n            ),\n            wrongCodeEntryLimit: MutableCluster.AsConditional(\n                PinCredentialOrRfidCredentialComponent.attributes.wrongCodeEntryLimit,\n                { mandatoryIf: [PIN, RID] }\n            ),\n            userCodeTemporaryDisableTime: MutableCluster.AsConditional(\n                PinCredentialOrRfidCredentialComponent.attributes.userCodeTemporaryDisableTime,\n                { mandatoryIf: [PIN, RID] }\n            ),\n            sendPinOverTheAir: MutableCluster.AsConditional(\n                PinCredentialNotUserComponent.attributes.sendPinOverTheAir,\n                { optionalIf: [PIN_NOT_USR] }\n            ),\n            requirePinForRemoteOperation: MutableCluster.AsConditional(\n                CredentialOverTheAirAccessAndPinCredentialComponent.attributes.requirePinForRemoteOperation,\n                { mandatoryIf: [COTA_PIN] }\n            ),\n            expiringUserTimeout: MutableCluster.AsConditional(\n                UserComponent.attributes.expiringUserTimeout,\n                { optionalIf: [USR] }\n            ),\n            keypadOperationEventMask: MutableCluster.AsConditional(\n                NotificationAndPinCredentialComponent.attributes.keypadOperationEventMask,\n                { optionalIf: [NOT_PIN] }\n            ),\n            remoteOperationEventMask: MutableCluster.AsConditional(\n                NotificationComponent.attributes.remoteOperationEventMask,\n                { optionalIf: [NOT] }\n            ),\n            manualOperationEventMask: MutableCluster.AsConditional(\n                NotificationComponent.attributes.manualOperationEventMask,\n                { optionalIf: [NOT] }\n            ),\n            rfidOperationEventMask: MutableCluster.AsConditional(\n                NotificationAndRfidCredentialComponent.attributes.rfidOperationEventMask,\n                { optionalIf: [NOT_RID] }\n            ),\n            keypadProgrammingEventMask: MutableCluster.AsConditional(\n                NotificationAndPinCredentialComponent.attributes.keypadProgrammingEventMask,\n                { optionalIf: [NOT_PIN] }\n            ),\n            remoteProgrammingEventMask: MutableCluster.AsConditional(\n                NotificationComponent.attributes.remoteProgrammingEventMask,\n                { optionalIf: [NOT] }\n            ),\n            rfidProgrammingEventMask: MutableCluster.AsConditional(\n                NotificationAndRfidCredentialComponent.attributes.rfidProgrammingEventMask,\n                { optionalIf: [NOT_RID] }\n            )\n        },\n\n        commands: {\n            ...Cluster.commands,\n            getLogRecord: MutableCluster.AsConditional(LoggingComponent.commands.getLogRecord, { mandatoryIf: [LOG] }),\n            setPinCode: MutableCluster.AsConditional(\n                PinCredentialNotUserComponent.commands.setPinCode,\n                { mandatoryIf: [PIN_NOT_USR] }\n            ),\n            getPinCode: MutableCluster.AsConditional(\n                PinCredentialNotUserComponent.commands.getPinCode,\n                { mandatoryIf: [PIN_NOT_USR] }\n            ),\n            clearPinCode: MutableCluster.AsConditional(\n                PinCredentialNotUserComponent.commands.clearPinCode,\n                { mandatoryIf: [PIN_NOT_USR] }\n            ),\n            clearAllPinCodes: MutableCluster.AsConditional(\n                PinCredentialNotUserComponent.commands.clearAllPinCodes,\n                { mandatoryIf: [PIN_NOT_USR] }\n            ),\n            setUserStatus: MutableCluster.AsConditional(\n                PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.setUserStatus,\n                { optionalIf: [PIN_RID_FGP_NOT_USR] }\n            ),\n            getUserStatus: MutableCluster.AsConditional(\n                PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.getUserStatus,\n                { optionalIf: [PIN_RID_FGP_NOT_USR] }\n            ),\n            setWeekDaySchedule: MutableCluster.AsConditional(\n                WeekDayAccessSchedulesComponent.commands.setWeekDaySchedule,\n                { mandatoryIf: [WDSCH] }\n            ),\n            getWeekDaySchedule: MutableCluster.AsConditional(\n                WeekDayAccessSchedulesComponent.commands.getWeekDaySchedule,\n                { mandatoryIf: [WDSCH] }\n            ),\n            clearWeekDaySchedule: MutableCluster.AsConditional(\n                WeekDayAccessSchedulesComponent.commands.clearWeekDaySchedule,\n                { mandatoryIf: [WDSCH] }\n            ),\n            setYearDaySchedule: MutableCluster.AsConditional(\n                YearDayAccessSchedulesComponent.commands.setYearDaySchedule,\n                { mandatoryIf: [YDSCH] }\n            ),\n            getYearDaySchedule: MutableCluster.AsConditional(\n                YearDayAccessSchedulesComponent.commands.getYearDaySchedule,\n                { mandatoryIf: [YDSCH] }\n            ),\n            clearYearDaySchedule: MutableCluster.AsConditional(\n                YearDayAccessSchedulesComponent.commands.clearYearDaySchedule,\n                { mandatoryIf: [YDSCH] }\n            ),\n            setHolidaySchedule: MutableCluster.AsConditional(\n                HolidaySchedulesComponent.commands.setHolidaySchedule,\n                { mandatoryIf: [HDSCH] }\n            ),\n            getHolidaySchedule: MutableCluster.AsConditional(\n                HolidaySchedulesComponent.commands.getHolidaySchedule,\n                { mandatoryIf: [HDSCH] }\n            ),\n            clearHolidaySchedule: MutableCluster.AsConditional(\n                HolidaySchedulesComponent.commands.clearHolidaySchedule,\n                { mandatoryIf: [HDSCH] }\n            ),\n            setUserType: MutableCluster.AsConditional(\n                PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.setUserType,\n                { optionalIf: [PIN_RID_FGP_NOT_USR] }\n            ),\n            getUserType: MutableCluster.AsConditional(\n                PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.getUserType,\n                { optionalIf: [PIN_RID_FGP_NOT_USR] }\n            ),\n            setRfidCode: MutableCluster.AsConditional(\n                RfidCredentialNotUserComponent.commands.setRfidCode,\n                { mandatoryIf: [RID_NOT_USR] }\n            ),\n            getRfidCode: MutableCluster.AsConditional(\n                RfidCredentialNotUserComponent.commands.getRfidCode,\n                { mandatoryIf: [RID_NOT_USR] }\n            ),\n            clearRfidCode: MutableCluster.AsConditional(\n                RfidCredentialNotUserComponent.commands.clearRfidCode,\n                { mandatoryIf: [RID_NOT_USR] }\n            ),\n            clearAllRfidCodes: MutableCluster.AsConditional(\n                RfidCredentialNotUserComponent.commands.clearAllRfidCodes,\n                { mandatoryIf: [RID_NOT_USR] }\n            ),\n            setUser: MutableCluster.AsConditional(UserComponent.commands.setUser, { mandatoryIf: [USR] }),\n            getUser: MutableCluster.AsConditional(UserComponent.commands.getUser, { mandatoryIf: [USR] }),\n            clearUser: MutableCluster.AsConditional(UserComponent.commands.clearUser, { mandatoryIf: [USR] }),\n            setCredential: MutableCluster.AsConditional(UserComponent.commands.setCredential, { mandatoryIf: [USR] }),\n            getCredentialStatus: MutableCluster.AsConditional(\n                UserComponent.commands.getCredentialStatus,\n                { mandatoryIf: [USR] }\n            ),\n            clearCredential: MutableCluster.AsConditional(\n                UserComponent.commands.clearCredential,\n                { mandatoryIf: [USR] }\n            ),\n            unboltDoor: MutableCluster.AsConditional(UnboltingComponent.commands.unboltDoor, { mandatoryIf: [UBOLT] })\n        },\n\n        events: {\n            ...Cluster.events,\n            doorStateChange: MutableCluster.AsConditional(\n                DoorPositionSensorComponent.events.doorStateChange,\n                { mandatoryIf: [DPS] }\n            ),\n            lockUserChange: MutableCluster.AsConditional(UserComponent.events.lockUserChange, { mandatoryIf: [USR] })\n        }\n    });\n\n    /**\n     * This cluster supports all DoorLock features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n\nexport type DoorLockCluster = DoorLock.Cluster;\nexport const DoorLockCluster = DoorLock.Cluster;\nClusterRegistry.register(DoorLock.Complete);\n"],
  "mappings": "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",
  "names": ["DoorLock", "Feature", "DoorState", "EventType", "EventSource", "DataOperationType", "UserStatus", "UserType", "CredentialRule", "CredentialType", "LockDataType", "OperationSource", "OperatingMode", "LockState", "LockType", "LedSetting", "SoundVolume", "AlarmCode", "LockOperationType", "OperationError", "OperationEventCode", "ProgrammingEventCode", "StatusCode"]
}
