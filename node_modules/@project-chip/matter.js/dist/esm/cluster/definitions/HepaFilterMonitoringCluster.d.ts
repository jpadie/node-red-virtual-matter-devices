/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { MutableCluster } from "../mutation/MutableCluster.js";
import { ResourceMonitoring } from "./ResourceMonitoringCluster.js";
import { Identity } from "../../util/Type.js";
export declare namespace HepaFilterMonitoring {
    const Base: {
        readonly id: 113;
        readonly name: "HepaFilterMonitoring";
        readonly features: {
            readonly condition: import("../../schema/BitmapSchema.js").BitFlag;
            readonly warning: import("../../schema/BitmapSchema.js").BitFlag;
            readonly replacementProductList: import("../../schema/BitmapSchema.js").BitFlag;
        };
        readonly revision: 1;
        readonly attributes: {
            readonly changeIndication: import("../Cluster.js").Attribute<ResourceMonitoring.ChangeIndication, any>;
            readonly inPlaceIndicator: import("../Cluster.js").OptionalAttribute<boolean, any>;
            readonly lastChangedTime: import("../Cluster.js").OptionalWritableAttribute<number | null, any>;
        };
        readonly commands: {
            readonly resetCondition: import("../Cluster.js").OptionalCommand<void, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly condition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly condition: import("../Cluster.js").Attribute<number, any>;
                    readonly degradationDirection: import("../Cluster.js").FixedAttribute<ResourceMonitoring.DegradationDirection, any>;
                };
            };
        }, {
            readonly flags: {
                readonly replacementProductList: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly replacementProductList: import("../Cluster.js").FixedAttribute<import("../../tlv/TlvObject.js").TypeFromFields<{
                        productIdentifierType: import("../../tlv/TlvObject.js").FieldType<ResourceMonitoring.ProductIdentifierType>;
                        productIdentifierValue: import("../../tlv/TlvObject.js").FieldType<string>;
                    }>[], any>;
                };
            };
        }];
    };
    /**
     * @see {@link Cluster}
     */
    const ClusterInstance: MutableCluster<{
        readonly id: 113;
        readonly name: "HepaFilterMonitoring";
        readonly features: {
            readonly condition: import("../../schema/BitmapSchema.js").BitFlag;
            readonly warning: import("../../schema/BitmapSchema.js").BitFlag;
            readonly replacementProductList: import("../../schema/BitmapSchema.js").BitFlag;
        };
        readonly revision: 1;
        readonly attributes: {
            readonly changeIndication: import("../Cluster.js").Attribute<ResourceMonitoring.ChangeIndication, any>;
            readonly inPlaceIndicator: import("../Cluster.js").OptionalAttribute<boolean, any>;
            readonly lastChangedTime: import("../Cluster.js").OptionalWritableAttribute<number | null, any>;
        };
        readonly commands: {
            readonly resetCondition: import("../Cluster.js").OptionalCommand<void, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly condition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly condition: import("../Cluster.js").Attribute<number, any>;
                    readonly degradationDirection: import("../Cluster.js").FixedAttribute<ResourceMonitoring.DegradationDirection, any>;
                };
            };
        }, {
            readonly flags: {
                readonly replacementProductList: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly replacementProductList: import("../Cluster.js").FixedAttribute<import("../../tlv/TlvObject.js").TypeFromFields<{
                        productIdentifierType: import("../../tlv/TlvObject.js").FieldType<ResourceMonitoring.ProductIdentifierType>;
                        productIdentifierValue: import("../../tlv/TlvObject.js").FieldType<string>;
                    }>[], any>;
                };
            };
        }];
    }, []>;
    /**
     * This alias specializes the semantics of {@link ResourceMonitoring.Base}.
     *
     * HepaFilterMonitoringCluster supports optional features that you can enable with the
     * HepaFilterMonitoringCluster.with() factory method.
     */
    interface Cluster extends Identity<typeof ClusterInstance> {
    }
    const Cluster: Cluster;
    /**
     * This cluster supports all HepaFilterMonitoring features. It may support illegal feature combinations.
     *
     * If you use this cluster you must manually specify which features are active and ensure the set of active
     * features is legal per the Matter specification.
     */
    const CompleteInstance: MutableCluster<{
        readonly id: 113;
        readonly name: "HepaFilterMonitoring";
        readonly revision: 1;
        readonly features: {
            readonly condition: import("../../schema/BitmapSchema.js").BitFlag;
            readonly warning: import("../../schema/BitmapSchema.js").BitFlag;
            readonly replacementProductList: import("../../schema/BitmapSchema.js").BitFlag;
        };
        readonly attributes: {
            readonly condition: import("../Cluster.js").Attribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../Cluster.js").ConditionalFeatureList<import("../../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    condition: boolean;
                }];
            };
            readonly degradationDirection: import("../Cluster.js").FixedAttribute<ResourceMonitoring.DegradationDirection, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../Cluster.js").ConditionalFeatureList<import("../../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    condition: boolean;
                }];
            };
            readonly replacementProductList: import("../Cluster.js").FixedAttribute<import("../../tlv/TlvObject.js").TypeFromFields<{
                productIdentifierType: import("../../tlv/TlvObject.js").FieldType<ResourceMonitoring.ProductIdentifierType>;
                productIdentifierValue: import("../../tlv/TlvObject.js").FieldType<string>;
            }>[], any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../Cluster.js").ConditionalFeatureList<import("../../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    replacementProductList: boolean;
                }];
            };
            readonly changeIndication: import("../Cluster.js").Attribute<ResourceMonitoring.ChangeIndication, any>;
            readonly inPlaceIndicator: import("../Cluster.js").OptionalAttribute<boolean, any>;
            readonly lastChangedTime: import("../Cluster.js").OptionalWritableAttribute<number | null, any>;
        };
        readonly commands: {
            readonly resetCondition: import("../Cluster.js").OptionalCommand<void, void, any>;
        };
    }, []>;
    interface Complete extends Identity<typeof CompleteInstance> {
    }
    const Complete: Complete;
}
export type HepaFilterMonitoringCluster = HepaFilterMonitoring.Cluster;
export declare const HepaFilterMonitoringCluster: HepaFilterMonitoring.Cluster;
//# sourceMappingURL=HepaFilterMonitoringCluster.d.ts.map