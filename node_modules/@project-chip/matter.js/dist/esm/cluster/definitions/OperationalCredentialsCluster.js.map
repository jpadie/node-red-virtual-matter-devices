{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/OperationalCredentialsCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport { FabricScopedAttribute, AccessLevel, FixedAttribute, Attribute, Command, TlvNoResponse } from \"../Cluster.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvField, TlvObject, TlvOptionalField } from \"../../tlv/TlvObject.js\";\nimport { TlvByteString, TlvString } from \"../../tlv/TlvString.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { TlvFabricIndex, FabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvVendorId } from \"../../datatype/VendorId.js\";\nimport { TlvFabricId } from \"../../datatype/FabricId.js\";\nimport { TlvNodeId } from \"../../datatype/NodeId.js\";\nimport { TlvUInt8, TlvEnum } from \"../../tlv/TlvNumber.js\";\nimport { TlvBoolean } from \"../../tlv/TlvBoolean.js\";\nimport { TlvSubjectId } from \"../../datatype/SubjectId.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace OperationalCredentials {\n    /**\n     * This encodes a fabric sensitive NOC chain, underpinning a commissioned Operational Identity for a given Node.\n     *\n     * Note that the Trusted Root CA Certificate is not included in this structure. The roots are available in the\n     * TrustedRootCertificates attribute of the Node Operational Credentials cluster.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.4\n     */\n    export const TlvNoc = TlvObject({\n        /**\n         * This field shall contain the NOC for the struct\u2019s associated fabric, encoded using Matter Certificate\n         * Encoding.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.4.1\n         */\n        noc: TlvField(1, TlvByteString.bound({ maxLength: 400 })),\n\n        /**\n         * This field shall contain the ICAC or the struct\u2019s associated fabric, encoded using Matter Certificate\n         * Encoding. If no ICAC is present in the chain, this field shall be set to null.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.4.2\n         */\n        icac: TlvField(2, TlvNullable(TlvByteString.bound({ maxLength: 400 }))),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * This encodes a fabric sensitive NOC chain, underpinning a commissioned Operational Identity for a given Node.\n     *\n     * Note that the Trusted Root CA Certificate is not included in this structure. The roots are available in the\n     * TrustedRootCertificates attribute of the Node Operational Credentials cluster.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.4\n     */\n    export interface Noc extends TypeFromSchema<typeof TlvNoc> {}\n\n    /**\n     * This structure encodes a Fabric Reference for a fabric within which a given Node is currently commissioned.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5\n     */\n    export const TlvFabricDescriptor = TlvObject({\n        /**\n         * This field shall contain the public key for the trusted root that scopes the fabric referenced by\n         * FabricIndex and its associated operational credential (see Section 6.4.5.3, \u201CTrusted Root CA Certificates\u201D).\n         * The format for the key shall be the same as that used in the ec-pub-key field of the Matter Certificate\n         * Encoding for the root in the operational certificate chain.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5.1\n         */\n        rootPublicKey: TlvField(1, TlvByteString.bound({ length: 65 })),\n\n        /**\n         * This field shall contain the value of AdminVendorID provided in the AddNOC command that led to the creation\n         * of this FabricDescriptorStruct. The set of allowed values is defined in AdminVendorID.\n         *\n         * The intent is to provide some measure of user transparency about which entities have Administer privileges\n         * on the Node.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5.2\n         */\n        vendorId: TlvField(2, TlvVendorId),\n\n        /**\n         * This field shall contain the FabricID allocated to the fabric referenced by FabricIndex. This field shall\n         * match the value found in the matter-fabric-id field from the operational certificate providing the\n         * operational identity under this Fabric.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5.3\n         */\n        fabricId: TlvField(3, TlvFabricId),\n\n        /**\n         * This field shall contain the NodeID in use within the fabric referenced by FabricIndex. This field shall\n         * match the value found in the matter-node-id field from the operational certificate providing this\n         * operational identity.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5.4\n         */\n        nodeId: TlvField(4, TlvNodeId),\n\n        /**\n         * This field shall contain a commissioner-set label for the fabric referenced by FabricIndex. This label is\n         * set by the UpdateFabricLabel command.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5.5\n         */\n        label: TlvField(5, TlvString.bound({ maxLength: 32 })),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * This structure encodes a Fabric Reference for a fabric within which a given Node is currently commissioned.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.5\n     */\n    export interface FabricDescriptor extends TypeFromSchema<typeof TlvFabricDescriptor> {}\n\n    /**\n     * Input to the OperationalCredentials attestationRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.1\n     */\n    export const TlvAttestationRequest = TlvObject({ attestationNonce: TlvField(0, TlvByteString.bound({ length: 32 })) });\n\n    /**\n     * Input to the OperationalCredentials attestationRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.1\n     */\n    export interface AttestationRequest extends TypeFromSchema<typeof TlvAttestationRequest> {}\n\n    /**\n     * This command shall be generated in response to an Attestation Request command.\n     *\n     * See Section 11.18.4.7, \u201CAttestation Information\u201D for details about the generation of the fields within this\n     * response command.\n     *\n     * See Section F.2, \u201CDevice Attestation Response test vector\u201D for an example computation of an AttestationResponse.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.2\n     */\n    export const TlvAttestationResponse = TlvObject({\n        /**\n         * This field shall contain the octet string of the serialized attestation_elements_message.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.2.1\n         */\n        attestationElements: TlvField(0, TlvByteString.bound({ maxLength: 900 })),\n\n        /**\n         * This field shall contain the octet string of the necessary attestation_signature as described in Section\n         * 11.18.4.7, \u201CAttestation Information\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.2.2\n         */\n        attestationSignature: TlvField(1, TlvByteString.bound({ length: 64 }))\n    });\n\n    /**\n     * This command shall be generated in response to an Attestation Request command.\n     *\n     * See Section 11.18.4.7, \u201CAttestation Information\u201D for details about the generation of the fields within this\n     * response command.\n     *\n     * See Section F.2, \u201CDevice Attestation Response test vector\u201D for an example computation of an AttestationResponse.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.2\n     */\n    export interface AttestationResponse extends TypeFromSchema<typeof TlvAttestationResponse> {}\n\n    /**\n     * This enumeration is used by the CertificateChainRequest command to convey which certificate from the device\n     * attestation certificate chain to transmit back to the client.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.2\n     */\n    export enum CertificateChainType {\n        /**\n         * Request the DER- encoded DAC certificate\n         */\n        DacCertificate = 1,\n\n        /**\n         * Request the DER- encoded PAI certificate\n         */\n        PaiCertificate = 2\n    }\n\n    /**\n     * Input to the OperationalCredentials certificateChainRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.3\n     */\n    export const TlvCertificateChainRequest = TlvObject({ certificateType: TlvField(0, TlvEnum<CertificateChainType>()) });\n\n    /**\n     * Input to the OperationalCredentials certificateChainRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.3\n     */\n    export interface CertificateChainRequest extends TypeFromSchema<typeof TlvCertificateChainRequest> {}\n\n    /**\n     * This command shall be generated in response to a CertificateChainRequest command.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.4\n     */\n    export const TlvCertificateChainResponse = TlvObject({\n        /**\n         * This field shall be the DER encoded certificate corresponding to the CertificateType field in the\n         * CertificateChainRequest command.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.4.1\n         */\n        certificate: TlvField(0, TlvByteString.bound({ maxLength: 600 }))\n    });\n\n    /**\n     * This command shall be generated in response to a CertificateChainRequest command.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.4\n     */\n    export interface CertificateChainResponse extends TypeFromSchema<typeof TlvCertificateChainResponse> {}\n\n    /**\n     * Input to the OperationalCredentials csrRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.5\n     */\n    export const TlvCsrRequest = TlvObject({\n        csrNonce: TlvField(0, TlvByteString.bound({ length: 32 })),\n        isForUpdateNoc: TlvOptionalField(1, TlvBoolean)\n    });\n\n    /**\n     * Input to the OperationalCredentials csrRequest command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.5\n     */\n    export interface CsrRequest extends TypeFromSchema<typeof TlvCsrRequest> {}\n\n    /**\n     * This command shall be generated in response to a CSRRequest Command.\n     *\n     * See Section 11.18.4.9, \u201CNOCSR Information\u201D for details about the generation of the fields within this response\n     * command.\n     *\n     * See Section F.3, \u201CNode Operational CSR Response test vector\u201D for an example computation of a CSRResponse.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.6\n     */\n    export const TlvCsrResponse = TlvObject({\n        /**\n         * This field shall contain the octet string of the serialized nocsr_elements_message.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.6.1\n         */\n        nocsrElements: TlvField(0, TlvByteString.bound({ maxLength: 900 })),\n\n        /**\n         * This field shall contain the octet string of the necessary attestation_signature as described in Section\n         * 11.18.4.9, \u201CNOCSR Information\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.6.2\n         */\n        attestationSignature: TlvField(1, TlvByteString.bound({ length: 64 }))\n    });\n\n    /**\n     * This command shall be generated in response to a CSRRequest Command.\n     *\n     * See Section 11.18.4.9, \u201CNOCSR Information\u201D for details about the generation of the fields within this response\n     * command.\n     *\n     * See Section F.3, \u201CNode Operational CSR Response test vector\u201D for an example computation of a CSRResponse.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.6\n     */\n    export interface CsrResponse extends TypeFromSchema<typeof TlvCsrResponse> {}\n\n    /**\n     * Input to the OperationalCredentials addNoc command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.8\n     */\n    export const TlvAddNocRequest = TlvObject({\n        nocValue: TlvField(0, TlvByteString.bound({ maxLength: 400 })),\n        icacValue: TlvOptionalField(1, TlvByteString.bound({ maxLength: 400 })),\n\n        /**\n         * This field shall contain the value of the Epoch Key for the Identity Protection Key (IPK) to set for the\n         * Fabric which is to be added. This is needed to bootstrap a necessary configuration value for subsequent CASE\n         * to succeed. See Section 4.14.2.6.1, \u201CIdentity Protection Key (IPK)\u201D for details.\n         *\n         * The IPK shall be provided as an octet string of length CRYPTO_SYMMETRIC_KEY_LENGTH_BYTES.\n         *\n         * On successful execution of the AddNOC command, the side-effect of having provided this field shall be\n         * equivalent to having done a GroupKeyManagement cluster KeySetWrite command invocation using the newly joined\n         * fabric as the accessing fabric and with the following argument fields (assuming KeySetWrite allowed a\n         * GroupKeySetID set to 0):\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.8.1\n         */\n        ipkValue: TlvField(2, TlvByteString.bound({ length: 16 })),\n\n        /**\n         * If the AddNOC command succeeds according to the semantics of the following subsections, then the Access\n         * Control SubjectID shall be used to atomically add an Access Control Entry enabling that Subject to\n         * subsequently administer the Node whose operational identity is being added by this command.\n         *\n         * The format of the new Access Control Entry, created from this, shall be:\n         *\n         * NOTE\n         *\n         * Unless such an Access Control Entry is added atomically as described here, there would be no way for the\n         * caller on its given Fabric to eventually add another Access Control Entry for CASE authentication mode, to\n         * enable the new Administrator to administer the device, since the Fabric Scoping of the Access Control List\n         * prevents the current Node from being able to write new entries scoped to that Fabric, if the session is\n         * established from CASE. While a session established from PASE does gain Fabric Scope of a newly-joined\n         * Fabric, this argument is made mandatory to provide symmetry between both types of session establishment,\n         * both of which need to eventually add an \"Administer Node over CASE\" Access Control Entry to finalize new\n         * Fabric configuration and subsequently be able to call the CommissioningComplete command.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.8.2\n         */\n        caseAdminSubject: TlvField(3, TlvSubjectId),\n\n        /**\n         * This field shall be set to the Vendor ID of the entity issuing the AddNOC command. This value shall NOT be\n         * one of the reserved Vendor ID values defined in Table 1, \u201CVendor ID Allocations\u201D.\n         *\n         * ### Effect When Received\n         *\n         * If this command is received without an armed fail-safe context (see Section 11.10.6.2, \u201CArmFailSafe\n         * Command\u201D), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the initiator.\n         *\n         * If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, then\n         * this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n         *\n         * If the prior CSRRequest state that preceded AddNOC had the IsForUpdateNOC field indicated as true, then this\n         * command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n         *\n         * If no prior AddTrustedRootCertificate command was successfully executed within the fail-safe timer period,\n         * then this command shall process an error by responding with a NOCResponse with a StatusCode of InvalidNOC as\n         * described in Section 11.18.6.7.2, \u201CHandling Errors\u201D. In other words, AddNOC always requires that the client\n         * provides the root of trust certificate within the same Fail- Safe context as the rest of the new fabric\u2019s\n         * operational credentials, even if some other fabric already uses the exact same root of trust certificate.\n         *\n         * If the NOC provided in the NOCValue encodes an Operational Identifier for a <Root Public Key, Fab\n         *\n         * ricID> pair already present on the device, then the device shall process the error by responding with a\n         * StatusCode of FabricConflict as described in Section 11.18.6.7.2, \u201CHandling Errors\u201D.\n         *\n         * If the device already has the CommissionedFabrics attribute equal to the SupportedFabrics attribute, then\n         * the device\u2019s operational credentials table is considered full and the device shall process the error by\n         * responding with a StatusCode of TableFull as described in Section 11.18.6.7.2, \u201CHandling Errors\u201D.\n         *\n         * If the CaseAdminSubject field is not a valid ACL subject in the context of AuthMode set to CASE, such as not\n         * being in either the Operational or CASE Authenticated Tag range, then the device shall process the error by\n         * responding with a StatusCode of InvalidAdminSubject as described in Section 11.18.6.7.2, \u201CHandling Errors\u201D.\n         *\n         * Otherwise, the command is considered an addition of credentials, also known as \"joining a fabric\", and the\n         * following shall apply:\n         *\n         *   1. A new FabricIndex shall be allocated, taking the next valid fabric-index value in monotonically\n         *       incrementing order, wrapping around from 254 (0xFE) to 1, since value 0 is reserved and using 255\n         *       (0xFF) would prevent cluster specifications from using nullable fabric-idx fields.\n         *\n         *   2. An entry within the Fabrics attribute table shall be added, reflecting the matter-fabric-id RDN within\n         *       the NOC\u2019s subject, along with the public key of the trusted root of the chain and the AdminVendorID\n         *       field.\n         *\n         *   3. The operational key pair associated with the incoming NOC from the NOCValue, and generated by the prior\n         *       CSRRequest command, shall be recorded for subsequent use during CASE within the fail-safe timer period\n         *       (see Section 5.5, \u201CCommissioning Flows\u201D).\n         *\n         *   4. The incoming NOCValue and ICACValue (if present) shall be stored under the FabricIndex associated with\n         *       the new Fabric Scope, along with the RootCACertificate provided with the prior successful\n         *       AddTrustedRootCertificate command invoked in the same fail-safe period.\n         *\n         *     a. Implementation of certificate chain storage may separate or otherwise encode the components of the\n         *        array in implementation-specific ways, as long as they follow the correct format when being read from\n         *        the NOCs list or used within other protocols such as CASE.\n         *\n         *   5. The NOCs list shall reflect the incoming NOC from the NOCValue field and ICAC from the ICACValue field\n         *       (if present).\n         *\n         *   6. The operational discovery service record shall immediately reflect the new Operational Identifier, such\n         *       that the Node immediately begins to exist within the Fabric and becomes reachable over CASE under the\n         *       new operational identity.\n         *\n         *   7. The receiver shall create and add a new Access Control Entry using the CaseAdminSubject field to grant\n         *       subsequent Administer access to an Administrator member of the new Fabric. It is recommended that the\n         *       Administrator presented in CaseAdminSubject exist within the same entity that is currently invoking\n         *       the AddNOC command, within another of the Fabrics of which it is a member.\n         *\n         *   8. The incoming IPKValue shall be stored in the Fabric-scoped slot within the Group Key Management cluster\n         *       (see KeySetWrite), for subsequent use during CASE.\n         *\n         *   9. The Fabric Index associated with the armed fail-safe context (see Section 11.10.6.2, \u201CArmFailSafe\n         *       Command\u201D) shall be updated to match the Fabric Index just allocated.\n         *\n         *   10. If the current secure session was established with PASE, the receiver shall:\n         *\n         *     a. Augment the secure session context with the FabricIndex generated above, such that subsequent\n         *        interactions have the proper accessing fabric.\n         *\n         *   11. If the current secure session was established with CASE, subsequent configuration of the newly\n         *       installed Fabric requires the opening of a new CASE session from the Administrator from the Fabric\n         *       just installed. This Administrator is the one listed in the CaseAdminSubject argument.\n         *\n         * Thereafter, the Node shall respond with an NOCResponse with a StatusCode of OK and a FabricIndex field\n         * matching the FabricIndex under which the new Node Operational Certificate (NOC) is scoped.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.8.3\n         */\n        adminVendorId: TlvField(4, TlvVendorId)\n    });\n\n    /**\n     * Input to the OperationalCredentials addNoc command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.8\n     */\n    export interface AddNocRequest extends TypeFromSchema<typeof TlvAddNocRequest> {}\n\n    /**\n     * This enumeration is used by the NOCResponse common response command to convey detailed outcome of several of\n     * this cluster\u2019s operations.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.4.3\n     */\n    export enum NodeOperationalCertStatus {\n        /**\n         * OK, no error\n         */\n        Ok = 0,\n\n        /**\n         * Public Key in the NOC does not match the public key in the NOCSR\n         */\n        InvalidPublicKey = 1,\n\n        /**\n         * The Node Operational ID in the NOC is not formatted correctly.\n         */\n        InvalidNodeOpId = 2,\n\n        /**\n         * Any other validation error in NOC chain\n         */\n        InvalidNoc = 3,\n\n        /**\n         * No record of prior CSR for which this NOC could match\n         */\n        MissingCsr = 4,\n\n        /**\n         * NOCs table full, cannot add another one\n         */\n        TableFull = 5,\n\n        /**\n         * Invalid CaseAdminSubject field for an AddNOC command.\n         */\n        InvalidAdminSubject = 6,\n\n        /**\n         * Trying to AddNOC instead of UpdateNOC against an existing Fabric.\n         */\n        FabricConflict = 9,\n\n        /**\n         * Label already exists on another Fabric.\n         */\n        LabelConflict = 10,\n\n        /**\n         * FabricIndex argument is invalid.\n         */\n        InvalidFabricIndex = 11\n    }\n\n    /**\n     * This command shall be generated in response to the following commands:\n     *\n     *   \u2022 AddNOC\n     *\n     *   \u2022 UpdateNOC\n     *\n     *   \u2022 UpdateFabricLabel\n     *\n     *   \u2022 RemoveFabric\n     *\n     * It provides status information about the success or failure of those commands.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.10\n     */\n    export const TlvNocResponse = TlvObject({\n        /**\n         * This field shall contain an NOCStatus value representing the status of an operation involving a NOC.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.10.1\n         */\n        statusCode: TlvField(0, TlvEnum<NodeOperationalCertStatus>()),\n\n        /**\n         * This field shall be present whenever StatusCode has a value of OK. If present, it shall contain the Fabric\n         * Index of the Fabric last added, removed or updated.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.10.2\n         */\n        fabricIndex: TlvOptionalField(1, TlvFabricIndex),\n\n        /**\n         * This field may contain debugging textual information from the cluster implementation, which SHOULD NOT be\n         * presented to user interfaces in any way. Its purpose is to help developers in troubleshooting errors and the\n         * contents may go into logs or crash reports.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.10.3\n         */\n        debugText: TlvOptionalField(2, TlvString.bound({ maxLength: 128 }))\n    });\n\n    /**\n     * This command shall be generated in response to the following commands:\n     *\n     *   \u2022 AddNOC\n     *\n     *   \u2022 UpdateNOC\n     *\n     *   \u2022 UpdateFabricLabel\n     *\n     *   \u2022 RemoveFabric\n     *\n     * It provides status information about the success or failure of those commands.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.10\n     */\n    export interface NocResponse extends TypeFromSchema<typeof TlvNocResponse> {}\n\n    /**\n     * Input to the OperationalCredentials updateNoc command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.9\n     */\n    export const TlvUpdateNocRequest = TlvObject({\n        nocValue: TlvField(0, TlvByteString.bound({ maxLength: 400 })),\n        icacValue: TlvOptionalField(1, TlvByteString.bound({ maxLength: 400 })),\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * Input to the OperationalCredentials updateNoc command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.9\n     */\n    export interface UpdateNocRequest extends TypeFromSchema<typeof TlvUpdateNocRequest> {}\n\n    /**\n     * Input to the OperationalCredentials updateFabricLabel command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.11\n     */\n    export const TlvUpdateFabricLabelRequest = TlvObject({\n        /**\n         * This field shall contain the label to set for the fabric associated with the current secure session.\n         *\n         * Effect on Receipt\n         *\n         * If the Label field is identical to a Label already in use by a Fabric within the Fabrics list that is not\n         * the accessing fabric, then an NOCResponse with a StatusCode of LabelConflict shall be returned for the\n         * command and there shall NOT be any permanent changes to any Fabric data.\n         *\n         * Otherwise, the Label field for the accessing fabric shall immediately be updated to reflect the Label\n         * argument provided. Following the update, an NOCResponse with a StatusCode of OK shall be returned.\n         *\n         * If the command was invoked within a fail-safe context after a successful UpdateNOC command, then the label\n         * update shall apply to the pending update state that will be reverted if fail-safe expires prior to a\n         * CommissioningComplete command. In other words, label updates apply to the state of the Fabrics Attribute as\n         * currently visible, even for an existing fabric currently in process of being updated.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.11.1\n         */\n        label: TlvField(0, TlvString.bound({ maxLength: 32 })),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * Input to the OperationalCredentials updateFabricLabel command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.11\n     */\n    export interface UpdateFabricLabelRequest extends TypeFromSchema<typeof TlvUpdateFabricLabelRequest> {}\n\n    /**\n     * Input to the OperationalCredentials removeFabric command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.12\n     */\n    export const TlvRemoveFabricRequest = TlvObject({\n        /**\n         * This field shall contain the Fabric Index reference (see fabric-index) associated with the Fabric which is\n         * to be removed from the device.\n         *\n         * Effect on Receipt\n         *\n         * If the FabricIndex field does not match the FabricIndex of any entry within the Fabrics list, then an\n         * NOCResponse with a StatusCode of InvalidFabricIndex shall be returned for the command and there shall NOT be\n         * any permanent changes to any device data.\n         *\n         * Otherwise, one of the following outcomes shall occur:\n         *\n         *   1. If the FabricIndex matches the last remaining entry in the Fabrics list, then the device shall delete\n         *      all Matter related data on the node which was created since it was commissioned. This\n         *\n         * includes all Fabric-Scoped data, including Access Control List, bindings, scenes, group keys, operational\n         * certificates, etc. All Trusted Roots shall also be removed. If a time synchronization cluster is present on\n         * the Node, the TrustedTimeSource and DefaultNtp shall be set to null. Any Matter related data including logs,\n         * secure sessions, exchanges and interaction model constructs shall also be removed. Since this operation\n         * involves the removal of the secure session data that may underpin the current set of exchanges, the Node\n         * invoking the command SHOULD NOT expect a response before terminating its secure session with the target.\n         *\n         * 2. If the FabricIndex does not equal the accessing fabric index, then the device shall begin the process of\n         * irrevocably deleting all associated Fabric-Scoped data, including Access Control List, bindings, group keys,\n         * operational certificates, etc. Any remaining Trusted Roots no longer referenced by any operational\n         * certificate shall also be removed. If a time synchronization cluster is present on the Node, and the\n         * TrustedTimeSource FabricIndex matches the given FabricIndex, the TrustedTimeSource shall be set to null. All\n         * secure sessions, exchanges and interaction model constructs related to the Operational Identity under the\n         * given Fabric shall also be removed. Following the removal, an NOCResponse with a StatusCode of OK shall be\n         * returned.\n         *\n         * 3. If the FabricIndex equals the accessing fabric index, then the device shall begin the process of\n         * irrevocably deleting all associated Fabric-Scoped data, including Access Control Entries, bindings, group\n         * keys, operational certificates, etc. Any remaining Trusted Roots no longer referenced by any operational\n         * certificate shall also be removed. If a time synchronization cluster is present on the Node, and the\n         * TrustedTimeSource FabricIndex matches the given FabricIndex, the TrustedTimeSource shall be set to null. All\n         * secure sessions, exchanges and interaction model constructs related to the Operational Identity under the\n         * given Fabric shall also be removed. Since this operation involves the removal of the secure session data\n         * that may underpin the current set of exchanges, the Node invoking the command SHOULD NOT expect a response\n         * before terminating its secure session with the target.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.12.1\n         */\n        fabricIndex: TlvField(0, TlvFabricIndex)\n    });\n\n    /**\n     * Input to the OperationalCredentials removeFabric command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.12\n     */\n    export interface RemoveFabricRequest extends TypeFromSchema<typeof TlvRemoveFabricRequest> {}\n\n    /**\n     * Input to the OperationalCredentials addTrustedRootCertificate command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.13\n     */\n    export const TlvAddTrustedRootCertificateRequest = TlvObject({\n        rootCaCertificate: TlvField(0, TlvByteString.bound({ maxLength: 400 }))\n    });\n\n    /**\n     * Input to the OperationalCredentials addTrustedRootCertificate command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.13\n     */\n    export interface AddTrustedRootCertificateRequest extends TypeFromSchema<typeof TlvAddTrustedRootCertificateRequest> {}\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster({\n        id: 0x3e,\n        name: \"OperationalCredentials\",\n        revision: 1,\n\n        attributes: {\n            /**\n             * This attribute contains all NOCs applicable to this Node, encoded as a read-only list of NOCStruct.\n             *\n             * Operational Certificates shall be added through the AddNOC command, and shall be removed through the\n             * RemoveFabric command.\n             *\n             * Upon Factory Data Reset, this attribute shall be set to a default value of an empty list.\n             *\n             * The number of entries in this list shall match the number of entries in the Fabrics attribute.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.5.1\n             */\n            nocs: FabricScopedAttribute(\n                0x0,\n                TlvArray(TlvNoc),\n\n                {\n                    persistent: true,\n                    omitChanges: true,\n                    default: [],\n                    readAcl: AccessLevel.Administer,\n                    writeAcl: AccessLevel.Administer\n                }\n            ),\n\n            /**\n             * This attribute describes all fabrics to which this Node is commissioned, encoded as a read-only list of\n             * FabricDescriptorStruct. This information may be computed directly from the NOCs attribute.\n             *\n             * Upon Factory Data Reset, this attribute shall be set to a default value of an empty list.\n             *\n             * The number of entries in this list shall match the number of entries in the NOCs attribute.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.5.2\n             */\n            fabrics: FabricScopedAttribute(0x1, TlvArray(TlvFabricDescriptor), { persistent: true, default: [] }),\n\n            /**\n             * This attribute contains the number of Fabrics that are supported by the device. This value is fixed for\n             * a particular device.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.5.3\n             */\n            supportedFabrics: FixedAttribute(0x2, TlvUInt8.bound({ min: 5, max: 254 })),\n\n            /**\n             * This attribute contains the number of Fabrics to which the device is currently commissioned. This\n             * attribute shall be equal to the following:\n             *\n             *   \u2022 The number of entries in the NOCs attribute.\n             *\n             *   \u2022 The number of entries in the Fabrics attribute.\n             *\n             * Upon Factory Data Reset, this attribute shall be set to a default value of 0.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.5.4\n             */\n            commissionedFabrics: Attribute(0x3, TlvUInt8, { persistent: true }),\n\n            /**\n             * This attribute shall contain a read-only list of Trusted Root CA Certificates installed on the Node, as\n             * octet strings containing their Matter Certificate Encoding representation.\n             *\n             * These certificates are installed through the AddTrustedRootCertificate command.\n             *\n             * Depending on the method of storage employed by the server, either shared storage for identical root\n             * certificates shared by many fabrics, or individually stored root certificate per fabric, multiple\n             * identical root certificates may legally appear within the list.\n             *\n             * To match a root with a given fabric, the root certificate\u2019s subject and subject public key need to be\n             * cross-referenced with the NOC or ICAC certificates that appear in the NOCs attribute for a given fabric.\n             *\n             * Upon Factory Data Reset, this attribute shall be set to a default value whereby the list is empty.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.5.5\n             */\n            trustedRootCertificates: Attribute(\n                0x4,\n                TlvArray(TlvByteString),\n                { persistent: true, omitChanges: true, default: [] }\n            ),\n\n            /**\n             * This attribute shall contain accessing fabric index.\n             *\n             * This attribute is useful to contextualize Fabric-Scoped entries obtained from response commands or\n             * attribute reads, since a given Fabric may be referenced by a different Fabric Index locally on a remote\n             * Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.5.6\n             */\n            currentFabricIndex: Attribute(0x5, TlvFabricIndex, { default: FabricIndex(0) })\n        },\n\n        commands: {\n            /**\n             * This command shall be generated to request the Attestation Information, in the form of an\n             * AttestationResponse Command. If the AttestationNonce that is provided in the command is malformed, a\n             * recipient shall fail the command with a Status Code of INVALID_COMMAND. The AttestationNonce field shall\n             * be used in the computation of the Attestation Information.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.1\n             */\n            attestationRequest: Command(\n                0x0,\n                TlvAttestationRequest,\n                0x1,\n                TlvAttestationResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * If the CertificateType is not a valid value per CertificateChainTypeEnum then the command shall fail\n             * with a Status Code of INVALID_COMMAND.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.3\n             */\n            certificateChainRequest: Command(\n                0x2,\n                TlvCertificateChainRequest,\n                0x3,\n                TlvCertificateChainResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * This command shall be generated to execute the Node Operational CSR Procedure and subsequently return\n             * the NOCSR Information, in the form of a CSRResponse Command.\n             *\n             * The CSRNonce field shall be used in the computation of the NOCSR Information. If the CSRNonce is\n             * malformed, then this command shall fail with an INVALID_COMMAND status code.\n             *\n             * If the IsForUpdateNOC field is present and set to true, but the command was received over a PASE\n             * session, the command shall fail with an INVALID_COMMAND status code, as it would never be possible to\n             * use a resulting subsequent certificate issued from the CSR with the UpdateNOC command, which is\n             * forbidden over PASE sessions.\n             *\n             * If the IsForUpdateNOC field is present and set to true, the internal state of the CSR associated keypair\n             * shall be tagged as being for a subsequent UpdateNOC, otherwise the internal state of the CSR shall be\n             * tagged as being for a subsequent AddNOC. See AddNOC and UpdateNOC for details about the processing.\n             *\n             * If this command is received without an armed fail-safe context (see Section 11.10.6.2, \u201CArmFailSafe\n             * Command\u201D), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the initiator.\n             *\n             * If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, then\n             * this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n             *\n             * If the Node Operational Key Pair generated during processing of the Node Operational CSR Procedure is\n             * found to collide with an existing key pair already previously generated and installed, and that check\n             * had been executed, then this command shall fail with a FAILURE status code sent back to the initiator.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.5\n             */\n            csrRequest: Command(0x4, TlvCsrRequest, 0x5, TlvCsrResponse, { invokeAcl: AccessLevel.Administer }),\n\n            /**\n             * This command shall add a new NOC chain to the device and commission a new Fabric association upon\n             * successful validation of all arguments and preconditions.\n             *\n             * The new value shall immediately be reflected in the NOCs list attribute.\n             *\n             * A Commissioner or Administrator shall issue this command after issuing the CSRRequest command and\n             * receiving its response.\n             *\n             * A Commissioner or Administrator SHOULD issue this command after performing the Attestation Procedure.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.8\n             */\n            addNoc: Command(0x6, TlvAddNocRequest, 0x8, TlvNocResponse, { invokeAcl: AccessLevel.Administer }),\n\n            /**\n             * This command shall replace the NOC and optional associated ICAC (if present) scoped under the accessing\n             * fabric upon successful validation of all arguments and preconditions. The new value shall immediately be\n             * reflected in the NOCs list attribute.\n             *\n             * A Commissioner or Administrator shall issue this command after issuing the CSRRequest Command and\n             * receiving its response.\n             *\n             * A Commissioner or Administrator SHOULD issue this command after performing the Attestation Procedure.\n             *\n             * Effect When Received\n             *\n             * If this command is received without an armed fail-safe context (see Section 11.10.6.2, \u201CArmFailSafe\n             * Command\u201D), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the initiator.\n             *\n             * If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, then\n             * this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n             *\n             * If a prior AddTrustedRootCertificate command was successfully invoked within the fail-safe timer period,\n             * then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator, since the\n             * only valid following logical operation is invoking the AddNOC command.\n             *\n             * If the prior CSRRequest state that preceded UpdateNOC had the IsForUpdateNOC field indicated as false,\n             * then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n             *\n             * If any of the following conditions arise, the Node shall process an error by responding with an\n             *\n             * NOCResponse with a StatusCode of InvalidNOC as described in Section 11.18.6.7.2, \u201CHandling Errors\u201D:\n             *\n             *   \u2022 The NOC provided in the NOCValue does not refer in its subject to the FabricID associated with the\n             *     accessing fabric.\n             *\n             *   \u2022 The ICAC provided in the ICACValue (if present) has a FabricID in its subject that does not match\n             *     the FabricID associated with the accessing fabric.\n             *\n             * Otherwise, the command is considered an update of existing credentials for a given Fabric, and the\n             * following shall apply:\n             *\n             *   1. The Operational Certificate under the accessing fabric index in the NOCs list shall be updated to\n             *      match the incoming NOCValue and ICACValue (if present), such that the Node\u2019s Operational Identifier\n             *      within the Fabric immediately changes.\n             *\n             *     a. The operational key pair associated with the incoming NOC from the NOCValue, and generated by the\n             *        prior CSRRequest command, shall be committed to permanent storage, for subsequent use during CASE.\n             *\n             *     b. The operational discovery service record shall immediately reflect the new Operational Identifier.\n             *\n             *     c. All internal data reflecting the prior operational identifier of the Node within the Fabric shall\n             *        be revoked and removed, to an outcome equivalent to the disappearance of the prior Node, except\n             *        for the ongoing CASE session context, which shall temporarily remain valid until the NOCResponse\n             *        has been successfully delivered or until the next transport-layer error, so that the response can\n             *        be received by the Administrator invoking the command.\n             *\n             * Thereafter, the Node shall respond with an NOCResponse with a StatusCode of OK and a FabricIndex field\n             * matching the FabricIndex under which the updated NOC is scoped.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.9\n             */\n            updateNoc: Command(0x7, TlvUpdateNocRequest, 0x8, TlvNocResponse, { invokeAcl: AccessLevel.Administer }),\n\n            /**\n             * This command shall be used by an Administrator to set the user-visible Label field for a given Fabric,\n             * as reflected by entries in the Fabrics attribute. An Administrator shall use this command to set the\n             * Label to a string (possibly selected by the user themselves) that the user can recognize and relate to\n             * this Administrator\n             *\n             *   \u2022 during the commissioning process, and\n             *\n             *   \u2022 whenever the user chooses to update this string.\n             *\n             * The Label field, along with the VendorID field in the same entry of the Fabrics attribute, SHOULD be\n             * used by Administrators to provide additional per-fabric context when operations such as RemoveFabric are\n             * considered or used.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.11\n             */\n            updateFabricLabel: Command(\n                0x9,\n                TlvUpdateFabricLabelRequest,\n                0x8,\n                TlvNocResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * This command is used by Administrators to remove a given Fabric and delete all associated fabric-scoped\n             * data.\n             *\n             * If the given Fabric being removed is the last one to reference a given Trusted Root CA Certificate\n             * stored in the Trusted Root Certificates list, then that Trusted Root Certificate shall be removed.\n             *\n             * WARNING\n             *\n             * This command, if referring to an already existing Fabric not under the control of the invoking\n             * Administrator, shall ONLY be invoked after obtaining some form of explicit user consent through some\n             * method executed by the Administrator or Commissioner. This method of obtaining consent SHOULD employ as\n             * much data as possible about the existing Fabric associations within the Fabrics list, so that likelihood\n             * is as small as possible of a user removing a Fabric unwittingly. If a method exists for an Administrator\n             * or Commissioner to convey Fabric Removal to an entity related to that Fabric, whether in-band or\n             * out-of-band, then this method SHOULD be used to notify the other Administrative Domain\u2019s party of the\n             * removal. Otherwise, users may only observe the removal of a Fabric association as persistently failing\n             * attempts to reach a Node operationally.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.12\n             */\n            removeFabric: Command(\n                0xa,\n                TlvRemoveFabricRequest,\n                0x8,\n                TlvNocResponse,\n                { invokeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * This command shall add a Trusted Root CA Certificate, provided as its Matter Certificate Encoding\n             * representation, to the TrustedRootCertificates Attribute list and shall ensure the next AddNOC command\n             * executed uses the provided certificate as its root of trust.\n             *\n             * If the certificate from the RootCACertificate field is already installed, based on exact byte-for-byte\n             * equality, then this command shall succeed with no change to the list.\n             *\n             * If this command is received without an armed fail-safe context (see Section 11.10.6.2, \u201CArmFailSafe\n             * Command\u201D), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the initiator.\n             *\n             * If a prior AddTrustedRootCertificate command was successfully invoked within the fail-safe timer period,\n             * which would cause the new invocation to add a second root certificate within a given fail- safe timer\n             * period, then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n             *\n             * If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, then\n             * this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator.\n             *\n             * If the certificate from the RootCACertificate field fails any validity checks, not fulfilling all the\n             * requirements for a valid Matter Certificate Encoding representation, including a truncated or oversize\n             * value, then this command shall fail with an INVALID_COMMAND status code sent back to the initiator.\n             *\n             * Note that the only method of removing a trusted root is by removing the Fabric that uses it as its root\n             * of trust using the RemoveFabric command.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.18.6.13\n             */\n            addTrustedRootCertificate: Command(\n                0xb,\n                TlvAddTrustedRootCertificateRequest,\n                0xb,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * This cluster is used to add or remove Node Operational credentials on a Commissionee or Node, as well as manage\n     * the associated Fabrics.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.18\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    export const Complete = Cluster;\n}\n\nexport type OperationalCredentialsCluster = OperationalCredentials.Cluster;\nexport const OperationalCredentialsCluster = OperationalCredentials.Cluster;\nClusterRegistry.register(OperationalCredentials.Complete);\n"],
  "mappings": "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",
  "names": ["OperationalCredentials", "CertificateChainType", "NodeOperationalCertStatus"]
}
