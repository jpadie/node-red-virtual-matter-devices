{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/FixedLabelCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport { Attribute } from \"../Cluster.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { Label } from \"./LabelCluster.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace FixedLabel {\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster({\n        id: 0x40,\n        name: \"FixedLabel\",\n        revision: 1,\n\n        attributes: {\n            /**\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.8.4\n             */\n            labelList: Attribute(0x0, TlvArray(Label.TlvLabelStruct), { persistent: true, default: [] })\n        }\n    });\n\n    /**\n     * This cluster provides a feature for the device to tag an endpoint with zero or more read only labels. Examples:\n     *\n     *   \u2022 A bridge can use this to indicate grouping of bridged devices. For example: All bridged devices whose\n     *     endpoints have an entry in their LabelList \"room\":\"bedroom 2\" are in the same (bed)room.\n     *\n     *   \u2022 A manufacturer can use this to identify a characteristic of an endpoint. For example to identify the\n     *     endpoints of a luminaire, one pointing up, the other pointing down, one of the endpoints would have a\n     *     LabelList entry \"orientation\":\"up\" while the other would have \"orientation\":\"down\". Using such indication,\n     *     the user interface of a Node controlling this luminaire knows which of the endpoints is which of the lights.\n     *\n     * Note that the TagList in the Descriptor cluster provides an alternative mechanism for such self- description\n     * using standardized tags rather than manufacturer-selected strings, yielding a standardized mechanism for\n     * features defined in the various namespaces. The second example above can be implemented using semantic tags\n     * Direction.Upward and Direction.Downward instead of (or in addition to) the Fixed Label cluster.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.8\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    export const Complete = Cluster;\n}\n\nexport type FixedLabelCluster = FixedLabel.Cluster;\nexport const FixedLabelCluster = FixedLabel.Cluster;\nClusterRegistry.register(FixedLabel.Complete);\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,SAAS,sBAAsB;AAC/B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,aAAa;AAEtB,SAAS,uBAAuB;AAEzB,IAAU;AAAA,CAAV,CAAUA,gBAAV;AAII,EAAMA,YAAA,kBAAkB,eAAe;AAAA,IAC1C,IAAI;AAAA,IACJ,MAAM;AAAA,IACN,UAAU;AAAA,IAEV,YAAY;AAAA;AAAA;AAAA;AAAA,MAIR,WAAW,UAAU,GAAK,SAAS,MAAM,cAAc,GAAG,EAAE,YAAY,MAAM,SAAS,CAAC,EAAE,CAAC;AAAA,IAC/F;AAAA,EACJ,CAAC;AAsBM,EAAMA,YAAA,UAAmBA,YAAA;AACzB,EAAMA,YAAA,WAAWA,YAAA;AAAA,GAtCX;AA0CV,MAAM,oBAAoB,WAAW;AAC5C,gBAAgB,SAAS,WAAW,QAAQ;",
  "names": ["FixedLabel"]
}
