{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/TimeSynchronizationCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport {\n    Attribute,\n    Command,\n    TlvNoResponse,\n    AccessLevel,\n    Event,\n    EventPriority,\n    FixedAttribute,\n    OptionalAttribute\n} from \"../Cluster.js\";\nimport { TlvField, TlvObject, TlvOptionalField } from \"../../tlv/TlvObject.js\";\nimport { TlvFabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { TlvNodeId } from \"../../datatype/NodeId.js\";\nimport { TlvEndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { TlvNoArguments } from \"../../tlv/TlvNoArguments.js\";\nimport { TlvString } from \"../../tlv/TlvString.js\";\nimport { TlvBoolean } from \"../../tlv/TlvBoolean.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvInt32, TlvEpochUs, TlvEnum, TlvUInt8 } from \"../../tlv/TlvNumber.js\";\nimport { BitFlag } from \"../../schema/BitmapSchema.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace TimeSynchronization {\n    /**\n     * These are optional features supported by TimeSynchronizationCluster.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5\n     */\n    export enum Feature {\n        /**\n         * TimeZone (TZ)\n         *\n         * Allows a server to translate a UTC time to a local time using the time zone and daylight savings time (DST)\n         * offsets. If a server supports the TimeZone feature, it shall support the SetTimeZone and SetDSTOffset\n         * commands, and TimeZone and DSTOffset attributes, and shall expose the local time through the LocalTime\n         * attribute.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.1\n         */\n        TimeZone = \"TimeZone\",\n\n        /**\n         * NtpClient (NTPC)\n         *\n         * Allows a node to use NTP/SNTP for time synchronization.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.2\n         */\n        NtpClient = \"NtpClient\",\n\n        /**\n         * NtpServer (NTPS)\n         *\n         * Allows a Node to host an NTP server for the network so that other Nodes can achieve a high accuracy time\n         * synchronization within the network. See Section 11.17.15, \u201CActing as an NTP Server\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.3\n         */\n        NtpServer = \"NtpServer\",\n\n        /**\n         * TimeSyncClient (TSC)\n         *\n         * This node also supports a time synchronization client and can connect to and read time from other nodes.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.4\n         */\n        TimeSyncClient = \"TimeSyncClient\"\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.4\n     */\n    export const TlvTrustedTimeSource = TlvObject({\n        /**\n         * The Fabric Index associated with the Fabric of the client which last set the value of the trusted time\n         * source node.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.4.1\n         */\n        fabricIndex: TlvField(0, TlvFabricIndex),\n\n        /**\n         * Node ID of the trusted time source node on the Fabric associated with the entry.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.4.2\n         */\n        nodeId: TlvField(1, TlvNodeId),\n\n        /**\n         * Endpoint on the trusted time source node that contains the Time Synchronization cluster server.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.4.3\n         */\n        endpoint: TlvField(2, TlvEndpointNumber)\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.4\n     */\n    export interface TrustedTimeSource extends TypeFromSchema<typeof TlvTrustedTimeSource> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.5\n     */\n    export const TlvFabricScopedTrustedTimeSource = TlvObject({\n        /**\n         * Node ID of the trusted time source node on the Fabric of the issuer.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.5.1\n         */\n        nodeId: TlvField(0, TlvNodeId),\n\n        /**\n         * Endpoint on the trusted time source node that contains the Time Synchronization cluster server. This is\n         * provided to avoid having to do discovery of the location of that endpoint by walking over all endpoints and\n         * checking their Descriptor Cluster.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.5.2\n         */\n        endpoint: TlvField(1, TlvEndpointNumber)\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.5\n     */\n    export interface FabricScopedTrustedTimeSource extends TypeFromSchema<typeof TlvFabricScopedTrustedTimeSource> {}\n\n    /**\n     * Input to the TimeSynchronization setTrustedTimeSource command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.2\n     */\n    export const TlvSetTrustedTimeSourceRequest = TlvObject({\n        /**\n         * This field contains the Node ID and endpoint of a trusted time source on the accessing fabric.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.2.1\n         */\n        trustedTimeSource: TlvField(0, TlvNullable(TlvFabricScopedTrustedTimeSource)),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * Input to the TimeSynchronization setTrustedTimeSource command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.2\n     */\n    export interface SetTrustedTimeSourceRequest extends TypeFromSchema<typeof TlvSetTrustedTimeSourceRequest> {}\n\n    /**\n     * Input to the TimeSynchronization setDefaultNtp command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.6\n     */\n    export const TlvSetDefaultNtpRequest = TlvObject({\n        /**\n         * This field contains the address of an NTP server than can be used as a fallback for time synchronization.\n         * The format of this field shall follow the requirements in the DefaultNTP attribute description.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.6.1\n         */\n        defaultNtp: TlvField(0, TlvNullable(TlvString.bound({ maxLength: 128 })))\n    });\n\n    /**\n     * Input to the TimeSynchronization setDefaultNtp command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.6\n     */\n    export interface SetDefaultNtpRequest extends TypeFromSchema<typeof TlvSetDefaultNtpRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.6\n     */\n    export const TlvTimeZone = TlvObject({\n        /**\n         * The time zone offset from UTC in seconds.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.6.1\n         */\n        offset: TlvField(0, TlvInt32.bound({ min: -43200, max: 50400 })),\n\n        /**\n         * The UTC time when the offset shall be applied.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.6.2\n         */\n        validAt: TlvField(1, TlvEpochUs),\n\n        /**\n         * The time zone name SHOULD provide a human-readable time zone name and it SHOULD use the country/city format\n         * specified by the IANA Time Zone Database. The Name field may be used for display. If the node supports a\n         * TimeZoneDatabase it may use the Name field to set its own DST offsets if it has database information for the\n         * supplied time zone Name and the given Offset matches.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.6.3\n         */\n        name: TlvOptionalField(2, TlvString.bound({ minLength: 0, maxLength: 64 }))\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.6\n     */\n    export interface TimeZone extends TypeFromSchema<typeof TlvTimeZone> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.7\n     */\n    export const TlvDstOffset = TlvObject({\n        /**\n         * The DST offset in seconds. Normally this is in the range of 0 to 3600 seconds (1 hour), but this field will\n         * accept any values in the int32 range to accommodate potential future legislation that does not fit with\n         * these assumptions.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.7.1\n         */\n        offset: TlvField(0, TlvInt32),\n\n        /**\n         * The UTC time when the offset shall be applied.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.7.2\n         */\n        validStarting: TlvField(1, TlvEpochUs),\n\n        /**\n         * The UTC time when the offset shall stop being applied. Providing a null value here indicates a permanent DST\n         * change. If this value is non-null the value shall be larger than the ValidStarting time.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.7.3\n         */\n        validUntil: TlvField(2, TlvNullable(TlvEpochUs))\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.7\n     */\n    export interface DstOffset extends TypeFromSchema<typeof TlvDstOffset> {}\n\n    /**\n     * It indicates what the device knows about the contents of the IANA Time Zone Database. Partial support on a\n     * device may be used to omit historical data, less commonly used time zones, and/or time zones not related to the\n     * region a product is sold in.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.3\n     */\n    export enum TimeZoneDatabase {\n        /**\n         * Node has a full list of the available time zones\n         */\n        Full = 0,\n\n        /**\n         * Node has a partial list of the available time zones\n         */\n        Partial = 1,\n\n        /**\n         * Node does not have a time zone database\n         */\n        None = 2\n    }\n\n    /**\n     * Input to the TimeSynchronization setTimeZone command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.3\n     */\n    export const TlvSetTimeZoneRequest = TlvObject({\n        timeZone: TlvField(0, TlvArray(TlvTimeZone, { minLength: 1, maxLength: 2 }))\n    });\n\n    /**\n     * Input to the TimeSynchronization setTimeZone command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.3\n     */\n    export interface SetTimeZoneRequest extends TypeFromSchema<typeof TlvSetTimeZoneRequest> {}\n\n    /**\n     * This command shall be generated in response to a SetTimeZone command.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.4\n     */\n    export const TlvSetTimeZoneResponse = TlvObject({\n        /**\n         * If the node supports a time zone database with information for the time zone that will be applied, it\n         *\n         * may use this information to set the DSTOffset attribute. If the node is setting its own DSTOffset attribute,\n         * the DSTOffsetsRequired field shall be set to false, otherwise it shall be set to true.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.4.1\n         */\n        dstOffsetsRequired: TlvField(0, TlvBoolean)\n    });\n\n    /**\n     * This command shall be generated in response to a SetTimeZone command.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.4\n     */\n    export interface SetTimeZoneResponse extends TypeFromSchema<typeof TlvSetTimeZoneResponse> {}\n\n    /**\n     * Input to the TimeSynchronization setDstOffset command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.5\n     */\n    export const TlvSetDstOffsetRequest = TlvObject({ dstOffset: TlvField(0, TlvArray(TlvDstOffset)) });\n\n    /**\n     * Input to the TimeSynchronization setDstOffset command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.5\n     */\n    export interface SetDstOffsetRequest extends TypeFromSchema<typeof TlvSetDstOffsetRequest> {}\n\n    /**\n     * Body of the TimeSynchronization dstStatus event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.2\n     */\n    export const TlvDstStatusEvent = TlvObject({ dstOffsetActive: TlvField(0, TlvBoolean) });\n\n    /**\n     * Body of the TimeSynchronization dstStatus event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.2\n     */\n    export interface DstStatusEvent extends TypeFromSchema<typeof TlvDstStatusEvent> {}\n\n    /**\n     * Body of the TimeSynchronization timeZoneStatus event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.3\n     */\n    export const TlvTimeZoneStatusEvent = TlvObject({\n        /**\n         * Current time zone offset from UTC in seconds.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.3.1\n         */\n        offset: TlvField(0, TlvInt32.bound({ min: -43200, max: 50400 })),\n\n        /**\n         * Current time zone name. This name SHOULD use the country/city format specified by the IANA Time Zone\n         * Database.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.3.2\n         */\n        name: TlvOptionalField(1, TlvString.bound({ minLength: 0, maxLength: 64 }))\n    });\n\n    /**\n     * Body of the TimeSynchronization timeZoneStatus event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.3\n     */\n    export interface TimeZoneStatusEvent extends TypeFromSchema<typeof TlvTimeZoneStatusEvent> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.1\n     */\n    export enum Granularity {\n        /**\n         * This indicates that the node is not currently synchronized with a UTC Time source and its clock is based on\n         * the Last Known Good UTC Time only.\n         */\n        NoTimeGranularity = 0,\n\n        /**\n         * This indicates the node was synchronized to an upstream source in the past, but sufficient clock drift has\n         * occurred such that the clock error is now > 5 seconds.\n         */\n        MinutesGranularity = 1,\n\n        /**\n         * This indicates the node is synchronized to an upstream source using a low resolution protocol. UTC Time is\n         * accurate to \u00B1 5 seconds.\n         */\n        SecondsGranularity = 2,\n\n        /**\n         * This indicates the node is synchronized to an upstream source using high resolution time- synchronization\n         * protocol such as NTP, or has built-in GNSS with some amount of jitter applying its GNSS timestamp. UTC Time\n         * is accurate to \u00B1 50 ms.\n         */\n        MillisecondsGranularity = 3,\n\n        /**\n         * This indicates the node is synchronized to an upstream source using a highly precise time- synchronization\n         * protocol such as PTP, or has built-in GNSS. UTC time is accurate to \u00B1 10 \u03BCs.\n         */\n        MicrosecondsGranularity = 4\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.6.2\n     */\n    export enum TimeSource {\n        /**\n         * Node is not currently synchronized with a UTC Time source.\n         */\n        None = 0,\n\n        /**\n         * Node uses an unlisted time source.\n         */\n        Unknown = 1,\n\n        /**\n         * Node received time from a client using the SetUTCTime Command.\n         */\n        Admin = 2,\n\n        /**\n         * Synchronized time by querying the Time Synchronization cluster of another Node.\n         */\n        NodeTimeCluster = 3,\n\n        /**\n         * SNTP from a server not in the Matter network. NTS is not used.\n         */\n        NonMatterSntp = 4,\n\n        /**\n         * NTP from servers not in the Matter network. None of the servers used NTS.\n         */\n        NonMatterNtp = 5,\n\n        /**\n         * SNTP from a server within the Matter network. NTS is not used.\n         */\n        MatterSntp = 6,\n\n        /**\n         * NTP from servers within the Matter network. None of the servers used NTS.\n         */\n        MatterNtp = 7,\n\n        /**\n         * NTP from multiple servers in the Matter network and external. None of the servers used NTS.\n         */\n        MixedNtp = 8,\n\n        /**\n         * SNTP from a server not in the Matter network. NTS is used.\n         */\n        NonMatterSntpnts = 9,\n\n        /**\n         * NTP from servers not in the Matter network. NTS is used on at least one server.\n         */\n        NonMatterNtpnts = 10,\n\n        /**\n         * SNTP from a server within the Matter network. NTS is used.\n         */\n        MatterSntpnts = 11,\n\n        /**\n         * NTP from a server within the Matter network. NTS is used on at least one server.\n         */\n        MatterNtpnts = 12,\n\n        /**\n         * NTP from multiple servers in the Matter network and external. NTS is used on at least one server.\n         */\n        MixedNtpnts = 13,\n\n        /**\n         * Time synchronization comes from a vendor cloud-based source (e.g. \"Date\" header in authenticated HTTPS\n         * connection).\n         */\n        CloudSource = 14,\n\n        /**\n         * Time synchronization comes from PTP.\n         */\n        Ptp = 15,\n\n        /**\n         * Time synchronization comes from a GNSS source.\n         */\n        Gnss = 16\n    }\n\n    /**\n     * Input to the TimeSynchronization setUtcTime command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1\n     */\n    export const TlvSetUtcTimeRequest = TlvObject({\n        /**\n         * This shall give the Client\u2019s UTC Time.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1.1\n         */\n        utcTime: TlvField(0, TlvEpochUs),\n\n        /**\n         * This shall give the Client\u2019s Granularity, as described in Section 11.17.8.2, \u201CGranularity Attribute\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1.2\n         */\n        granularity: TlvField(1, TlvEnum<Granularity>()),\n\n        /**\n         * This shall give the Client\u2019s TimeSource, as described in Section 11.17.8.3, \u201CTimeSource Attribute\u201D.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1.3\n         */\n        timeSource: TlvOptionalField(2, TlvEnum<TimeSource>())\n    });\n\n    /**\n     * Input to the TimeSynchronization setUtcTime command\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1\n     */\n    export interface SetUtcTimeRequest extends TypeFromSchema<typeof TlvSetUtcTimeRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.7.1\n     */\n    export enum StatusCode {\n        /**\n         * Node rejected the attempt to set the UTC time\n         */\n        TimeNotAccepted = 2\n    }\n\n    /**\n     * A TimeSynchronizationCluster supports these elements if it supports feature TimeSyncClient.\n     */\n    export const TimeSyncClientComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * A Node ID, endpoint, and associated fabric index of a Node that may be used as trusted time source. See\n             * Time source prioritization. This attribute reflects the last value set by an administrator using the\n             * SetTrustedTimeSource command. If the value is null, no trusted time source has yet been set.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.4\n             */\n            trustedTimeSource: Attribute(0x3, TlvNullable(TlvTrustedTimeSource), { persistent: true, default: null })\n        },\n\n        commands: {\n            /**\n             * This command shall set the TrustedTimeSource attribute. Upon receipt of this command, * If the\n             * TrustedTimeSource field in the command is null, the node shall set the TrustedTimeSource attribute to\n             * null and shall generate a MissingTrustedTimeSource event. * Otherwise, the node shall set the\n             * TrustedTimeSource attribute to a struct which has NodeID and Endpoint fields matching those in the\n             * TrustedTimeSource field and has its FabricIndex field set to the command\u2019s accessing fabric index.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.2\n             */\n            setTrustedTimeSource: Command(\n                0x1,\n                TlvSetTrustedTimeSourceRequest,\n                0x1,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        },\n\n        events: {\n            /**\n             * This event shall be generated if the TrustedTimeSource is set to null upon fabric removal or by a\n             * SetTrustedTimeSource command.\n             *\n             * This event shall also be generated if the node has not generated a MissingTrustedTimeSource event in the\n             * last hour, and the node fails to update its time from the TrustedTimeSource because the\n             * TrustedTimeSource is null or the specified peer cannot be reached. MissingTrustedTimeSource events\n             * corresponding to a time update SHOULD NOT be generated more often than once per hour.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.5\n             */\n            missingTrustedTimeSource: Event(0x4, EventPriority.Info, TlvNoArguments)\n        }\n    });\n\n    /**\n     * A TimeSynchronizationCluster supports these elements if it supports feature NtpClient.\n     */\n    export const NtpClientComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * The default NTP server that this Node may use if other time sources are unavailable. This attribute is\n             * settable by an Administrator using the SetDefaultNTP command. It SHOULD be set by the Commissioner\n             * during commissioning. If no default NTP server is available, the Commissioner may set this value to\n             * null. The default IANA assigned NTP port of 123 shall be used to access the NTP server.\n             *\n             * If set, the format of this attribute shall be a domain name or a static IPv6 address with no port, in\n             * text format, as specified in RFC 5952. The address format shall follow the recommendations in Section 4\n             * and shall NOT contain a port number.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.5\n             */\n            defaultNtp: Attribute(\n                0x4,\n                TlvNullable(TlvString.bound({ maxLength: 128 })),\n                { persistent: true, default: null }\n            ),\n\n            /**\n             * This attribute is true if the node supports resolving a domain name. DefaultNTP Address values for these\n             * nodes may include domain names. If this is False, the Address for a DefaultNTP shall be an IPv6 address.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.13\n             */\n            supportsDnsResolve: FixedAttribute(0xc, TlvBoolean, { default: false })\n        },\n\n        commands: {\n            /**\n             * This command is used to set the DefaultNTP attribute. If the DefaultNTP Address field does not conform\n             * to the requirements in the DefaultNTP attribute description, the command shall fail with a status code\n             * of INVALID_COMMAND. If the node does not support DNS resolution (as specified in SupportsDNSResolve) and\n             * the provided Address is a domain name, the command shall fail with a status code of INVALID_COMMAND.\n             * Otherwise, the node shall set the DefaultNTP attribute to match the DefaultNTP provided in this command.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.6\n             */\n            setDefaultNtp: Command(\n                0x5,\n                TlvSetDefaultNtpRequest,\n                0x5,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * A TimeSynchronizationCluster supports these elements if it supports feature TimeZone.\n     */\n    export const TimeZoneComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * A list of time zone offsets from UTC and when they shall take effect. This attribute uses a list of time\n             * offset configurations to allow Nodes to handle scheduled regulatory time zone changes. This attribute\n             * shall NOT be used to indicate daylight savings time changes (see DSTOffset attribute for daylight\n             * savings time).\n             *\n             * The first entry shall have a ValidAt entry of 0. If there is a second entry, it shall have a non-zero\n             *\n             * ValidAt time.\n             *\n             * If a node supports a TimeZoneDatabase, and it has data for the given time zone Name and the given Offset\n             * matches, the node may update its own DSTOffset attribute to add new DST change times as required, based\n             * on the Name fields of the TimeZoneStruct. Administrators may add additional entries to the DSTOffset of\n             * other Nodes with the same time zone, if required.\n             *\n             * If a node does not support a TimeZoneDatabase, the Name field of the TimeZoneStruct is only applicable\n             * for client-side localization. In particular:\n             *\n             *   \u2022 If the node does not support a TimeZoneDatabase, the Name field shall NOT be used to calculate the\n             *     local time.\n             *\n             *   \u2022 If the node does not support a TimeZoneDatabase, the Name field shall NOT be used to calculate DST\n             *     start or end dates.\n             *\n             * When time passes, the node SHOULD remove any entries which are no longer active and change the ValidAt\n             * time for the currently used TimeZoneStruct list item to zero.\n             *\n             * This attribute shall have at least one entry. If the node does not have a default time zone and no time\n             * zone has been set, it may set this value to a list containing a single TimeZoneStruct with an offset of\n             * 0 (UTC) and a ValidAt time of 0.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.6\n             */\n            timeZone: Attribute(\n                0x5,\n                TlvArray(TlvTimeZone, { minLength: 1, maxLength: 2 }),\n                { persistent: true, default: [{ offset: 0, validAt: 0 }] }\n            ),\n\n            /**\n             * A list of offsets to apply for daylight savings time, and their validity period. List entries shall be\n             * sorted by ValidStarting time.\n             *\n             * A list entry shall NOT have a ValidStarting time that is smaller than the ValidUntil time of the\n             * previous entry. There shall be at most one list entry with a null ValidUntil time and, if such an entry\n             * is present, it shall appear last in the list.\n             *\n             * Over time, the node SHOULD remove any entries which are no longer active from the list.\n             *\n             * Over time, if the node supports a TimeZoneDatabase and it has information available for the given time\n             * zone name, it may update its own list to add additional entries.\n             *\n             * If a time zone does not use DST, this shall be indicated by a single entry with a 0 offset and a null\n             * ValidUntil field.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.7\n             */\n            dstOffset: Attribute(0x6, TlvArray(TlvDstOffset), { persistent: true, default: [] }),\n\n            /**\n             * The computed current local time of the node as a epoch-us (Epoch Time in Microseconds). The value of\n             * LocalTime shall be the sum of the UTCTime, the offset of the currently valid TimeZoneStruct from the\n             * TimeZone attribute (converted to microseconds), and the offset of the currently valid DSTOffsetStruct\n             * from the DSTOffset attribute (converted to microseconds), if such an entry exists.\n             *\n             * If the node has not achieved time synchronization, this shall be null. If the node has an empty\n             * DSTOffset, this shall be null.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.8\n             */\n            localTime: Attribute(0x7, TlvNullable(TlvEpochUs), { omitChanges: true, default: null }),\n\n            /**\n             * Indicates whether the node has access to a time zone database. Nodes with a time zone database may\n             * update their own DSTOffset attribute to add new entries and may push DSTOffset updates to other Nodes in\n             * the same time zone as required.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.9\n             */\n            timeZoneDatabase: FixedAttribute(0x8, TlvEnum<TimeZoneDatabase>(), { default: TimeZoneDatabase.None }),\n\n            /**\n             * Number of supported list entries in the TimeZone attribute. This attribute may take the value of 1 or 2,\n             * where the optional second list entry may be used to handle scheduled regulatory time zone changes.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.11\n             */\n            timeZoneListMaxSize: FixedAttribute(0xa, TlvUInt8.bound({ min: 1, max: 2 })),\n\n            /**\n             * Number of supported list entries in DSTOffset attribute. This value must be at least 1.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.12\n             */\n            dstOffsetListMaxSize: FixedAttribute(0xb, TlvUInt8.bound({ min: 1 }))\n        },\n\n        commands: {\n            /**\n             * This command is used to set the time zone of the node.\n             *\n             * If the given list is larger than the TimeZoneListMaxSize, the node shall respond with RESOURCE_EXHAUSTED\n             * and the TimeZone attribute shall NOT be updated.\n             *\n             * If the given list does not conform to the list requirements in TimeZone attribute the node shall respond\n             * with a CONSTRAINT_ERROR and the TimeZone attribute shall NOT be updated.\n             *\n             * If there are no errors in the list, the TimeZone field shall be copied to the TimeZone attribute. A\n             * TimeZoneStatus event shall be generated with the new time zone information.\n             *\n             * If the node supports a time zone database and it has information available for the time zone that will\n             * be applied, it may set its DSTOffset attribute, otherwise the DSTOffset attribute shall be set to an\n             * empty list. A DSTTableEmpty event shall be generated if the DSTOffset attribute is empty. A DSTStatus\n             * event shall be generated if the node was previously applying a DST offset.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.3\n             */\n            setTimeZone: Command(\n                0x2,\n                TlvSetTimeZoneRequest,\n                0x3,\n                TlvSetTimeZoneResponse,\n                { invokeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * This command is used to set the DST offsets for a node.\n             *\n             *   \u2022 If the length of DSTOffset is larger than DSTOffsetListMaxSize, the node shall respond with\n             *     RESOURCE_EXHAUSTED.\n             *\n             *   \u2022 Else if the list entries do not conform to the list requirements for DSTOffset attribute, the node\n             *     shall respond with CONSTRAINT_ERROR.\n             *\n             * If there are no errors in the list, the DSTOffset field shall be copied to the DSTOffset attribute.\n             *\n             * If the DSTOffset attribute change causes a corresponding change to the DST state, a DSTStatus event\n             * shall be generated. If the list is empty, the node shall generate a DSTTableEmpty event.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.5\n             */\n            setDstOffset: Command(0x4, TlvSetDstOffsetRequest, 0x4, TlvNoResponse, { invokeAcl: AccessLevel.Manage })\n        },\n\n        events: {\n            /**\n             * This event shall be generated when the node stops applying the current DSTOffset and there are no\n             * entries in the list with a larger ValidStarting time, indicating the need to possibly get new DST data.\n             * This event shall also be generated if the DSTOffset list is cleared either by a SetTimeZone command, or\n             * by a SetDSTOffset command with an empty list.\n             *\n             * The node shall generate this event if the node has not generated a DSTTableEmpty event in the last hour,\n             * and the DSTOffset list is empty when the node attempts to update its time. DSTTableEmpty events\n             * corresponding to a time update SHOULD NOT be generated more often than once per hour.\n             *\n             * There is no data for this event.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.1\n             */\n            dstTableEmpty: Event(0x0, EventPriority.Info, TlvNoArguments),\n\n            /**\n             * This event shall be generated when the node starts or stops applying a DST offset.\n             *\n             * DSTOffsetActive\n             *\n             * Indicates whether the current DST offset is being applied (i.e, daylight savings time is applied, as\n             * opposed to standard time).\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.2\n             */\n            dstStatus: Event(0x1, EventPriority.Info, TlvDstStatusEvent),\n\n            /**\n             * This event shall be generated when the node changes its time zone offset or name. It shall NOT be sent\n             * for DST changes that are not accompanied by a time zone change.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.3\n             */\n            timeZoneStatus: Event(0x2, EventPriority.Info, TlvTimeZoneStatusEvent)\n        }\n    });\n\n    /**\n     * A TimeSynchronizationCluster supports these elements if it supports feature NtpServer.\n     */\n    export const NtpServerComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * If the node is running an RFC 5905 NTPv4 compliant server on port 123, this value shall be True. If the\n             * node is not currently running an NTP server, this value shall be False.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.10\n             */\n            ntpServerAvailable: Attribute(0x9, TlvBoolean, { default: false })\n        }\n    });\n\n    /**\n     * These elements and properties are present in all TimeSynchronization clusters.\n     */\n    export const Base = MutableCluster.Component({\n        id: 0x38,\n        name: \"TimeSynchronization\",\n        revision: 2,\n\n        features: {\n            /**\n             * TimeZone\n             *\n             * Allows a server to translate a UTC time to a local time using the time zone and daylight savings time\n             * (DST) offsets. If a server supports the TimeZone feature, it shall support the SetTimeZone and\n             * SetDSTOffset commands, and TimeZone and DSTOffset attributes, and shall expose the local time through\n             * the LocalTime attribute.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.1\n             */\n            timeZone: BitFlag(0),\n\n            /**\n             * NtpClient\n             *\n             * Allows a node to use NTP/SNTP for time synchronization.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.2\n             */\n            ntpClient: BitFlag(1),\n\n            /**\n             * NtpServer\n             *\n             * Allows a Node to host an NTP server for the network so that other Nodes can achieve a high accuracy time\n             * synchronization within the network. See Section 11.17.15, \u201CActing as an NTP Server\u201D.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.3\n             */\n            ntpServer: BitFlag(2),\n\n            /**\n             * TimeSyncClient\n             *\n             * This node also supports a time synchronization client and can connect to and read time from other nodes.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.5.4\n             */\n            timeSyncClient: BitFlag(3)\n        },\n\n        attributes: {\n            /**\n             * If the node has achieved time synchronization, this shall indicate the current time as a UTC epoch-us\n             * (Epoch Time in Microseconds).\n             *\n             * If the node has not achieved time synchronization, this shall be null. This attribute may be set when a\n             * SetUTCTime is received.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.1\n             */\n            utcTime: Attribute(0x0, TlvNullable(TlvEpochUs), { omitChanges: true, default: null }),\n\n            /**\n             * The granularity of the error that the node is willing to guarantee on the time synchronization. It is of\n             * type GranularityEnum.\n             *\n             * This value shall be set to NoTimeGranularity if UTCTime is null and shall NOT be set to\n             * NoTimeGranularity if UTCTime is non-null.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.2\n             */\n            granularity: Attribute(0x1, TlvEnum<Granularity>(), { default: Granularity.NoTimeGranularity }),\n\n            /**\n             * The node\u2019s time source. This attribute indicates what method the node is using to sync, whether the\n             * source uses NTS or not and whether the source is internal or external to the Matter network. This\n             * attribute may be used by a client to determine its level of trust in the UTCTime. It is of type\n             * TimeSourceEnum.\n             *\n             * If a node is unsure if the selected NTP server is within the Matter network, it SHOULD select one of the\n             * NonMatter* values.\n             *\n             * This value shall be set to None if UTCTime is null and shall NOT be set to None if UTCTime is non-null.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.8.3\n             */\n            timeSource: OptionalAttribute(0x2, TlvEnum<TimeSource>(), { default: TimeSource.None })\n        },\n\n        commands: {\n            /**\n             * This command may be issued by Administrator to set the time. If the Commissioner does not have a valid\n             * time source, it may send a Granularity of NoTimeGranularity.\n             *\n             * Upon receipt of this command, the node may update its UTCTime attribute to match the time specified in\n             * the command, if the stated Granularity and TimeSource are acceptable. The node shall update its UTCTime\n             * attribute if its current Granularity is NoTimeGranularity.\n             *\n             * If the time is updated, the node shall also update its Granularity attribute based on the granularity\n             * specified in the command and the expected clock drift of the node. This SHOULD normally be one level\n             * lower than the stated command Granularity. It shall also update its TimeSource attribute to Admin. It\n             * shall also update its Last Known Good UTC Time as defined in Section 3.5.6.1, \u201CLast Known Good UTC Time\u201D.\n             *\n             * If the node updates its UTCTime attribute, it shall accept the command with a status code of SUCCESS. If\n             * it opts to not update its time, it shall fail the command with a cluster specific Status Code of\n             * TimeNotAccepted.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.9.1\n             */\n            setUtcTime: Command(0x0, TlvSetUtcTimeRequest, 0x0, TlvNoResponse, { invokeAcl: AccessLevel.Administer })\n        },\n\n        events: {\n            /**\n             * This event shall be generated if the node has not generated a TimeFailure event in the last hour, and\n             * the node is unable to get a time from any source. This event SHOULD NOT be generated more often than\n             * once per hour.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 11.17.10.4\n             */\n            timeFailure: Event(0x3, EventPriority.Info, TlvNoArguments)\n        },\n\n        /**\n         * This metadata controls which TimeSynchronizationCluster elements matter.js activates for specific feature\n         * combinations.\n         */\n        extensions: MutableCluster.Extensions(\n            { flags: { timeSyncClient: true }, component: TimeSyncClientComponent },\n            { flags: { ntpClient: true }, component: NtpClientComponent },\n            { flags: { timeZone: true }, component: TimeZoneComponent },\n            { flags: { ntpServer: true }, component: NtpServerComponent }\n        )\n    });\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster(Base);\n\n    /**\n     * Accurate time is required for a number of reasons, including scheduling, display and validating security\n     * materials.\n     *\n     * This section describes a mechanism for Nodes to achieve and maintain time synchronization. The Time\n     * Synchronization cluster provides attributes for reading a Node\u2019s current time. It also allows Administrators to\n     * set current time, time zone and daylight savings time (DST) settings.\n     *\n     * The Time Synchronization cluster may be present on the root node endpoint, and shall NOT be present on any other\n     * Endpoint of any Node.\n     *\n     * TimeSynchronizationCluster supports optional features that you can enable with the\n     * TimeSynchronizationCluster.with() factory method.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 11.17\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    const TSC = { timeSyncClient: true };\n    const NTPC = { ntpClient: true };\n    const TZ = { timeZone: true };\n    const NTPS = { ntpServer: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster({\n        id: Cluster.id,\n        name: Cluster.name,\n        revision: Cluster.revision,\n        features: Cluster.features,\n\n        attributes: {\n            ...Cluster.attributes,\n            trustedTimeSource: MutableCluster.AsConditional(\n                TimeSyncClientComponent.attributes.trustedTimeSource,\n                { mandatoryIf: [TSC] }\n            ),\n            defaultNtp: MutableCluster.AsConditional(NtpClientComponent.attributes.defaultNtp, { mandatoryIf: [NTPC] }),\n            timeZone: MutableCluster.AsConditional(TimeZoneComponent.attributes.timeZone, { mandatoryIf: [TZ] }),\n            dstOffset: MutableCluster.AsConditional(TimeZoneComponent.attributes.dstOffset, { mandatoryIf: [TZ] }),\n            localTime: MutableCluster.AsConditional(TimeZoneComponent.attributes.localTime, { mandatoryIf: [TZ] }),\n            timeZoneDatabase: MutableCluster.AsConditional(\n                TimeZoneComponent.attributes.timeZoneDatabase,\n                { mandatoryIf: [TZ] }\n            ),\n            ntpServerAvailable: MutableCluster.AsConditional(\n                NtpServerComponent.attributes.ntpServerAvailable,\n                { mandatoryIf: [NTPS] }\n            ),\n            timeZoneListMaxSize: MutableCluster.AsConditional(\n                TimeZoneComponent.attributes.timeZoneListMaxSize,\n                { mandatoryIf: [TZ] }\n            ),\n            dstOffsetListMaxSize: MutableCluster.AsConditional(\n                TimeZoneComponent.attributes.dstOffsetListMaxSize,\n                { mandatoryIf: [TZ] }\n            ),\n            supportsDnsResolve: MutableCluster.AsConditional(\n                NtpClientComponent.attributes.supportsDnsResolve,\n                { mandatoryIf: [NTPC] }\n            )\n        },\n\n        commands: {\n            ...Cluster.commands,\n            setTrustedTimeSource: MutableCluster.AsConditional(\n                TimeSyncClientComponent.commands.setTrustedTimeSource,\n                { mandatoryIf: [TSC] }\n            ),\n            setTimeZone: MutableCluster.AsConditional(TimeZoneComponent.commands.setTimeZone, { mandatoryIf: [TZ] }),\n            setDstOffset: MutableCluster.AsConditional(TimeZoneComponent.commands.setDstOffset, { mandatoryIf: [TZ] }),\n            setDefaultNtp: MutableCluster.AsConditional(\n                NtpClientComponent.commands.setDefaultNtp,\n                { mandatoryIf: [NTPC] }\n            )\n        },\n\n        events: {\n            ...Cluster.events,\n            dstTableEmpty: MutableCluster.AsConditional(TimeZoneComponent.events.dstTableEmpty, { mandatoryIf: [TZ] }),\n            dstStatus: MutableCluster.AsConditional(TimeZoneComponent.events.dstStatus, { mandatoryIf: [TZ] }),\n            timeZoneStatus: MutableCluster.AsConditional(\n                TimeZoneComponent.events.timeZoneStatus,\n                { mandatoryIf: [TZ] }\n            ),\n            missingTrustedTimeSource: MutableCluster.AsConditional(\n                TimeSyncClientComponent.events.missingTrustedTimeSource,\n                { mandatoryIf: [TSC] }\n            )\n        }\n    });\n\n    /**\n     * This cluster supports all TimeSynchronization features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n\nexport type TimeSynchronizationCluster = TimeSynchronization.Cluster;\nexport const TimeSynchronizationCluster = TimeSynchronization.Cluster;\nClusterRegistry.register(TimeSynchronization.Complete);\n"],
  "mappings": "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",
  "names": ["TimeSynchronization", "Feature", "TimeZoneDatabase", "Granularity", "TimeSource", "StatusCode"]
}
