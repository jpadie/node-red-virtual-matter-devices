/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterController } from "./MatterController.js";
import { ImplementationError } from "./common/MatterError.js";
import { MdnsService } from "./environment/MdnsService.js";
import { Logger } from "./log/Logger.js";
import { Network } from "./net/Network.js";
import { UdpInterface } from "./net/UdpInterface.js";
import { ControllerDiscovery } from "./protocol/ControllerDiscovery.js";
const logger = new Logger("PaseCommissioner");
class PaseCommissioner {
  /**
   * Creates a new CommissioningController instance
   *
   * @param options The options for the CommissioningController
   */
  constructor(options) {
    this.options = options;
    if (options.environment === void 0) {
      throw new ImplementationError("You need to prove an environment for the commissioner.");
    }
    const { environment } = options.environment;
    this.environment = environment;
  }
  environment;
  controllerInstance;
  get nodeId() {
    return this.controllerInstance?.nodeId;
  }
  assertControllerIsStarted(errorText) {
    if (this.controllerInstance === void 0) {
      throw new ImplementationError(
        errorText ?? "Controller instance not yet started. Please call start() first."
      );
    }
    return this.controllerInstance;
  }
  /** Internal method to initialize a MatterController instance. */
  async initializeController() {
    if (this.controllerInstance !== void 0) {
      return this.controllerInstance;
    }
    const { localPort, listeningAddressIpv4, listeningAddressIpv6, rootCertificateData, fabricData } = this.options;
    let mdnsScanner;
    let ipv4Disabled = false;
    let netInterfaceIpv4;
    let netInterfaceIpv6;
    try {
      const mdnsService = await this.environment.load(MdnsService);
      ipv4Disabled = !mdnsService.enableIpv4;
      mdnsScanner = mdnsService.scanner;
      if (!ipv4Disabled) {
        netInterfaceIpv4 = await UdpInterface.create(Network.get(), "udp4", localPort, listeningAddressIpv4);
      }
      netInterfaceIpv6 = await UdpInterface.create(Network.get(), "udp6", localPort, listeningAddressIpv6);
    } catch {
      logger.debug("No networking available, using only BLE");
    }
    return await MatterController.createAsPaseCommissioner({
      rootCertificateData,
      fabricData,
      netInterfaceIpv4,
      netInterfaceIpv6,
      mdnsScanner
    });
  }
  /**
   * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned node.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commissionNode(nodeOptions, completeCommissioningCallback) {
    const controller = this.assertControllerIsStarted();
    return await controller.commission(nodeOptions, completeCommissioningCallback);
  }
  /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */
  async close() {
    await this.controllerInstance?.close();
    this.controllerInstance = void 0;
  }
  /** Initialize the controller. */
  async start() {
    const runtime = this.environment.runtime;
    runtime.add(this);
    if (this.controllerInstance === void 0) {
      this.controllerInstance = await this.initializeController();
    }
  }
  cancelCommissionableDeviceDiscovery(identifierData, discoveryCapabilities) {
    const controller = this.assertControllerIsStarted();
    controller.collectScanners(discoveryCapabilities).forEach(
      (scanner) => ControllerDiscovery.cancelCommissionableDeviceDiscovery(scanner, identifierData)
    );
  }
  async discoverCommissionableDevices(identifierData, discoveryCapabilities, discoveredCallback, timeoutSeconds = 900) {
    const controller = this.assertControllerIsStarted();
    return await ControllerDiscovery.discoverCommissionableDevices(
      controller.collectScanners(discoveryCapabilities),
      timeoutSeconds,
      identifierData,
      discoveredCallback
    );
  }
}
export {
  PaseCommissioner
};
//# sourceMappingURL=PaseCommissioner.js.map
