{
  "version": 3,
  "sources": ["../../src/MatterDevice.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Important note: This file is part of the legacy matter-node (internal) API and should not be used anymore directly!\n * Please use the new API classes!\n * @deprecated\n */\n\nimport {\n    DEVICE_ANNOUNCEMENT_DURATION_MS,\n    DEVICE_ANNOUNCEMENT_INTERVAL_MS,\n} from \"./behavior/definitions/administrator-commissioning/AdministratorCommissioningConstants.js\";\nimport { CommissioningOptions } from \"./behavior/system/commissioning/CommissioningOptions.js\";\nimport { AdministratorCommissioning } from \"./cluster/definitions/AdministratorCommissioningCluster.js\";\n\nimport { Channel } from \"./common/Channel.js\";\nimport { FailsafeContext } from \"./common/FailsafeContext.js\";\nimport { InstanceBroadcaster } from \"./common/InstanceBroadcaster.js\";\nimport { Lifecycle } from \"./common/Lifecycle.js\";\nimport { InternalError, MatterFlowError } from \"./common/MatterError.js\";\nimport { Scanner } from \"./common/Scanner.js\";\nimport { TransportInterface } from \"./common/TransportInterface.js\";\nimport { Crypto } from \"./crypto/Crypto.js\";\nimport { FabricIndex } from \"./datatype/FabricIndex.js\";\nimport { NodeId } from \"./datatype/NodeId.js\";\nimport { Fabric } from \"./fabric/Fabric.js\";\nimport { FabricAction, FabricManager } from \"./fabric/FabricManager.js\";\nimport { Diagnostic } from \"./log/Diagnostic.js\";\nimport { Logger } from \"./log/Logger.js\";\nimport { Specification } from \"./model/index.js\";\nimport { NetInterface, isNetworkInterface } from \"./net/NetInterface.js\";\nimport { NetworkError } from \"./net/Network.js\";\nimport { ChannelManager } from \"./protocol/ChannelManager.js\";\nimport { ExchangeManager } from \"./protocol/ExchangeManager.js\";\nimport { ProtocolHandler } from \"./protocol/ProtocolHandler.js\";\nimport { DEFAULT_MAX_PATHS_PER_INVOKE } from \"./protocol/interaction/InteractionServer.js\";\nimport { StatusCode, StatusResponseError } from \"./protocol/interaction/StatusCode.js\";\nimport { SecureChannelProtocol } from \"./protocol/securechannel/SecureChannelProtocol.js\";\nimport {\n    SESSION_ACTIVE_INTERVAL_MS,\n    SESSION_ACTIVE_THRESHOLD_MS,\n    SESSION_IDLE_INTERVAL_MS,\n    Session,\n    SessionParameters,\n} from \"./session/Session.js\";\nimport { ResumptionRecord, SessionManager } from \"./session/SessionManager.js\";\nimport { PaseServer } from \"./session/pase/PaseServer.js\";\nimport { StorageContext } from \"./storage/StorageContext.js\";\nimport { Time, Timer } from \"./time/Time.js\";\nimport { ByteArray } from \"./util/ByteArray.js\";\nimport { Construction, asyncNew } from \"./util/Construction.js\";\nimport { Mutex } from \"./util/Mutex.js\";\n\nconst logger = Logger.get(\"MatterDevice\");\n\nexport class MatterDevice {\n    private readonly scanners = new Array<Scanner>();\n    private readonly broadcasters = new Array<InstanceBroadcaster>();\n    private readonly transportInterfaces = new Array<TransportInterface | NetInterface>();\n    private readonly channelManager: ChannelManager;\n    private readonly secureChannelProtocol = new SecureChannelProtocol(() => this.endCommissioning());\n    private activeCommissioningMode = AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;\n    private activeCommissioningDiscriminator?: number;\n    private activeCommissioningEndCallback?: () => void;\n    private announceInterval: Timer;\n    private announcementStartedTime: number | null = null;\n    #isClosing = false;\n    readonly #exchangeManager;\n    readonly #fabricManager: FabricManager;\n    readonly #sessionManager: SessionManager<MatterDevice>;\n    #failsafeContext?: FailsafeContext;\n    readonly sessionParameters: SessionParameters;\n\n    // Currently we do not put much effort into synchronizing announcements as it probably isn't really necessary.  But\n    // this mutex prevents automated announcements from piling up and allows us to ensure announcements are complete\n    // on close\n    #announcementMutex = new Mutex(this);\n    #construction: Construction<MatterDevice>;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    static async create(\n        sessionStorage: StorageContext,\n        fabricStorage: StorageContext,\n        getCommissioningConfig: () => CommissioningOptions.Configuration,\n        minimumCaseSessionsPerFabricAndNode = 3,\n        commissioningChangedCallback: (fabricIndex: FabricIndex, fabricAction: FabricAction) => void,\n        sessionChangedCallback: (fabricIndex: FabricIndex) => void,\n        sessionParameters?: Partial<SessionParameters>,\n    ) {\n        return asyncNew(\n            MatterDevice,\n            sessionStorage,\n            fabricStorage,\n            getCommissioningConfig,\n            minimumCaseSessionsPerFabricAndNode,\n            commissioningChangedCallback,\n            sessionChangedCallback,\n            sessionParameters,\n        );\n    }\n\n    constructor(\n        readonly sessionStorage: StorageContext,\n        readonly fabricStorage: StorageContext,\n        private readonly getCommissioningConfig: () => CommissioningOptions.Configuration,\n        minimumCaseSessionsPerFabricAndNode: number,\n        private readonly commissioningChangedCallback: (fabricIndex: FabricIndex, fabricAction: FabricAction) => void,\n        private readonly sessionChangedCallback: (fabricIndex: FabricIndex) => void,\n        sessionParameters: Partial<SessionParameters> = {},\n    ) {\n        // We use defaults and allow overriding them\n        this.sessionParameters = {\n            idleIntervalMs: SESSION_IDLE_INTERVAL_MS,\n            activeIntervalMs: SESSION_ACTIVE_INTERVAL_MS,\n            activeThresholdMs: SESSION_ACTIVE_THRESHOLD_MS,\n            dataModelRevision: Specification.DATA_MODEL_REVISION,\n            interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,\n            specificationVersion: Specification.SPECIFICATION_VERSION,\n            maxPathsPerInvoke: DEFAULT_MAX_PATHS_PER_INVOKE,\n            ...sessionParameters,\n        };\n\n        this.channelManager = new ChannelManager(minimumCaseSessionsPerFabricAndNode);\n\n        this.#fabricManager = new FabricManager(fabricStorage);\n\n        this.#fabricManager.events.deleted.on(async fabric => {\n            const { fabricIndex, rootNodeId } = fabric;\n            // When fabric is removed, also remove the resumption record\n            await this.#sessionManager.removeResumptionRecord(rootNodeId);\n            this.commissioningChangedCallback(fabricIndex, FabricAction.Removed);\n            if (this.#fabricManager.getFabrics().length === 0) {\n                // Last fabric got removed, so expire all announcements\n                await this.expireAllFabricAnnouncements();\n            }\n            // If a commissioning window is open then we reannounce this because it was ended as fabric got added\n            this.reAnnounceAsCommissionable();\n        });\n        this.#fabricManager.events.updated.on(({ fabricIndex }) =>\n            this.commissioningChangedCallback(fabricIndex, FabricAction.Updated),\n        );\n\n        this.#sessionManager = new SessionManager(this, sessionStorage);\n\n        this.#exchangeManager = new ExchangeManager<MatterDevice>(this.#sessionManager, this.channelManager);\n\n        this.addProtocolHandler(this.secureChannelProtocol);\n\n        this.announceInterval = Time.getPeriodicTimer(\"Server node announcement\", DEVICE_ANNOUNCEMENT_INTERVAL_MS, () =>\n            // Announcement needs to await a previous announcement because otherwise in testing at least announcement\n            // may crash if started simultaneously\n            this.#announcementMutex.run(() => this.announce()),\n        );\n\n        this.#sessionManager.sessionOpened.on(session => {\n            if (session.fabric) {\n                this.sessionChangedCallback(session.fabric.fabricIndex);\n            }\n        });\n\n        this.#sessionManager.sessionClosed.on(async session => {\n            if (!session.closingAfterExchangeFinished) {\n                // Delayed closing is executed when exchange is closed\n                await this.exchangeManager.closeSession(session);\n            }\n\n            const currentFabricIndex = session.fabric?.fabricIndex;\n            if (currentFabricIndex !== undefined) {\n                this.sessionChangedCallback(currentFabricIndex);\n            }\n\n            if (this.isClosing) {\n                return;\n            }\n\n            // Verify if the session associated fabric still exists\n            const existingSessionFabric =\n                currentFabricIndex === undefined ? undefined : this.getFabricByIndex(currentFabricIndex)?.fabricIndex;\n\n            // When a session closes, announce existing fabrics again so that controller can detect the device again.\n            // When session was closed and no fabric exist anymore then this is triggering a factory reset in upper layer\n            // and it would be not good to announce a commissionable device and then reset that again with the factory reset\n            if (this.#fabricManager.getFabrics().length > 0 || session.isPase || !existingSessionFabric) {\n                this.startAnnouncement().catch(error => logger.warn(`Error while announcing`, error));\n            }\n        });\n\n        this.#sessionManager.subscriptionsChanged.on(session => {\n            const currentFabric = session.fabric;\n            if (currentFabric !== undefined) {\n                this.sessionChangedCallback(currentFabric.fabricIndex);\n            }\n        });\n\n        this.#construction = Construction(this, async () => {\n            await this.#fabricManager.initFromStorage();\n\n            // Attach added events delayed because initialization from storage would else trigger it\n            this.#fabricManager.events.added.on(({ fabricIndex }) =>\n                this.commissioningChangedCallback(fabricIndex, FabricAction.Added),\n            );\n\n            await this.#sessionManager.initFromStorage(this.#fabricManager.getFabrics());\n        });\n    }\n\n    get fabricManager() {\n        return this.#fabricManager;\n    }\n\n    get sessionManager() {\n        return this.#sessionManager;\n    }\n\n    get exchangeManager() {\n        return this.#exchangeManager;\n    }\n\n    get failsafeContext() {\n        this.assertFailSafeArmed();\n        return this.#failsafeContext as FailsafeContext;\n    }\n\n    get isClosing() {\n        return this.#isClosing;\n    }\n\n    async beginTimed(failsafeContext: FailsafeContext) {\n        await failsafeContext.construction;\n\n        this.#failsafeContext = failsafeContext;\n\n        this.#fabricManager.events.added.on(fabric => {\n            const fabrics = this.#fabricManager.getFabrics();\n            this.sendFabricAnnouncements(fabrics, true).catch(error =>\n                logger.warn(`Error sending Fabric announcement for Index ${fabric.fabricIndex}`, error),\n            );\n            logger.info(\"Announce done\", Diagnostic.dict({ fabric: fabric.fabricId, fabricIndex: fabric.fabricIndex }));\n        });\n\n        failsafeContext.commissioned.on(async () => await this.endCommissioning());\n\n        failsafeContext.construction.change.on(status => {\n            if (status === Lifecycle.Status.Destroyed) {\n                this.#failsafeContext = undefined;\n            }\n        });\n    }\n\n    assertFailSafeArmed(message?: string) {\n        if (this.isFailsafeArmed()) return;\n        throw new StatusResponseError(\n            message ?? \"Failsafe timer needs to be armed to execute this action.\",\n            StatusCode.FailsafeRequired,\n        );\n    }\n\n    isFailsafeArmed() {\n        return this.#failsafeContext !== undefined;\n    }\n\n    addScanner(scanner: Scanner) {\n        this.scanners.push(scanner);\n        return this;\n    }\n\n    hasBroadcaster(broadcaster: InstanceBroadcaster) {\n        return this.broadcasters.includes(broadcaster);\n    }\n\n    addBroadcaster(broadcaster: InstanceBroadcaster) {\n        this.broadcasters.push(broadcaster);\n        return this;\n    }\n\n    async deleteBroadcaster(broadcaster: InstanceBroadcaster) {\n        const pos = this.broadcasters.findIndex(b => b === broadcaster);\n        if (pos !== -1) {\n            this.broadcasters.splice(pos, 1);\n            await broadcaster.expireAllAnnouncements();\n        }\n    }\n\n    addTransportInterface(transport: TransportInterface) {\n        this.exchangeManager.addTransportInterface(transport);\n        this.transportInterfaces.push(transport);\n        return this;\n    }\n\n    async deleteTransportInterface(transport: TransportInterface) {\n        const pos = this.transportInterfaces.findIndex(t => t === transport);\n        if (pos !== -1) {\n            this.transportInterfaces.splice(pos, 1);\n            await transport.close();\n        }\n    }\n\n    hasProtocolHandler(protocolId: number) {\n        return this.exchangeManager.hasProtocolHandler(protocolId);\n    }\n\n    addProtocolHandler(protocol: ProtocolHandler<MatterDevice>) {\n        this.exchangeManager.addProtocolHandler(protocol);\n        return this;\n    }\n\n    async start() {\n        await this.startAnnouncement();\n    }\n\n    async startAnnouncement() {\n        if (this.isClosing) return;\n        if (this.announceInterval.isRunning) {\n            this.announceInterval.stop();\n        }\n        this.announcementStartedTime = Time.nowMs();\n        this.announceInterval.start();\n        await this.announce();\n    }\n\n    async expireAllFabricAnnouncements() {\n        for (const broadcaster of this.broadcasters) {\n            await broadcaster.expireFabricAnnouncement();\n        }\n    }\n\n    async announce(announceOnce = false) {\n        if (!announceOnce) {\n            // Stop announcement if duration is reached\n            if (\n                this.announcementStartedTime !== null &&\n                Time.nowMs() - this.announcementStartedTime > DEVICE_ANNOUNCEMENT_DURATION_MS\n            ) {\n                await this.endCommissioning();\n                logger.debug(\"Announcement duration reached, stop announcing\");\n                return;\n            }\n            if (this.activeCommissioningMode !== AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {\n                // Re-Announce but do not re-set Fabrics\n                for (const broadcaster of this.broadcasters) {\n                    await broadcaster.announce();\n                }\n                return;\n            }\n        }\n        const fabrics = this.#fabricManager.getFabrics();\n        if (fabrics.length) {\n            let fabricsWithoutSessions = 0;\n            for (const fabric of fabrics) {\n                const session = this.#sessionManager.getSessionForNode(fabric, fabric.rootNodeId);\n                if (session === undefined || !session.isSecure || session.numberOfActiveSubscriptions === 0) {\n                    fabricsWithoutSessions++;\n                    logger.debug(\"Announcing\", Diagnostic.dict({ fabric: fabric.fabricId }));\n                }\n            }\n            for (const broadcaster of this.broadcasters) {\n                await broadcaster.setFabrics(fabrics);\n                if (\n                    fabricsWithoutSessions > 0 ||\n                    this.activeCommissioningMode !== AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen\n                ) {\n                    await broadcaster.announce();\n                }\n            }\n        } else {\n            // No fabric paired yet, so announce as \"ready for commissioning\"\n            // And expire operational Fabric announcements (if fabric got just deleted)\n            await this.expireAllFabricAnnouncements();\n            await this.allowBasicCommissioning();\n        }\n    }\n\n    private async announceAsCommissionable(\n        mode: AdministratorCommissioning.CommissioningWindowStatus,\n        activeCommissioningEndCallback?: () => void,\n        discriminator?: number,\n    ) {\n        if (\n            this.activeCommissioningMode === mode &&\n            (discriminator === undefined || discriminator === this.activeCommissioningDiscriminator)\n        ) {\n            // We want to re-announce\n            return this.reAnnounceAsCommissionable();\n        }\n        if (this.activeCommissioningMode !== AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {\n            throw new InternalError(\n                `Commissioning window already open with different mode (${this.activeCommissioningMode})!`,\n            );\n        }\n        if (this.activeCommissioningEndCallback !== undefined) {\n            throw new InternalError(\"Commissioning window already open with different callback!\");\n        }\n        this.activeCommissioningMode = mode;\n        this.activeCommissioningDiscriminator = discriminator;\n        if (activeCommissioningEndCallback !== undefined) {\n            this.activeCommissioningEndCallback = activeCommissioningEndCallback;\n        }\n        // MDNS is sent in parallel\n        // TODO - untracked promise\n        this.sendCommissionableAnnouncement(mode, discriminator).catch(error =>\n            logger.warn(\"Error sending announcement:\", error),\n        );\n    }\n\n    reAnnounceAsCommissionable() {\n        if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {\n            return;\n        }\n        this.sendCommissionableAnnouncement(this.activeCommissioningMode, this.activeCommissioningDiscriminator).catch(\n            error => logger.warn(\"Error sending announcement:\", error),\n        );\n    }\n\n    async sendCommissionableAnnouncement(\n        mode: AdministratorCommissioning.CommissioningWindowStatus,\n        discriminator?: number,\n    ) {\n        const commissioningConfig = this.getCommissioningConfig();\n        for (const broadcaster of this.broadcasters) {\n            await broadcaster.setCommissionMode(\n                mode === AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen ? 2 : 1,\n                {\n                    ...commissioningConfig.productDescription,\n                    discriminator: discriminator ?? commissioningConfig.discriminator,\n                },\n            );\n        }\n        await this.startAnnouncement();\n    }\n\n    async getNextAvailableSessionId() {\n        return this.#sessionManager.getNextAvailableSessionId();\n    }\n\n    findFabricFromDestinationId(destinationId: ByteArray, peerRandom: ByteArray) {\n        return this.#fabricManager.findFabricFromDestinationId(destinationId, peerRandom);\n    }\n\n    async sendFabricAnnouncements(fabrics: Fabric[], expireCommissioningAnnouncement = false) {\n        for (const broadcaster of this.broadcasters) {\n            await broadcaster.setFabrics(fabrics, expireCommissioningAnnouncement);\n            await broadcaster.announce();\n        }\n    }\n\n    getFabricByIndex(fabricIndex: FabricIndex) {\n        return this.#fabricManager.getFabrics().find(fabric => fabric.fabricIndex === fabricIndex);\n    }\n\n    initiateExchange(fabric: Fabric, nodeId: NodeId, protocolId: number) {\n        return this.exchangeManager.initiateExchange(fabric, nodeId, protocolId);\n    }\n\n    findResumptionRecordById(resumptionId: ByteArray) {\n        return this.#sessionManager.findResumptionRecordById(resumptionId);\n    }\n\n    async saveResumptionRecord(resumptionRecord: ResumptionRecord) {\n        return this.#sessionManager.saveResumptionRecord(resumptionRecord);\n    }\n\n    getFabrics() {\n        return this.#fabricManager.getFabrics();\n    }\n\n    isCommissioned() {\n        return !!this.#fabricManager.getFabrics().length;\n    }\n\n    async allowEnhancedCommissioning(\n        discriminator: number,\n        paseServer: PaseServer,\n        commissioningEndCallback: () => void,\n    ) {\n        if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen) {\n            throw new MatterFlowError(\n                \"Basic commissioning window is already open! Cannot set Enhanced commissioning mode.\",\n            );\n        }\n\n        this.secureChannelProtocol.setPaseCommissioner(paseServer);\n        await this.announceAsCommissionable(\n            AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen,\n            commissioningEndCallback,\n            discriminator,\n        );\n    }\n\n    async allowBasicCommissioning(commissioningEndCallback?: () => void) {\n        if (this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen) {\n            throw new MatterFlowError(\n                \"Enhanced commissioning window is already open! Cannot set Basic commissioning mode.\",\n            );\n        }\n\n        this.secureChannelProtocol.setPaseCommissioner(\n            await PaseServer.fromPin(this.getCommissioningConfig().passcode, {\n                iterations: 1000,\n                salt: Crypto.get().getRandomData(32),\n            }),\n        );\n\n        await this.announceAsCommissionable(\n            AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen,\n            commissioningEndCallback,\n        );\n    }\n\n    async endCommissioning() {\n        logger.debug(\"Commissioning mode ended, stop announcements.\");\n        // Remove PASE responder when we close enhanced commissioning window or node is commissioned\n        if (\n            this.activeCommissioningMode === AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen ||\n            this.isCommissioned()\n        ) {\n            this.secureChannelProtocol.removePaseCommissioner();\n        }\n        this.activeCommissioningMode = AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;\n        this.announceInterval.stop();\n        this.announcementStartedTime = null;\n        if (this.activeCommissioningEndCallback !== undefined) {\n            const activeCommissioningEndCallback = this.activeCommissioningEndCallback;\n            this.activeCommissioningEndCallback = undefined;\n            activeCommissioningEndCallback();\n        }\n        for (const broadcaster of this.broadcasters) {\n            await broadcaster.expireCommissioningAnnouncement();\n        }\n        logger.info(\"All announcements expired\");\n    }\n\n    existsOpenPaseSession() {\n        return !!this.#sessionManager.getPaseSession();\n    }\n\n    async findDevice(\n        fabric: Fabric,\n        nodeId: NodeId,\n        timeOutSeconds = 5,\n    ): Promise<undefined | { session: Session<MatterDevice>; channel: Channel<ByteArray> }> {\n        // TODO: return the first not undefined answer or undefined\n        const device = await this.scanners[0].findOperationalDevice(fabric, nodeId, timeOutSeconds);\n        if (device === undefined) return undefined;\n        const session = this.#sessionManager.getSessionForNode(fabric, nodeId);\n        if (session === undefined) return undefined;\n        // TODO: have the interface and scanner linked\n        const networkInterface = this.transportInterfaces.find(netInterface => isNetworkInterface(netInterface));\n        if (networkInterface === undefined || !isNetworkInterface(networkInterface)) {\n            throw new NetworkError(\"No network interface found\");\n        } // TODO meeehhh\n        return { session, channel: await networkInterface.openChannel(device.addresses[0]) };\n    }\n\n    async clearSubscriptionsForNode(fabricIndex: FabricIndex, peerNodeId: NodeId, flushSubscriptions?: boolean) {\n        await this.#sessionManager.clearSubscriptionsForNode(fabricIndex, peerNodeId, flushSubscriptions);\n    }\n\n    async close() {\n        this.#isClosing = true;\n        await this.endCommissioning();\n        await this.#announcementMutex;\n        for (const broadcaster of this.broadcasters) {\n            await broadcaster.close();\n        }\n        if (this.#failsafeContext) {\n            await this.#failsafeContext.close();\n            this.#failsafeContext = undefined;\n        }\n        await this.exchangeManager.close();\n        await this.#sessionManager.close();\n        await this.channelManager.close();\n        for (const transportInterface of this.transportInterfaces) {\n            await transportInterface.close();\n        }\n    }\n\n    getActiveSessionInformation() {\n        return this.#sessionManager.getActiveSessionInformation();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
