{
  "version": 3,
  "sources": ["../../../src/endpoint/EndpointServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Behavior } from \"../behavior/Behavior.js\";\nimport { ClusterBehavior } from \"../behavior/cluster/ClusterBehavior.js\";\nimport { BehaviorBacking } from \"../behavior/internal/BehaviorBacking.js\";\nimport { ClusterServerBacking } from \"../behavior/internal/ClusterServerBacking.js\";\nimport { ServerBehaviorBacking } from \"../behavior/internal/ServerBacking.js\";\nimport { ClusterType } from \"../cluster/ClusterType.js\";\nimport { ClusterClientObj } from \"../cluster/client/ClusterClientTypes.js\";\nimport { ClusterServer } from \"../cluster/server/ClusterServer.js\";\nimport { ImplementationError, InternalError, NotImplementedError } from \"../common/MatterError.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { Endpoint } from \"./Endpoint.js\";\nimport { EndpointInterface } from \"./EndpointInterface.js\";\n\nconst SERVER = Symbol(\"server\");\ninterface ServerPart extends Endpoint {\n    [SERVER]?: EndpointServer;\n}\n\n/**\n * EndpointServer makes an {@link Endpoint} available for remote access as an Endpoint on a Matter network.\n */\nexport class EndpointServer implements EndpointInterface {\n    #endpoint: Endpoint;\n    #name = \"\";\n    readonly #clusterServers = new Map<ClusterId, ClusterServer>();\n\n    get endpoint() {\n        return this.#endpoint;\n    }\n\n    get deviceType() {\n        return this.#endpoint.type.deviceType;\n    }\n\n    constructor(endpoint: Endpoint) {\n        (endpoint as ServerPart)[SERVER] = this;\n        this.#endpoint = endpoint;\n        this.#name = endpoint.type.name;\n    }\n\n    createBacking(type: Behavior.Type): BehaviorBacking {\n        let backing: BehaviorBacking;\n        if (type.prototype instanceof ClusterBehavior) {\n            const cluster = (type as ClusterBehavior.Type).cluster;\n\n            // Sanity check\n            if (this.#clusterServers.has(cluster.id)) {\n                throw new InternalError(`${this.#endpoint}.${cluster.id} initialized multiple times`);\n            }\n\n            backing = new ClusterServerBacking(this, type as ClusterBehavior.Type);\n        } else {\n            backing = new ServerBehaviorBacking(this.#endpoint, type);\n        }\n        return backing;\n    }\n\n    get number() {\n        return this.#endpoint.number;\n    }\n\n    get name() {\n        return this.#name;\n    }\n\n    getNumber(): EndpointNumber {\n        if (this.number === undefined) {\n            throw new InternalError(\"Endpoint ID has not been assigned yet\");\n        }\n        return this.number;\n    }\n\n    removeFromStructure(): void {\n        // Unused\n    }\n\n    updatePartsList(): EndpointNumber[] {\n        // We don't use this\n        return [];\n    }\n\n    getChildEndpoints(): EndpointInterface[] {\n        if (this.#endpoint.hasParts) {\n            const parts = this.#endpoint.parts;\n            return [...parts].map(endpoint => EndpointServer.forEndpoint(endpoint));\n        }\n        return [];\n    }\n\n    determineUniqueID(): string | undefined {\n        return this.#endpoint.id;\n    }\n\n    verifyRequiredClusters(): void {\n        this.#endpoint.behaviors.validateRequirements(this.#endpoint.type.requirements.server?.mandatory);\n    }\n\n    close(): void {\n        // This is in EndpointInterface but we handle destruction asynchronously so just ignore\n    }\n\n    async [Symbol.asyncDispose]() {\n        // I believe the cluster servers are effectively disposed when the structure is emptied\n        this.#clusterServers.clear();\n        delete (this.#endpoint as ServerPart)[SERVER];\n        for (const endpoint of this.#endpoint.parts) {\n            const server = (endpoint as ServerPart)[SERVER];\n            if (server) {\n                await server[Symbol.asyncDispose]();\n            }\n        }\n    }\n\n    setStructureChangedCallback(): void {\n        // Unused, should move out of EndpointInterface\n    }\n\n    addClusterServer<const T extends ClusterType>(server: ClusterServer<T>): void {\n        this.#clusterServers.set(server.id, server);\n    }\n\n    hasClusterServer(cluster: ClusterType): boolean {\n        return this.#clusterServers.has(cluster.id);\n    }\n\n    getClusterServer<const T extends ClusterType>(cluster: T): ClusterServer<T> | undefined {\n        const server = this.#clusterServers.get(cluster.id);\n        if (server !== undefined) {\n            return server as ClusterServer<T>;\n        }\n    }\n\n    getClusterServerById(clusterId: ClusterId): ClusterServer | undefined {\n        return this.#clusterServers.get(clusterId);\n    }\n\n    getAllClusterServers(): ClusterServer[] {\n        return [...this.#clusterServers.values()];\n    }\n\n    getAllClusterClients(): ClusterClientObj[] {\n        // TODO -- no binding support yet (or client behaviors)\n        return [];\n    }\n\n    addClusterClient(): void {\n        throw new NotImplementedError(\"Cluster clients unavailable on EndpointServer\");\n    }\n\n    getClusterClient(): any {\n        throw new NotImplementedError(\"Cluster clients unavailable on EndpointServer\");\n    }\n\n    addChildEndpoint(endpoint: EndpointInterface): void {\n        if (endpoint instanceof EndpointServer) {\n            this.#endpoint.parts.add(endpoint.#endpoint);\n        } else {\n            throw new ImplementationError(\"Attempt to add unmanaged endpoint as child of Endpoint\");\n        }\n    }\n\n    getChildEndpoint(id: EndpointNumber): EndpointInterface | undefined {\n        if (!this.#endpoint.hasParts) {\n            return;\n        }\n        for (const endpoint of this.#endpoint.parts) {\n            if (endpoint.number === id) {\n                return EndpointServer.forEndpoint(endpoint);\n            }\n        }\n    }\n\n    /**\n     * Retrieve the server for an endpoint.\n     */\n    static forEndpoint(endpoint: Endpoint) {\n        let server = (endpoint as ServerPart)[SERVER];\n        if (!server) {\n            server = (endpoint as ServerPart)[SERVER] = new EndpointServer(endpoint);\n        }\n        return server;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
