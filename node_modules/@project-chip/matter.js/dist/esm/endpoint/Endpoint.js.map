{
  "version": 3,
  "sources": ["../../../src/endpoint/Endpoint.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Behavior } from \"../behavior/Behavior.js\";\nimport { NodeActivity } from \"../behavior/context/NodeActivity.js\";\nimport { OfflineContext } from \"../behavior/context/server/OfflineContext.js\";\nimport { Lifecycle, UninitializedDependencyError } from \"../common/Lifecycle.js\";\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { Environment } from \"../environment/Environment.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { DataModelPath } from \"../model/definitions/DataModelPath.js\";\nimport type { Node } from \"../node/Node.js\";\nimport { IdentityService } from \"../node/server/IdentityService.js\";\nimport { Construction } from \"../util/Construction.js\";\nimport { MaybePromise } from \"../util/Promises.js\";\nimport { Immutable } from \"../util/Type.js\";\nimport { Agent } from \"./Agent.js\";\nimport { RootEndpoint } from \"./definitions/system/RootEndpoint.js\";\nimport { Behaviors } from \"./properties/Behaviors.js\";\nimport { EndpointInitializer } from \"./properties/EndpointInitializer.js\";\nimport { EndpointLifecycle } from \"./properties/EndpointLifecycle.js\";\nimport { Parts } from \"./properties/Parts.js\";\nimport { SupportedBehaviors } from \"./properties/SupportedBehaviors.js\";\nimport { EndpointType } from \"./type/EndpointType.js\";\n\nconst logger = Logger.get(\"Endpoint\");\n\n/**\n * Endpoints consist of a hierarchy of parts.  This class manages the current state of a single endpoint.\n *\n * You can interact with endpoints using an {@link Agent} created with {@link Endpoint.agentFor}.  Agents are stateless and\n * designed for quick instantiation so you can create them as needed then discard.\n *\n * Most often direct access to {@link Agent} is transparent as Matter.js acquires an agent as necessary for\n * {@link Behavior} interactions.\n */\nexport class Endpoint<T extends EndpointType = EndpointType.Empty> {\n    #type: EndpointType;\n    #id?: string;\n    #number?: EndpointNumber;\n    #owner?: Endpoint;\n    #agentType?: Agent.Type<T>;\n    #behaviors: Behaviors;\n    #lifecycle: EndpointLifecycle;\n    #parts?: Parts;\n    #construction: Construction<Endpoint<T>>;\n    #stateView = {} as Immutable<SupportedBehaviors.StateOf<T[\"behaviors\"]>>;\n    #events = {} as SupportedBehaviors.EventsOf<T[\"behaviors\"]>;\n    #activity?: NodeActivity;\n\n    /**\n     * A string that uniquely identifies an endpoint.\n     *\n     * This ID must be unique amongst all Parts with the same owner.\n     */\n    get id() {\n        if (this.#id === undefined) {\n            throw new UninitializedDependencyError(\n                this.toString(),\n                \"endpoint ID is not yet assigned; set ID or await endpoint.construction to avoid this error\",\n            );\n        }\n        return this.#id;\n    }\n\n    /**\n     * The endpoint ID or undefined if not yet assigned.\n     */\n    get maybeId() {\n        return this.#id;\n    }\n\n    /**\n     * The Matter {@link EndpointNumber} of the endpoint.  This uniquely identifies the {@link Endpoint} in the scope of the\n     * Matter node.\n     */\n    get number(): EndpointNumber {\n        if (this.#number === undefined) {\n            throw new UninitializedDependencyError(\n                this.toString(),\n                \"endpoint number is not yet assigned; set number or await endpoint.construction to avoid this error\",\n            );\n        }\n        return this.#number;\n    }\n\n    /**\n     * The endpoint number or undefined if not yet assigned.\n     */\n    get maybeNumber() {\n        return this.#number;\n    }\n\n    /**\n     * The owner of the endpoint.\n     *\n     * Every endpoint but the root endpoint (the \"node\") is owned by another endpoint.\n     */\n    get owner(): Endpoint | undefined {\n        return this.#owner;\n    }\n\n    /**\n     * Search for the owner of a specific type.\n     *\n     * Returns undefined if this owner is not found on the way up to the root endpoint.\n     */\n    ownerOfType<T extends EndpointType.Empty>(type: T): Endpoint<T> | undefined {\n        for (let endpoint: Endpoint | undefined = this; endpoint !== undefined; endpoint = endpoint.owner) {\n            if (endpoint.type.deviceClass === type.deviceClass) {\n                return endpoint as Endpoint<T>;\n            }\n        }\n    }\n\n    /**\n     * The endpoint's environment.  Endpoint implementations use the environment to access platform components such as\n     * storage and network components.\n     */\n    get env(): Environment {\n        if (this.owner) {\n            return this.owner.env;\n        }\n        return Environment.default;\n    }\n\n    /**\n     * Access the pool of behaviors supported by this endpoint.\n     */\n    get behaviors() {\n        return this.#behaviors;\n    }\n\n    /**\n     * Current state values for all behaviors, keyed by behavior ID.  This view is read-only.\n     */\n    get state() {\n        return this.#stateView;\n    }\n\n    /**\n     * Current state for a specific behavior.\n     */\n    stateOf<T extends Behavior.Type>(type: T) {\n        if (!this.behaviors.has(type)) {\n            throw new ImplementationError(`Behavior ${type.id} is not supported by ${this}`);\n        }\n        return (this.#stateView as Record<string, unknown>)[type.id] as Immutable<Behavior.StateOf<T>>;\n    }\n\n    /**\n     * Update state values.  This is a patch operation; it only modifies properties in {@link values}.\n     *\n     * {@link values} is an object with a {@link Behavior.id} as the key and state values as sub-objects.\n     *\n     * Input values must adhere to the {@link Behavior.schema} of the target {@link Behavior}.  If not, set will throw\n     * an error.\n     *\n     * This is a transactional operation.  An error results in no change.  The endpoint will wait for exclusive access\n     * before applying changes.\n     *\n     * @param values the values to change\n     */\n    async set(values: SupportedBehaviors.StatePatchOf<T[\"behaviors\"]>) {\n        await this.act(`set<${this}>`, async agent => {\n            const tx = agent.context.transaction;\n\n            await tx.begin();\n\n            for (const behaviorId in values) {\n                const behavior = agent[behaviorId];\n                if (!(behavior instanceof Behavior)) {\n                    throw new ImplementationError(`Behavior ID ${behaviorId} does not exist`);\n                }\n\n                const vals = values[behaviorId];\n                if (vals === undefined) {\n                    continue;\n                }\n\n                await tx.addResources(behavior);\n\n                const patch = (behavior.constructor as Behavior.Type).supervisor.patch;\n\n                if (typeof vals !== \"object\") {\n                    throw new ImplementationError(\n                        `State values for ${behaviorId} must be an object, not ${typeof vals}`,\n                    );\n                }\n                if (Array.isArray(vals)) {\n                    throw new ImplementationError(`StateValue for ${behaviorId} must be an object, not an array`);\n                }\n\n                patch(vals, behavior.state, this.path);\n            }\n        });\n    }\n\n    /**\n     * Update state values for a single behavior.\n     *\n     * The patch semantics used here are identical to {@link set}.\n     *\n     * @param type the {@link Behavior} to patch\n     * @param values the values to change\n     */\n    async setStateOf<T extends Behavior.Type>(type: T, values: Behavior.PatchStateOf<T>) {\n        await this.act(`setStateOf<${this}>`, async agent => {\n            const behavior = agent.get(type);\n\n            const tx = agent.context.transaction;\n            await tx.begin();\n            await tx.addResources(behavior);\n\n            const patch = (behavior.constructor as Behavior.Type).supervisor.patch;\n\n            if (typeof values !== \"object\") {\n                throw new ImplementationError(`State values for ${type.id} must be an object, not ${typeof values}`);\n            }\n            if (Array.isArray(values)) {\n                throw new ImplementationError(`State values for ${type.id} must be an object, not an array`);\n            }\n\n            patch(values, behavior.state, this.path);\n        });\n    }\n\n    /**\n     * Events for all behaviors keyed by behavior ID.\n     */\n    get events() {\n        return this.#events;\n    }\n\n    /**\n     * Events for a specific behavior.\n     */\n    eventsOf<T extends Behavior.Type>(type: T) {\n        if (!this.behaviors.has(type)) {\n            throw new ImplementationError(`Behavior ${type.id} is not supported by this endpoint`);\n        }\n        return this.#events[type.id] as Behavior.EventsOf<T>;\n    }\n\n    get construction() {\n        return this.#construction;\n    }\n\n    /**\n     * Create new endpoint.\n     *\n     * The endpoint will not initialize fully until added to a {@link Node}.  You can use {@link Endpoint.add} to\n     * construct and initialize an {@link Endpoint} in one step.\n     *\n     * @param config\n     */\n    constructor(config: Endpoint.Configuration<T> | T);\n\n    /**\n     * Create new endpoint.\n     *\n     * The endpoint will not initialize fully until added to a {@link Node}.  You can use {@link Endpoint.add} to\n     * construct and initialize an {@link Endpoint} in one step.\n     *\n     * @param config\n     */\n    constructor(type: T, options?: Endpoint.Options<T>);\n\n    constructor(definition: T | Endpoint.Configuration<T>, options?: Endpoint.Options<T>) {\n        const config = Endpoint.configurationFor(definition, options);\n\n        this.#type = config.type;\n\n        // Create construction early so other components can hook events\n        this.#construction = Construction(this);\n\n        this.#lifecycle = this.createLifecycle(config.isEssential);\n        this.#lifecycle.ready.on(() => this.#logReady());\n\n        if (config.id !== undefined) {\n            this.id = config.id;\n        }\n\n        if (config.number !== undefined) {\n            this.number = config.number;\n        }\n\n        this.#behaviors = new Behaviors(this, config as Record<string, object | undefined>);\n\n        if (config.owner) {\n            this.owner = config.owner instanceof Agent ? config.owner.endpoint : config.owner;\n        }\n\n        if (config.parts) {\n            for (const part of config.parts) {\n                this.parts.add(part);\n            }\n        }\n    }\n\n    set id(id: string) {\n        if (this.#id === id) {\n            return;\n        }\n        if (this.#id !== undefined) {\n            throw new ImplementationError(`${this} ID is already assigned, cannot reassign`);\n        }\n        if (typeof id !== \"string\") {\n            throw new ImplementationError(`Illegal endpoint ID type \"${typeof id}\"`);\n        }\n        if (id === \"\") {\n            throw new ImplementationError(\"Endpoint ID may not be empty\");\n        }\n        if (id.includes(\".\")) {\n            throw new ImplementationError('Endpoint ID may not include \".\"');\n        }\n\n        if (this.lifecycle.isInstalled && this.owner instanceof Endpoint) {\n            this.owner.parts.assertIdAvailable(id, this);\n        }\n\n        this.#id = id;\n        this.lifecycle.change(EndpointLifecycle.Change.IdAssigned);\n    }\n\n    set number(number: number) {\n        if (this.#number === number) {\n            return;\n        }\n        if (this.#number !== undefined) {\n            throw new ImplementationError(\n                `${this} endpoint number ${this.#number} is already assigned, cannot reassign`,\n            );\n        }\n        if (typeof number !== \"number\") {\n            throw new ImplementationError(`Illegal endpoint number type \"${typeof number}\"`);\n        }\n        if (!Number.isInteger(number)) {\n            throw new ImplementationError(`Endpoint number ${number} is not an integer`);\n        }\n        if (number < 0) {\n            throw new ImplementationError(`Endpoint number ${number} is negative`);\n        }\n        if (number > 0xffff) {\n            throw new ImplementationError(`Endpoint number ${number} is greater than the maximum of 65535`);\n        }\n\n        if (this.type.deviceClass === RootEndpoint.deviceClass) {\n            if (number !== 0) {\n                throw new ImplementationError(\"The root endpoint must have ID 0\");\n            }\n        } else {\n            if (number === 0) {\n                throw new ImplementationError(\"Only root endpoint may have ID 0\");\n            }\n\n            if (this.lifecycle.isInstalled) {\n                this.env.get(IdentityService).assertNumberAvailable(number, this);\n            }\n        }\n\n        this.#number = EndpointNumber(number);\n\n        this.lifecycle.change(EndpointLifecycle.Change.NumberAssigned);\n    }\n\n    set owner(owner: Endpoint | undefined) {\n        if (this.#owner === owner) {\n            return;\n        }\n        if (this.#owner) {\n            throw new ImplementationError(\"Endpoint owner cannot be reassigned\");\n        }\n        if (owner === undefined) {\n            throw new ImplementationError(\"Endpoint owner must be defined\");\n        }\n\n        this.#owner = owner;\n\n        try {\n            owner.parts.add(this);\n        } catch (e) {\n            owner.parts.delete(this);\n            this.#owner = undefined;\n            throw e;\n        }\n    }\n\n    /**\n     * Add a child endpoint.  If this endpoint is initialized, awaits child initialization.\n     *\n     * If child initialization fails:\n     *\n     *   - If the child is essential (@see {@link EndpointLifecycle#isEssential}), removes the child and rethrows\n     *\n     *   - If the child is non-essential then logs the error but leaves the child installed.\n     *\n     * @param endpoint the {@link Endpoint} or {@link Endpoint.Configuration}\n     */\n    async add<T extends EndpointType>(endpoint: Endpoint<T> | Endpoint.Configuration<T> | T): Promise<Endpoint<T>>;\n\n    /**\n     * Add a child endpoint with separate type and options arguments.\n     *\n     * @param type the {@link EndpointType} of the child endpoint\n     * @param options settings for the new endpoint\n     */\n    async add<T extends EndpointType>(type: T, options?: Endpoint.Options<T>): Promise<Endpoint<T>>;\n\n    async add<T extends EndpointType>(\n        definition: T | Endpoint<T> | Endpoint.Configuration<T>,\n        options?: Endpoint.Options<T>,\n    ) {\n        if (!this.lifecycle.isInstalled) {\n            throw new ImplementationError(`You may not use add() here because ${this} is not installed in a Node`);\n        }\n\n        await this.construction;\n\n        let endpoint;\n        if (definition instanceof Endpoint) {\n            endpoint = definition;\n        } else {\n            endpoint = new Endpoint(definition as any, options);\n        }\n\n        if (this.#lifecycle.isPartsReady) {\n            // Disable the default logging of construction errors because we throw the cause below\n            endpoint.construction.onError(() => {});\n        }\n\n        this.parts.add(endpoint);\n\n        try {\n            await endpoint.construction.ready;\n        } catch (e) {\n            // If endpoint is essential do not allow it to be added\n            if (endpoint.lifecycle.isEssential) {\n                await endpoint.reset();\n                this.parts.delete(endpoint);\n                endpoint.#owner = undefined;\n            }\n\n            // For non-essential endpoints just log the error\n            if (!endpoint.lifecycle.isEssential) {\n                logger.error(`Initialization error in non-essential endpoint ${endpoint}:`, e);\n            }\n\n            throw e;\n        }\n\n        return endpoint;\n    }\n\n    /**\n     * The type of endpoint this endpoint implements.\n     */\n    get type() {\n        return this.#type;\n    }\n\n    /**\n     * Access child parts.\n     */\n    get parts() {\n        if (!this.#parts) {\n            this.#parts = new Parts(this);\n        }\n        return this.#parts;\n    }\n\n    /**\n     * Is this a parent Endpoint?\n     */\n    get hasParts() {\n        return !!this.#parts?.size;\n    }\n\n    /**\n     * Endpoint information that varies as the endpoint initializes.\n     */\n    get lifecycle() {\n        return this.#lifecycle;\n    }\n\n    protected createLifecycle(isEssential?: boolean) {\n        return new EndpointLifecycle(this, isEssential);\n    }\n\n    /**\n     * Create an {@link Agent.Type} for the endpoint.\n     */\n    get agentType() {\n        if (!this.#agentType) {\n            this.#agentType = Agent.for(this.type, this.behaviors.supported);\n        }\n        return this.#agentType;\n    }\n\n    /**\n     * Execute a function against an {@link Agent} for the endpoint.\n     *\n     * Agents provide the highest-leve API for interacting with endpoints.  The agent is a composite object with\n     * properties for each supported behavior.\n     *\n     * State changes made by {@link actor} are atomic and made permanent only when the actor exits unless you commit the\n     * transaction manually.\n     *\n     * {@link actor} runs in an \"offline\" context where ACLs are ignored and all state is read/write.\n     *\n     * The {@link Agent} is destroyed after {@link actor} exits so you should not maintain references to the agent, its\n     * behaviors or associated state.\n     *\n     * {@link actor} may be async.  If so, the acting context will remain open until the returned {@link Promise}\n     * resolves.\n     *\n     * @param purpose textual description of operation used for diagnostics\n     * @param actor the function that performs the action\n     */\n    act<R>(purpose: string, actor: (agent: Agent.Instance<T>) => MaybePromise<R>): MaybePromise<R>;\n\n    /**\n     * Version of {@link act} without explicit diagnostic purpose.\n     */\n    act<R>(actor: (agent: Agent.Instance<T>) => MaybePromise<R>): MaybePromise<R>;\n\n    act<R>(\n        actorOrPurpose: string | ((agent: Agent.Instance<T>) => MaybePromise<R>),\n        actor?: (agent: Agent.Instance<T>) => MaybePromise<R>,\n    ): MaybePromise<R> {\n        let purpose;\n        if (typeof actorOrPurpose === \"string\") {\n            purpose = actorOrPurpose;\n        } else {\n            actor = actorOrPurpose;\n            purpose = \"offline\";\n        }\n\n        if (typeof actor !== \"function\") {\n            throw new ImplementationError(\"Actor must be a function\");\n        }\n\n        this.construction.assert(this.toString());\n\n        if (!this.#activity) {\n            this.#activity = this.env.get(NodeActivity);\n        }\n\n        return OfflineContext.act(purpose, this.#activity, context => {\n            return actor(context.agentFor(this));\n        });\n    }\n\n    /**\n     * Perform \"soft\" reset of the endpoint, reverting all in-memory structures to uninitialized.\n     */\n    async reset() {\n        try {\n            // Revert lifecycle to uninitialized\n            this.lifecycle.resetting();\n\n            // Reset child parts\n            await this.parts.reset();\n\n            // Reset behaviors\n            await this.behaviors.close();\n\n            // Notify\n            await this.lifecycle.reset.emit();\n\n            // Set construction to inactive so we can restart\n            this.construction.setStatus(Lifecycle.Status.Inactive);\n        } catch (e) {\n            logger.error(`Unhandled error during reset of ${this}`, e);\n        }\n    }\n\n    /**\n     * Apply a depth-first visitor function to myself and all descendents.\n     */\n    visit<T extends void | PromiseLike<void>>(visitor: (endpoint: Endpoint) => T): T {\n        const promise = visitor(this);\n\n        const childIterator = this.parts[Symbol.iterator]();\n\n        const visitChildren = (): MaybePromise => {\n            for (let next = childIterator.next(); !next.done; next = childIterator.next()) {\n                const promise = next.value.visit(visitor);\n                if (MaybePromise.is(promise)) {\n                    return promise.then(visitChildren);\n                }\n            }\n        };\n\n        if (MaybePromise.is(promise)) {\n            return promise.then(visitChildren) as T;\n        }\n\n        return visitChildren() as T;\n    }\n\n    async close() {\n        await this.#construction.close();\n    }\n\n    async [Construction.destruct]() {\n        await this.#parts?.close();\n        await this.#behaviors?.close();\n\n        for (const events of Object.values(this.#events)) {\n            events[Symbol.dispose]();\n        }\n\n        this.lifecycle.change(EndpointLifecycle.Change.Destroyed);\n        this.#owner = undefined;\n    }\n\n    async [Symbol.asyncDispose]() {\n        await this.close();\n    }\n\n    toString() {\n        return this.path.toString();\n    }\n\n    /**\n     * Path identifying the endpoint in the Matter data model.\n     */\n    get path(): DataModelPath {\n        let ident;\n        if (this.lifecycle?.hasId) {\n            ident = this.id;\n        } else if (this.lifecycle?.hasNumber) {\n            ident = this.number;\n        } else {\n            ident = \"?\";\n        }\n\n        if (this.#owner) {\n            return this.#owner.path.at(ident, this.#type.name);\n        }\n\n        return DataModelPath(ident, this.type?.name);\n    }\n\n    /**\n     * Asynchronous initialization.\n     *\n     * Derivatives may override to perform async construction prior to full initialization.\n     */\n    protected initialize() {\n        // Configure the endpoint for the appropriate node type\n        this.env.get(EndpointInitializer).initializeDescendent(this);\n\n        // Initialize behaviors.  Success brings endpoint to \"ready\" state\n        let promise = this.behaviors.initialize();\n\n        // Initialize parts.  Success brings endpoint to \"tree ready\" state\n        if (promise) {\n            promise = promise.then(this.parts.initialize.bind(this.parts));\n        } else {\n            promise = this.parts.initialize();\n        }\n\n        return promise;\n    }\n\n    /**\n     * Ensure requirements for construction are met.\n     */\n    protected assertConstructable() {\n        if (this.#owner === undefined) {\n            throw new ImplementationError(`Endpoint construction initiated without owner`);\n        }\n        if (!this.#owner.#lifecycle.isInstalled) {\n            throw new ImplementationError(`Endpoint construction initiated with uninstalled owner`);\n        }\n    }\n\n    /**\n     * Complete initialization.  Invoked via {@link Construction#start} by the owner.\n     */\n    [Construction.construct]() {\n        // Sanity checks\n        this.assertConstructable();\n\n        // We now consider the endpoint \"installed\"\n        this.lifecycle.change(EndpointLifecycle.Change.Installed);\n\n        // Initialize\n        return this.initialize();\n    }\n\n    #logReady() {\n        logger.info(Diagnostic.strong(this.toString()), \"ready\", this.diagnosticDict);\n    }\n\n    /**\n     * Hierarchical diagnostics of endpoint and children.\n     */\n    get [Diagnostic.value](): unknown {\n        return [\n            Diagnostic.strong(this.id),\n            Diagnostic.dict({\n                ...this.#diagnosticProps,\n                class: this.constructor.name,\n            }),\n            Diagnostic.list([...this.behaviors.detailedDiagnostic, ...this.parts]),\n        ];\n    }\n\n    /**\n     * Diagnostic information regarding endpoint state.\n     */\n    get diagnosticDict() {\n        return Diagnostic.dict({\n            ...this.#diagnosticProps,\n            behaviors: this.behaviors,\n        });\n    }\n\n    get #diagnosticProps() {\n        return {\n            \"endpoint#\": this.number,\n            type: `${this.type.name} (0x${this.type.deviceType.toString(16)})`,\n        };\n    }\n}\n\nexport namespace Endpoint {\n    export type BehaviorOptions<\n        T extends EndpointType = EndpointType.Empty,\n        O extends EndpointOptions = EndpointOptions,\n    > = {\n        -readonly [K in keyof T[\"behaviors\"] as K extends keyof O ? never : K]?: Behavior.Options<T[\"behaviors\"][K]>;\n    };\n\n    export interface EndpointOptions {\n        /**\n         * The owner of the endpoint.\n         *\n         * If provided, takes ownership of the endpoint at construction.\n         */\n        owner?: Endpoint | Agent;\n\n        /**\n         * The endpoint's string identifier.  Must be unique within the parent.\n         *\n         * If you omit the identifier the node assigns a generated one for you.\n         */\n        id?: string;\n\n        /**\n         * The endpoint number.  Must be unique within the node.\n         *\n         * If you omit the endpoint number the node assigns a sequential one for you.\n         */\n        number?: number;\n\n        /**\n         * Child endpoints.\n         *\n         * This is the inverse of setting {@link owner} above.  The endpoint instantiates and takes ownership of child\n         * endpoints at construction time.\n         */\n        parts?: Iterable<Endpoint.Definition>;\n\n        /**\n         * Designates whether an endpoint is essential.\n         *\n         * Endpoints are essential by default but you may disable by setting this to false.\n         */\n        isEssential?: boolean;\n    }\n\n    export type Options<\n        T extends EndpointType = EndpointType.Empty,\n        O extends EndpointOptions = EndpointOptions,\n    > = BehaviorOptions<T, O> & O;\n\n    export type Configuration<\n        T extends EndpointType = EndpointType.Empty,\n        O extends EndpointOptions = EndpointOptions,\n    > = Options<T, O & { type: T }> & { type: T };\n\n    /**\n     * Definition of an endpoint.  May be an {@link EndpointType}, {@link Configuration}, or a {@link Endpoint}\n     * instance.\n     */\n    export type Definition<T extends EndpointType = EndpointType.Empty> = T | Configuration<T> | Endpoint<T>;\n\n    /**\n     * Obtain a configuration from constructor parameters.\n     */\n    export function configurationFor<T extends EndpointType>(\n        definition: T | Endpoint.Configuration<T>,\n        options?: Endpoint.Options<T>,\n    ) {\n        if ((definition as EndpointType).deviceType) {\n            return {\n                ...options,\n                type: definition as T,\n            } as Configuration<T>;\n        }\n        return definition as Configuration<T>;\n    }\n\n    /**\n     * Obtain an endpoint for the given {@link Definition}.\n     */\n    export function partFor<T extends EndpointType>(definition: Definition<T>): Endpoint<T> {\n        if (definition instanceof Endpoint) {\n            return definition;\n        }\n\n        return new Endpoint(definition);\n    }\n}\n"],
  "mappings": "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",
  "names": ["promise", "Endpoint"]
}
