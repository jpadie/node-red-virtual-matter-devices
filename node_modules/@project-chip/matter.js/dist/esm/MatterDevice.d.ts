/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CommissioningOptions } from "./behavior/system/commissioning/CommissioningOptions.js";
import { AdministratorCommissioning } from "./cluster/definitions/AdministratorCommissioningCluster.js";
import { Channel } from "./common/Channel.js";
import { FailsafeContext } from "./common/FailsafeContext.js";
import { InstanceBroadcaster } from "./common/InstanceBroadcaster.js";
import { Scanner } from "./common/Scanner.js";
import { TransportInterface } from "./common/TransportInterface.js";
import { FabricIndex } from "./datatype/FabricIndex.js";
import { NodeId } from "./datatype/NodeId.js";
import { Fabric } from "./fabric/Fabric.js";
import { FabricAction, FabricManager } from "./fabric/FabricManager.js";
import { ExchangeManager } from "./protocol/ExchangeManager.js";
import { ProtocolHandler } from "./protocol/ProtocolHandler.js";
import { Session, SessionParameters } from "./session/Session.js";
import { ResumptionRecord, SessionManager } from "./session/SessionManager.js";
import { PaseServer } from "./session/pase/PaseServer.js";
import { StorageContext } from "./storage/StorageContext.js";
import { ByteArray } from "./util/ByteArray.js";
import { Construction } from "./util/Construction.js";
export declare class MatterDevice {
    #private;
    readonly sessionStorage: StorageContext;
    readonly fabricStorage: StorageContext;
    private readonly getCommissioningConfig;
    private readonly commissioningChangedCallback;
    private readonly sessionChangedCallback;
    private readonly scanners;
    private readonly broadcasters;
    private readonly transportInterfaces;
    private readonly channelManager;
    private readonly secureChannelProtocol;
    private activeCommissioningMode;
    private activeCommissioningDiscriminator?;
    private activeCommissioningEndCallback?;
    private announceInterval;
    private announcementStartedTime;
    readonly sessionParameters: SessionParameters;
    get construction(): Construction<MatterDevice>;
    static create(sessionStorage: StorageContext, fabricStorage: StorageContext, getCommissioningConfig: () => CommissioningOptions.Configuration, minimumCaseSessionsPerFabricAndNode: number | undefined, commissioningChangedCallback: (fabricIndex: FabricIndex, fabricAction: FabricAction) => void, sessionChangedCallback: (fabricIndex: FabricIndex) => void, sessionParameters?: Partial<SessionParameters>): Promise<MatterDevice>;
    constructor(sessionStorage: StorageContext, fabricStorage: StorageContext, getCommissioningConfig: () => CommissioningOptions.Configuration, minimumCaseSessionsPerFabricAndNode: number, commissioningChangedCallback: (fabricIndex: FabricIndex, fabricAction: FabricAction) => void, sessionChangedCallback: (fabricIndex: FabricIndex) => void, sessionParameters?: Partial<SessionParameters>);
    get fabricManager(): FabricManager;
    get sessionManager(): SessionManager<MatterDevice>;
    get exchangeManager(): ExchangeManager<MatterDevice>;
    get failsafeContext(): FailsafeContext;
    get isClosing(): boolean;
    beginTimed(failsafeContext: FailsafeContext): Promise<void>;
    assertFailSafeArmed(message?: string): void;
    isFailsafeArmed(): boolean;
    addScanner(scanner: Scanner): this;
    hasBroadcaster(broadcaster: InstanceBroadcaster): boolean;
    addBroadcaster(broadcaster: InstanceBroadcaster): this;
    deleteBroadcaster(broadcaster: InstanceBroadcaster): Promise<void>;
    addTransportInterface(transport: TransportInterface): this;
    deleteTransportInterface(transport: TransportInterface): Promise<void>;
    hasProtocolHandler(protocolId: number): boolean;
    addProtocolHandler(protocol: ProtocolHandler<MatterDevice>): this;
    start(): Promise<void>;
    startAnnouncement(): Promise<void>;
    expireAllFabricAnnouncements(): Promise<void>;
    announce(announceOnce?: boolean): Promise<void>;
    private announceAsCommissionable;
    reAnnounceAsCommissionable(): void;
    sendCommissionableAnnouncement(mode: AdministratorCommissioning.CommissioningWindowStatus, discriminator?: number): Promise<void>;
    getNextAvailableSessionId(): Promise<number>;
    findFabricFromDestinationId(destinationId: ByteArray, peerRandom: ByteArray): Fabric;
    sendFabricAnnouncements(fabrics: Fabric[], expireCommissioningAnnouncement?: boolean): Promise<void>;
    getFabricByIndex(fabricIndex: FabricIndex): Fabric | undefined;
    initiateExchange(fabric: Fabric, nodeId: NodeId, protocolId: number): import("./protocol/MessageExchange.js").MessageExchange<MatterDevice>;
    findResumptionRecordById(resumptionId: ByteArray): ResumptionRecord | undefined;
    saveResumptionRecord(resumptionRecord: ResumptionRecord): Promise<void>;
    getFabrics(): Fabric[];
    isCommissioned(): boolean;
    allowEnhancedCommissioning(discriminator: number, paseServer: PaseServer, commissioningEndCallback: () => void): Promise<void>;
    allowBasicCommissioning(commissioningEndCallback?: () => void): Promise<void>;
    endCommissioning(): Promise<void>;
    existsOpenPaseSession(): boolean;
    findDevice(fabric: Fabric, nodeId: NodeId, timeOutSeconds?: number): Promise<undefined | {
        session: Session<MatterDevice>;
        channel: Channel<ByteArray>;
    }>;
    clearSubscriptionsForNode(fabricIndex: FabricIndex, peerNodeId: NodeId, flushSubscriptions?: boolean): Promise<void>;
    close(): Promise<void>;
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("./fabric/Fabric.js").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
}
//# sourceMappingURL=MatterDevice.d.ts.map