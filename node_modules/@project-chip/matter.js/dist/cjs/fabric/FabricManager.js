"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FabricManager_exports = {};
__export(FabricManager_exports, {
  FabricAction: () => FabricAction,
  FabricManager: () => FabricManager,
  FabricNotFoundError: () => FabricNotFoundError,
  FabricTableFullError: () => FabricTableFullError
});
module.exports = __toCommonJS(FabricManager_exports);
var import_MatterError = require("../common/MatterError.js");
var import_FabricIndex = require("../datatype/FabricIndex.js");
var import_Observable = require("../util/Observable.js");
var import_Promises = require("../util/Promises.js");
var import_Fabric = require("./Fabric.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class FabricNotFoundError extends import_MatterError.MatterError {
}
class FabricTableFullError extends import_MatterError.MatterError {
}
var FabricAction = /* @__PURE__ */ ((FabricAction2) => {
  FabricAction2[FabricAction2["Added"] = 0] = "Added";
  FabricAction2[FabricAction2["Removed"] = 1] = "Removed";
  FabricAction2[FabricAction2["Updated"] = 2] = "Updated";
  return FabricAction2;
})(FabricAction || {});
class FabricManager {
  #nextFabricIndex = 1;
  #fabrics = /* @__PURE__ */ new Map();
  #initializationDone = false;
  #fabricStorage;
  #events = {
    added: (0, import_Observable.Observable)(),
    updated: (0, import_Observable.Observable)(),
    deleted: (0, import_Observable.Observable)(),
    failsafeClosed: (0, import_Observable.Observable)()
  };
  constructor(fabricStorage) {
    this.#fabricStorage = fabricStorage;
  }
  async initFromStorage() {
    const fabrics = await this.#fabricStorage.get("fabrics", []);
    fabrics.forEach((fabric) => this.addFabric(import_Fabric.Fabric.createFromStorageObject(fabric)));
    this.#nextFabricIndex = await this.#fabricStorage.get("nextFabricIndex", this.#nextFabricIndex);
    this.#initializationDone = true;
  }
  get events() {
    return this.#events;
  }
  getNextFabricIndex() {
    for (let i = 0; i < 254; i++) {
      const fabricIndex = this.#nextFabricIndex++;
      if (this.#nextFabricIndex > 254) this.#nextFabricIndex = 1;
      if (!this.#fabrics.has((0, import_FabricIndex.FabricIndex)(fabricIndex))) {
        return (0, import_FabricIndex.FabricIndex)(fabricIndex);
      }
    }
    throw new FabricTableFullError("No free fabric index available.");
  }
  persistFabrics() {
    const storeResult = this.#fabricStorage.set(
      "fabrics",
      Array.from(this.#fabrics.values()).map((fabric) => fabric.toStorageObject())
    );
    if (import_Promises.MaybePromise.is(storeResult)) {
      return storeResult.then(() => this.#fabricStorage.set("nextFabricIndex", this.#nextFabricIndex));
    }
    return this.#fabricStorage.set("nextFabricIndex", this.#nextFabricIndex);
  }
  addFabric(fabric) {
    const { fabricIndex } = fabric;
    if (this.#fabrics.has(fabricIndex)) {
      throw new import_MatterError.MatterFlowError(`Fabric with index ${fabricIndex} already exists.`);
    }
    this.#fabrics.set(fabricIndex, fabric);
    fabric.addRemoveCallback(async () => this.removeFabric(fabricIndex));
    fabric.persistCallback = (isUpdate = true) => {
      const persistResult = this.persistFabrics();
      return import_Promises.MaybePromise.then(persistResult, () => {
        if (isUpdate) {
          this.#events.updated.emit(fabric);
        }
      });
    };
    if (this.#initializationDone) {
      this.#events.added.emit(fabric);
    }
  }
  async removeFabric(fabricIndex) {
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0)
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be removed because it does not exist.`
      );
    this.#fabrics.delete(fabricIndex);
    await this.persistFabrics();
    this.#events.deleted.emit(fabric);
  }
  getFabrics() {
    return Array.from(this.#fabrics.values());
  }
  findFabricFromDestinationId(destinationId, initiatorRandom) {
    for (const fabric of this.#fabrics.values()) {
      const candidateDestinationId = fabric.getDestinationId(fabric.nodeId, initiatorRandom);
      if (!candidateDestinationId.equals(destinationId)) continue;
      return fabric;
    }
    throw new import_MatterError.InternalError("Fabric cannot be found from destinationId");
  }
  findByKeypair(keypair) {
    for (const fabric of this.#fabrics.values()) {
      if (fabric.matchesKeyPair(keypair)) {
        return fabric;
      }
    }
    return void 0;
  }
  async updateFabric(fabric) {
    const { fabricIndex } = fabric;
    if (!this.#fabrics.has(fabricIndex)) {
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be updated because it does not exist.`
      );
    }
    this.#fabrics.set(fabricIndex, fabric);
    await this.persistFabrics();
    this.#events.updated.emit(fabric);
  }
  async revokeFabric(fabricIndex) {
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0) {
      throw new import_MatterError.MatterFlowError(`Fabric with index ${fabricIndex} does not exist to revoke.`);
    }
    await fabric.remove();
  }
}
//# sourceMappingURL=FabricManager.js.map
