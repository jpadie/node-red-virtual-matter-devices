/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { NodeId } from "../datatype/NodeId.js";
import { Diagnostic } from "../log/Diagnostic.js";
import { ByteArray } from "../util/ByteArray.js";
export interface PacketHeader {
    sessionId: number;
    sessionType: SessionType;
    hasPrivacyEnhancements: boolean;
    isControlMessage: boolean;
    hasMessageExtensions: boolean;
    messageId: number;
    sourceNodeId?: NodeId;
    destNodeId?: NodeId;
    destGroupId?: number;
}
export interface DecodedPacketHeader extends PacketHeader {
    securityFlags: number;
}
export interface PayloadHeader {
    exchangeId: number;
    protocolId: number;
    messageType: number;
    isInitiatorMessage: boolean;
    requiresAck: boolean;
    ackedMessageId?: number;
    hasSecuredExtension: boolean;
}
export interface Packet {
    header: PacketHeader;
    messageExtension?: ByteArray;
    applicationPayload: ByteArray;
}
export interface DecodedPacket extends Packet {
    header: DecodedPacketHeader;
}
export interface Message {
    packetHeader: PacketHeader;
    payloadHeader: PayloadHeader;
    securityExtension?: ByteArray;
    payload: ByteArray;
}
export interface DecodedMessage extends Message {
    packetHeader: DecodedPacketHeader;
}
export declare enum SessionType {
    Group = 1,
    Unicast = 0
}
export declare class MessageCodec {
    static decodePacket(data: ByteArray): DecodedPacket;
    static decodePayload({ header, applicationPayload }: DecodedPacket): DecodedMessage;
    static encodePayload({ packetHeader, payloadHeader, payload, securityExtension }: Message): Packet;
    static encodePacket({ header, applicationPayload, messageExtension }: Packet): ByteArray;
    private static decodePacketHeader;
    private static decodePayloadHeader;
    static encodePacketHeader({ messageId: messageCounter, sessionId, destGroupId, destNodeId, sourceNodeId, sessionType, }: PacketHeader): Uint8Array;
    static messageDiagnostics({ packetHeader: { messageId, sessionId }, payloadHeader: { exchangeId, messageType, protocolId, ackedMessageId, requiresAck }, payload, }: Message, isDuplicate?: boolean): Record<string, unknown> & Diagnostic;
    private static encodePayloadHeader;
}
//# sourceMappingURL=MessageCodec.d.ts.map