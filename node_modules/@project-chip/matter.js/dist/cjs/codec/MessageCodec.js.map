{
  "version": 3,
  "sources": ["../../../src/codec/MessageCodec.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NotImplementedError, UnexpectedDataError } from \"../common/MatterError.js\";\nimport { GroupId } from \"../datatype/GroupId.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataReader } from \"../util/DataReader.js\";\nimport { DataWriter } from \"../util/DataWriter.js\";\n\nexport interface PacketHeader {\n    sessionId: number;\n    sessionType: SessionType;\n    hasPrivacyEnhancements: boolean;\n    isControlMessage: boolean;\n    hasMessageExtensions: boolean;\n    messageId: number;\n    sourceNodeId?: NodeId;\n    destNodeId?: NodeId;\n    destGroupId?: number;\n}\n\nexport interface DecodedPacketHeader extends PacketHeader {\n    securityFlags: number; // The SecurityFlags as pure data field to be used as nonce\n}\n\nexport interface PayloadHeader {\n    exchangeId: number;\n    protocolId: number;\n    messageType: number;\n    isInitiatorMessage: boolean;\n    requiresAck: boolean;\n    ackedMessageId?: number;\n    hasSecuredExtension: boolean;\n}\n\nexport interface Packet {\n    header: PacketHeader;\n    messageExtension?: ByteArray;\n    applicationPayload: ByteArray;\n}\n\nexport interface DecodedPacket extends Packet {\n    header: DecodedPacketHeader;\n}\nexport interface Message {\n    packetHeader: PacketHeader;\n    payloadHeader: PayloadHeader;\n    securityExtension?: ByteArray;\n    payload: ByteArray;\n}\n\nexport interface DecodedMessage extends Message {\n    packetHeader: DecodedPacketHeader;\n}\n\nconst HEADER_VERSION = 0x00;\n\nexport enum SessionType {\n    Group = 1,\n    Unicast = 0,\n}\n\nconst COMMON_VENDOR_ID = 0x0000;\n\nconst enum PacketHeaderFlag {\n    HasDestNodeId = 0b00000001,\n    HasDestGroupId = 0b00000010,\n    HasSourceNodeId = 0b00000100,\n    Reserved = 0b00001000,\n    VersionMask = 0b11110000,\n}\n\nconst enum PayloadHeaderFlag {\n    IsInitiatorMessage = 0b00000001,\n    IsAckMessage = 0b00000010,\n    RequiresAck = 0b00000100,\n    HasSecureExtension = 0b00001000,\n    HasVendorId = 0b00010000,\n}\n\nconst enum SecurityFlag {\n    HasPrivacyEnhancements = 0b10000000,\n    IsControlMessage = 0b01000000,\n    HasMessageExtension = 0b00100000,\n}\n\nexport class MessageCodec {\n    static decodePacket(data: ByteArray): DecodedPacket {\n        const reader = new DataReader(data, Endian.Little);\n        const header = this.decodePacketHeader(reader);\n\n        let messageExtension: ByteArray | undefined = undefined;\n        if (header.hasMessageExtensions) {\n            const extensionLength = reader.readUInt16();\n            messageExtension = reader.readByteArray(extensionLength);\n        }\n\n        const applicationPayload = reader.getRemainingBytes();\n        return {\n            header,\n            messageExtension,\n            applicationPayload,\n        };\n    }\n\n    static decodePayload({ header, applicationPayload }: DecodedPacket): DecodedMessage {\n        const reader = new DataReader(applicationPayload, Endian.Little);\n        const payloadHeader = this.decodePayloadHeader(reader);\n        let securityExtension: ByteArray | undefined = undefined;\n        if (payloadHeader.hasSecuredExtension) {\n            const extensionLength = reader.readUInt16();\n            securityExtension = reader.readByteArray(extensionLength);\n        }\n        return {\n            packetHeader: header,\n            payloadHeader,\n            securityExtension,\n            payload: reader.getRemainingBytes(),\n        };\n    }\n\n    static encodePayload({ packetHeader, payloadHeader, payload, securityExtension }: Message): Packet {\n        if (securityExtension !== undefined || payloadHeader.hasSecuredExtension) {\n            throw new NotImplementedError(`Security extensions not supported when encoding a payload.`);\n        }\n\n        return {\n            header: packetHeader,\n            applicationPayload: ByteArray.concat(this.encodePayloadHeader(payloadHeader), payload),\n        };\n    }\n\n    static encodePacket({ header, applicationPayload, messageExtension }: Packet): ByteArray {\n        if (messageExtension !== undefined || header.hasMessageExtensions) {\n            throw new NotImplementedError(`Message extensions not supported when encoding a packet.`);\n        }\n        return ByteArray.concat(this.encodePacketHeader(header), applicationPayload);\n    }\n\n    private static decodePacketHeader(reader: DataReader<Endian.Little>): DecodedPacketHeader {\n        // Read and parse message flags\n        const flags = reader.readUInt8();\n        const version = (flags & PacketHeaderFlag.VersionMask) >> 4;\n        const hasDestNodeId = (flags & PacketHeaderFlag.HasDestNodeId) !== 0;\n        const hasDestGroupId = (flags & PacketHeaderFlag.HasDestGroupId) !== 0;\n        const hasSourceNodeId = (flags & PacketHeaderFlag.HasSourceNodeId) !== 0;\n\n        if (hasDestNodeId && hasDestGroupId)\n            throw new UnexpectedDataError(\n                \"The header cannot contain destination group and node at the same time. Reserved for future use. Discard message.\",\n            );\n        if (version !== HEADER_VERSION) throw new NotImplementedError(`Unsupported header version ${version}.`);\n\n        const sessionId = reader.readUInt16();\n        const securityFlags = reader.readUInt8();\n        const messageId = reader.readUInt32();\n        const sourceNodeId = hasSourceNodeId ? NodeId(reader.readUInt64()) : undefined;\n        const destNodeId = hasDestNodeId ? NodeId(reader.readUInt64()) : undefined;\n        const destGroupId = hasDestGroupId ? GroupId(reader.readUInt16()) : undefined;\n\n        const sessionType = securityFlags & 0b00000011;\n        if (sessionType !== SessionType.Group && sessionType !== SessionType.Unicast)\n            throw new UnexpectedDataError(`Unsupported session type ${sessionType}`);\n        const hasPrivacyEnhancements = (securityFlags & SecurityFlag.HasPrivacyEnhancements) !== 0;\n        if (hasPrivacyEnhancements) throw new NotImplementedError(`Privacy enhancements not supported`);\n        const isControlMessage = (securityFlags & SecurityFlag.IsControlMessage) !== 0;\n        if (isControlMessage) throw new NotImplementedError(`Control Messages not supported`);\n        const hasMessageExtensions = (securityFlags & SecurityFlag.HasMessageExtension) !== 0;\n\n        return {\n            securityFlags,\n            sessionId,\n            sourceNodeId,\n            messageId,\n            destGroupId,\n            destNodeId,\n            sessionType,\n            hasPrivacyEnhancements,\n            isControlMessage,\n            hasMessageExtensions,\n        };\n    }\n\n    private static decodePayloadHeader(reader: DataReader<Endian.Little>): PayloadHeader {\n        const exchangeFlags = reader.readUInt8();\n        const isInitiatorMessage = (exchangeFlags & PayloadHeaderFlag.IsInitiatorMessage) !== 0;\n        const isAckMessage = (exchangeFlags & PayloadHeaderFlag.IsAckMessage) !== 0;\n        const requiresAck = (exchangeFlags & PayloadHeaderFlag.RequiresAck) !== 0;\n        const hasSecuredExtension = (exchangeFlags & PayloadHeaderFlag.HasSecureExtension) !== 0;\n        const hasVendorId = (exchangeFlags & PayloadHeaderFlag.HasVendorId) !== 0;\n\n        const messageType = reader.readUInt8();\n        const exchangeId = reader.readUInt16();\n        const vendorId = hasVendorId ? reader.readUInt16() : COMMON_VENDOR_ID;\n        const protocolId = (vendorId << 16) | reader.readUInt16();\n        const ackedMessageId = isAckMessage ? reader.readUInt32() : undefined;\n\n        return {\n            protocolId,\n            exchangeId,\n            messageType,\n            isInitiatorMessage,\n            requiresAck,\n            ackedMessageId,\n            hasSecuredExtension,\n        };\n    }\n\n    static encodePacketHeader({\n        messageId: messageCounter,\n        sessionId,\n        destGroupId,\n        destNodeId,\n        sourceNodeId,\n        sessionType,\n    }: PacketHeader) {\n        const writer = new DataWriter(Endian.Little);\n        const flags =\n            (HEADER_VERSION << 4) |\n            (destGroupId !== undefined ? PacketHeaderFlag.HasDestGroupId : 0) |\n            (destNodeId !== undefined ? PacketHeaderFlag.HasDestNodeId : 0) |\n            (sourceNodeId !== undefined ? PacketHeaderFlag.HasSourceNodeId : 0);\n        const securityFlags = sessionType;\n\n        writer.writeUInt8(flags);\n        writer.writeUInt16(sessionId);\n        writer.writeUInt8(securityFlags);\n        writer.writeUInt32(messageCounter);\n        if (sourceNodeId !== undefined) writer.writeUInt64(sourceNodeId);\n        if (destNodeId !== undefined) writer.writeUInt64(destNodeId);\n        if (destGroupId !== undefined) writer.writeUInt32(destGroupId);\n        return writer.toByteArray();\n    }\n\n    static messageDiagnostics(\n        {\n            packetHeader: { messageId, sessionId },\n            payloadHeader: { exchangeId, messageType, protocolId, ackedMessageId, requiresAck },\n            payload,\n        }: Message,\n        isDuplicate = false,\n    ) {\n        return Diagnostic.dict({\n            id: `${sessionId}/${exchangeId}/${messageId}`,\n            type: `${protocolId}/${messageType}`,\n            acked: ackedMessageId,\n            reqAck: requiresAck,\n            duplicate: isDuplicate,\n            payload: payload,\n        });\n    }\n\n    private static encodePayloadHeader({\n        exchangeId,\n        isInitiatorMessage,\n        messageType,\n        protocolId,\n        requiresAck,\n        ackedMessageId: ackedMessageCounter,\n    }: PayloadHeader) {\n        const writer = new DataWriter(Endian.Little);\n        const vendorId = (protocolId & 0xffff0000) >> 16;\n        const flags =\n            (isInitiatorMessage ? PayloadHeaderFlag.IsInitiatorMessage : 0) |\n            (ackedMessageCounter !== undefined ? PayloadHeaderFlag.IsAckMessage : 0) |\n            (requiresAck ? PayloadHeaderFlag.RequiresAck : 0) |\n            (vendorId !== COMMON_VENDOR_ID ? PayloadHeaderFlag.HasVendorId : 0);\n\n        writer.writeUInt8(flags);\n        writer.writeUInt8(messageType);\n        writer.writeUInt16(exchangeId);\n        vendorId !== COMMON_VENDOR_ID ? writer.writeUInt32(protocolId) : writer.writeUInt16(protocolId);\n        if (ackedMessageCounter !== undefined) writer.writeUInt32(ackedMessageCounter);\n        return writer.toByteArray();\n    }\n}\n"],
  "mappings": "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",
  "names": ["SessionType", "PacketHeaderFlag", "PayloadHeaderFlag", "SecurityFlag"]
}
