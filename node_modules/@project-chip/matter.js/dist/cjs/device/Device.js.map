{
  "version": 3,
  "sources": ["../../../src/device/Device.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Cluster } from \"../cluster/Cluster.js\";\nimport { ClusterType } from \"../cluster/ClusterType.js\";\nimport { ClusterClientObj, isClusterClient } from \"../cluster/client/ClusterClientTypes.js\";\nimport { Binding } from \"../cluster/definitions/BindingCluster.js\";\nimport { BridgedDeviceBasicInformationCluster } from \"../cluster/definitions/BridgedDeviceBasicInformationCluster.js\";\nimport { ClusterServer } from \"../cluster/server/ClusterServer.js\";\nimport { ClusterServerHandlers, ClusterServerObj, isClusterServer } from \"../cluster/server/ClusterServerTypes.js\";\nimport { ImplementationError, NotImplementedError } from \"../common/MatterError.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { AtLeastOne } from \"../util/Array.js\";\nimport { HandlerFunction, NamedHandler } from \"../util/NamedHandler.js\";\nimport { DeviceClasses, DeviceTypeDefinition, DeviceTypes } from \"./DeviceTypes.js\";\nimport { Endpoint, EndpointOptions } from \"./Endpoint.js\";\n\n/**\n * Utility function to wrap externally registered command handlers into the internal command handler and make sure\n * the custom ones are used if defined\n *\n * @param commandHandler Command handler instance with the registered handlers\n * @param handler Internal handlers instance to wrap the external handler into\n */\nexport const WrapCommandHandler = <C extends Cluster<any, any, any, any, any>>(\n    handler: ClusterServerHandlers<C>,\n    commandHandler?: NamedHandler<any>,\n): ClusterServerHandlers<C> => {\n    if (commandHandler === undefined) {\n        return handler;\n    }\n    const mergedHandler = {} as any;\n    for (const key in handler) {\n        if (\n            key.endsWith(\"AttributeGetter\") ||\n            key.endsWith(\"AttributeSetter\") ||\n            key.endsWith(\"AttributeValidator\") ||\n            key === \"initializeClusterServer\" ||\n            key === \"destroyClusterServer\"\n        ) {\n            mergedHandler[key] = (handler as any)[key];\n            continue;\n        }\n        mergedHandler[key] = async (...args: any[]) => {\n            if (commandHandler.hasHandler(key)) {\n                return await commandHandler.executeHandler(key, ...args);\n            }\n            return await (handler as any)[key](...args);\n        };\n    }\n    return mergedHandler as ClusterServerHandlers<C>;\n};\n\n/**\n * Temporary used device class for paired devices until we added a layer to choose the right specialized device class\n * based on the device classes and features of the paired device\n */\nexport class PairedDevice extends Endpoint {\n    private readonly declineAddingMoreClusters: boolean;\n    /**\n     * Create a new PairedDevice instance. All data are automatically parsed from the paired device!\n     *\n     * @param definition DeviceTypeDefinitions of the paired device as reported by the device\n     * @param clusters Clusters of the paired device as reported by the device\n     * @param endpointId Endpoint ID of the paired device as reported by the device\n     */\n    constructor(\n        definition: AtLeastOne<DeviceTypeDefinition>,\n        clusters: (ClusterServerObj | ClusterClientObj)[] = [],\n        endpointId: EndpointNumber,\n    ) {\n        super(definition, { endpointId });\n        clusters.forEach(cluster => {\n            if (isClusterServer(cluster)) {\n                this.addClusterServer(cluster);\n            } else if (isClusterClient(cluster)) {\n                this.addClusterClient(cluster);\n            }\n        });\n\n        this.declineAddingMoreClusters = true;\n    }\n\n    /**\n     * Add cluster servers (used internally only!)\n     * @deprecated PairedDevice does not support adding additional clusters\n     */\n    override addClusterServer<const T extends ClusterType>(cluster: ClusterServerObj<T>) {\n        if (this.declineAddingMoreClusters) {\n            throw new ImplementationError(\"PairedDevice does not support adding additional clusters\");\n        }\n        return super.addClusterServer(cluster);\n    }\n\n    /**\n     * Add cluster clients (used internally only!)\n     * @deprecated PairedDevice does not support adding additional clusters\n     */\n    override addClusterClient<const T extends ClusterType>(cluster: ClusterClientObj<T>) {\n        if (this.declineAddingMoreClusters) {\n            throw new ImplementationError(\"PairedDevice does not support adding additional clusters\");\n        }\n        return super.addClusterClient(cluster);\n    }\n}\n\n/**\n * Root endpoint of a device. This is used internally and not needed to be instanced by the user.\n */\nexport class RootEndpoint extends Endpoint {\n    /**\n     * Create a new RootEndpoint instance. This is automatically instanced by the CommissioningServer class.\n     */\n    constructor() {\n        super([DeviceTypes.ROOT], { endpointId: EndpointNumber(0) });\n    }\n\n    /**\n     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterServer to get or undefined if not existing\n     */\n    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined {\n        return this.getClusterServer(cluster);\n    }\n\n    /**\n     * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterClient object to add\n     */\n    addRootClusterClient(cluster: ClusterClientObj) {\n        this.addClusterClient(cluster);\n    }\n\n    /**\n     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterClient to get or undefined if not existing\n     */\n    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined {\n        return this.getClusterClient(cluster);\n    }\n}\n\n// TODO Add checks that only allowed clusters are added\n// TODO add \"get adds dummy instance\" when optional and not existing\n// TODO add typing support to know which clusters are available based on required clusters from device type def to be used by getClusterServer/Client\n\n/**\n * Base class for all devices. This class should be extended by all devices.\n */\nexport class Device extends Endpoint {\n    protected commandHandler = new NamedHandler<any>();\n\n    /**\n     * Create a new Device instance.\n     *\n     * @param definition DeviceTypeDefinitions of the device\n     * @param options Optional endpoint options\n     */\n    constructor(definition: DeviceTypeDefinition, options: EndpointOptions = {}) {\n        if (definition.deviceClass === DeviceClasses.Node) {\n            throw new NotImplementedError(\"MatterNode devices are not supported\");\n        }\n        super([definition], options);\n        if (definition.deviceClass === DeviceClasses.Simple || definition.deviceClass === DeviceClasses.Client) {\n            this.addClusterServer(\n                ClusterServer(\n                    Binding.Cluster,\n                    {\n                        binding: [],\n                    },\n                    {},\n                ),\n            );\n        }\n    }\n\n    /**\n     * Method to add command handlers to the device.\n     * The base class do not expose any commands!\n     *\n     * @param command Command name to add a handler for\n     * @param handler Handler function to be executed when the command is received\n     */\n    addCommandHandler(command: never, handler: HandlerFunction) {\n        this.commandHandler.addHandler(command, handler);\n    }\n\n    /**\n     * Method to remove command handlers from the device.\n     * The base class do not expose any commands!\n     *\n     * @param command Command name to remove the handler from\n     * @param handler Handler function to be removed\n     */\n    removeCommandHandler(command: never, handler: HandlerFunction) {\n        this.commandHandler.removeHandler(command, handler);\n    }\n\n    /**\n     * Execute a command handler. Should only be used internally, but cannot be declared as protected officially\n     * because needed public for derived classes.\n     *\n     * @protected\n     * @param command Command name to execute the handler for\n     * @param args Arguments to be passed to the handler\n     */\n    protected async _executeHandler(command: never, ...args: any[]) {\n        return await this.commandHandler.executeHandler(command, ...args);\n    }\n\n    protected createOptionalClusterServer<const T extends ClusterType>(_cluster: T): ClusterServerObj<T> {\n        // TODO: Implement this in upper classes to add optional clusters on the fly\n        throw new ImplementationError(\"createOptionalClusterServer needs to be implemented by derived classes\");\n    }\n\n    protected createOptionalClusterClient<const T extends ClusterType>(_cluster: T): ClusterClientObj<T> {\n        // TODO: Implement this in upper classes to add optional clusters on the fly\n        throw new ImplementationError(\"createOptionalClusterClient needs to be implemented by derived classes\");\n    }\n\n    override getClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined {\n        const clusterServer = super.getClusterServer(cluster);\n        if (clusterServer !== undefined) {\n            return clusterServer;\n        }\n        for (const deviceType of this.deviceTypes) {\n            if (deviceType.optionalServerClusters.includes(cluster.id)) {\n                const clusterServer = this.createOptionalClusterServer(cluster);\n                this.addClusterServer(clusterServer);\n                return clusterServer;\n            }\n        }\n    }\n\n    override getClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined {\n        const clusterClient = super.getClusterClient(cluster);\n        if (clusterClient !== undefined) {\n            return clusterClient;\n        }\n        for (const deviceType of this.deviceTypes) {\n            if (deviceType.optionalClientClusters.includes(cluster.id)) {\n                const clusterClient = this.createOptionalClusterClient(cluster);\n                this.addClusterClient(clusterClient);\n            }\n        }\n    }\n\n    /**\n     * Set the reachability of the device exposed via the bridge. If this is a device inside  a composed device the\n     * reachability needs to be set there.\n     *\n     * @param reachable true if reachable, false otherwise\n     */\n    setBridgedDeviceReachability(reachable: boolean) {\n        const bridgedBasicInformationCluster = this.getClusterServer(BridgedDeviceBasicInformationCluster);\n        if (bridgedBasicInformationCluster === undefined) {\n            throw new ImplementationError(\n                \"The reachability flag can only be set for bridged devices this way. To set the reachability flag for a non-bridged device or for the bridget itself please set it on the CommissioningServer!\",\n            );\n        }\n        bridgedBasicInformationCluster.setReachableAttribute(reachable);\n    }\n}\n"],
  "mappings": "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",
  "names": ["clusterServer", "clusterClient"]
}
