{
  "version": 3,
  "sources": ["../../../src/device/Endpoint.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Attributes, Cluster, Commands, Events } from \"../cluster/Cluster.js\";\nimport { getClusterNameById } from \"../cluster/ClusterHelper.js\";\nimport { ClusterType } from \"../cluster/ClusterType.js\";\nimport { ClusterClientObj } from \"../cluster/client/ClusterClientTypes.js\";\nimport { BasicInformationCluster } from \"../cluster/definitions/BasicInformationCluster.js\";\nimport { BridgedDeviceBasicInformationCluster } from \"../cluster/definitions/BridgedDeviceBasicInformationCluster.js\";\nimport { DescriptorCluster } from \"../cluster/definitions/DescriptorCluster.js\";\nimport { FixedLabelCluster } from \"../cluster/definitions/FixedLabelCluster.js\";\nimport { UserLabelCluster } from \"../cluster/definitions/UserLabelCluster.js\";\nimport { ClusterServer } from \"../cluster/server/ClusterServer.js\";\nimport { ClusterServerObj, asClusterServerInternal } from \"../cluster/server/ClusterServerTypes.js\";\nimport { ImplementationError, InternalError, NotImplementedError } from \"../common/MatterError.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { DeviceTypeId } from \"../datatype/DeviceTypeId.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { EndpointInterface } from \"../endpoint/EndpointInterface.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../schema/BitmapSchema.js\";\nimport { AtLeastOne } from \"../util/Array.js\";\nimport { DeviceTypeDefinition } from \"./DeviceTypes.js\";\n\nexport interface EndpointOptions {\n    endpointId?: EndpointNumber;\n    uniqueStorageKey?: string;\n}\n\nexport class Endpoint implements EndpointInterface {\n    private readonly clusterServers = new Map<ClusterId, ClusterServerObj>();\n    private readonly clusterClients = new Map<ClusterId, ClusterClientObj>();\n    private readonly childEndpoints: Endpoint[] = [];\n    number: EndpointNumber | undefined;\n    uniqueStorageKey: string | undefined;\n    name = \"\";\n    private structureChangedCallback: () => void = () => {\n        /** noop until officially set **/\n    };\n\n    private descriptorCluster: ClusterServerObj<typeof DescriptorCluster>;\n\n    /**\n     * Create a new Endpoint instance.\n     *\n     * @param deviceTypes One or multiple DeviceTypeDefinitions of the endpoint\n     * @param options Options for the endpoint\n     */\n    constructor(\n        protected deviceTypes: AtLeastOne<DeviceTypeDefinition>,\n        options: EndpointOptions = {},\n    ) {\n        this.descriptorCluster = ClusterServer(\n            DescriptorCluster,\n            {\n                deviceTypeList: deviceTypes.map(deviceType => ({\n                    deviceType: deviceType.code,\n                    revision: deviceType.revision,\n                })),\n                serverList: [],\n                clientList: [],\n                partsList: [],\n            },\n            {},\n        );\n        this.addClusterServer(this.descriptorCluster);\n        this.setDeviceTypes(deviceTypes);\n\n        if (options.endpointId !== undefined) {\n            this.number = options.endpointId;\n        }\n        if (options.uniqueStorageKey !== undefined) {\n            this.uniqueStorageKey = options.uniqueStorageKey;\n        }\n    }\n\n    get deviceType(): DeviceTypeId {\n        return this.deviceTypes[0].code;\n    }\n\n    setStructureChangedCallback(callback: () => void) {\n        this.structureChangedCallback = callback;\n        this.childEndpoints.forEach(endpoint => endpoint.setStructureChangedCallback(callback));\n    }\n\n    removeFromStructure() {\n        this.close();\n        this.structureChangedCallback = () => {\n            /** noop **/\n        };\n        this.childEndpoints.forEach(endpoint => endpoint.removeFromStructure());\n    }\n\n    close() {\n        for (const clusterServer of this.clusterServers.values()) {\n            asClusterServerInternal(clusterServer)._close();\n        }\n    }\n\n    getNumber() {\n        if (this.number === undefined) {\n            throw new InternalError(\"Endpoint has not been assigned yet\");\n        }\n        return this.number;\n    }\n\n    addFixedLabel(label: string, value: string) {\n        if (!this.hasClusterServer(FixedLabelCluster)) {\n            this.addClusterServer(\n                ClusterServer(\n                    FixedLabelCluster,\n                    {\n                        labelList: [],\n                    },\n                    {},\n                ),\n            );\n        }\n        const fixedLabelCluster = this.getClusterServer(FixedLabelCluster);\n        const labelList = (fixedLabelCluster?.getLabelListAttribute() ?? []).filter(\n            ({ label: entryLabel }) => entryLabel !== label, // Prevent adding duplicate labels\n        );\n        labelList.push({ label, value });\n        fixedLabelCluster?.setLabelListAttribute(labelList);\n    }\n\n    addUserLabel(label: string, value: string) {\n        if (!this.hasClusterServer(UserLabelCluster)) {\n            this.addClusterServer(\n                ClusterServer(\n                    UserLabelCluster,\n                    {\n                        labelList: [],\n                    },\n                    {},\n                ),\n            );\n        }\n        const userLabelCluster = this.getClusterServer(UserLabelCluster);\n        const labelList = (userLabelCluster?.getLabelListAttribute() ?? []).filter(\n            ({ label: entryLabel }) => entryLabel !== label, // Prevent adding duplicate labels\n        );\n        labelList.push({ label, value });\n        userLabelCluster?.setLabelListAttribute(labelList);\n    }\n\n    addClusterServer<const T extends ClusterType>(cluster: ClusterServerObj<T>) {\n        const currentCluster = this.clusterServers.get(cluster.id);\n        if (currentCluster !== undefined) {\n            asClusterServerInternal(currentCluster)._close();\n        }\n        asClusterServerInternal(cluster)._assignToEndpoint(this);\n        if (cluster.id === DescriptorCluster.id) {\n            this.descriptorCluster = cluster as unknown as ClusterServerObj<typeof DescriptorCluster>;\n        }\n\n        // In ts4 the cast to \"any\" here was unnecessary.  In TS5 the fact that\n        // the string index signature in Attributes and Events doesn't allow\n        // for undefined results in the error:\n        //\n        //   Type 'undefined' is not assignable to type '() => any'\n        //\n        // I'm not sure if I'd classify the old or new behavior as more correct\n        // but the solution would be to add \"| undefined\" to the string index\n        // signature in Attributes and Events, which will force additional\n        // assertions everywhere those interfaces are used.  I'm treating that\n        // as low priority for now\n        this.clusterServers.set(cluster.id, cluster as any);\n\n        this.descriptorCluster.attributes.serverList.init(Array.from(this.clusterServers.keys()).sort((a, b) => a - b));\n        this.structureChangedCallback(); // Inform parent about structure change\n    }\n\n    addClusterClient(cluster: ClusterClientObj) {\n        this.clusterClients.set(cluster.id, cluster);\n        this.descriptorCluster.attributes.clientList.init(Array.from(this.clusterClients.keys()).sort((a, b) => a - b));\n        this.structureChangedCallback(); // Inform parent about structure change\n    }\n\n    // TODO cleanup with id number vs ClusterId\n    // TODO add instance if optional and not existing, maybe get rid of undefined by throwing?\n    getClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined {\n        const clusterServer = this.clusterServers.get(cluster.id);\n        if (clusterServer !== undefined) {\n            // See comment in addClusterServer, this is the inverse of that\n            // issue\n            return clusterServer as unknown as ClusterServerObj<T>;\n        }\n    }\n\n    getClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined {\n        return this.clusterClients.get(cluster.id) as ClusterClientObj<T>;\n    }\n\n    getClusterServerById(clusterId: ClusterId): ClusterServerObj | undefined {\n        return this.clusterServers.get(clusterId);\n    }\n\n    getClusterClientById(clusterId: ClusterId): ClusterClientObj | undefined {\n        return this.clusterClients.get(clusterId);\n    }\n\n    hasClusterServer<\n        F extends BitSchema,\n        SF extends TypeFromPartialBitSchema<F>,\n        A extends Attributes,\n        C extends Commands,\n        E extends Events,\n    >(cluster: Cluster<F, SF, A, C, E>): boolean {\n        return this.clusterServers.has(cluster.id);\n    }\n\n    hasClusterClient<\n        F extends BitSchema,\n        SF extends TypeFromPartialBitSchema<F>,\n        A extends Attributes,\n        C extends Commands,\n        E extends Events,\n    >(cluster: Cluster<F, SF, A, C, E>): boolean {\n        return this.clusterClients.has(cluster.id);\n    }\n\n    getDeviceTypes(): AtLeastOne<DeviceTypeDefinition> {\n        return this.deviceTypes;\n    }\n\n    setDeviceTypes(deviceTypes: AtLeastOne<DeviceTypeDefinition>): void {\n        // Remove duplicates, for now we ignore that there could be different revisions\n        const deviceTypeList = new Map<number, DeviceTypeDefinition>();\n        deviceTypes.forEach(deviceType => deviceTypeList.set(deviceType.code, deviceType));\n        this.deviceTypes = Array.from(deviceTypeList.values()) as AtLeastOne<DeviceTypeDefinition>;\n        this.name = deviceTypes[0].name;\n\n        // Update descriptor cluster\n        this.descriptorCluster.attributes.deviceTypeList.init(\n            this.deviceTypes.map(deviceType => ({\n                deviceType: deviceType.code,\n                revision: deviceType.revision,\n            })),\n        );\n    }\n\n    addChildEndpoint(endpoint: EndpointInterface): void {\n        if (!(endpoint instanceof Endpoint)) {\n            throw new Error(\"Only supported EndpointInterface implementation is Endpoint\");\n        }\n\n        if (endpoint.number !== undefined && this.getChildEndpoint(endpoint.number) !== undefined) {\n            throw new ImplementationError(\n                `Endpoint with id ${endpoint.number} already exists as child from ${this.number}.`,\n            );\n        }\n\n        this.childEndpoints.push(endpoint);\n        endpoint.setStructureChangedCallback(this.structureChangedCallback);\n        this.structureChangedCallback(); // Inform parent about structure change\n    }\n\n    getChildEndpoint(id: EndpointNumber): Endpoint | undefined {\n        return this.childEndpoints.find(endpoint => endpoint.number === id);\n    }\n\n    getChildEndpoints(): Endpoint[] {\n        return this.childEndpoints;\n    }\n\n    protected removeChildEndpoint(endpoint: Endpoint): void {\n        const index = this.childEndpoints.indexOf(endpoint);\n        if (index === -1) {\n            throw new ImplementationError(`Provided endpoint for deletion does not exist as child endpoint.`);\n        }\n        this.childEndpoints.splice(index, 1);\n        endpoint.removeFromStructure();\n        this.structureChangedCallback(); // Inform parent about structure change\n    }\n\n    determineUniqueID(): string | undefined {\n        // if the options in constructor contained a custom uniqueStorageKey, use this\n        if (this.uniqueStorageKey !== undefined) {\n            return `custom_${this.uniqueStorageKey}`;\n        }\n        // Else we check if we have a basic information cluster or bridged device basic information cluster and\n        // use the uniqueId or serial number, if provided\n        const basicInformationCluster =\n            this.getClusterServer(BasicInformationCluster) ??\n            this.getClusterServer(BridgedDeviceBasicInformationCluster);\n        if (basicInformationCluster !== undefined) {\n            const uniqueId = basicInformationCluster.getUniqueIdAttribute?.();\n            if (uniqueId !== undefined) {\n                return `unique_${uniqueId}`;\n            }\n            const serialNumber = basicInformationCluster.getSerialNumberAttribute?.();\n            if (serialNumber !== undefined) {\n                return `serial_${serialNumber}`;\n            }\n        }\n    }\n\n    public verifyRequiredClusters(): void {\n        this.deviceTypes.forEach(deviceType => {\n            deviceType.requiredServerClusters?.forEach(clusterId => {\n                if (!this.clusterServers.has(clusterId)) {\n                    const clusterName = getClusterNameById(clusterId);\n                    throw new ImplementationError(\n                        `Device type ${deviceType.name} (0x${deviceType.code.toString(\n                            16,\n                        )}) requires cluster server ${clusterName}(0x${clusterId.toString(\n                            16,\n                        )}) but it is not present on endpoint ${this.number}`,\n                    );\n                }\n            });\n\n            if (this.clusterClients.size > 0) {\n                // TODO remove once supported\n                throw new NotImplementedError(`Devices with client clusters are not supported yet`);\n            }\n            deviceType.requiredClientClusters?.forEach(clusterId => {\n                const clusterName = getClusterNameById(clusterId);\n                if (!this.clusterClients.has(clusterId)) {\n                    throw new ImplementationError(\n                        `Device type ${deviceType.name} (0x${deviceType.code.toString(\n                            16,\n                        )}) requires cluster client ${clusterName}(0x${clusterId.toString(\n                            16,\n                        )}) but it is not present on endpoint ${this.number}`,\n                    );\n                }\n            });\n        });\n    }\n\n    getAllClusterServers(): ClusterServerObj[] {\n        return Array.from(this.clusterServers.values());\n    }\n\n    getAllClusterClients(): ClusterClientObj[] {\n        return Array.from(this.clusterClients.values());\n    }\n\n    updatePartsList() {\n        const newPartsList = new Array<EndpointNumber>();\n\n        for (const child of this.childEndpoints) {\n            const childPartsList = child.updatePartsList();\n\n            if (child.number === undefined) {\n                throw new InternalError(`Child endpoint has no id, cannot add to parts list`);\n            }\n\n            newPartsList.push(EndpointNumber(child.number));\n            newPartsList.push(...childPartsList);\n        }\n\n        this.descriptorCluster.attributes.partsList.setLocal(newPartsList);\n\n        return newPartsList;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
