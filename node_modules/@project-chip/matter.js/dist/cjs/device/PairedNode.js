"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PairedNode_exports = {};
__export(PairedNode_exports, {
  NodeStateInformation: () => NodeStateInformation,
  PairedNode: () => PairedNode
});
module.exports = __toCommonJS(PairedNode_exports);
var import_ClusterClientTypes = require("../cluster/client/ClusterClientTypes.js");
var import_ClusterHelper = require("../cluster/ClusterHelper.js");
var import_ClusterClient = require("../cluster/client/ClusterClient.js");
var import_DescriptorCluster = require("../cluster/definitions/DescriptorCluster.js");
var import_OperationalCredentialsCluster = require("../cluster/definitions/OperationalCredentialsCluster.js");
var import_ClusterServer = require("../cluster/server/ClusterServer.js");
var import_ClusterServerTypes = require("../cluster/server/ClusterServerTypes.js");
var import_MatterError = require("../common/MatterError.js");
var import_EndpointNumber = require("../datatype/EndpointNumber.js");
var import_Logger = require("../log/Logger.js");
var import_AttributeDataDecoder = require("../protocol/interaction/AttributeDataDecoder.js");
var import_Aggregator = require("./Aggregator.js");
var import_ComposedDevice = require("./ComposedDevice.js");
var import_Device = require("./Device.js");
var import_BasicInformationCluster = require("../cluster/definitions/BasicInformationCluster.js");
var import_definitions = require("../cluster/definitions/index.js");
var import_Crypto = require("../crypto/Crypto.js");
var import_Diagnostic = require("../log/Diagnostic.js");
var import_StatusCode = require("../protocol/interaction/StatusCode.js");
var import_PairingCodeSchema = require("../schema/PairingCodeSchema.js");
var import_PaseClient = require("../session/pase/PaseClient.js");
var import_Time = require("../time/Time.js");
var import_DeviceTypes = require("./DeviceTypes.js");
var import_EndpointStructureLogger = require("./EndpointStructureLogger.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("PairedNode");
const STRUCTURE_UPDATE_TIMEOUT_MS = 5e3;
var NodeStateInformation = /* @__PURE__ */ ((NodeStateInformation2) => {
  NodeStateInformation2[NodeStateInformation2["Connected"] = 0] = "Connected";
  NodeStateInformation2[NodeStateInformation2["Disconnected"] = 1] = "Disconnected";
  NodeStateInformation2[NodeStateInformation2["Reconnecting"] = 2] = "Reconnecting";
  NodeStateInformation2[NodeStateInformation2["WaitingForDeviceDiscovery"] = 3] = "WaitingForDeviceDiscovery";
  NodeStateInformation2[NodeStateInformation2["StructureChanged"] = 4] = "StructureChanged";
  NodeStateInformation2[NodeStateInformation2["Decommissioned"] = 5] = "Decommissioned";
  return NodeStateInformation2;
})(NodeStateInformation || {});
class PairedNode {
  constructor(nodeId, commissioningController, options = {}, reconnectInteractionClient, assignDisconnectedHandler) {
    this.nodeId = nodeId;
    this.commissioningController = commissioningController;
    this.options = options;
    this.reconnectInteractionClient = reconnectInteractionClient;
    assignDisconnectedHandler(async () => {
      logger.info(
        `Node ${this.nodeId}: Session disconnected${this.connectionState !== 1 /* Disconnected */ ? ", trying to reconnect ..." : ""}`
      );
      if (this.connectionState === 0 /* Connected */) {
        await this.reconnect();
      }
    });
  }
  endpoints = /* @__PURE__ */ new Map();
  interactionClient;
  reconnectDelayTimer = import_Time.Time.getTimer(
    "Reconnect delay",
    STRUCTURE_UPDATE_TIMEOUT_MS,
    async () => await this.reconnect()
  );
  updateEndpointStructureTimer = import_Time.Time.getTimer(
    "Endpoint structure update",
    STRUCTURE_UPDATE_TIMEOUT_MS,
    async () => await this.updateEndpointStructure()
  );
  connectionState = 1 /* Disconnected */;
  static async create(nodeId, commissioningController, options = {}, reconnectInteractionClient, assignDisconnectedHandler) {
    const node = new PairedNode(
      nodeId,
      commissioningController,
      options,
      reconnectInteractionClient,
      assignDisconnectedHandler
    );
    await node.initialize();
    return node;
  }
  get isConnected() {
    return this.connectionState === 0 /* Connected */;
  }
  setConnectionState(state) {
    if (this.connectionState === state || this.connectionState === 1 /* Disconnected */ && state === 2 /* Reconnecting */ || this.connectionState === 3 /* WaitingForDeviceDiscovery */ && state === 2 /* Reconnecting */)
      return;
    this.connectionState = state;
    this.options.stateInformationCallback?.(this.nodeId, state);
  }
  /**
   * Force a reconnection to the device. This method is mainly used internally to reconnect after the active session
   * was closed or the device went offline and was detected as being online again.
   */
  async reconnect() {
    this.setConnectionState(2 /* Reconnecting */);
    while (true) {
      if (this.interactionClient !== void 0) {
        this.interactionClient.close();
        this.interactionClient = void 0;
      }
      try {
        await this.initialize();
        return;
      } catch (error) {
        import_MatterError.MatterError.accept(error);
        if (this.connectionState === 1 /* Disconnected */) {
          return;
        }
        logger.info(`Node ${this.nodeId}: Error waiting for device rediscovery`, error);
        this.setConnectionState(3 /* WaitingForDeviceDiscovery */);
      }
    }
  }
  /** Ensure that the node is connected by creating a new InteractionClient if needed. */
  async ensureConnection() {
    if (this.interactionClient !== void 0) return this.interactionClient;
    this.interactionClient = await this.reconnectInteractionClient();
    return this.interactionClient;
  }
  /**
   * Initialize the node after the InteractionClient was created and to subscribe attributes and events if requested.
   */
  async initialize() {
    const interactionClient = await this.ensureConnection();
    const { autoSubscribe, attributeChangedCallback, eventTriggeredCallback } = this.options;
    if (autoSubscribe !== false) {
      const initialSubscriptionData = await this.subscribeAllAttributesAndEvents({
        ignoreInitialTriggers: true,
        attributeChangedCallback: (data) => attributeChangedCallback?.(this.nodeId, data),
        eventTriggeredCallback: (data) => eventTriggeredCallback?.(this.nodeId, data)
      });
      if (initialSubscriptionData.attributeReports === void 0) {
        throw new import_MatterError.InternalError("No attribute reports received when subscribing to all values!");
      }
      await this.initializeEndpointStructure(initialSubscriptionData.attributeReports ?? []);
      const rootDescriptorCluster = this.getRootClusterClient(import_DescriptorCluster.DescriptorCluster);
      rootDescriptorCluster?.addPartsListAttributeListener(() => {
        logger.info(`Node ${this.nodeId}: PartsList changed, reinitializing endpoint structure ...`);
        this.updateEndpointStructureTimer.stop().start();
      });
    } else {
      const allClusterAttributes = await interactionClient.getAllAttributes();
      await this.initializeEndpointStructure(allClusterAttributes);
    }
    this.setConnectionState(0 /* Connected */);
  }
  /**
   * Request the current InteractionClient for custom special case interactions with the device. Usually the
   * ClusterClients of the Devices of the node should be used instead.
   */
  async getInteractionClient() {
    return await this.ensureConnection();
  }
  /** Method to log the structure of this node with all endpoint and clusters. */
  logStructure(options) {
    const rootEndpoint = this.endpoints.get((0, import_EndpointNumber.EndpointNumber)(0));
    if (rootEndpoint === void 0) {
      logger.info(`Node ${this.nodeId} has not yet been initialized!`);
      return;
    }
    (0, import_EndpointStructureLogger.logEndpoint)(rootEndpoint, options);
  }
  /**
   * Subscribe to all attributes and events of the device. Unless setting the Controller property autoSubscribe to
   * false this is executed automatically. Alternatively you can manually subscribe by calling this method.
   */
  async subscribeAllAttributesAndEvents(options) {
    options = options ?? {};
    const { attributeChangedCallback, eventTriggeredCallback } = options;
    let { ignoreInitialTriggers = false } = options;
    const interactionClient = await this.ensureConnection();
    const initialSubscriptionData = await interactionClient.subscribeAllAttributesAndEvents({
      isUrgent: true,
      minIntervalFloorSeconds: this.options.subscribeMinIntervalFloorSeconds ?? 0,
      maxIntervalCeilingSeconds: this.options.subscribeMaxIntervalCeilingSeconds ?? 60,
      attributeListener: (data) => {
        const {
          path: { endpointId, clusterId, attributeId },
          value
        } = data;
        if (ignoreInitialTriggers) return;
        const device = this.endpoints.get(endpointId);
        if (device === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received attribute update for unknown endpoint ${endpointId}!`
          );
          return;
        }
        const cluster = device.getClusterClientById(clusterId);
        if (cluster === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received attribute update for unknown cluster ${import_Diagnostic.Diagnostic.hex(
              clusterId
            )} on endpoint ${endpointId}!`
          );
          return;
        }
        logger.debug(
          `Node ${this.nodeId} Trigger attribute update for ${endpointId}.${cluster.name}.${attributeId} to ${import_Logger.Logger.toJSON(
            value
          )}`
        );
        (0, import_ClusterClientTypes.asClusterClientInternal)(cluster)._triggerAttributeUpdate(attributeId, value);
        if (attributeChangedCallback !== void 0) {
          attributeChangedCallback(data);
        }
      },
      eventListener: (data) => {
        const {
          path: { endpointId, clusterId, eventId },
          events
        } = data;
        if (ignoreInitialTriggers) return;
        const device = this.endpoints.get(endpointId);
        if (device === void 0) {
          logger.info(`Node ${this.nodeId} Ignoring received event for unknown endpoint ${endpointId}!`);
          return;
        }
        const cluster = device.getClusterClientById(clusterId);
        if (cluster === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received event for unknown cluster ${import_Diagnostic.Diagnostic.hex(
              clusterId
            )} on endpoint ${endpointId}!`
          );
          return;
        }
        logger.debug(
          `Node ${this.nodeId} Trigger event update for ${endpointId}.${cluster.name}.${eventId} for ${events.length} events`
        );
        (0, import_ClusterClientTypes.asClusterClientInternal)(cluster)._triggerEventUpdate(eventId, events);
        if (eventTriggeredCallback !== void 0) {
          eventTriggeredCallback(data);
        }
        if (clusterId === import_BasicInformationCluster.BasicInformation.Cluster.id && eventId === import_BasicInformationCluster.BasicInformation.Cluster.events.shutDown.id) {
          this.handleNodeShutdown().catch(
            (error) => logger.warn(`Node ${this.nodeId}: Error handling node shutdown`, error)
          );
        }
      },
      updateTimeoutHandler: async () => {
        logger.info(`Node ${this.nodeId}: Subscription update not received ...`);
        try {
          await this.subscribeAllAttributesAndEvents({ ...options, ignoreInitialTriggers: false });
        } catch (error) {
          logger.info(`Node ${this.nodeId}: Error resubscribing to all attributes and events`, error);
          this.interactionClient = void 0;
        }
      }
    });
    ignoreInitialTriggers = false;
    return initialSubscriptionData;
  }
  /** Handles a node shutDown event (if supported by the node and received). */
  async handleNodeShutdown() {
    logger.info(`Node ${this.nodeId}: Node shutdown detected, trying to reconnect ...`);
    if (!this.reconnectDelayTimer.isRunning) {
      this.reconnectDelayTimer.start();
    }
    this.setConnectionState(2 /* Reconnecting */);
  }
  async updateEndpointStructure() {
    const interactionClient = await this.ensureConnection();
    const allClusterAttributes = await interactionClient.getAllAttributes();
    await this.initializeEndpointStructure(allClusterAttributes, true);
    this.options.stateInformationCallback?.(this.nodeId, 4 /* StructureChanged */);
  }
  /** Reads all data from the device and create a device object structure out of it. */
  async initializeEndpointStructure(allClusterAttributes, updateStructure = false) {
    const interactionClient = await this.ensureConnection();
    const allData = (0, import_AttributeDataDecoder.structureReadAttributeDataToClusterObject)(allClusterAttributes);
    if (updateStructure) {
      const endpointsToRemove = new Set(this.endpoints.keys());
      for (const [endpointId] of Object.entries(allData)) {
        const endpointIdNumber = (0, import_EndpointNumber.EndpointNumber)(parseInt(endpointId));
        if (this.endpoints.has(endpointIdNumber)) {
          logger.debug("Retaining device", endpointId);
          endpointsToRemove.delete(endpointIdNumber);
        }
      }
      for (const endpointId of endpointsToRemove.values()) {
        logger.debug("Removing device", endpointId);
        this.endpoints.get(endpointId)?.removeFromStructure();
        this.endpoints.delete(endpointId);
      }
    } else {
      this.endpoints.clear();
    }
    const partLists = /* @__PURE__ */ new Map();
    for (const [endpointId, clusters] of Object.entries(allData)) {
      const endpointIdNumber = (0, import_EndpointNumber.EndpointNumber)(parseInt(endpointId));
      const descriptorData = clusters[import_DescriptorCluster.DescriptorCluster.id];
      partLists.set(endpointIdNumber, descriptorData.partsList);
      if (this.endpoints.has(endpointIdNumber)) {
        continue;
      }
      logger.debug("Creating device", endpointId, import_Logger.Logger.toJSON(clusters));
      this.endpoints.set(endpointIdNumber, this.createDevice(endpointIdNumber, clusters, interactionClient));
    }
    this.structureEndpoints(partLists);
  }
  /** Bring the endpoints in a structure based on their partsList attribute. */
  structureEndpoints(partLists) {
    logger.debug(`Node ${this.nodeId}: Endpoints from PartsLists`, import_Logger.Logger.toJSON(Array.from(partLists.entries())));
    const endpointUsages = {};
    Array.from(partLists.entries()).forEach(
      ([parent, partsList]) => partsList.forEach((endPoint) => {
        endpointUsages[endPoint] = endpointUsages[endPoint] || [];
        endpointUsages[endPoint].push(parent);
      })
    );
    logger.debug(`Node ${this.nodeId}: Endpoint usages`, import_Logger.Logger.toJSON(endpointUsages));
    while (true) {
      const singleUsageEndpoints = Object.entries(endpointUsages).filter(([_, usages]) => usages.length === 1);
      if (singleUsageEndpoints.length === 0) {
        if (Object.entries(endpointUsages).length)
          throw new import_MatterError.InternalError(`Endpoint structure for Node ${this.nodeId} could not be parsed!`);
        break;
      }
      logger.debug(`Node ${this.nodeId}: Processing Endpoint ${import_Logger.Logger.toJSON(singleUsageEndpoints)}`);
      const idsToCleanup = {};
      singleUsageEndpoints.forEach(([childId, usages]) => {
        const childEndpointId = (0, import_EndpointNumber.EndpointNumber)(parseInt(childId));
        const childEndpoint = this.endpoints.get(childEndpointId);
        const parentEndpoint = this.endpoints.get(usages[0]);
        if (childEndpoint === void 0 || parentEndpoint === void 0) {
          throw new import_MatterError.InternalError(`Node ${this.nodeId}: Endpoint not found!`);
        }
        if (parentEndpoint.getChildEndpoint(childEndpointId) === void 0) {
          logger.debug(
            `Node ${this.nodeId}: Endpoint structure: Child: ${childEndpointId} -> Parent: ${parentEndpoint.number}`
          );
          parentEndpoint.addChildEndpoint(childEndpoint);
        }
        delete endpointUsages[(0, import_EndpointNumber.EndpointNumber)(parseInt(childId))];
        idsToCleanup[usages[0]] = true;
      });
      logger.debug(`Node ${this.nodeId}: Endpoint data Cleanup`, import_Logger.Logger.toJSON(idsToCleanup));
      Object.keys(idsToCleanup).forEach((idToCleanup) => {
        Object.keys(endpointUsages).forEach((id) => {
          const usageId = (0, import_EndpointNumber.EndpointNumber)(parseInt(id));
          endpointUsages[usageId] = endpointUsages[usageId].filter(
            (endpointId) => endpointId !== parseInt(idToCleanup)
          );
          if (!endpointUsages[usageId].length) {
            delete endpointUsages[usageId];
          }
        });
      });
    }
  }
  /**
   * Create a device object from the data read from the device.
   *
   * @param endpointId Endpoint ID
   * @param data Data of all clusters read from the device
   * @param interactionClient InteractionClient to use for the device
   * @private
   */
  createDevice(endpointId, data, interactionClient) {
    const descriptorData = data[import_DescriptorCluster.DescriptorCluster.id];
    const deviceTypes = descriptorData.deviceTypeList.flatMap(({ deviceType, revision }) => {
      const deviceTypeDefinition = (0, import_DeviceTypes.getDeviceTypeDefinitionByCode)(deviceType);
      if (deviceTypeDefinition === void 0) {
        logger.info(
          `NodeId ${this.nodeId}: Device type with code ${deviceType} not known, use generic replacement.`
        );
        return (0, import_DeviceTypes.UnknownDeviceType)(deviceType);
      }
      if (deviceTypeDefinition.revision < revision) {
        logger.debug(
          `NodeId ${this.nodeId}: Device type with code ${deviceType} and revision ${revision} not supported, some data might be unknown.`
        );
      }
      return deviceTypeDefinition;
    });
    if (deviceTypes.length === 0) {
      logger.info(`NodeId ${this.nodeId}: No device type found for endpoint ${endpointId}, ignore`);
      throw new import_MatterError.MatterError(`NodeId ${this.nodeId}: No device type found for endpoint`);
    }
    const endpointClusters = Array();
    for (const clusterId of descriptorData.serverList) {
      const cluster = (0, import_ClusterHelper.getClusterById)(clusterId);
      const clusterClient = (0, import_ClusterClient.ClusterClient)(cluster, endpointId, interactionClient, data[clusterId]);
      endpointClusters.push(clusterClient);
    }
    for (const clusterId of descriptorData.clientList) {
      const cluster = (0, import_ClusterHelper.getClusterById)(clusterId);
      const clusterData = data[clusterId] ?? {};
      endpointClusters.push(
        (0, import_ClusterServer.ClusterServer)(
          cluster,
          /*clusterData.featureMap,*/
          clusterData,
          {},
          void 0,
          true
        )
      );
    }
    if (endpointId === 0) {
      const rootEndpoint = new import_Device.RootEndpoint();
      rootEndpoint.setDeviceTypes(deviceTypes);
      endpointClusters.forEach((cluster) => {
        if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
          rootEndpoint.addClusterServer(cluster);
        } else if ((0, import_ClusterClientTypes.isClusterClient)(cluster)) {
          rootEndpoint.addClusterClient(cluster);
        }
      });
      return rootEndpoint;
    } else if (deviceTypes.find((deviceType) => deviceType.code === import_DeviceTypes.DeviceTypes.AGGREGATOR.code) !== void 0) {
      const aggregator = new import_Aggregator.Aggregator([], { endpointId });
      aggregator.setDeviceTypes(deviceTypes);
      endpointClusters.forEach((cluster) => {
        if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
          aggregator.addClusterServer(cluster);
        } else if ((0, import_ClusterClientTypes.isClusterClient)(cluster)) {
          aggregator.addClusterClient(cluster);
        }
      });
      return aggregator;
    } else {
      if (descriptorData.partsList.length > 0) {
        const composedDevice = new import_ComposedDevice.ComposedDevice(deviceTypes[0], [], { endpointId });
        composedDevice.setDeviceTypes(deviceTypes);
        endpointClusters.forEach((cluster) => {
          if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
            composedDevice.addClusterServer(cluster);
          } else if ((0, import_ClusterClientTypes.isClusterClient)(cluster)) {
            composedDevice.addClusterClient(cluster);
          }
        });
        return composedDevice;
      } else {
        return new import_Device.PairedDevice(deviceTypes, endpointClusters, endpointId);
      }
    }
  }
  /** Returns the functional devices/endpoints (those below the Root Endpoint) known for this node. */
  getDevices() {
    return this.endpoints.get((0, import_EndpointNumber.EndpointNumber)(0))?.getChildEndpoints() ?? [];
  }
  /** Returns the device/endpoint with the given endpoint ID. */
  getDeviceById(endpointId) {
    return this.endpoints.get((0, import_EndpointNumber.EndpointNumber)(endpointId));
  }
  getRootEndpoint() {
    return this.getDeviceById(0);
  }
  /** De-Commission (unpair) the device from this controller by removing the fabric from the device. */
  async decommission() {
    if (!this.commissioningController.isNodeCommissioned(this.nodeId)) {
      throw new import_MatterError.ImplementationError(`This Node ${this.nodeId} is not commissioned.`);
    }
    const operationalCredentialsCluster = this.getRootClusterClient(import_OperationalCredentialsCluster.OperationalCredentials.Cluster);
    if (operationalCredentialsCluster === void 0) {
      throw new import_MatterError.ImplementationError(`OperationalCredentialsCluster for node ${this.nodeId} not found.`);
    }
    const fabricIndex = await operationalCredentialsCluster.getCurrentFabricIndexAttribute(true);
    logger.debug(`Removing node ${this.nodeId} by removing fabric ${fabricIndex} on the node.`);
    const result = await operationalCredentialsCluster.commands.removeFabric({ fabricIndex });
    if (result.statusCode !== import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.Ok) {
      throw new import_MatterError.MatterError(
        `Removing node ${this.nodeId} failed with status ${result.statusCode} "${result.debugText}".`
      );
    }
    this.setConnectionState(1 /* Disconnected */);
    this.options.stateInformationCallback?.(this.nodeId, 5 /* Decommissioned */);
    await this.commissioningController.removeNode(this.nodeId, false);
  }
  /** Opens a Basic Commissioning Window (uses the original Passcode printed on the device) with the device. */
  async openBasicCommissioningWindow(commissioningTimeout = 900) {
    const adminCommissioningCluster = this.getRootClusterClient(import_definitions.AdministratorCommissioning.Cluster.with("Basic"));
    if (adminCommissioningCluster === void 0) {
      throw new import_MatterError.ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);
    }
    if (adminCommissioningCluster.supportedFeatures.basic === false) {
      throw new import_MatterError.ImplementationError(
        `AdministratorCommissioningCluster for node ${this.nodeId} does not support basic commissioning.`
      );
    }
    try {
      await adminCommissioningCluster.commands.revokeCommissioning();
    } catch (error) {
      if (!import_StatusCode.StatusResponseError.is(error, import_StatusCode.StatusCode.Failure) || error.clusterCode !== import_definitions.AdministratorCommissioning.StatusCode.WindowNotOpen) {
        throw error;
      }
    }
    await adminCommissioningCluster.commands.openBasicCommissioningWindow({ commissioningTimeout });
  }
  /** Opens an Enhanced Commissioning Window (uses a generated random Passcode) with the device. */
  async openEnhancedCommissioningWindow(commissioningTimeout = 900) {
    const adminCommissioningCluster = this.getRootClusterClient(import_definitions.AdministratorCommissioning.Cluster);
    if (adminCommissioningCluster === void 0) {
      throw new import_MatterError.ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);
    }
    try {
      await adminCommissioningCluster.commands.revokeCommissioning();
    } catch (error) {
      if (!import_StatusCode.StatusResponseError.is(error, import_StatusCode.StatusCode.Failure) || error.clusterCode !== import_definitions.AdministratorCommissioning.StatusCode.WindowNotOpen) {
        throw error;
      }
    }
    const basicInformationCluster = this.getRootClusterClient(import_BasicInformationCluster.BasicInformation.Cluster);
    if (basicInformationCluster == void 0) {
      throw new import_MatterError.ImplementationError(`BasicInformationCluster for node ${this.nodeId} not found.`);
    }
    const vendorId = await basicInformationCluster.getVendorIdAttribute();
    const productId = await basicInformationCluster.getProductIdAttribute();
    const discriminator = import_PaseClient.PaseClient.generateRandomDiscriminator();
    const passcode = import_PaseClient.PaseClient.generateRandomPasscode();
    const salt = import_Crypto.Crypto.get().getRandomData(32);
    const iterations = 1e3;
    const pakePasscodeVerifier = await import_PaseClient.PaseClient.generatePakePasscodeVerifier(passcode, {
      iterations,
      salt
    });
    await adminCommissioningCluster.commands.openCommissioningWindow({
      commissioningTimeout,
      pakePasscodeVerifier,
      salt,
      iterations,
      discriminator
    });
    const qrPairingCode = import_PairingCodeSchema.QrPairingCodeCodec.encode([
      {
        version: 0,
        vendorId,
        productId,
        flowType: import_PairingCodeSchema.CommissioningFlowType.Standard,
        discriminator,
        passcode,
        discoveryCapabilities: import_PairingCodeSchema.DiscoveryCapabilitiesSchema.encode({
          onIpNetwork: true
        })
      }
    ]);
    return {
      manualPairingCode: import_PairingCodeSchema.ManualPairingCodeCodec.encode({
        discriminator,
        passcode
      }),
      qrPairingCode
    };
  }
  async disconnect() {
    this.close();
    await this.commissioningController.disconnectNode(this.nodeId);
  }
  close() {
    this.interactionClient?.close();
    this.setConnectionState(1 /* Disconnected */);
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getRootClusterServer(cluster) {
    return this.endpoints.get((0, import_EndpointNumber.EndpointNumber)(0))?.getClusterServer(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getRootClusterClient(cluster) {
    return this.endpoints.get((0, import_EndpointNumber.EndpointNumber)(0))?.getClusterClient(cluster);
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId EndpointNumber to get the cluster from
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getClusterServerForDevice(endpointId, cluster) {
    return this.getDeviceById(endpointId)?.getClusterServer(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId EndpointNumber to get the cluster from
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getClusterClientForDevice(endpointId, cluster) {
    return this.getDeviceById(endpointId)?.getClusterClient(cluster);
  }
}
//# sourceMappingURL=PairedNode.js.map
