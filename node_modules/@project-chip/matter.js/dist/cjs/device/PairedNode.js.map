{
  "version": 3,
  "sources": ["../../../src/device/PairedNode.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CommissioningController } from \"../CommissioningController.js\";\nimport { Attributes } from \"../cluster/Cluster.js\";\nimport { ClusterClientObj, asClusterClientInternal, isClusterClient } from \"../cluster/client/ClusterClientTypes.js\";\n\nimport { getClusterById } from \"../cluster/ClusterHelper.js\";\nimport { ClusterClient } from \"../cluster/client/ClusterClient.js\";\nimport { DescriptorCluster } from \"../cluster/definitions/DescriptorCluster.js\";\nimport { OperationalCredentials } from \"../cluster/definitions/OperationalCredentialsCluster.js\";\nimport { ClusterServer } from \"../cluster/server/ClusterServer.js\";\nimport {\n    AttributeInitialValues,\n    AttributeServerValues,\n    ClusterServerObj,\n    isClusterServer,\n} from \"../cluster/server/ClusterServerTypes.js\";\nimport { ImplementationError, InternalError, MatterError } from \"../common/MatterError.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { EndpointNumber } from \"../datatype/EndpointNumber.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport {\n    DecodedAttributeReportValue,\n    structureReadAttributeDataToClusterObject,\n} from \"../protocol/interaction/AttributeDataDecoder.js\";\nimport { InteractionClient } from \"../protocol/interaction/InteractionClient.js\";\nimport { AtLeastOne } from \"../util/Array.js\";\nimport { Aggregator } from \"./Aggregator.js\";\nimport { ComposedDevice } from \"./ComposedDevice.js\";\nimport { PairedDevice, RootEndpoint } from \"./Device.js\";\n\nimport { ClusterType } from \"../cluster/ClusterType.js\";\nimport { BasicInformation } from \"../cluster/definitions/BasicInformationCluster.js\";\nimport { AdministratorCommissioning } from \"../cluster/definitions/index.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { EndpointInterface } from \"../endpoint/EndpointInterface.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { DecodedEventReportValue } from \"../protocol/interaction/EventDataDecoder.js\";\nimport { StatusCode, StatusResponseError } from \"../protocol/interaction/StatusCode.js\";\nimport {\n    CommissioningFlowType,\n    DiscoveryCapabilitiesSchema,\n    ManualPairingCodeCodec,\n    QrPairingCodeCodec,\n} from \"../schema/PairingCodeSchema.js\";\nimport { PaseClient } from \"../session/pase/PaseClient.js\";\nimport { Time } from \"../time/Time.js\";\nimport { DeviceTypeDefinition, DeviceTypes, UnknownDeviceType, getDeviceTypeDefinitionByCode } from \"./DeviceTypes.js\";\nimport { Endpoint } from \"./Endpoint.js\";\nimport { EndpointLoggingOptions, logEndpoint } from \"./EndpointStructureLogger.js\";\n\nconst logger = Logger.get(\"PairedNode\");\n\n/** Delay after receiving a changed partList  from a device to update the device structure */\nconst STRUCTURE_UPDATE_TIMEOUT_MS = 5_000; // 5 seconds, TODO: Verify if this value makes sense in practice\n\nexport enum NodeStateInformation {\n    /** Node is connected and all data is up-to-date. */\n    Connected,\n\n    /**\n     * Node is disconnected. Data are stale and interactions will most likely return an error. If controller instance\n     * is still active then the device will be reconnected once it is available again.\n     */\n    Disconnected,\n\n    /** Node is reconnecting. Data are stale. It is yet unknown if the reconnection is successful. */\n    Reconnecting,\n\n    /**\n     * The node could not be connected and the controller is now waiting for a MDNS announcement and tries every 10\n     * minutes to reconnect.\n     */\n    WaitingForDeviceDiscovery,\n\n    /**\n     * Node structure has changed (Endpoints got added or also removed). Data are up-to-date.\n     * This State information will only be fired when the subscribeAllAttributesAndEvents option is set to true.\n     */\n    StructureChanged,\n\n    /**\n     * The node was just Decommissioned.\n     */\n    Decommissioned,\n}\n\nexport type CommissioningControllerNodeOptions = {\n    /**\n     * Unless set to false all events and attributes are subscribed and value changes are reflected in the ClusterClient\n     * instances. With this reading attributes values is mostly looked up in the locally cached data.\n     * Additionally more features like reaction on shutdown event or endpoint structure changes (for bridges) are done\n     * internally automatically.\n     */\n    readonly autoSubscribe?: boolean;\n\n    /** Minimum subscription interval when values are changed. Default it is set to 0s.*/\n    readonly subscribeMinIntervalFloorSeconds?: number;\n\n    /**\n     * Maximum subscription interval when values are changed. This is also used as a keepalive mechanism to validate\n     * that the device is still available. Default it is set to 60s.\n     */\n    readonly subscribeMaxIntervalCeilingSeconds?: number;\n\n    /**\n     * Optional additional callback method which is called for each Attribute change reported by the device. Use this\n     * if subscribing to all relevant attributes is too much effort.\n     */\n    readonly attributeChangedCallback?: (nodeId: NodeId, data: DecodedAttributeReportValue<any>) => void;\n\n    /**\n     * Optional additional callback method which is called for each Event reported by the device. Use this if\n     * subscribing to all relevant events is too much effort.\n     */\n    readonly eventTriggeredCallback?: (nodeId: NodeId, data: DecodedEventReportValue<any>) => void;\n\n    /**\n     * Optional callback method which is called when the state of the node changes. This can be used to detect when\n     * the node goes offline or comes back online.\n     */\n    readonly stateInformationCallback?: (nodeId: NodeId, state: NodeStateInformation) => void;\n};\n\n/**\n * Class to represents one node that is paired/commissioned with the matter.js Controller. Instances are returned by\n * the CommissioningController on commissioning or when connecting.\n */\nexport class PairedNode {\n    private readonly endpoints = new Map<EndpointNumber, Endpoint>();\n    private interactionClient?: InteractionClient;\n    private readonly reconnectDelayTimer = Time.getTimer(\n        \"Reconnect delay\",\n        STRUCTURE_UPDATE_TIMEOUT_MS,\n        async () => await this.reconnect(),\n    );\n    private readonly updateEndpointStructureTimer = Time.getTimer(\n        \"Endpoint structure update\",\n        STRUCTURE_UPDATE_TIMEOUT_MS,\n        async () => await this.updateEndpointStructure(),\n    );\n    private connectionState: NodeStateInformation = NodeStateInformation.Disconnected;\n\n    static async create(\n        nodeId: NodeId,\n        commissioningController: CommissioningController,\n        options: CommissioningControllerNodeOptions = {},\n        reconnectInteractionClient: () => Promise<InteractionClient>,\n        assignDisconnectedHandler: (handler: () => Promise<void>) => void,\n    ) {\n        const node = new PairedNode(\n            nodeId,\n            commissioningController,\n            options,\n            reconnectInteractionClient,\n            assignDisconnectedHandler,\n        );\n        await node.initialize();\n        return node;\n    }\n\n    constructor(\n        readonly nodeId: NodeId,\n        private readonly commissioningController: CommissioningController,\n        private readonly options: CommissioningControllerNodeOptions = {},\n        private readonly reconnectInteractionClient: () => Promise<InteractionClient>,\n        assignDisconnectedHandler: (handler: () => Promise<void>) => void,\n    ) {\n        assignDisconnectedHandler(async () => {\n            logger.info(\n                `Node ${this.nodeId}: Session disconnected${\n                    this.connectionState !== NodeStateInformation.Disconnected ? \", trying to reconnect ...\" : \"\"\n                }`,\n            );\n            if (this.connectionState === NodeStateInformation.Connected) {\n                await this.reconnect();\n            }\n        });\n    }\n\n    get isConnected() {\n        return this.connectionState === NodeStateInformation.Connected;\n    }\n\n    private setConnectionState(state: NodeStateInformation) {\n        if (\n            this.connectionState === state ||\n            (this.connectionState === NodeStateInformation.Disconnected &&\n                state === NodeStateInformation.Reconnecting) ||\n            (this.connectionState === NodeStateInformation.WaitingForDeviceDiscovery &&\n                state === NodeStateInformation.Reconnecting)\n        )\n            return;\n        this.connectionState = state;\n        this.options.stateInformationCallback?.(this.nodeId, state);\n    }\n\n    /**\n     * Force a reconnection to the device. This method is mainly used internally to reconnect after the active session\n     * was closed or the device went offline and was detected as being online again.\n     */\n    async reconnect() {\n        this.setConnectionState(NodeStateInformation.Reconnecting);\n        while (true) {\n            if (this.interactionClient !== undefined) {\n                this.interactionClient.close();\n                this.interactionClient = undefined;\n            }\n            try {\n                await this.initialize();\n                return;\n            } catch (error) {\n                MatterError.accept(error);\n\n                // When we already know that the node is disconnected ignore all MatterErrors and rethrow all others\n                if (this.connectionState === NodeStateInformation.Disconnected) {\n                    return;\n                }\n                logger.info(`Node ${this.nodeId}: Error waiting for device rediscovery`, error);\n                this.setConnectionState(NodeStateInformation.WaitingForDeviceDiscovery);\n            }\n        }\n    }\n\n    /** Ensure that the node is connected by creating a new InteractionClient if needed. */\n    private async ensureConnection() {\n        if (this.interactionClient !== undefined) return this.interactionClient;\n        this.interactionClient = await this.reconnectInteractionClient();\n        return this.interactionClient;\n    }\n\n    /**\n     * Initialize the node after the InteractionClient was created and to subscribe attributes and events if requested.\n     */\n    private async initialize() {\n        const interactionClient = await this.ensureConnection();\n        const { autoSubscribe, attributeChangedCallback, eventTriggeredCallback } = this.options;\n        if (autoSubscribe !== false) {\n            const initialSubscriptionData = await this.subscribeAllAttributesAndEvents({\n                ignoreInitialTriggers: true,\n                attributeChangedCallback: data => attributeChangedCallback?.(this.nodeId, data),\n                eventTriggeredCallback: data => eventTriggeredCallback?.(this.nodeId, data),\n            }); // Ignore Triggers from Subscribing during initialization\n\n            if (initialSubscriptionData.attributeReports === undefined) {\n                throw new InternalError(\"No attribute reports received when subscribing to all values!\");\n            }\n            await this.initializeEndpointStructure(initialSubscriptionData.attributeReports ?? []);\n\n            const rootDescriptorCluster = this.getRootClusterClient(DescriptorCluster);\n            rootDescriptorCluster?.addPartsListAttributeListener(() => {\n                logger.info(`Node ${this.nodeId}: PartsList changed, reinitializing endpoint structure ...`);\n                this.updateEndpointStructureTimer.stop().start(); // Restart timer\n            });\n        } else {\n            const allClusterAttributes = await interactionClient.getAllAttributes();\n            await this.initializeEndpointStructure(allClusterAttributes);\n        }\n        this.setConnectionState(NodeStateInformation.Connected);\n    }\n\n    /**\n     * Request the current InteractionClient for custom special case interactions with the device. Usually the\n     * ClusterClients of the Devices of the node should be used instead.\n     */\n    async getInteractionClient() {\n        return await this.ensureConnection();\n    }\n\n    /** Method to log the structure of this node with all endpoint and clusters. */\n    logStructure(options?: EndpointLoggingOptions) {\n        const rootEndpoint = this.endpoints.get(EndpointNumber(0));\n        if (rootEndpoint === undefined) {\n            logger.info(`Node ${this.nodeId} has not yet been initialized!`);\n            return;\n        }\n        logEndpoint(rootEndpoint, options);\n    }\n\n    /**\n     * Subscribe to all attributes and events of the device. Unless setting the Controller property autoSubscribe to\n     * false this is executed automatically. Alternatively you can manually subscribe by calling this method.\n     */\n    async subscribeAllAttributesAndEvents(options?: {\n        ignoreInitialTriggers?: boolean;\n        attributeChangedCallback?: (data: DecodedAttributeReportValue<any>) => void;\n        eventTriggeredCallback?: (data: DecodedEventReportValue<any>) => void;\n    }) {\n        options = options ?? {};\n        const { attributeChangedCallback, eventTriggeredCallback } = options;\n        let { ignoreInitialTriggers = false } = options;\n\n        const interactionClient = await this.ensureConnection();\n        // If we subscribe anything we use these data to create the endpoint structure, so we do not need to fetch again\n        const initialSubscriptionData = await interactionClient.subscribeAllAttributesAndEvents({\n            isUrgent: true,\n            minIntervalFloorSeconds: this.options.subscribeMinIntervalFloorSeconds ?? 0,\n            maxIntervalCeilingSeconds: this.options.subscribeMaxIntervalCeilingSeconds ?? 60,\n            attributeListener: data => {\n                const {\n                    path: { endpointId, clusterId, attributeId },\n                    value,\n                } = data;\n                if (ignoreInitialTriggers) return;\n                const device = this.endpoints.get(endpointId);\n                if (device === undefined) {\n                    logger.info(\n                        `Node ${this.nodeId} Ignoring received attribute update for unknown endpoint ${endpointId}!`,\n                    );\n                    return;\n                }\n                const cluster = device.getClusterClientById(clusterId);\n                if (cluster === undefined) {\n                    logger.info(\n                        `Node ${this.nodeId} Ignoring received attribute update for unknown cluster ${Diagnostic.hex(\n                            clusterId,\n                        )} on endpoint ${endpointId}!`,\n                    );\n                    return;\n                }\n                logger.debug(\n                    `Node ${this.nodeId} Trigger attribute update for ${endpointId}.${cluster.name}.${attributeId} to ${Logger.toJSON(\n                        value,\n                    )}`,\n                );\n                asClusterClientInternal(cluster)._triggerAttributeUpdate(attributeId, value);\n                if (attributeChangedCallback !== undefined) {\n                    attributeChangedCallback(data);\n                }\n            },\n            eventListener: data => {\n                const {\n                    path: { endpointId, clusterId, eventId },\n                    events,\n                } = data;\n                if (ignoreInitialTriggers) return;\n                const device = this.endpoints.get(endpointId);\n                if (device === undefined) {\n                    logger.info(`Node ${this.nodeId} Ignoring received event for unknown endpoint ${endpointId}!`);\n                    return;\n                }\n                const cluster = device.getClusterClientById(clusterId);\n                if (cluster === undefined) {\n                    logger.info(\n                        `Node ${this.nodeId} Ignoring received event for unknown cluster ${Diagnostic.hex(\n                            clusterId,\n                        )} on endpoint ${endpointId}!`,\n                    );\n                    return;\n                }\n                logger.debug(\n                    `Node ${this.nodeId} Trigger event update for ${endpointId}.${cluster.name}.${eventId} for ${events.length} events`,\n                );\n                asClusterClientInternal(cluster)._triggerEventUpdate(eventId, events);\n\n                if (eventTriggeredCallback !== undefined) {\n                    eventTriggeredCallback(data);\n                }\n\n                // When we subscribe all data here then we can also catch this case and handle it\n                if (\n                    clusterId === BasicInformation.Cluster.id &&\n                    eventId === BasicInformation.Cluster.events.shutDown.id\n                ) {\n                    this.handleNodeShutdown().catch(error =>\n                        logger.warn(`Node ${this.nodeId}: Error handling node shutdown`, error),\n                    );\n                }\n            },\n            updateTimeoutHandler: async () => {\n                logger.info(`Node ${this.nodeId}: Subscription update not received ...`);\n                try {\n                    await this.subscribeAllAttributesAndEvents({ ...options, ignoreInitialTriggers: false });\n                } catch (error) {\n                    logger.info(`Node ${this.nodeId}: Error resubscribing to all attributes and events`, error);\n                    // TODO resume logic right now retries and discovers for 60s .. prolong this but without command repeating\n                    this.interactionClient = undefined;\n                }\n            },\n        });\n        ignoreInitialTriggers = false;\n        return initialSubscriptionData;\n    }\n\n    /** Handles a node shutDown event (if supported by the node and received). */\n    private async handleNodeShutdown() {\n        logger.info(`Node ${this.nodeId}: Node shutdown detected, trying to reconnect ...`);\n        if (!this.reconnectDelayTimer.isRunning) {\n            this.reconnectDelayTimer.start();\n        }\n        this.setConnectionState(NodeStateInformation.Reconnecting);\n    }\n\n    async updateEndpointStructure() {\n        const interactionClient = await this.ensureConnection();\n        const allClusterAttributes = await interactionClient.getAllAttributes();\n        await this.initializeEndpointStructure(allClusterAttributes, true);\n        this.options.stateInformationCallback?.(this.nodeId, NodeStateInformation.StructureChanged);\n    }\n\n    /** Reads all data from the device and create a device object structure out of it. */\n    private async initializeEndpointStructure(\n        allClusterAttributes: DecodedAttributeReportValue<any>[],\n        updateStructure = false,\n    ) {\n        const interactionClient = await this.ensureConnection();\n        const allData = structureReadAttributeDataToClusterObject(allClusterAttributes);\n\n        if (updateStructure) {\n            // Find out what we need to remove or retain\n            const endpointsToRemove = new Set<EndpointNumber>(this.endpoints.keys());\n            for (const [endpointId] of Object.entries(allData)) {\n                const endpointIdNumber = EndpointNumber(parseInt(endpointId));\n                if (this.endpoints.has(endpointIdNumber)) {\n                    logger.debug(\"Retaining device\", endpointId);\n                    endpointsToRemove.delete(endpointIdNumber);\n                }\n            }\n            // And remove all endpoints no longer in the structure\n            for (const endpointId of endpointsToRemove.values()) {\n                logger.debug(\"Removing device\", endpointId);\n                this.endpoints.get(endpointId)?.removeFromStructure();\n                this.endpoints.delete(endpointId);\n            }\n        } else {\n            this.endpoints.clear();\n        }\n\n        const partLists = new Map<EndpointNumber, EndpointNumber[]>();\n        for (const [endpointId, clusters] of Object.entries(allData)) {\n            const endpointIdNumber = EndpointNumber(parseInt(endpointId));\n            const descriptorData = clusters[DescriptorCluster.id] as AttributeServerValues<\n                typeof DescriptorCluster.attributes\n            >;\n\n            partLists.set(endpointIdNumber, descriptorData.partsList);\n\n            if (this.endpoints.has(endpointIdNumber)) {\n                // Endpoint exists already, so mo need to create device instance again\n                continue;\n            }\n\n            logger.debug(\"Creating device\", endpointId, Logger.toJSON(clusters));\n            this.endpoints.set(endpointIdNumber, this.createDevice(endpointIdNumber, clusters, interactionClient));\n        }\n\n        this.structureEndpoints(partLists);\n    }\n\n    /** Bring the endpoints in a structure based on their partsList attribute. */\n    private structureEndpoints(partLists: Map<EndpointNumber, EndpointNumber[]>) {\n        logger.debug(`Node ${this.nodeId}: Endpoints from PartsLists`, Logger.toJSON(Array.from(partLists.entries())));\n\n        const endpointUsages: { [key: EndpointNumber]: EndpointNumber[] } = {};\n        Array.from(partLists.entries()).forEach(([parent, partsList]) =>\n            partsList.forEach(endPoint => {\n                endpointUsages[endPoint] = endpointUsages[endPoint] || [];\n                endpointUsages[endPoint].push(parent);\n            }),\n        );\n\n        logger.debug(`Node ${this.nodeId}: Endpoint usages`, Logger.toJSON(endpointUsages));\n\n        while (true) {\n            // get all endpoints with only one usage\n            const singleUsageEndpoints = Object.entries(endpointUsages).filter(([_, usages]) => usages.length === 1);\n            if (singleUsageEndpoints.length === 0) {\n                if (Object.entries(endpointUsages).length)\n                    throw new InternalError(`Endpoint structure for Node ${this.nodeId} could not be parsed!`);\n                break;\n            }\n\n            logger.debug(`Node ${this.nodeId}: Processing Endpoint ${Logger.toJSON(singleUsageEndpoints)}`);\n\n            const idsToCleanup: { [key: EndpointNumber]: boolean } = {};\n            singleUsageEndpoints.forEach(([childId, usages]) => {\n                const childEndpointId = EndpointNumber(parseInt(childId));\n                const childEndpoint = this.endpoints.get(childEndpointId);\n                const parentEndpoint = this.endpoints.get(usages[0]);\n                if (childEndpoint === undefined || parentEndpoint === undefined) {\n                    throw new InternalError(`Node ${this.nodeId}: Endpoint not found!`); // Should never happen!\n                }\n\n                if (parentEndpoint.getChildEndpoint(childEndpointId) === undefined) {\n                    logger.debug(\n                        `Node ${this.nodeId}: Endpoint structure: Child: ${childEndpointId} -> Parent: ${parentEndpoint.number}`,\n                    );\n\n                    parentEndpoint.addChildEndpoint(childEndpoint);\n                }\n\n                delete endpointUsages[EndpointNumber(parseInt(childId))];\n                idsToCleanup[usages[0]] = true;\n            });\n            logger.debug(`Node ${this.nodeId}: Endpoint data Cleanup`, Logger.toJSON(idsToCleanup));\n            Object.keys(idsToCleanup).forEach(idToCleanup => {\n                Object.keys(endpointUsages).forEach(id => {\n                    const usageId = EndpointNumber(parseInt(id));\n                    endpointUsages[usageId] = endpointUsages[usageId].filter(\n                        endpointId => endpointId !== parseInt(idToCleanup),\n                    );\n                    if (!endpointUsages[usageId].length) {\n                        delete endpointUsages[usageId];\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * Create a device object from the data read from the device.\n     *\n     * @param endpointId Endpoint ID\n     * @param data Data of all clusters read from the device\n     * @param interactionClient InteractionClient to use for the device\n     * @private\n     */\n    private createDevice(\n        endpointId: EndpointNumber,\n        data: { [key: ClusterId]: { [key: string]: any } },\n        interactionClient: InteractionClient,\n    ) {\n        const descriptorData = data[DescriptorCluster.id] as AttributeServerValues<typeof DescriptorCluster.attributes>;\n\n        const deviceTypes = descriptorData.deviceTypeList.flatMap(({ deviceType, revision }) => {\n            const deviceTypeDefinition = getDeviceTypeDefinitionByCode(deviceType);\n            if (deviceTypeDefinition === undefined) {\n                logger.info(\n                    `NodeId ${this.nodeId}: Device type with code ${deviceType} not known, use generic replacement.`,\n                );\n                return UnknownDeviceType(deviceType);\n            }\n            if (deviceTypeDefinition.revision < revision) {\n                logger.debug(\n                    `NodeId ${this.nodeId}: Device type with code ${deviceType} and revision ${revision} not supported, some data might be unknown.`,\n                );\n            }\n            return deviceTypeDefinition;\n        });\n        if (deviceTypes.length === 0) {\n            logger.info(`NodeId ${this.nodeId}: No device type found for endpoint ${endpointId}, ignore`);\n            throw new MatterError(`NodeId ${this.nodeId}: No device type found for endpoint`);\n        }\n\n        const endpointClusters = Array<ClusterServerObj | ClusterClientObj>();\n\n        // Add ClusterClients for all server clusters of the device\n        for (const clusterId of descriptorData.serverList) {\n            const cluster = getClusterById(clusterId);\n            const clusterClient = ClusterClient(cluster, endpointId, interactionClient, data[clusterId]);\n            endpointClusters.push(clusterClient);\n        }\n\n        // TODO use the attributes attributeList, acceptedCommands, generatedCommands to create the ClusterClient/Server objects\n        // Add ClusterServers for all client clusters of the device\n        for (const clusterId of descriptorData.clientList) {\n            const cluster = getClusterById(clusterId);\n            const clusterData = (data[clusterId] ?? {}) as AttributeInitialValues<Attributes>; // TODO correct typing\n            // Todo add logic for Events\n            endpointClusters.push(\n                ClusterServer(\n                    cluster,\n                    /*clusterData.featureMap,*/ clusterData,\n                    {},\n                    undefined,\n                    true,\n                ) as ClusterServerObj,\n            ); // TODO Add Default handler!\n        }\n\n        if (endpointId === 0) {\n            // Endpoint 0 is the root endpoint, so we use a RootEndpoint object\n            const rootEndpoint = new RootEndpoint();\n            rootEndpoint.setDeviceTypes(deviceTypes as AtLeastOne<DeviceTypeDefinition>); // Ideally only root one as defined\n            endpointClusters.forEach(cluster => {\n                if (isClusterServer(cluster)) {\n                    rootEndpoint.addClusterServer(cluster);\n                } else if (isClusterClient(cluster)) {\n                    rootEndpoint.addClusterClient(cluster);\n                }\n            });\n            return rootEndpoint;\n        } else if (deviceTypes.find(deviceType => deviceType.code === DeviceTypes.AGGREGATOR.code) !== undefined) {\n            // When AGGREGATOR is in the device type list, this is an aggregator\n            const aggregator = new Aggregator([], { endpointId });\n            aggregator.setDeviceTypes(deviceTypes as AtLeastOne<DeviceTypeDefinition>);\n            endpointClusters.forEach(cluster => {\n                // TODO There should be none?\n                if (isClusterServer(cluster)) {\n                    aggregator.addClusterServer(cluster);\n                } else if (isClusterClient(cluster)) {\n                    aggregator.addClusterClient(cluster);\n                }\n            });\n            return aggregator;\n        } else {\n            // It seems to be device but has a partsList, so it is a composed device\n            if (descriptorData.partsList.length > 0) {\n                const composedDevice = new ComposedDevice(deviceTypes[0], [], { endpointId });\n                composedDevice.setDeviceTypes(deviceTypes as AtLeastOne<DeviceTypeDefinition>);\n                endpointClusters.forEach(cluster => {\n                    if (isClusterServer(cluster)) {\n                        composedDevice.addClusterServer(cluster);\n                    } else if (isClusterClient(cluster)) {\n                        composedDevice.addClusterClient(cluster);\n                    }\n                });\n                return composedDevice;\n            } else {\n                // else it's a normal Device\n                // TODO Should we find the really correct Device derived class to instance?\n                return new PairedDevice(deviceTypes as AtLeastOne<DeviceTypeDefinition>, endpointClusters, endpointId);\n            }\n        }\n    }\n\n    /** Returns the functional devices/endpoints (those below the Root Endpoint) known for this node. */\n    getDevices(): EndpointInterface[] {\n        return this.endpoints.get(EndpointNumber(0))?.getChildEndpoints() ?? [];\n    }\n\n    /** Returns the device/endpoint with the given endpoint ID. */\n    getDeviceById(endpointId: number) {\n        return this.endpoints.get(EndpointNumber(endpointId));\n    }\n\n    getRootEndpoint() {\n        return this.getDeviceById(0);\n    }\n\n    /** De-Commission (unpair) the device from this controller by removing the fabric from the device. */\n    async decommission() {\n        if (!this.commissioningController.isNodeCommissioned(this.nodeId)) {\n            throw new ImplementationError(`This Node ${this.nodeId} is not commissioned.`);\n        }\n        const operationalCredentialsCluster = this.getRootClusterClient(OperationalCredentials.Cluster);\n\n        if (operationalCredentialsCluster === undefined) {\n            throw new ImplementationError(`OperationalCredentialsCluster for node ${this.nodeId} not found.`);\n        }\n\n        const fabricIndex = await operationalCredentialsCluster.getCurrentFabricIndexAttribute(true);\n\n        logger.debug(`Removing node ${this.nodeId} by removing fabric ${fabricIndex} on the node.`);\n\n        const result = await operationalCredentialsCluster.commands.removeFabric({ fabricIndex });\n        if (result.statusCode !== OperationalCredentials.NodeOperationalCertStatus.Ok) {\n            throw new MatterError(\n                `Removing node ${this.nodeId} failed with status ${result.statusCode} \"${result.debugText}\".`,\n            );\n        }\n        this.setConnectionState(NodeStateInformation.Disconnected);\n        this.options.stateInformationCallback?.(this.nodeId, NodeStateInformation.Decommissioned);\n        await this.commissioningController.removeNode(this.nodeId, false);\n    }\n\n    /** Opens a Basic Commissioning Window (uses the original Passcode printed on the device) with the device. */\n    async openBasicCommissioningWindow(commissioningTimeout = 900 /* 15 minutes */) {\n        const adminCommissioningCluster = this.getRootClusterClient(AdministratorCommissioning.Cluster.with(\"Basic\"));\n        if (adminCommissioningCluster === undefined) {\n            throw new ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);\n        }\n        if (adminCommissioningCluster.supportedFeatures.basic === false) {\n            throw new ImplementationError(\n                `AdministratorCommissioningCluster for node ${this.nodeId} does not support basic commissioning.`,\n            );\n        }\n\n        try {\n            await adminCommissioningCluster.commands.revokeCommissioning();\n        } catch (error) {\n            // Accept the error if no window is already open\n            if (\n                !StatusResponseError.is(error, StatusCode.Failure) ||\n                error.clusterCode !== AdministratorCommissioning.StatusCode.WindowNotOpen\n            ) {\n                throw error;\n            }\n        }\n\n        await adminCommissioningCluster.commands.openBasicCommissioningWindow({ commissioningTimeout });\n    }\n\n    /** Opens an Enhanced Commissioning Window (uses a generated random Passcode) with the device. */\n    async openEnhancedCommissioningWindow(commissioningTimeout = 900 /* 15 minutes */) {\n        const adminCommissioningCluster = this.getRootClusterClient(AdministratorCommissioning.Cluster);\n        if (adminCommissioningCluster === undefined) {\n            throw new ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);\n        }\n\n        try {\n            await adminCommissioningCluster.commands.revokeCommissioning();\n        } catch (error) {\n            // Accept the error if no window is already open\n            if (\n                !StatusResponseError.is(error, StatusCode.Failure) ||\n                error.clusterCode !== AdministratorCommissioning.StatusCode.WindowNotOpen\n            ) {\n                throw error;\n            }\n        }\n\n        const basicInformationCluster = this.getRootClusterClient(BasicInformation.Cluster);\n        if (basicInformationCluster == undefined) {\n            throw new ImplementationError(`BasicInformationCluster for node ${this.nodeId} not found.`);\n        }\n\n        const vendorId = await basicInformationCluster.getVendorIdAttribute();\n        const productId = await basicInformationCluster.getProductIdAttribute();\n\n        const discriminator = PaseClient.generateRandomDiscriminator();\n        const passcode = PaseClient.generateRandomPasscode();\n        const salt = Crypto.get().getRandomData(32);\n        const iterations = 1_000; // Minimum 1_000, Maximum 100_000\n        const pakePasscodeVerifier = await PaseClient.generatePakePasscodeVerifier(passcode, {\n            iterations,\n            salt,\n        });\n        await adminCommissioningCluster.commands.openCommissioningWindow({\n            commissioningTimeout,\n            pakePasscodeVerifier,\n            salt,\n            iterations,\n            discriminator,\n        });\n\n        // TODO: If Timeout is shorter then 15 minutes set the timeout also in TlvData of QR-Code\n        const qrPairingCode = QrPairingCodeCodec.encode([\n            {\n                version: 0,\n                vendorId,\n                productId,\n                flowType: CommissioningFlowType.Standard,\n                discriminator: discriminator,\n                passcode: passcode,\n                discoveryCapabilities: DiscoveryCapabilitiesSchema.encode({\n                    onIpNetwork: true,\n                }),\n            },\n        ]);\n\n        return {\n            manualPairingCode: ManualPairingCodeCodec.encode({\n                discriminator: discriminator,\n                passcode: passcode,\n            }),\n            qrPairingCode,\n        };\n    }\n\n    async disconnect() {\n        this.close();\n        await this.commissioningController.disconnectNode(this.nodeId);\n    }\n\n    close() {\n        this.interactionClient?.close();\n        this.setConnectionState(NodeStateInformation.Disconnected);\n    }\n\n    /**\n     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterServer to get or undefined if not existing\n     */\n    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined {\n        return this.endpoints.get(EndpointNumber(0))?.getClusterServer(cluster);\n    }\n\n    /**\n     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterClient to get or undefined if not existing\n     */\n    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined {\n        return this.endpoints.get(EndpointNumber(0))?.getClusterClient(cluster);\n    }\n\n    /**\n     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param endpointId EndpointNumber to get the cluster from\n     * @param cluster ClusterServer to get or undefined if not existing\n     */\n    getClusterServerForDevice<const T extends ClusterType>(\n        endpointId: EndpointNumber,\n        cluster: T,\n    ): ClusterServerObj<T> | undefined {\n        return this.getDeviceById(endpointId)?.getClusterServer(cluster);\n    }\n\n    /**\n     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param endpointId EndpointNumber to get the cluster from\n     * @param cluster ClusterClient to get or undefined if not existing\n     */\n    getClusterClientForDevice<const T extends ClusterType>(\n        endpointId: EndpointNumber,\n        cluster: T,\n    ): ClusterClientObj<T> | undefined {\n        return this.getDeviceById(endpointId)?.getClusterClient(cluster);\n    }\n}\n"],
  "mappings": "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",
  "names": ["NodeStateInformation"]
}
