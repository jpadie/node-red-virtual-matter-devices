/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CommissioningController } from "../CommissioningController.js";
import { ClusterClientObj } from "../cluster/client/ClusterClientTypes.js";
import { ClusterServerObj } from "../cluster/server/ClusterServerTypes.js";
import { EndpointNumber } from "../datatype/EndpointNumber.js";
import { NodeId } from "../datatype/NodeId.js";
import { DecodedAttributeReportValue } from "../protocol/interaction/AttributeDataDecoder.js";
import { InteractionClient } from "../protocol/interaction/InteractionClient.js";
import { ClusterType } from "../cluster/ClusterType.js";
import { EndpointInterface } from "../endpoint/EndpointInterface.js";
import { DecodedEventReportValue } from "../protocol/interaction/EventDataDecoder.js";
import { Endpoint } from "./Endpoint.js";
import { EndpointLoggingOptions } from "./EndpointStructureLogger.js";
export declare enum NodeStateInformation {
    /** Node is connected and all data is up-to-date. */
    Connected = 0,
    /**
     * Node is disconnected. Data are stale and interactions will most likely return an error. If controller instance
     * is still active then the device will be reconnected once it is available again.
     */
    Disconnected = 1,
    /** Node is reconnecting. Data are stale. It is yet unknown if the reconnection is successful. */
    Reconnecting = 2,
    /**
     * The node could not be connected and the controller is now waiting for a MDNS announcement and tries every 10
     * minutes to reconnect.
     */
    WaitingForDeviceDiscovery = 3,
    /**
     * Node structure has changed (Endpoints got added or also removed). Data are up-to-date.
     * This State information will only be fired when the subscribeAllAttributesAndEvents option is set to true.
     */
    StructureChanged = 4,
    /**
     * The node was just Decommissioned.
     */
    Decommissioned = 5
}
export type CommissioningControllerNodeOptions = {
    /**
     * Unless set to false all events and attributes are subscribed and value changes are reflected in the ClusterClient
     * instances. With this reading attributes values is mostly looked up in the locally cached data.
     * Additionally more features like reaction on shutdown event or endpoint structure changes (for bridges) are done
     * internally automatically.
     */
    readonly autoSubscribe?: boolean;
    /** Minimum subscription interval when values are changed. Default it is set to 0s.*/
    readonly subscribeMinIntervalFloorSeconds?: number;
    /**
     * Maximum subscription interval when values are changed. This is also used as a keepalive mechanism to validate
     * that the device is still available. Default it is set to 60s.
     */
    readonly subscribeMaxIntervalCeilingSeconds?: number;
    /**
     * Optional additional callback method which is called for each Attribute change reported by the device. Use this
     * if subscribing to all relevant attributes is too much effort.
     */
    readonly attributeChangedCallback?: (nodeId: NodeId, data: DecodedAttributeReportValue<any>) => void;
    /**
     * Optional additional callback method which is called for each Event reported by the device. Use this if
     * subscribing to all relevant events is too much effort.
     */
    readonly eventTriggeredCallback?: (nodeId: NodeId, data: DecodedEventReportValue<any>) => void;
    /**
     * Optional callback method which is called when the state of the node changes. This can be used to detect when
     * the node goes offline or comes back online.
     */
    readonly stateInformationCallback?: (nodeId: NodeId, state: NodeStateInformation) => void;
};
/**
 * Class to represents one node that is paired/commissioned with the matter.js Controller. Instances are returned by
 * the CommissioningController on commissioning or when connecting.
 */
export declare class PairedNode {
    readonly nodeId: NodeId;
    private readonly commissioningController;
    private readonly options;
    private readonly reconnectInteractionClient;
    private readonly endpoints;
    private interactionClient?;
    private readonly reconnectDelayTimer;
    private readonly updateEndpointStructureTimer;
    private connectionState;
    static create(nodeId: NodeId, commissioningController: CommissioningController, options: CommissioningControllerNodeOptions | undefined, reconnectInteractionClient: () => Promise<InteractionClient>, assignDisconnectedHandler: (handler: () => Promise<void>) => void): Promise<PairedNode>;
    constructor(nodeId: NodeId, commissioningController: CommissioningController, options: CommissioningControllerNodeOptions, reconnectInteractionClient: () => Promise<InteractionClient>, assignDisconnectedHandler: (handler: () => Promise<void>) => void);
    get isConnected(): boolean;
    private setConnectionState;
    /**
     * Force a reconnection to the device. This method is mainly used internally to reconnect after the active session
     * was closed or the device went offline and was detected as being online again.
     */
    reconnect(): Promise<void>;
    /** Ensure that the node is connected by creating a new InteractionClient if needed. */
    private ensureConnection;
    /**
     * Initialize the node after the InteractionClient was created and to subscribe attributes and events if requested.
     */
    private initialize;
    /**
     * Request the current InteractionClient for custom special case interactions with the device. Usually the
     * ClusterClients of the Devices of the node should be used instead.
     */
    getInteractionClient(): Promise<InteractionClient>;
    /** Method to log the structure of this node with all endpoint and clusters. */
    logStructure(options?: EndpointLoggingOptions): void;
    /**
     * Subscribe to all attributes and events of the device. Unless setting the Controller property autoSubscribe to
     * false this is executed automatically. Alternatively you can manually subscribe by calling this method.
     */
    subscribeAllAttributesAndEvents(options?: {
        ignoreInitialTriggers?: boolean;
        attributeChangedCallback?: (data: DecodedAttributeReportValue<any>) => void;
        eventTriggeredCallback?: (data: DecodedEventReportValue<any>) => void;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
    }>;
    /** Handles a node shutDown event (if supported by the node and received). */
    private handleNodeShutdown;
    updateEndpointStructure(): Promise<void>;
    /** Reads all data from the device and create a device object structure out of it. */
    private initializeEndpointStructure;
    /** Bring the endpoints in a structure based on their partsList attribute. */
    private structureEndpoints;
    /**
     * Create a device object from the data read from the device.
     *
     * @param endpointId Endpoint ID
     * @param data Data of all clusters read from the device
     * @param interactionClient InteractionClient to use for the device
     * @private
     */
    private createDevice;
    /** Returns the functional devices/endpoints (those below the Root Endpoint) known for this node. */
    getDevices(): EndpointInterface[];
    /** Returns the device/endpoint with the given endpoint ID. */
    getDeviceById(endpointId: number): Endpoint | undefined;
    getRootEndpoint(): Endpoint | undefined;
    /** De-Commission (unpair) the device from this controller by removing the fabric from the device. */
    decommission(): Promise<void>;
    /** Opens a Basic Commissioning Window (uses the original Passcode printed on the device) with the device. */
    openBasicCommissioningWindow(commissioningTimeout?: number): Promise<void>;
    /** Opens an Enhanced Commissioning Window (uses a generated random Passcode) with the device. */
    openEnhancedCommissioningWindow(commissioningTimeout?: number): Promise<{
        manualPairingCode: string;
        qrPairingCode: string;
    }>;
    disconnect(): Promise<void>;
    close(): void;
    /**
     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterServer to get or undefined if not existing
     */
    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined;
    /**
     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterClient to get or undefined if not existing
     */
    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined;
    /**
     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param endpointId EndpointNumber to get the cluster from
     * @param cluster ClusterServer to get or undefined if not existing
     */
    getClusterServerForDevice<const T extends ClusterType>(endpointId: EndpointNumber, cluster: T): ClusterServerObj<T> | undefined;
    /**
     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param endpointId EndpointNumber to get the cluster from
     * @param cluster ClusterClient to get or undefined if not existing
     */
    getClusterClientForDevice<const T extends ClusterType>(endpointId: EndpointNumber, cluster: T): ClusterClientObj<T> | undefined;
}
//# sourceMappingURL=PairedNode.d.ts.map