{
  "version": 3,
  "sources": ["../../../../src/behavior/state/Val.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AccessControl } from \"../AccessControl.js\";\nimport type { ValueSupervisor } from \"../supervision/ValueSupervisor.js\";\n\n/**\n * General type for state values.\n */\nexport type Val = unknown;\n\nexport namespace Val {\n    /**\n     * Type for Matter structs.  In JS this is an object with string keys.\n     */\n    export type Struct = Record<string, Val>;\n\n    /**\n     * Type for Matter lists.  In Js this is an array.\n     */\n    export type List = Val[];\n\n    /**\n     * Any matter collection type.\n     */\n    export type Collection = Struct | List;\n\n    /**\n     * A Reference offers a simple mechanism for referring to properties by reference.\n     */\n    export interface Reference<T extends Val = Val> {\n        /**\n         * The current value of the referenced property.  Cleared when the reference is no longer functional.\n         */\n        value: T;\n\n        /**\n         * The current canonical value of the referenced property.\n         */\n        readonly original: T;\n\n        /**\n         * When true, the reference is no longer usable because the owning context has exited.\n         */\n        readonly expired: boolean;\n\n        /**\n         * Diagnostic path to the referenced value.\n         */\n        location: AccessControl.Location;\n\n        /**\n         * Active references to child properties.\n         */\n        subrefs?: Record<number | string, Reference>;\n\n        /**\n         * Mutates data.  Clones the container and updates metadata when called on an unmodified transactional\n         * reference.\n         *\n         * Then runs the specified mutator to make the actual changes.\n         *\n         * @param mutator the mutation logic, may freely modify {@link value}\n         */\n        change(mutator: () => void): void;\n\n        /**\n         * Refresh any internal cache from the referenced container.\n         */\n        refresh(): void;\n\n        /**\n         * The managed value that owns the reference.\n         */\n        owner?: T;\n\n        /**\n         * The object that owns the root managed value.\n         */\n        rootOwner?: any;\n    }\n\n    export const properties = Symbol(\"properties\");\n\n    /**\n     * Unmanaged raw state classes have no contextual information.  They may implement this interface to provide an\n     * alternate context-aware object for property read, write and validation.\n     */\n    export interface Dynamic<O = any, S extends ValueSupervisor.Session = ValueSupervisor.Session> extends Struct {\n        /**\n         * Obtain a context-aware property source (and sink).  Supervision will read/write properties from here if\n         * present.  Otherwise they're read from static state as normal.\n         *\n         * @param owner the owner of the root reference of the managed value\n         * @param session the {@link ValueSupervisor.Session} accessing the value\n         */\n        [properties]<This extends Val.Struct>(this: This, owner: O, session: S): Partial<This>;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcO,IAAU;AAAA,CAAV,CAAUA,SAAV;AAuEI,EAAMA,KAAA,aAAa,OAAO,YAAY;AAAA,GAvEhC;",
  "names": ["Val"]
}
