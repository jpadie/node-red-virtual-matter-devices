{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/transaction/Tx.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError, ReadOnlyError } from \"../../../common/MatterError.js\";\nimport { Diagnostic } from \"../../../log/Diagnostic.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { Observable } from \"../../../util/Observable.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { describeList } from \"../../../util/String.js\";\nimport { FinalizationError, TransactionDestroyedError, TransactionFlowError } from \"./Errors.js\";\nimport type { Participant } from \"./Participant.js\";\nimport type { Resource } from \"./Resource.js\";\nimport { ResourceSet } from \"./ResourceSet.js\";\nimport { Status } from \"./Status.js\";\nimport { Transaction } from \"./Transaction.js\";\n\nconst logger = Logger.get(\"Transaction\");\n\n// Controls the number of times we will cycle pre-commit handlers waiting for state to settle\nconst MAX_PRECOMMIT_CYCLES = 5;\n\n// Controls the number of commits that may occur due to mutation in post-commit handlers\nconst MAX_CHAINED_COMMITS = 5;\n\n/**\n * This is the only public interface to this file.\n */\nexport function act<T>(via: string, actor: (transaction: Transaction) => T): T {\n    const tx = new Tx(via);\n    let commits = 0;\n\n    // Post-commit logic may result in the transaction requiring commit again so commit iteratively up to\n    // MAX_CHAINED_COMMITS times\n    function commitTransaction(finalResult: T): MaybePromise<T> {\n        commits++;\n\n        if (commits > MAX_CHAINED_COMMITS) {\n            throw new TransactionFlowError(\n                `Transaction commits have cascaded ${MAX_CHAINED_COMMITS} times which likely indicates an infinite loop`,\n            );\n        }\n\n        // Avoid MaybePromise.then to shorten stack traces\n        const result = tx.commit();\n        if (MaybePromise.is(result)) {\n            return result.then(() => {\n                if (tx.status === Transaction.Status.Exclusive) {\n                    return commitTransaction(finalResult);\n                }\n                return finalResult;\n            });\n        } else if (tx.status === Transaction.Status.Exclusive) {\n            return commitTransaction(finalResult);\n        }\n\n        return finalResult;\n    }\n\n    const handleTransactionError = ((error: any) => {\n        // If we've committed, error happened during commit and we've already logged and cleaned up\n        if (commits) {\n            throw error;\n        }\n\n        logger.error(\"Rolling back\", tx.via, \"due to error:\", Diagnostic.weak(error?.message || `${error}`));\n\n        try {\n            const result = tx.rollback();\n            if (MaybePromise.is(result)) {\n                return Promise.resolve(result).catch(error2 => {\n                    if (error2 !== error) {\n                        logger.error(\"Secondary error in\", tx.via, \"rollback:\", error2);\n                    }\n                    throw error;\n                });\n            }\n        } catch (error2) {\n            if (error2 !== error) {\n                logger.error(\"Secondary error in\", tx.via, \"rollback:\", error2);\n            }\n        }\n\n        throw error;\n    }) as (error: any) => MaybePromise<T>; // Cast because otherwise type is MaybePromise<void>\n\n    const closeTransaction = tx.close.bind(tx);\n\n    let isAsync = false;\n    try {\n        // Execute the actor\n        const actorResult = actor(tx);\n\n        // If actor is async, chain commit and close asynchronously\n        if (MaybePromise.is(actorResult)) {\n            isAsync = true;\n            return Promise.resolve(actorResult)\n                .then(commitTransaction, handleTransactionError)\n                .finally(closeTransaction) as T;\n        }\n\n        // Actor is not async but if commit is, chain closeTransaction\n        const commitResult = commitTransaction(actorResult);\n        if (MaybePromise.is(commitResult)) {\n            isAsync = true;\n            return Promise.resolve(commitResult).catch(handleTransactionError).finally(closeTransaction) as T;\n        }\n\n        // Fully synchronous action\n        return commitResult;\n    } catch (e) {\n        const result = handleTransactionError(e);\n\n        // Above throws if synchronous so this is async code path\n        isAsync = true;\n        return Promise.resolve(result).finally(closeTransaction) as T;\n    } finally {\n        if (!isAsync) {\n            tx.close();\n        }\n    }\n}\n\n/**\n * The concrete implementation of the Transaction interface.\n */\nclass Tx implements Transaction {\n    #participants = new Set<Participant>();\n    #roles = new Map<{}, Participant>();\n    #resources = new Set<Resource>();\n    #status;\n    #waitingOn?: Iterable<Transaction>;\n    #via: string;\n    #shared?: Observable<[]>;\n    #closed?: Observable<[]>;\n\n    constructor(via: string, readonly = false) {\n        this.#via = Diagnostic.via(via);\n        if (readonly) {\n            this.#status = Status.ReadOnly;\n        } else {\n            this.#status = Status.Shared;\n        }\n    }\n\n    close() {\n        this.#status = Status.Destroyed;\n        this.#resources.clear();\n        this.#roles.clear();\n        this.#participants.clear();\n        this.#closed?.emit();\n    }\n\n    get via() {\n        return this.#via;\n    }\n\n    get status() {\n        return this.#status;\n    }\n\n    get participants() {\n        return this.#participants;\n    }\n\n    get resources() {\n        return this.#resources;\n    }\n\n    get waitingOn() {\n        return this.#waitingOn;\n    }\n\n    onShared(listener: () => void, once?: boolean) {\n        if (this.#shared === undefined) {\n            this.#shared = Observable();\n        }\n\n        this.#shared[once ? \"once\" : \"on\"](listener);\n    }\n\n    onClose(listener: () => void) {\n        if (this.status === Status.Destroyed) {\n            listener();\n        }\n        if (this.#closed === undefined) {\n            this.#closed = Observable();\n        }\n        this.#closed.once(listener);\n    }\n\n    async addResources(...resources: Resource[]) {\n        this.#assertAvailable();\n\n        if (this.#status === Status.Exclusive) {\n            const set = new ResourceSet(this, resources);\n            const locked = await set.acquireLocks();\n            this.#locksChanged(locked);\n        }\n\n        this.addResourcesSync(...resources);\n    }\n\n    addResourcesSync(...resources: Resource[]) {\n        this.#assertAvailable();\n\n        if (this.#status === Status.Exclusive) {\n            const set = new ResourceSet(this, resources);\n            const locked = set.acquireLocksSync();\n            this.#locksChanged(locked);\n        } else if (this.#status !== Status.Shared) {\n            throw new TransactionFlowError(`Cannot add resources to transaction that is ${this.status}`);\n        }\n\n        for (const resource of resources) {\n            this.#resources.add(resource);\n        }\n    }\n\n    async begin() {\n        this.#assertAvailable();\n\n        if (this.status === Status.Exclusive) {\n            return;\n        }\n        if (this.status !== Status.Shared) {\n            throw new TransactionFlowError(`Cannot begin write transaction because transaction is ${this.#status}`);\n        }\n\n        this.#status = Status.Waiting;\n        try {\n            const resources = new ResourceSet(this, this.#resources);\n            const locked = await resources.acquireLocks();\n            this.#locksChanged(locked);\n            this.#status = Status.Exclusive;\n        } catch (e) {\n            this.#status = Status.Shared;\n            throw e;\n        }\n    }\n\n    beginSync() {\n        this.#assertAvailable();\n\n        if (this.status === Status.Exclusive) {\n            return;\n        }\n        if (this.status !== Status.Shared) {\n            throw new TransactionFlowError(`Cannot begin write transaction because transaction is ${this.#status}`);\n        }\n\n        this.#status = Status.Exclusive;\n        try {\n            const resources = new ResourceSet(this, this.#resources);\n            const locked = resources.acquireLocksSync();\n            this.#locksChanged(locked);\n        } catch (e) {\n            this.#status = Status.Shared;\n            throw e;\n        }\n    }\n\n    addParticipants(...participants: Participant[]) {\n        this.#assertAvailable();\n\n        for (const participant of participants) {\n            if (this.#participants.has(participant)) {\n                continue;\n            }\n\n            // This sanity check uses the participant's diagnostic name to prevent logic errors from installing multiple\n            // participants that modify the same data\n            if ([...this.#participants].findIndex(p => p.toString() === participant.toString()) !== -1) {\n                throw new ImplementationError(`Participant ${participant} identity is not unique`);\n            }\n\n            this.#participants.add(participant);\n\n            if (participant.role !== undefined) {\n                if (this.#roles.has(participant.role)) {\n                    throw new TransactionFlowError(`A participant is already registered for role ${participant.role}`);\n                }\n                this.#roles.set(participant.role, participant);\n            }\n        }\n    }\n\n    getParticipant(role: {}) {\n        this.#assertAvailable();\n\n        return this.#roles.get(role);\n    }\n\n    commit() {\n        this.#assertAvailable();\n\n        if (this.#status === Status.Shared) {\n            // Use rollback() to reset state\n            return this.rollback();\n        }\n\n        // Perform the actual commit once preCommit completes\n        const performCommit = () => {\n            const participants = [...this.#participants];\n            const result = this.#finalize(Status.CommittingPhaseOne, \"committed\", this.#executeCommit.bind(this));\n            if (MaybePromise.is(result)) {\n                return result.then(() => this.#executePostCommit(participants));\n            }\n            return this.#executePostCommit(participants);\n        };\n\n        const result = this.#executePreCommit();\n        if (MaybePromise.is(result)) {\n            return result.then(performCommit);\n        }\n        return performCommit();\n    }\n\n    rollback() {\n        this.#assertAvailable();\n\n        return this.#finalize(Status.RollingBack, \"rolled back\", () => this.#executeRollback());\n    }\n\n    waitFor(others: Set<Transaction>) {\n        this.#assertAvailable();\n\n        if (this.waitingOn) {\n            throw new TransactionFlowError(\"Attempted wait on a transaction that is already waiting\");\n        }\n\n        logger.debug(\n            \"Transaction\",\n            this.via,\n            \"waiting on\",\n            describeList(\"and\", ...[...others].map(other => other.via)),\n        );\n\n        this.#waitingOn = others;\n        return new Promise<void>(resolve => {\n            for (const other of others) {\n                other.onShared(() => {\n                    others.delete(other);\n                    if (!others.size) {\n                        this.#waitingOn = undefined;\n                        resolve();\n                    }\n                }, true);\n            }\n        }).finally(() => (this.#waitingOn = undefined));\n    }\n\n    toString() {\n        return `transaction<${this.via}>`;\n    }\n\n    /**\n     * Shared implementation for commit and rollback.\n     */\n    #finalize(status: Status, why: string, finalizer: () => MaybePromise) {\n        // Sanity check on status\n        if (this.status !== Status.Shared && this.status !== Status.Exclusive) {\n            throw new TransactionFlowError(\n                `Illegal attempt to enter status ${status} when transaction is ${this.#status}`,\n            );\n        }\n\n        // Post-finalization state reset\n        const cleanup = () => {\n            // Release locks\n            const set = new ResourceSet(this, this.#resources);\n            const unlocked = set.releaseLocks();\n            this.#locksChanged(unlocked, `${why} and unlocked`);\n\n            // Release participants\n            this.#participants.clear();\n\n            // Revert to shared\n            this.#status = Status.Shared;\n\n            // Notify listeners\n            this.#shared?.emit();\n        };\n\n        // Perform the commit or rollback\n        let isAsync = false;\n        try {\n            this.#status = status;\n            const result = finalizer();\n            if (MaybePromise.is(result)) {\n                isAsync = true;\n                return Promise.resolve(result).finally(cleanup);\n            }\n        } finally {\n            if (!isAsync) {\n                cleanup();\n            }\n        }\n    }\n\n    /**\n     * Iteratively execute pre-commit until all participants \"settle\" and report no possible mutation.\n     */\n    #executePreCommit(): MaybePromise<void> {\n        let mayHaveMutated = false;\n        let abortedDueToError = false;\n        let iterator = this.participants[Symbol.iterator]();\n        let cycles = 1;\n\n        const errorRollback = (error?: any) => {\n            const result = this.#finalize(Status.RollingBack, \"rolled back\", () => this.#executeRollback());\n\n            if (MaybePromise.is(result)) {\n                return result.then(() => {\n                    StatusResponseError.reject(error);\n                    throw new FinalizationError(\"Rolled back due to pre-commit error\");\n                });\n            }\n\n            StatusResponseError.reject(error);\n            throw new FinalizationError(\"Rolled back due to pre-commit error\");\n        };\n\n        const nextCycle = () => {\n            // Guard against infinite loops\n            cycles++;\n            if (cycles > MAX_PRECOMMIT_CYCLES) {\n                logger.error(\n                    `State has not settled after ${MAX_PRECOMMIT_CYCLES} pre-commit cycles which likely indicates an infinite loop`,\n                );\n                return errorRollback();\n            }\n\n            // Restart iteration at the first participant\n            mayHaveMutated = false;\n            iterator = this.participants[Symbol.iterator]();\n        };\n\n        const nextPreCommit = (previousResult?: boolean): MaybePromise<void> => {\n            // If an error occurred\n            if (abortedDueToError) {\n                return;\n            }\n\n            // When resuming after an async pre-commit handler, \"previousResult\" is the handler's return value\n            // indicating whether mutation may have occurred\n            if (previousResult) {\n                mayHaveMutated = true;\n            }\n\n            // Cycle through participants until exhausted, there is an error or a pre-commit function is async\n            while (true) {\n                const n = iterator.next();\n\n                // If we've exhausted participants, we are either done or need to restart the cycle\n                if (n.done) {\n                    // Restart the cycle if necessary\n                    if (mayHaveMutated) {\n                        const result = nextCycle();\n                        if (MaybePromise.is(result)) {\n                            return result;\n                        }\n                        continue;\n                    }\n\n                    // Done\n                    break;\n                }\n\n                // Process the next participant\n                const participant = n.value;\n\n                // When an error occurs this function performs rollback then throws\n                const handleError = (error: any) => {\n                    abortedDueToError = true;\n                    logger.error(`Error pre-commit of ${participant}:`, error);\n                    return errorRollback(error);\n                };\n\n                // Execute the pre-commit for this participant\n                try {\n                    const result = participant.preCommit?.();\n                    if (MaybePromise.is(result)) {\n                        return Promise.resolve(result).catch(handleError).then(nextPreCommit);\n                    }\n                    if (result) {\n                        mayHaveMutated = true;\n                    }\n                } catch (e) {\n                    return handleError(e);\n                }\n            }\n        };\n\n        return nextPreCommit();\n    }\n\n    /**\n     * Commit logic passed to #finalize.\n     */\n    #executeCommit(): MaybePromise {\n        //this.#log(\"commit\");\n        const result = this.#executeCommit1();\n        if (MaybePromise.is(result)) {\n            return Promise.resolve(result).then(this.#executeCommit2.bind(this));\n        }\n        return this.#executeCommit2();\n    }\n\n    #executeCommit1(): MaybePromise {\n        // Commit phase 1\n\n        let needRollback = false;\n        let asyncCommits: undefined | Promise<void>[];\n        for (const participant of this.participants) {\n            const handleParticipantError = (error: any) => {\n                logger.error(`Error committing ${participant} (phase one):`, error);\n                needRollback = true;\n            };\n\n            try {\n                const result = participant.commit1();\n                if (MaybePromise.is(result)) {\n                    if (!asyncCommits) {\n                        asyncCommits = [];\n                    }\n                    asyncCommits.push(Promise.resolve(result).catch(handleParticipantError));\n                }\n            } catch (e) {\n                handleParticipantError(e);\n                break;\n            }\n        }\n\n        const abortIfFailed = () => {\n            if (needRollback) {\n                const result = this.#executeRollback();\n\n                if (MaybePromise.is(result)) {\n                    return result.then(() => {\n                        throw new FinalizationError(\"Rolled back due to commit phase one error\");\n                    });\n                }\n\n                throw new FinalizationError(\"Rolled back due to commit phase one error\");\n            }\n        };\n\n        if (asyncCommits) {\n            return Promise.allSettled(asyncCommits).then(abortIfFailed);\n        }\n\n        return abortIfFailed();\n    }\n\n    #executeCommit2() {\n        // Commit phase 2\n        this.#status = Status.CommittingPhaseTwo;\n        let errored: undefined | Array<Participant>;\n        let ongoing: undefined | Array<Promise<void>>;\n        for (const participant of this.participants) {\n            const promise = MaybePromise.then(\n                () => participant.commit2(),\n                undefined,\n                error => {\n                    logger.error(`Error committing (phase two) ${participant}, state inconsistency possible:`, error);\n\n                    if (errored) {\n                        errored.push(participant);\n                    } else {\n                        errored = [participant];\n                    }\n                },\n            );\n\n            if (MaybePromise.is(promise)) {\n                if (ongoing) {\n                    ongoing.push(promise as Promise<void>);\n                } else {\n                    ongoing = [promise as Promise<void>];\n                }\n            }\n        }\n\n        if (ongoing) {\n            // Async commit\n            return Promise.allSettled(ongoing).then(() => throwIfErrored(errored, \"in commit phase 2\"));\n        } else {\n            // Synchronous commit\n            throwIfErrored(errored, \"in commit phase 2\");\n        }\n    }\n\n    #executePostCommit(participants: Participant[]) {\n        const participantIterator = participants[Symbol.iterator]();\n\n        const postCommitNextParticipant = (): MaybePromise => {\n            const next = participantIterator.next();\n\n            if (next.done) {\n                return;\n            }\n\n            const participant = next.value;\n\n            return MaybePromise.then(\n                () => participant.postCommit?.(),\n                () => postCommitNextParticipant(),\n                error => {\n                    logger.error(`Error post-commit of ${participant}:`, error);\n                },\n            );\n        };\n\n        return postCommitNextParticipant();\n    }\n\n    /**\n     * Rollback logic passed to #finish.\n     */\n    #executeRollback() {\n        //this.#log(\"rollback\");\n        this.#status = Status.RollingBack;\n        let errored: undefined | Array<Participant>;\n        let ongoing: undefined | Array<Promise<void>>;\n\n        for (const participant of this.participants) {\n            // Perform rollback\n            const promise = MaybePromise.then(\n                () => participant.rollback(),\n                undefined,\n                error => {\n                    logger.error(`Error rolling back ${participant}, state inconsistency possible:`, error);\n\n                    if (errored) {\n                        errored.push(participant);\n                    } else {\n                        errored = [participant];\n                    }\n                },\n            );\n\n            // If commit is asynchronous, collect the promise\n            if (MaybePromise.is(promise)) {\n                if (ongoing) {\n                    ongoing.push(promise as Promise<void>);\n                } else {\n                    ongoing = [promise as Promise<void>];\n                }\n            }\n        }\n\n        const finished = () => {\n            this.#status = Status.Shared;\n            throwIfErrored(errored, \"in commit phase 2\");\n        };\n\n        if (ongoing) {\n            // Async commit\n            return Promise.allSettled(ongoing).then(finished);\n        } else {\n            // Synchronous commit\n            finished();\n        }\n    }\n\n    #log(...message: unknown[]) {\n        logger.debug(\"Transaction\", this.#via, message);\n    }\n\n    #locksChanged(resources: Set<Resource>, how = \"locked\") {\n        if (!resources.size) {\n            return;\n        }\n\n        let resourceDescription;\n        if (how === \"locked\") {\n            resourceDescription = Diagnostic.strong(describeList(\"and\", ...[...resources].map(r => r.toString())));\n        } else {\n            resourceDescription = `${resources.size} resource${resources.size === 1 ? \"\" : \"s\"}`;\n        }\n        this.#log(how, resourceDescription);\n    }\n\n    #assertAvailable() {\n        if (this.#status === Status.Destroyed) {\n            logger.warn(\n                \"You have accessed transaction\",\n                this.via,\n                \"outside of the context in which it was active.  Open a new context or ensure your operation completes before the context exits\",\n            );\n            throw new TransactionDestroyedError(`Transaction ${this.#via} is destroyed`);\n        }\n        if (this.#status === Status.ReadOnly) {\n            throw new ReadOnlyError();\n        }\n    }\n}\n\nexport const ReadOnlyTransaction = new Tx(\"readonly\", true);\n\nfunction throwIfErrored(errored: undefined | Array<Participant>, when: string) {\n    if (!errored?.length) {\n        return;\n    }\n    const suffix = errored.length > 1 ? \"s\" : \"\";\n    throw new FinalizationError(\n        `Unhandled error${suffix} ${when} participant${suffix} ${describeList(\n            \"and\",\n            ...errored.map(p => p.toString()),\n        )}`,\n    );\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
