{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/transaction/ResourceSet.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Logger } from \"../../../log/Logger.js\";\nimport { describeList } from \"../../../util/String.js\";\nimport { SynchronousTransactionConflictError, TransactionDeadlockError, TransactionFlowError } from \"./Errors.js\";\nimport { Resource } from \"./Resource.js\";\nimport type { Transaction } from \"./Transaction.js\";\n\nconst logger = Logger.get(\"ResourceSet\");\n\n/**\n * An internal set of resources supporting bulk operations for {@link Transaction}.\n */\nexport class ResourceSet {\n    #transaction: Transaction;\n    #resources = new Set<Resource>();\n\n    constructor(transaction: Transaction, resources: Iterable<Resource> = transaction.resources) {\n        this.#transaction = transaction;\n        for (let resource of resources) {\n            while (resource[Resource.reference]) {\n                resource = resource[Resource.reference];\n            }\n            this.#resources.add(resource);\n        }\n    }\n\n    /**\n     * Wait until the resources have no exclusive transactions and then lock.\n     */\n    async acquireLocks() {\n        while (true) {\n            let blockedBy: undefined | Set<Transaction>;\n\n            for (const resource of this.#resources) {\n                const lockedBy = resource.lockedBy;\n                if (lockedBy && lockedBy !== this.#transaction) {\n                    if (!blockedBy) {\n                        blockedBy = new Set();\n                    }\n                    blockedBy.add(lockedBy);\n                }\n            }\n\n            if (!blockedBy) {\n                break;\n            }\n\n            this.#detectDeadlock(blockedBy);\n\n            await this.#transaction.waitFor(blockedBy);\n        }\n\n        return this.acquireLocksSync();\n    }\n\n    /**\n     * Acquire locks synchronously.\n     *\n     * Throws an error if resources aren't lockable.\n     */\n    acquireLocksSync() {\n        const toLock = new Set<Resource>();\n        const blocked = new Set<Resource>();\n        for (const resource of this.#resources) {\n            if (resource.lockedBy) {\n                if (resource.lockedBy === this.#transaction) {\n                    continue;\n                }\n                logger.warn(\"Transaction\", this.#transaction.via, \"blocked by\", resource.lockedBy.via);\n                blocked.add(resource);\n            }\n            toLock.add(resource);\n        }\n        if (blocked.size) {\n            logger.warn(\"You may need to await transaction.begin() to acquire locks asynchronously\");\n            const names = [...blocked].map(s => s.toString());\n            throw new SynchronousTransactionConflictError(`Cannot lock ${describeList(\"and\", ...names)} synchronously`);\n        }\n\n        // Update resource status\n        for (const resource of toLock) {\n            resource.lockedBy = this.#transaction;\n        }\n\n        return toLock;\n    }\n\n    /**\n     * Release locks.\n     */\n    releaseLocks() {\n        const unlocked = new Set<Resource>();\n\n        for (const resource of this.#resources) {\n            if (resource.lockedBy === this.#transaction) {\n                delete resource.lockedBy;\n                unlocked.add(resource);\n            }\n        }\n\n        return unlocked;\n    }\n\n    /**\n     * Ensure that a transaction that is committing or rolling back has all resources locked.\n     *\n     * This is just a sanity check.\n     */\n    assertResourcesAreLocked(transaction: Transaction, why: string) {\n        for (const resource of transaction.resources) {\n            if (resource.lockedBy !== transaction) {\n                throw new TransactionFlowError(`Transaction attempted ${why} but does not have all resources locked`);\n            }\n        }\n    }\n\n    /**\n     * If two transactions would block each other then we would have a deadlock.\n     *\n     * This is unlikely but not impossible.  It can happen if an endpoint is added to an exclusive transaction but a\n     * second transaction already has exclusivity on the new endpoint *and* is waiting on the first transaction.\n     *\n     * So... detect if the wait graph would have cycles if we an endpoint.  If so, throw an error.\n     */\n    #detectDeadlock(blockedBy: Set<Transaction>) {\n        // Recursively examine the transaction holding each resource we wish to lock.  If any of them are waiting for a\n        // resource that I have locked then we've detected deadlock\n        const examined = new Set<Transaction>();\n        const examineBlocker = (transaction: Transaction) => {\n            examined.add(transaction);\n            if (transaction === this.#transaction) {\n                throw new TransactionDeadlockError(\n                    \"Resource deadlock detected, write operation cannot proceed.  \" +\n                        \"To prevent this you can await transaction.begin() before modifying state\",\n                );\n            }\n\n            if (transaction.waitingOn) {\n                for (const blocker of transaction.waitingOn) {\n                    if (!examined.has(blocker)) {\n                        examineBlocker(blocker);\n                    }\n                }\n            }\n        };\n\n        for (const transaction of blockedBy) {\n            examineBlocker(transaction);\n        }\n    }\n\n    [Symbol.iterator]() {\n        return this.#resources[Symbol.iterator]();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
