{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/validation/ValueValidator.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DataModelPath } from \"../../../model/definitions/DataModelPath.js\";\nimport { AttributeModel, ClusterModel, Metatype, ValueModel } from \"../../../model/index.js\";\nimport { FeatureMap } from \"../../../model/standard/elements/FeatureMap.js\";\nimport { StatusCode } from \"../../../protocol/interaction/StatusCode.js\";\nimport { camelize } from \"../../../util/String.js\";\nimport { ConformanceError, DatatypeError, SchemaImplementationError } from \"../../errors.js\";\nimport { RootSupervisor } from \"../../supervision/RootSupervisor.js\";\nimport { Schema } from \"../../supervision/Schema.js\";\nimport type { ValueSupervisor } from \"../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../Val.js\";\nimport { Internal } from \"../managed/Internal.js\";\nimport {\n    assertArray,\n    assertBoolean,\n    assertBytes,\n    assertNumber,\n    assertNumeric,\n    assertObject,\n    assertString,\n} from \"./assertions.js\";\nimport { createConformanceValidator } from \"./conformance.js\";\nimport { createConstraintValidator } from \"./constraint.js\";\nimport { ValidationLocation } from \"./location.js\";\n\n/**\n * Generate a function that performs data validation.\n *\n * @param schema the schema against which we validate\n * @param factory used to retrieve validators for sub-properties\n */\nexport function ValueValidator(schema: Schema, factory: RootSupervisor): ValueSupervisor.Validate | undefined {\n    if (schema instanceof ClusterModel) {\n        return createStructValidator(schema, factory) ?? (() => {});\n    }\n\n    let validator: ValueSupervisor.Validate | undefined;\n    const metatype = schema.effectiveMetatype;\n    switch (metatype) {\n        case Metatype.enum:\n            validator = createEnumValidator(schema);\n            break;\n\n        case Metatype.bitmap:\n            validator = createBitmapValidator(schema);\n            break;\n\n        case Metatype.integer:\n        case Metatype.float:\n            validator = createSimpleValidator(schema, assertNumeric);\n            break;\n\n        case Metatype.boolean:\n            validator = createSimpleValidator(schema, assertBoolean);\n            break;\n\n        case Metatype.string:\n            validator = createSimpleValidator(schema, assertString);\n            break;\n\n        case Metatype.bytes:\n            validator = createSimpleValidator(schema, assertBytes);\n            break;\n\n        case Metatype.object:\n            validator = createStructValidator(schema, factory);\n            break;\n\n        case Metatype.array:\n            validator = createListValidator(schema, factory);\n            break;\n\n        case Metatype.date:\n        case Metatype.any:\n            break;\n\n        case undefined:\n            const type = schema.effectiveType;\n            if (type === undefined) {\n                if (schema.isDisallowed) {\n                    // We do not need to validate types for disallowed members and the specification may not include\n                    // them\n                    break;\n                }\n                throw new SchemaImplementationError(DataModelPath(schema.path), `No type defined`);\n            }\n            throw new SchemaImplementationError(\n                DataModelPath(schema.path),\n                `Cannot determine metatype for type \"${type}\"`,\n            );\n\n        default:\n            throw new SchemaImplementationError(\n                DataModelPath((schema as Schema).path),\n                `Unsupported validation metatype ${metatype}`,\n            );\n    }\n\n    validator = createNullValidator(schema, validator);\n\n    validator = createConformanceValidator(schema, factory.featureMap, factory.supportedFeatures, validator);\n\n    return validator;\n}\n\nfunction createNullValidator(\n    schema: ValueModel,\n    nextValidator?: ValueSupervisor.Validate,\n): ValueSupervisor.Validate | undefined {\n    if (schema.effectiveQuality.nullable === true) {\n        return (value, options, location) => {\n            if (value !== null) {\n                nextValidator?.(value, options, location);\n            }\n        };\n    }\n\n    // If the field is not nullable, let the datatype check handle validation\n    return nextValidator;\n}\n\nfunction createEnumValidator(schema: ValueModel): ValueSupervisor.Validate | undefined {\n    const valid = new Set(schema.activeMembers.map(member => member.id).filter(e => e !== undefined));\n\n    const constraint = schema.effectiveConstraint;\n    const constraintValidator = constraint.in\n        ? createConstraintValidator(schema.effectiveConstraint, schema)\n        : undefined;\n\n    return (value, session, location) => {\n        assertNumber(value, location);\n        if (!valid.has(value)) {\n            throw new DatatypeError(location, \"defined in enum\", value, StatusCode.ConstraintError);\n        }\n\n        constraintValidator?.(value, session, location);\n    };\n}\n\nfunction createBitmapValidator(schema: ValueModel): ValueSupervisor.Validate | undefined {\n    const fields = {} as Record<string, { schema: ValueModel; max: number }>;\n\n    for (const field of schema.activeMembers) {\n        const constraint = field.effectiveConstraint;\n        let max;\n        if (typeof constraint.min === \"number\" && typeof constraint.max === \"number\") {\n            max = constraint.max - constraint.min;\n        } else {\n            max = 1;\n        }\n        let name;\n        if (field?.parent?.id === FeatureMap.id) {\n            name = camelize(field.description ?? field.name);\n        } else {\n            name = camelize(field.name);\n        }\n        fields[name] = {\n            schema: field,\n            max,\n        };\n    }\n\n    return (value, _session, location) => {\n        assertObject(value, location);\n\n        for (const key in value) {\n            const field = fields[key];\n            const subpath = location.path.at(key);\n\n            if (field === undefined) {\n                throw new DatatypeError(subpath, \"defined in bitmap\", key);\n            }\n\n            const fieldValue = value[key];\n            if (fieldValue === undefined) {\n                continue;\n            }\n\n            if (field.max === 1) {\n                assertBoolean(fieldValue, subpath);\n            } else {\n                assertNumber(fieldValue, subpath);\n\n                if (fieldValue > field.max) {\n                    throw new DatatypeError(subpath, \"in range of bit field\", fieldValue);\n                }\n            }\n        }\n    };\n}\n\nfunction createSimpleValidator(\n    schema: ValueModel,\n    validateType: (value: Val, location: ValidationLocation) => void,\n): ValueSupervisor.Validate {\n    const validateConstraint = createConstraintValidator(schema.effectiveConstraint, schema);\n\n    return (value, session, location) => {\n        // If undefined, only conformance tests apply\n        if (value === undefined) {\n            return;\n        }\n\n        validateType(value, location);\n\n        validateConstraint?.(value, session, location);\n    };\n}\n\nfunction createStructValidator(schema: Schema, factory: RootSupervisor): ValueSupervisor.Validate | undefined {\n    const validators = {} as Record<string, ValueSupervisor.Validate>;\n\n    for (const field of schema.activeMembers) {\n        // Skip deprecated, and global attributes we currently handle in lower levels\n        if (field.isDeprecated || AttributeModel.isGlobal(field)) {\n            continue;\n        }\n        const validate = factory.get(field).validate;\n        if (validate) {\n            validators[camelize(field.name)] = validate;\n        }\n    }\n\n    const validateStruct: ValueSupervisor.Validate = (struct, session, location) => {\n        assertObject(struct, location);\n        const sublocation = {\n            path: location.path.at(\"\"),\n            siblings: struct,\n            choices: {},\n        } as ValidationLocation;\n\n        for (const name in validators) {\n            let value;\n\n            if ((struct as Val.Dynamic)[Val.properties]) {\n                const rootOwner = (struct as unknown as Internal.Collection)[Internal.reference];\n                const properties = (struct as Val.Dynamic)[Val.properties](rootOwner, session);\n                if (name in properties) {\n                    value = properties[name];\n                } else {\n                    value = struct[name];\n                }\n            } else {\n                value = struct[name];\n            }\n\n            sublocation.path.id = name;\n            validators[name](value, session, sublocation);\n        }\n\n        for (const name in sublocation.choices) {\n            const choice = sublocation.choices[name];\n\n            if (choice.count < choice.target) {\n                throw new ConformanceError(\n                    schema,\n                    location,\n                    `Too few fields present (${choice.count} of min ${choice.target})`,\n                    name,\n                );\n            }\n\n            if (choice.count > choice.target && !choice.orMore) {\n                throw new ConformanceError(\n                    schema,\n                    location,\n                    `Too many fields present (${choice.count} of max ${choice.target})`,\n                    name,\n                );\n            }\n        }\n    };\n\n    return validateStruct;\n}\n\nfunction createListValidator(schema: ValueModel, factory: RootSupervisor): ValueSupervisor.Validate | undefined {\n    const entry = schema.listEntry;\n    let validateEntries: undefined | ValueSupervisor.Validate;\n    if (entry) {\n        const entryValidator = factory.get(entry).validate;\n\n        if (entryValidator) {\n            validateEntries = (list: Val, session: ValueSupervisor.Session, location: ValidationLocation) => {\n                if (!list || typeof (list as Iterable<unknown>)[Symbol.iterator] !== \"function\") {\n                    throw new DatatypeError(location, \"a list\", list);\n                }\n\n                let index = 0;\n                const sublocation = {\n                    path: location.path.at(\"\"),\n                };\n                for (const e of list as Iterable<unknown>) {\n                    if (e === undefined || e === null) {\n                        // Accept nullish\n                        continue;\n                    }\n\n                    sublocation.path.id = index;\n                    entryValidator(e, session, sublocation);\n\n                    index++;\n                }\n            };\n        }\n    }\n\n    const validateConstraint = createConstraintValidator(schema.constraint, schema);\n\n    return (value, session, location) => {\n        assertArray(value, location);\n        validateConstraint?.(value, session, location);\n        validateEntries?.(value, session, location);\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
