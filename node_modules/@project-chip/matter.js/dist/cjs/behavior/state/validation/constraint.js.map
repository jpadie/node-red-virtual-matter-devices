{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/validation/constraint.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../../common/MatterError.js\";\nimport { Constraint, FieldValue, Metatype, ValueModel } from \"../../../model/index.js\";\nimport { ConstraintError } from \"../../errors.js\";\nimport { ValueSupervisor } from \"../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../Val.js\";\nimport { assertArray, assertBoolean, assertNumeric, assertSequence } from \"./assertions.js\";\n\n/**\n * Creates a function that validates values based on the constraint in the\n * schema.\n */\nexport function createConstraintValidator(\n    constraint: Constraint,\n    schema: ValueModel,\n): ValueSupervisor.Validate | undefined {\n    if (constraint.empty) {\n        return;\n    }\n\n    const metatype = schema.effectiveMetatype;\n    if (metatype === Metatype.array) {\n        return createArrayConstraintValidator(constraint, schema);\n    }\n\n    if (constraint.in) {\n        return (value, _session, location) => {\n            if (!constraint.test(value as FieldValue, location.siblings)) {\n                throw new ConstraintError(\n                    schema,\n                    location,\n                    `Value ${value} is not one of the values allowed by \"in\" constraint`,\n                );\n            }\n        };\n    }\n\n    switch (schema.effectiveMetatype) {\n        case Metatype.integer:\n        case Metatype.float:\n            return (value, _session, location) => {\n                assertNumeric(value, location);\n                if (!constraint.test(value, location.siblings)) {\n                    throw new ConstraintError(\n                        schema,\n                        location,\n                        `Value ${value} is not within bounds defined by constraint`,\n                    );\n                }\n            };\n\n        case Metatype.boolean:\n            return (value, _session, location) => {\n                assertBoolean(value, location);\n                if (!constraint.test(value, location.siblings)) {\n                    throw new ConstraintError(schema, location, `Value ${value} is disallowed by constraint`);\n                }\n            };\n\n        case Metatype.string:\n        case Metatype.bytes:\n            return (value: Val, _session, location) => {\n                assertSequence(value, location);\n                if (!constraint.test(value.length, location.siblings)) {\n                    throw new ConstraintError(\n                        schema,\n                        location,\n                        `Lenght of value ${value} is not within bounds defined by constraint`,\n                    );\n                }\n            };\n\n        default:\n            throw new InternalError(`Cannot define constraint for unsupported metatype ${schema.effectiveMetatype}`);\n    }\n}\n\n/**\n * Validate array constraints specifically.\n *\n * Array constraints behave like other sequence constraints in that they apply\n * to the length.  They are special however as they may have sub-constraints\n * that apply to data elements.\n */\nfunction createArrayConstraintValidator(constraint: Constraint, schema: ValueModel): ValueSupervisor.Validate {\n    let validateEntryConstraint: ValueSupervisor.Validate | undefined;\n    if (constraint.entry) {\n        const entrySchema = schema.listEntry;\n        if (entrySchema) {\n            validateEntryConstraint = createConstraintValidator(constraint.entry, entrySchema);\n        }\n    }\n\n    return (value, session, location) => {\n        assertArray(value, location);\n\n        if (!constraint.test(value.length, location.siblings)) {\n            throw new ConstraintError(\n                schema,\n                location,\n                `Array length ${value.length} is not within bounds defined by constraint`,\n            );\n        }\n\n        if (validateEntryConstraint) {\n            const sublocation = {\n                ...location,\n                path: location.path.at(\"\"),\n            };\n\n            let pos = 0;\n            for (const e of value) {\n                if (e === undefined || e === null) {\n                    // Accept nullish\n                    continue;\n                }\n\n                sublocation.path.id = pos;\n                validateEntryConstraint(e, session, sublocation);\n\n                pos++;\n            }\n        }\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,yBAA8B;AAC9B,mBAA6D;AAC7D,oBAAgC;AAGhC,wBAA0E;AAX1E;AAAA;AAAA;AAAA;AAAA;AAiBO,SAAS,0BACZ,YACA,QACoC;AACpC,MAAI,WAAW,OAAO;AAClB;AAAA,EACJ;AAEA,QAAM,WAAW,OAAO;AACxB,MAAI,aAAa,sBAAS,OAAO;AAC7B,WAAO,+BAA+B,YAAY,MAAM;AAAA,EAC5D;AAEA,MAAI,WAAW,IAAI;AACf,WAAO,CAAC,OAAO,UAAU,aAAa;AAClC,UAAI,CAAC,WAAW,KAAK,OAAqB,SAAS,QAAQ,GAAG;AAC1D,cAAM,IAAI;AAAA,UACN;AAAA,UACA;AAAA,UACA,SAAS,KAAK;AAAA,QAClB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAEA,UAAQ,OAAO,mBAAmB;AAAA,IAC9B,KAAK,sBAAS;AAAA,IACd,KAAK,sBAAS;AACV,aAAO,CAAC,OAAO,UAAU,aAAa;AAClC,6CAAc,OAAO,QAAQ;AAC7B,YAAI,CAAC,WAAW,KAAK,OAAO,SAAS,QAAQ,GAAG;AAC5C,gBAAM,IAAI;AAAA,YACN;AAAA,YACA;AAAA,YACA,SAAS,KAAK;AAAA,UAClB;AAAA,QACJ;AAAA,MACJ;AAAA,IAEJ,KAAK,sBAAS;AACV,aAAO,CAAC,OAAO,UAAU,aAAa;AAClC,6CAAc,OAAO,QAAQ;AAC7B,YAAI,CAAC,WAAW,KAAK,OAAO,SAAS,QAAQ,GAAG;AAC5C,gBAAM,IAAI,8BAAgB,QAAQ,UAAU,SAAS,KAAK,8BAA8B;AAAA,QAC5F;AAAA,MACJ;AAAA,IAEJ,KAAK,sBAAS;AAAA,IACd,KAAK,sBAAS;AACV,aAAO,CAAC,OAAY,UAAU,aAAa;AACvC,8CAAe,OAAO,QAAQ;AAC9B,YAAI,CAAC,WAAW,KAAK,MAAM,QAAQ,SAAS,QAAQ,GAAG;AACnD,gBAAM,IAAI;AAAA,YACN;AAAA,YACA;AAAA,YACA,mBAAmB,KAAK;AAAA,UAC5B;AAAA,QACJ;AAAA,MACJ;AAAA,IAEJ;AACI,YAAM,IAAI,iCAAc,qDAAqD,OAAO,iBAAiB,EAAE;AAAA,EAC/G;AACJ;AASA,SAAS,+BAA+B,YAAwB,QAA8C;AAC1G,MAAI;AACJ,MAAI,WAAW,OAAO;AAClB,UAAM,cAAc,OAAO;AAC3B,QAAI,aAAa;AACb,gCAA0B,0BAA0B,WAAW,OAAO,WAAW;AAAA,IACrF;AAAA,EACJ;AAEA,SAAO,CAAC,OAAO,SAAS,aAAa;AACjC,uCAAY,OAAO,QAAQ;AAE3B,QAAI,CAAC,WAAW,KAAK,MAAM,QAAQ,SAAS,QAAQ,GAAG;AACnD,YAAM,IAAI;AAAA,QACN;AAAA,QACA;AAAA,QACA,gBAAgB,MAAM,MAAM;AAAA,MAChC;AAAA,IACJ;AAEA,QAAI,yBAAyB;AACzB,YAAM,cAAc;AAAA,QAChB,GAAG;AAAA,QACH,MAAM,SAAS,KAAK,GAAG,EAAE;AAAA,MAC7B;AAEA,UAAI,MAAM;AACV,iBAAW,KAAK,OAAO;AACnB,YAAI,MAAM,UAAa,MAAM,MAAM;AAE/B;AAAA,QACJ;AAEA,oBAAY,KAAK,KAAK;AACtB,gCAAwB,GAAG,SAAS,WAAW;AAE/C;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
