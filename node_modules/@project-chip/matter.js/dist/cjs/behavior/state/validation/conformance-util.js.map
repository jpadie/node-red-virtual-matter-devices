{
  "version": 3,
  "sources": ["../../../../../src/behavior/state/validation/conformance-util.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DataModelPath } from \"../../../model/definitions/DataModelPath.js\";\nimport { Conformance, SchemaErrorPath, SchemaImplementationError } from \"../../../model/index.js\";\nimport { Schema } from \"../../supervision/Schema.js\";\nimport { Val } from \"../Val.js\";\nimport { ValidationLocation } from \"./location.js\";\n\nexport class UnsupportedConformanceNodeError extends SchemaImplementationError {\n    constructor(schema: Schema, compiledNode: DynamicNode) {\n        super(\n            DataModelPath(schema.path),\n            `Unknown or unsupported top-level conformance node type ${compiledNode.code}`,\n        );\n    }\n}\n\nexport enum Code {\n    // Ignored in logical disjunctions (groups and \"|\" operator); equivalent to disallowed otherwise\n    Nonconformant = \"nonconformant\",\n\n    // Expression matches; may convert to optional inside [] but mandatory otherwise\n    Conformant = \"conformant\",\n\n    // Expression matches and value is optional\n    Optional = \"optional\",\n\n    // Value must be undefined\n    Disallowed = \"disallowed\",\n\n    // A value; used in an expression or else evaluates to mandatory iff the associated value is defined\n    Value = \"value\",\n\n    // Dynamic node must be evaluated at runtime to produce static node\n    Evaluate = \"evaluate\",\n}\n\nexport interface ValueNode {\n    code: Code.Value;\n    value: Val;\n}\n\nexport type StaticNode =\n    | {\n          code: Code.Nonconformant | Code.Optional | Code.Conformant | Code.Disallowed;\n      }\n    | ValueNode;\n\nexport interface RuntimeNode {\n    code: Code.Evaluate;\n    evaluate: (value: Val, location: ValidationLocation) => StaticNode;\n}\n\nexport type DynamicNode = StaticNode | RuntimeNode;\n\n/**\n * Convert a static node to a dynamic node at runtime.\n */\nexport function evaluateNode(node: DynamicNode, value: Val, location: ValidationLocation): StaticNode {\n    if (node.code === Code.Evaluate) {\n        return node.evaluate(value, location);\n    }\n    return node;\n}\n\n/**\n * Cast value nodes to a conformance.\n *\n * A value node is conformant if the value is defined\n *\n * Non-value nodes are returned unchanged.\n */\nexport function asConformance<T extends DynamicNode>(node: T) {\n    if (node.code === Code.Value) {\n        return {\n            code:\n                node.value === undefined || node.value === null || node.value === false\n                    ? Code.Nonconformant\n                    : Code.Conformant,\n        } as const;\n    } else {\n        return node;\n    }\n}\n\nexport function isStatic(node: DynamicNode): node is StaticNode {\n    return node.code !== Code.Evaluate;\n}\n\nexport function asBoolean(node: StaticNode) {\n    node = asConformance(node);\n    switch (node.code) {\n        case Code.Conformant:\n        case Code.Optional:\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Throw an error if a node is not a value.\n *\n * We use this to ensure inputs to binary operators make sense.\n */\nexport function assertValue(location: SchemaErrorPath, node: DynamicNode, where: string): asserts node is ValueNode {\n    if (node.code !== Code.Value) {\n        throw new SchemaImplementationError(\n            location,\n            `Expected a value for ${where} but conformance node is \"${node.code}\"`,\n        );\n    }\n}\n\nexport const ConformantNode = { code: Code.Conformant } as const;\nexport const NonconformantNode = { code: Code.Nonconformant } as const;\n\n/**\n * Create a node that logically inverts the value of the input node.\n */\nexport function createLogicalInversion(node: DynamicNode): DynamicNode {\n    const operand = asConformance(node);\n\n    switch (operand.code) {\n        case Code.Nonconformant:\n            return ConformantNode;\n\n        case Code.Evaluate:\n            const evaluate = operand.evaluate;\n            return {\n                code: Code.Evaluate,\n\n                evaluate: (value, options) => {\n                    let staticOperand = evaluate(value, options);\n                    staticOperand = asConformance(staticOperand);\n\n                    if (staticOperand.code === Code.Nonconformant) {\n                        return ConformantNode;\n                    }\n                    return NonconformantNode;\n                },\n            };\n\n        default:\n            return NonconformantNode;\n    }\n}\n\ntype BinaryOperator<T> = (lhs: T, rhs: T) => boolean;\n\n/**\n * Create a node that evaluates a logical binary operator at runtime.\n */\nexport function createLogicalBinaryEvaluator(\n    lhs: RuntimeNode,\n    rhs: RuntimeNode,\n    operator: BinaryOperator<boolean>,\n): RuntimeNode {\n    return {\n        code: Code.Evaluate,\n\n        evaluate: (value, options) => {\n            const staticLhs = evaluateNode(lhs, value, options);\n            const staticRhs = evaluateNode(rhs, value, options);\n            return operator(asBoolean(staticLhs), asBoolean(staticRhs)) ? ConformantNode : NonconformantNode;\n        },\n    };\n}\n\nconst ComparisonOperators: Record<string, BinaryOperator<{}>> = {\n    [Conformance.Operator.EQ]: (a, b) => a === b,\n    [Conformance.Operator.GT]: (a, b) => a > b,\n    [Conformance.Operator.GTE]: (a, b) => a >= b,\n    [Conformance.Operator.LT]: (a, b) => a < b,\n    [Conformance.Operator.LTE]: (a, b) => a <= b,\n};\n\nfunction performComparison(\n    operatorName: Conformance.Operator,\n    lhs: StaticNode,\n    rhs: StaticNode,\n    schema: Schema,\n    location: SchemaErrorPath,\n): StaticNode {\n    const operator = ComparisonOperators[operatorName];\n    if (operator === undefined) {\n        throw new SchemaImplementationError(DataModelPath(schema.path), `Unknown binary operator ${operatorName}`);\n    }\n\n    assertValue(location, lhs, `Left-hand side of \"${operatorName}\"`);\n    assertValue(location, rhs, `Right-hand side of \"${operatorName}\"`);\n\n    if (\n        lhs.value !== undefined &&\n        lhs.value !== null &&\n        rhs.value !== undefined &&\n        rhs.value !== null &&\n        operator(lhs.value, rhs.value)\n    ) {\n        return ConformantNode;\n    }\n\n    return NonconformantNode;\n}\n\n/**\n * Create a node that evaluates a comparison operator.\n */\nexport function createComparison(\n    operatorName: Conformance.Operator,\n    lhs: DynamicNode,\n    rhs: DynamicNode,\n    schema: Schema,\n): DynamicNode {\n    // If both sides are static evaluate statically\n    if (isStatic(lhs) && isStatic(rhs)) {\n        return performComparison(operatorName, lhs, rhs, schema, DataModelPath(schema.path));\n    }\n\n    // Evaluate at runtime\n    return {\n        code: Code.Evaluate,\n\n        evaluate: (value, location) =>\n            performComparison(\n                operatorName,\n                evaluateNode(lhs, value, location),\n                evaluateNode(rhs, value, location),\n                schema,\n                location,\n            ),\n    };\n}\n\n/**\n * Create a node that performs a runtime boolean test.\n */\nexport function createBooleanTest(node: DynamicNode): DynamicNode {\n    if (isStatic(node)) {\n        return node;\n    }\n\n    const { evaluate } = node;\n\n    return {\n        code: Code.Evaluate,\n\n        evaluate: (value, location) => {\n            const result = evaluate(value, location);\n            assertValue(location, result, \"boolean test\");\n            return asConformance(result);\n        },\n    };\n}\n\nexport type EnumMemberValidator = (location: ValidationLocation) => void;\n"],
  "mappings": "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",
  "names": ["Code"]
}
