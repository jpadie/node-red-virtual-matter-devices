{
  "version": 3,
  "sources": ["../../../../../../src/behavior/state/managed/values/ValuePatcher.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"../../../../common/MatterError.js\";\nimport { DataModelPath } from \"../../../../model/definitions/DataModelPath.js\";\nimport { Metatype, ValueModel } from \"../../../../model/index.js\";\nimport { camelize } from \"../../../../util/String.js\";\nimport { isObject } from \"../../../../util/Type.js\";\nimport { SchemaImplementationError, WriteError } from \"../../../errors.js\";\nimport { RootSupervisor } from \"../../../supervision/RootSupervisor.js\";\nimport { Schema } from \"../../../supervision/Schema.js\";\nimport { ValueSupervisor } from \"../../../supervision/ValueSupervisor.js\";\nimport { Val } from \"../../Val.js\";\n\n/**\n * Obtain a {@link ValueSupervisor.Patch} function for the given schema.\n */\nexport function ValuePatcher(schema: Schema, owner: RootSupervisor) {\n    switch (schema.effectiveMetatype) {\n        // \"any\" means the schema defines no type.  Assume it's an object since ValuePatcher is only invoked where\n        // an object is expected naturally\n        case Metatype.any:\n        case Metatype.object:\n            return StructPatcher(schema as ValueModel, owner);\n\n        case Metatype.array:\n            return ListPatcher(schema as ValueModel, owner);\n\n        default:\n            return PrimitivePatcher();\n    }\n}\n\nconst defaultsCache = new WeakMap<Schema, Val.Struct>();\n\n/**\n * Obtain default values for a struct.\n */\nfunction getDefaults(schema: Schema): Val.Struct {\n    if (defaultsCache.has(schema)) {\n        return defaultsCache.get(schema) as Val.Struct;\n    }\n\n    const defaults = {} as Val.Struct;\n    for (const member of schema.activeMembers) {\n        if (member.default !== undefined) {\n            defaults[camelize(member.name)] = member.default;\n            continue;\n        }\n\n        if (member.mandatory && member.nullable) {\n            defaults[camelize(member.name)] = null;\n            continue;\n        }\n\n        // No default\n    }\n\n    defaultsCache.set(schema, defaults);\n\n    return defaults;\n}\n\n/**\n * Create a function that takes a patch object and applies it to a target object.\n */\nfunction StructPatcher(schema: ValueModel, owner: RootSupervisor): ValueSupervisor.Patch {\n    // An object mapping name to a patch function for sub-collections and undefined otherwise\n    const memberPatchers = {} as Record<string, ValueSupervisor.Patch | undefined>;\n\n    // An object mapping name to default value (if any) for sub-structs\n    const memberDefaults = {} as Record<string, Val.Struct>;\n\n    // An object mapping name to true iff member is an array\n    const memberArrays = {} as Record<string, boolean>;\n\n    for (const member of schema.activeMembers) {\n        const metatype = member.effectiveMetatype;\n\n        let handler: ValueSupervisor.Patch | undefined;\n        if (metatype === Metatype.object || metatype === Metatype.array) {\n            handler = owner.get(member).patch;\n        }\n\n        const key = camelize(member.name);\n\n        memberPatchers[key] = handler;\n\n        if (metatype === Metatype.object) {\n            memberDefaults[key] = getDefaults(member);\n        }\n\n        if (metatype === Metatype.array) {\n            memberArrays[key] = true;\n        }\n    }\n\n    return (changes, target, path) => {\n        // Validate changes\n        if (typeof changes !== \"object\" || changes === null || Array.isArray(changes)) {\n            throw new WriteError(path, `patch definition ${changes} is not an object`);\n        }\n\n        // Validate target\n        if (typeof target !== \"object\" || target === null || Array.isArray(target)) {\n            throw new WriteError(path, `cannot patch ${target} because it is not an object`);\n        }\n\n        for (const key in changes) {\n            // Validate the key\n            if (!(key in memberPatchers)) {\n                throw new WriteError(path, `${key} is not a property of ${schema.name}`);\n            }\n\n            let newValue = changes[key];\n\n            // If this is not a subcollection or the new value is not an object, just do direct set\n            const subpatch = memberPatchers[key];\n            if (!subpatch || newValue === null || typeof newValue !== \"object\") {\n                target[key] = newValue;\n                continue;\n            }\n\n            // If the target is a list but currently empty, create by patching an empty array.  This ensures arrays of\n            // structs have defaults initialized\n            if (memberArrays[key]) {\n                if (target[key] === undefined || target[key] === null) {\n                    newValue = subpatch(newValue as Val.Collection, [], path.at(key));\n                    target[key] = newValue;\n                    continue;\n                }\n            }\n\n            // If the field is a struct but currently empty, create by patching over defaults\n            if (target[key] === undefined || target[key] === null) {\n                newValue = subpatch(newValue as Val.Collection, { ...memberDefaults[key] }, path.at(key));\n                target[key] = newValue;\n                continue;\n            }\n\n            // Patch existing container.  Casts to collection here may be incorrect but we the subpatcher will validate\n            // input and throw for non-collections\n            subpatch(newValue as Val.Collection, target[key] as Val.Collection, path.at(key));\n        }\n\n        return target;\n    };\n}\n\n/**\n * Creates a function that takes a patch object and applies it to a target array.\n */\nfunction ListPatcher(schema: ValueModel, owner: RootSupervisor): ValueSupervisor.Patch {\n    const entry = schema.listEntry;\n    if (entry === undefined) {\n        throw new SchemaImplementationError(DataModelPath(schema.path), \"List schema has no entry definition\");\n    }\n\n    const entryMetatype = entry?.effectiveMetatype;\n\n    let patchEntry: ValueSupervisor.Patch | undefined;\n    if (entryMetatype === Metatype.object || entryMetatype === Metatype.array) {\n        patchEntry = owner.get(entry).patch;\n    }\n\n    let entryDefaults: Val.Struct | undefined;\n    if (entryMetatype === Metatype.object) {\n        entryDefaults = getDefaults(entry);\n    }\n\n    return (changes, target, path) => {\n        // Validate changes\n        if (typeof changes !== \"object\" || changes === null) {\n            throw new WriteError(path, `patch definition ${changes} is not an object`);\n        }\n\n        // Validate target\n        if (!Array.isArray(target)) {\n            throw new WriteError(path, `patch definition ${changes} is not an object`);\n        }\n\n        for (const indexStr in changes) {\n            const index = Number.parseInt(indexStr);\n\n            if (index < 0 || Number.isNaN(index)) {\n                throw new WriteError(path, `key ${index} is not a valid array index`);\n            }\n\n            // Changes may be an array or object but JS allows string indices either way even though TS doesn't\n            let newValue = (changes as Val.Struct)[indexStr];\n\n            if (patchEntry) {\n                const oldValue = index < target.length ? target[index] : undefined;\n                if (newValue === undefined || newValue === null || oldValue === undefined || oldValue === null) {\n                    // If creating a new object, apply as a patch to the object's defaults before insertion\n                    if (entryDefaults && isObject(newValue)) {\n                        newValue = patchEntry(newValue as Val.Collection, { ...entryDefaults }, path.at(index));\n                    }\n\n                    target[index] = newValue;\n                } else {\n                    patchEntry(newValue as Val.Collection, target[index] as Val.Collection, path.at(index));\n                }\n            } else {\n                target[index] = newValue;\n            }\n        }\n\n        return target;\n    };\n}\n\nfunction PrimitivePatcher(): ValueSupervisor.Patch {\n    return (_changes, _target, path) => {\n        throw new ImplementationError(`Cannot generate patch ${path} because it does not define not a collection`);\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
