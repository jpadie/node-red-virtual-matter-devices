{
  "version": 3,
  "sources": ["../../../../src/behavior/cluster/ClusterBehaviorUtil.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Attribute } from \"../../cluster/Cluster.js\";\nimport { ClusterType } from \"../../cluster/ClusterType.js\";\nimport { ImplementationError } from \"../../common/MatterError.js\";\nimport { ClusterModel, ElementTag, FeatureSet, Matter, Metatype, ValueModel } from \"../../model/index.js\";\nimport { FeatureMap } from \"../../model/standard/elements/FeatureMap.js\";\nimport { GeneratedClass } from \"../../util/GeneratedClass.js\";\nimport { AsyncObservable } from \"../../util/Observable.js\";\nimport { camelize } from \"../../util/String.js\";\nimport { Behavior } from \"../Behavior.js\";\nimport { DerivedState } from \"../state/StateType.js\";\nimport { Val } from \"../state/Val.js\";\nimport { Schema } from \"../supervision/Schema.js\";\nimport type { ClusterBehavior } from \"./ClusterBehavior.js\";\n\nconst KNOWN_DEFAULTS = Symbol(\"knownDefaults\");\n\n/**\n * This is an internal utility used to track default values that we've erased due to conformance.  We reuse in\n * derivatives if the property is once again enabled.\n *\n * We cast the state constructor to this type so [KNOWN_DEFAULTS] becomes a static field on the state class.\n */\ninterface HasKnownDefaults {\n    [KNOWN_DEFAULTS]?: Val.Struct;\n}\n\n/**\n * Create a non-functional instance of a {@link Behavior} for introspection purposes.\n */\nexport function introspectionInstanceOf(type: Behavior.Type) {\n    return new (type as unknown as new () => Record<string, (...args: any[]) => any>)();\n}\n\n/**\n * This is the actual implementation of ClusterBehavior.for().  The result must match {@link ClusterBehavior.Type}<C>.\n */\nexport function createType<const C extends ClusterType>(cluster: C, base: Behavior.Type, schema?: Schema) {\n    const namesUsed = new Set<string>();\n\n    if (schema === undefined) {\n        if (base.schema) {\n            schema = base.schema;\n        }\n        if (!schema) {\n            schema = schemaForCluster(cluster);\n        }\n    }\n\n    schema = syncFeatures(schema, cluster);\n\n    let name;\n    if (base.name.startsWith(cluster.name)) {\n        name = base.name;\n    } else {\n        name = `${cluster.name}Behavior`;\n    }\n\n    // Mutation of schema will almost certainly result in logic errors so ensure that can't happen\n    schema.freeze();\n\n    return GeneratedClass({\n        name,\n        base,\n\n        // These are really read-only but installing as getters on the prototype prevents us from overriding using\n        // namespace overrides.  If we instead override as static properties then we lose the automatic interface type.\n        // So just publish as static properties.\n        staticProperties: {\n            State: createDerivedState(cluster, schema, base, namesUsed),\n\n            Events: createDerivedEvents(cluster, base, namesUsed),\n        },\n\n        staticDescriptors: {\n            id: {\n                value: camelize(cluster.name) as Uncapitalize<string>,\n                enumerable: true,\n            },\n\n            cluster: {\n                value: cluster,\n                enumerable: true,\n            },\n\n            schema: {\n                value: schema,\n            },\n        },\n\n        instanceDescriptors: createDefaultCommandDescriptors(cluster, base),\n    });\n}\n\n/**\n * The cluster type for a behavior.\n */\nexport type ClusterOf<B extends Behavior.Type> = B extends { cluster: infer C extends ClusterType }\n    ? C\n    : ClusterType.Unknown;\n\n/**\n * The extension interface for a behavior.\n */\nexport type ExtensionInterfaceOf<B extends Behavior.Type> = B extends { ExtensionInterface: infer I extends {} }\n    ? I\n    : {};\n\n/**\n * Create a new state subclass that inherits relevant default values from a base Behavior.Type and adds new default\n * values from cluster attributes.\n *\n * Note - we only use the cluster here for default values\n */\nfunction createDerivedState(cluster: ClusterType, schema: Schema, base: Behavior.Type, namesUsed: Set<string>) {\n    const BaseState = base[\"State\"];\n    if (BaseState === undefined) {\n        throw new ImplementationError(`No state class defined for behavior class ${base.name}`);\n    }\n\n    const oldDefaults = new BaseState() as Record<string, any>;\n    let knownDefaults = (BaseState as HasKnownDefaults)[KNOWN_DEFAULTS];\n\n    // Determine the set of features so we can test attribute applicability\n    let featuresAvailable, featuresSupported;\n    if (schema instanceof ClusterModel) {\n        const normalized = FeatureSet.normalize(schema.featureMap, schema.supportedFeatures);\n        featuresAvailable = normalized.featuresAvailable;\n        featuresSupported = normalized.featuresSupported;\n    } else {\n        featuresAvailable = new FeatureSet();\n        featuresSupported = new FeatureSet();\n    }\n\n    // Index schema members by name\n    const props = {} as Record<string, ValueModel[]>;\n    for (const member of schema.activeMembers) {\n        const name = camelize(member.name);\n        if (props[name]) {\n            props[name].push(member);\n        } else {\n            props[name] = [member];\n        }\n    }\n\n    // For each new attribute, inject the attribute's default if we don't already have a value, then inject a descriptor\n    const defaults = {} as Record<string, any>;\n    for (const name in props) {\n        // Determine whether attribute applies based on conformance.  If it doesn't, make sure to overwrite any existing\n        // value from previous configurations as otherwise conformance may not pass\n        const attrs = props[name];\n        let propSchema;\n        let applies = false;\n\n        // Determine whether the attribute applies\n        for (const attr of attrs) {\n            if (attr.effectiveConformance.isApplicable(featuresAvailable, featuresSupported)) {\n                propSchema = attr;\n                applies = true;\n                break;\n            }\n        }\n\n        // If the attribute doesn't apply, erase any previous default\n        if (!applies) {\n            if (oldDefaults[name] !== undefined) {\n                // Save the default value so we can recreate it if a future derivative re-enables this element\n                if (!knownDefaults) {\n                    knownDefaults = {};\n                } else if (knownDefaults === (BaseState as HasKnownDefaults)[KNOWN_DEFAULTS]) {\n                    knownDefaults = { ...knownDefaults };\n                }\n                knownDefaults[name] = oldDefaults[name];\n\n                // Now clear the default value\n                defaults[name] = undefined;\n            }\n            continue;\n        }\n\n        // Attribute applies\n        const attribute = cluster.attributes[name];\n\n        // The feature map value requires a special case because it's encoded in the \"supportedFeatures\" cluster\n        // property\n        if (attribute?.id === FeatureMap.id) {\n            defaults[name] = cluster.supportedFeatures;\n            continue;\n        }\n\n        // Make sure a default value is present\n        defaults[name] = selectDefaultValue(\n            oldDefaults[name] === undefined ? knownDefaults?.[name] : oldDefaults[name],\n            attribute,\n            propSchema,\n        );\n    }\n\n    for (const name in defaults) {\n        // Convey the name to the event generator\n        namesUsed.add(name);\n    }\n\n    const StateType = DerivedState({\n        name: `${cluster.name}$State`,\n        base: base.State,\n        values: defaults,\n    });\n\n    if (knownDefaults) {\n        (StateType as HasKnownDefaults)[KNOWN_DEFAULTS] = knownDefaults;\n    }\n\n    return StateType;\n}\n\n/**\n * Extend events with additional implementations.\n */\nfunction createDerivedEvents(cluster: ClusterType, base: Behavior.Type, stateNames: Set<string>) {\n    const names = new Set<string>([\"interactionBegin\", \"interactionEnd\"]);\n\n    const baseInstance = new base.Events() as unknown as Record<string, unknown>;\n\n    // Add mandatory events that are not present in the base class\n    const applicableClusterEvents = new Set();\n    for (const name in cluster.events) {\n        applicableClusterEvents.add(name);\n        if (!cluster.events[name].optional && baseInstance[name] === undefined) {\n            names.add(name);\n        }\n    }\n\n    // Add events for mandatory attributes that are not present in the base class\n    for (const attrName of stateNames) {\n        const changing = `${attrName}$Changing`;\n        if (baseInstance[changing] === undefined) {\n            names.add(changing);\n        }\n\n        const changed = `${attrName}$Changed`;\n        if (baseInstance[changed] === undefined) {\n            names.add(changed);\n        }\n    }\n\n    // TODO - if necessary, mask out (set to undefined) events present in base cluster but not derived cluster\n\n    return GeneratedClass({\n        name: `${cluster.name}$Events`,\n        base: base.Events,\n\n        initialize() {\n            for (const name of names) {\n                (this as any)[name] = AsyncObservable();\n            }\n        },\n    });\n}\n\n/**\n * Obtain schema for a particular cluster.\n *\n * Currently we model TLV and TypeScript types with ClusterType and use ClusterModel for logical operations.  This dual\n * mode could probably be improved but we will continue to need a source for type information (ClusterType) and more\n * exhaustive operational metadata (ClusterModel).\n *\n * This acts as an adapter to load the appropriate {@link ClusterModel} for a {@link ClusterType}.\n */\nfunction schemaForCluster(cluster: ClusterType) {\n    let schema: ClusterModel | undefined;\n\n    for (const child of Matter.children) {\n        if (child.tag === ElementTag.Cluster && child.id === cluster.id) {\n            schema = new ClusterModel(child);\n            break;\n        }\n    }\n\n    if (schema === undefined) {\n        throw new ImplementationError(`Cannot locate schema for cluster ${cluster.id}, please supply manually`);\n    }\n\n    return schema;\n}\n\n/**\n * Ensure the supported features enumerated by schema align with a cluster definition.\n */\nfunction syncFeatures(schema: Schema, cluster: ClusterType) {\n    if (!(schema instanceof ClusterModel)) {\n        return schema;\n    }\n\n    const incomingFeatures = new FeatureSet(cluster.supportedFeatures);\n    if (new FeatureSet(cluster.supportedFeatures).is(schema.supportedFeatures)) {\n        return schema;\n    }\n    schema = schema.clone();\n    schema.supportedFeatures = incomingFeatures;\n    return schema;\n}\n\nfunction createDefaultCommandDescriptors(cluster: ClusterType, base: Behavior.Type) {\n    const result = {} as Record<string, PropertyDescriptor>;\n    const instance = introspectionInstanceOf(base);\n\n    for (const name in cluster.commands) {\n        if (!instance[name]) {\n            result[name] = {\n                value: Behavior.unimplemented,\n                writable: true,\n            };\n        }\n    }\n\n    return result;\n}\n\nfunction selectDefaultValue(oldDefault: Val, clusterAttr?: Attribute<any, any>, schemaProp?: ValueModel) {\n    if (oldDefault !== undefined) {\n        return oldDefault;\n    }\n\n    // Use cluster attribute rather than model attribute because currently \"enable\" modifies the cluster, not the schema\n    if (clusterAttr?.optional) {\n        return;\n    }\n\n    // Use cluster attribute rather than model attribute because currently \"set\" modifies the cluster, not the schema\n    if (clusterAttr?.default !== undefined) {\n        return clusterAttr.default;\n    }\n\n    // Following checks use the schema\n    if (!schemaProp) {\n        return;\n    }\n\n    if (schemaProp.nullable) {\n        return null;\n    }\n\n    const effectiveDefault = schemaProp.effectiveDefault;\n    if (effectiveDefault) {\n        return effectiveDefault;\n    }\n\n    // TODO - skip the following defaults if conformance is not absolutely mandatory.  This is pretty limited, may need\n    // to use more sophisticated evaluation if insufficient\n    const conformance = schemaProp.effectiveConformance;\n    if (!conformance.isMandatory) {\n        return;\n    }\n\n    switch (schemaProp.effectiveMetatype) {\n        case Metatype.bitmap:\n        case Metatype.object:\n            // This is not a very good default but it is better than undefined\n            return {};\n\n        case Metatype.array:\n            // Same\n            return [];\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
