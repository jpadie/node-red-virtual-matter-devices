{
  "version": 3,
  "sources": ["../../../../src/behavior/cluster/ClusterInterface.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type { ClusterType } from \"../../cluster/ClusterType.js\";\nimport type { ClusterComposer } from \"../../cluster/mutation/ClusterComposer.js\";\nimport type { BitSchema, TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport type { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport type { MaybePromise } from \"../../util/Promises.js\";\n\n/**\n * This type defines methods for a behavior grouped by named cluster component.\n *\n * Ideally we would do this using a simple mapped type.  Unfortunately as of TypeScript 5.2 there is no way to define a\n * method using a mapped type. Instead the mapped type defines function properties.\n *\n * Function properties work identically to methods semantically but TypeScript doesn't allow you to override them with\n * standard methods (see error TS2425).\n *\n * Thus we are forced to generate an interface for every cluster component and assemble based on selected features using\n * logic that mirrors {@link ClusterComposer.Of}.\n *\n * Note that we only need to do this for commands.  The public interface for attributes and events consists solely of\n * properties so we generate using mapped types.  This is handled by ClusterState and ClusterEvents respectively.\n *\n * If TS team ever fixes:\n *\n *   https://github.com/microsoft/TypeScript/issues/27965\n *\n * ...then we can remove the interface and just use {@link ClusterInterface.MappedMethodsOf}.\n *\n * This appears to be a duplicate (but is still open):\n *\n *   https://github.com/microsoft/TypeScript/issues/27689\n *\n * Proposed solution is to just remove the error:\n *\n *   https://github.com/microsoft/TypeScript/issues/48125\n *\n */\nexport type ClusterInterface<F extends BitSchema = {}> = {\n    components: ClusterInterface.Component<F>[];\n};\n\nexport namespace ClusterInterface {\n    export const Empty = { components: [] };\n    export interface Empty {\n        components: [];\n    }\n\n    export interface Component<F extends BitSchema = {}> {\n        flags: TypeFromPartialBitSchema<F>;\n        methods: {};\n    }\n\n    export type InterfaceOf<B> = B extends { Interface: infer I extends ClusterInterface } ? I : ClusterInterface;\n\n    export type MethodsOf<I extends ClusterInterface, C extends ClusterType> =\n        // This is the workaround for TS issue #27965\n        InterfaceMethodsOf<I, C[\"supportedFeatures\"]> &\n            // Fall back to mapping for methods not defined in an interface\n            Omit<MappedMethodsOf<C[\"commands\"]>, keyof InterfaceMethodsOf<I, C[\"supportedFeatures\"]>>;\n\n    export type InterfaceMethodsOf<\n        I extends ClusterInterface,\n        S extends ClusterComposer.FeatureFlags,\n    > = ClusterInterface extends I ? {} : AppliedMethodsOf<ApplicableComponents<I[\"components\"], S>>;\n\n    export type AppliedMethodsOf<CA extends Component[]> = CA extends [\n        infer C extends Component,\n        ...infer R extends Component[],\n    ]\n        ? C[\"methods\"] & AppliedMethodsOf<R>\n        : {};\n\n    export type ApplicableComponents<CA extends Component[], S extends ClusterComposer.FeatureFlags> = CA extends [\n        infer C extends Component,\n        ...infer R extends Component[],\n    ]\n        ? S extends C[\"flags\"]\n            ? [C, ...ApplicableComponents<R, S>]\n            : ApplicableComponents<R, S>\n        : [];\n\n    export type MethodForCommand<C extends ClusterType.Command> = (\n        request: TypeFromSchema<C[\"requestSchema\"]>,\n    ) => MaybePromise<TypeFromSchema<C[\"responseSchema\"]>>;\n\n    export type MappedMethodsOf<C extends Record<string, ClusterType.Command>> = string extends keyof C\n        ? {}\n        : {\n              readonly [K in keyof C as C[K] extends { optional: true } ? never : K]: MethodForCommand<C[K]>;\n          } & {\n              readonly [K in keyof C as C[K] extends { optional: true } ? K : never]?: MethodForCommand<C[K]>;\n          };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8CO,IAAU;AAAA,CAAV,CAAUA,sBAAV;AACI,EAAMA,kBAAA,QAAQ,EAAE,YAAY,CAAC,EAAE;AAAA,GADzB;",
  "names": ["ClusterInterface"]
}
