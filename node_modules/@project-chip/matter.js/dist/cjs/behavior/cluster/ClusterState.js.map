{
  "version": 3,
  "sources": ["../../../../src/behavior/cluster/ClusterState.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type { ClusterType } from \"../../cluster/ClusterType.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport type { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport type { Behavior } from \"../Behavior.js\";\nimport type { ClusterOf } from \"./ClusterBehaviorUtil.js\";\n\n/**\n * Instance type for complete (endpoint + fabric) state.\n */\nexport type ClusterState<C extends ClusterType, B extends Behavior.Type> = ClusterState.Type<C, B>;\n\n/**\n * State values for global attributes.\n *\n * These properties are present in the state object for all cluster behaviors.  We manage them automatically and they\n * would add unnecessary noise in the API so we omit them from public types.  But they are accessible in TypeScript by\n * casting state to GlobalAttributeState.\n */\nexport interface GlobalAttributeState {\n    clusterRevision: number;\n    featureMap: TypeFromPartialBitSchema<BitSchema>;\n    attributeList: AttributeId[];\n    acceptedCommandList: CommandId[];\n    generatedCommandList: CommandId[];\n    eventList: EventId[];\n}\n\nexport namespace ClusterState {\n    /**\n     * Instance type for ClusterBehavior state.\n     */\n    export type Type<C extends ClusterType, B extends Behavior.Type> =\n        // Keep properties *not* from attributes of the old cluster\n        Omit<InstanceType<B[\"State\"]>, keyof PropertiesOf<ClusterOf<B>>> &\n            // Add properties from attributes of the old cluster\n            PropertiesOf<C>;\n\n    /**\n     * Properties a cluster contributes state.\n     */\n    export type PropertiesOf<C> = PropertiesOfAttributes<ClusterType.AttributesOf<C>>;\n\n    export type PropertiesOfAttributes<A extends Record<string, ClusterType.Attribute>> = {\n        -readonly [N in keyof A as A[N] extends { fixed: true }\n            ? never\n            : A[N] extends { optional: true }\n              ? never\n              : N]: TypeFromSchema<A[N][\"schema\"]>;\n    } & {\n        -readonly [N in keyof A as A[N] extends { fixed: true }\n            ? never\n            : A[N] extends { optional: true }\n              ? N\n              : never]?: TypeFromSchema<A[N][\"schema\"]>;\n    } & {\n        -readonly [N in keyof A as A[N] extends { fixed: true }\n            ? A[N] extends { optional: true }\n                ? never\n                : N\n            : never]: TypeFromSchema<A[N][\"schema\"]>;\n    } & {\n        -readonly [N in keyof A as A[N] extends { fixed: true }\n            ? A[N] extends { optional: true }\n                ? N\n                : never\n            : never]?: TypeFromSchema<A[N][\"schema\"]>;\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
