{
  "version": 3,
  "sources": ["../../../../src/behavior/supervision/RootSupervisor.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { AttributeModel, ClusterModel, FeatureSet, ValueModel } from \"../../model/index.js\";\nimport { FeatureMap } from \"../../model/standard/elements/FeatureMap.js\";\nimport { camelize } from \"../../util/String.js\";\nimport { AccessControl } from \"../AccessControl.js\";\nimport { Val } from \"../state/Val.js\";\nimport { ValueCaster } from \"../state/managed/values/ValueCaster.js\";\nimport { ValueManager } from \"../state/managed/values/ValueManager.js\";\nimport { ValuePatcher } from \"../state/managed/values/ValuePatcher.js\";\nimport { ValueValidator } from \"../state/validation/ValueValidator.js\";\nimport { Schema } from \"./Schema.js\";\nimport { ValueSupervisor } from \"./ValueSupervisor.js\";\n\n/**\n * A RootSupervisor is a {@link ValueSupervisor} that supervises a specific root {@link Schema}.  It acts as a factory\n * for {@link ValueSupervisor}s for sub-schemas of the root schema.\n *\n * You can produce a ValueSupervisor for any schema using this factory. However, there are specific customizations\n * controlled by the root schema:\n *\n * - Change eventing occur for root schema members.  In the case of a cluster this means you can monitor for changes on\n *   a per-attribute basis.\n *\n * - If the root schema defines a cluster, the cluster's featureMap and supportedFeatures affect conformance-based\n *   validation.\n */\nexport class RootSupervisor implements ValueSupervisor {\n    #generating = new Set<Schema>();\n    #cache = new WeakMap<Schema, ValueSupervisor>();\n    #featureMap: ValueModel;\n    #supportedFeatures: FeatureSet;\n    #members: Set<ValueModel>;\n    #root: ValueSupervisor;\n    #memberNames?: Set<string>;\n    #persistentNames?: Set<string>;\n\n    /**\n     * Create a new supervisor.\n     *\n     * @param schema the {@link Schema} for the supervised data\n     */\n    constructor(schema: Schema) {\n        if (schema instanceof ClusterModel) {\n            this.#featureMap = schema.featureMap;\n            this.#supportedFeatures = schema.supportedFeatures ?? new FeatureSet();\n        } else {\n            this.#featureMap = new AttributeModel(FeatureMap);\n            this.#supportedFeatures = new FeatureSet();\n        }\n        this.#members = new Set(schema.activeMembers);\n\n        this.#root = this.#createValueSupervisor(schema);\n    }\n\n    get owner() {\n        return this.#root.owner;\n    }\n\n    get schema() {\n        return this.#root.schema;\n    }\n\n    get access() {\n        return this.#root.access;\n    }\n\n    get validate() {\n        return this.#root.validate;\n    }\n\n    get manage() {\n        return this.#root.manage;\n    }\n\n    get patch() {\n        return this.#root.patch;\n    }\n\n    get cast() {\n        return this.#root.cast;\n    }\n\n    /**\n     * The names of all members.\n     */\n    get memberNames() {\n        let names = this.#memberNames;\n        if (!names) {\n            names = new Set();\n            for (const member of this.#members) {\n                names.add(camelize(member.name));\n            }\n            this.#memberNames = names;\n        }\n        return names;\n    }\n\n    /**\n     * Names of fields configured as non-volatile.\n     */\n    get persistentNames() {\n        let persistent = this.#persistentNames;\n        if (!persistent) {\n            persistent = new Set();\n            for (const member of this.#members) {\n                // TODO: We should handle writable/fabric scoped being non-volatile already in the conformance interpreter\n                if (\n                    member.effectiveQuality.nonvolatile ||\n                    member.effectiveAccess.writable ||\n                    member.effectiveAccess.fabricScoped\n                ) {\n                    persistent.add(camelize(member.name));\n                }\n            }\n            this.#persistentNames = persistent;\n        }\n        return persistent;\n    }\n\n    /**\n     * All available features defined in the schema.\n     */\n    get featureMap() {\n        return this.#featureMap;\n    }\n\n    /**\n     * Features supported by this implementation.\n     */\n    get supportedFeatures() {\n        return this.#supportedFeatures;\n    }\n\n    /**\n     * Obtain {@link ValueSupervisor} implementation for a specific schema.\n     *\n     * @param schema the model describing the record type\n     * @returns the I/O implementation\n     */\n    get(schema: Schema): ValueSupervisor {\n        // #root isn't set whilc we generate root schema so guard against this.#root === undefined\n        if (schema === this.#root?.schema) {\n            return this;\n        }\n\n        let supervisor = this.#cache.get(schema);\n        if (supervisor === undefined) {\n            supervisor = this.#createValueSupervisor(schema);\n            this.#cache.set(schema, supervisor);\n        }\n\n        return supervisor;\n    }\n\n    #createValueSupervisor(schema: Schema) {\n        // Implements deferred generation (see comments below).  Proxies to the real generator, installs the generated\n        // function, then invokes. Since I/O functions are properties and not methods, we then continue to proxy to the\n        // generated function for places where the function is held directly.\n        const deferGeneration = (\n            name: string,\n            generator: (schema: Schema, factory: RootSupervisor, base?: new () => Val) => any,\n        ) => {\n            let generated = false;\n\n            return ((...args: any[]): any => {\n                if (!generated) {\n                    if (manager === undefined) {\n                        throw new InternalError(\"Deferred I/O generation invoked impossibly early\");\n                    }\n\n                    (manager as any)[name] = generator(schema, this);\n\n                    generated = true;\n                }\n\n                return (manager as any)[name](...args);\n            }) as any;\n        };\n\n        let manager: ValueSupervisor;\n        if (this.#isGenerating(schema)) {\n            manager = {\n                owner: this,\n                schema,\n                access: AccessControl(schema),\n                validate: deferGeneration(\"validate\", ValueValidator),\n                manage: deferGeneration(\"manage\", ValueManager),\n                patch: deferGeneration(\"patch\", ValuePatcher),\n                cast: deferGeneration(\"cast\", ValueCaster),\n            };\n        } else {\n            try {\n                this.#generating.add(schema);\n                manager = {\n                    owner: this,\n                    schema,\n                    access: AccessControl(schema),\n                    validate: ValueValidator(schema, this),\n                    manage: ValueManager(schema, this),\n                    patch: ValuePatcher(schema, this),\n                    cast: ValueCaster(schema, this),\n                };\n            } finally {\n                this.#generating.delete(schema);\n            }\n        }\n\n        this.#cache.set(schema, manager);\n\n        return manager;\n    }\n\n    /**\n     * If a schema has circular references, code generation may need to defer generation of child functions to avoid\n     * infinite loops.\n     *\n     * In order to keep generation code simpler we use this method to detect when lazy generation is necessary and\n     * install stubs that bootstrap each method.\n     */\n    #isGenerating(schema: Schema) {\n        return this.#generating.has(schema);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
