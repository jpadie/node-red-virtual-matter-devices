{
  "version": 3,
  "sources": ["../../../../src/behavior/supervision/BehaviorSupervisor.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Access, ClusterModel, DatatypeModel, FieldModel, type ValueModel } from \"../../model/index.js\";\nimport { camelize } from \"../../util/String.js\";\nimport type { Behavior } from \"../Behavior.js\";\nimport type { StateType } from \"../state/StateType.js\";\nimport type { Val } from \"../state/Val.js\";\nimport { RootSupervisor } from \"./RootSupervisor.js\";\nimport { Schema } from \"./Schema.js\";\n\n/**\n * Create a {@link RootSupervisor} for a {@link Behavior}.\n *\n * {@link Behavior} uses this internally for its {@link Behavior.supervisor}.\n *\n * BehaviorSupervisor derives operational schema from a \"logical\" schema.  If the {@link Behavior} implementation has a\n * static schema property this defines the logical schema.  Otherwise the logical schema is {@link Schema.empty}.\n *\n * This function loads the logical schema and mutates as required.  This includes addition of fields for any\n * programmatic extensions of state.  This allows schema-driven logic to process state fields added in pure JS.\n *\n * The {@link RootSupervisor} is then constructed from the mutated logical schema.\n */\nexport function BehaviorSupervisor(options: BehaviorSupervisor.Options): RootSupervisor {\n    const logical = options.schema ?? Schema.empty;\n\n    // Copy children so we can extend\n    const children = logical.children.map(child => child.clone());\n\n    // Add fields for programmatic extensions\n    addExtensionFields(logical, new options.State(), children);\n\n    // Create the root operational schema\n    let schema: Schema;\n    if (logical instanceof ClusterModel) {\n        schema = new ClusterModel({\n            ...logical,\n            name: `${camelize(options.id, true)}$State`,\n            children,\n        });\n    } else {\n        schema = new DatatypeModel({\n            ...logical,\n            type: logical.type ?? \"struct\",\n            name: `${camelize(options.id, true)}$State`,\n            children,\n        });\n    }\n\n    schema.freeze();\n\n    return new RootSupervisor(schema);\n}\n\nexport namespace BehaviorSupervisor {\n    export interface Options {\n        id: string;\n        schema?: Schema;\n        State: StateType;\n    }\n}\n\n/**\n * Adds a field for every property in state that isn't defined in the schema.\n *\n * Note 1: We skip all attributes, not just those that are applicable given the supported features.\n *\n * Note 2: Finding fields isn't as simple as just using \"for ... in\" because ES6 class accessors are non-enumerable.  So\n * we instead search the prototype chain for read/write descriptors.\n *\n * Note 3: We can't do anything with types either.  This means e.g. writing to subfields won't behave as expected.\n * Really to do things correctly behavior authors should hand-craft schema.  Or maybe we do something with decorators?.\n */\nfunction addExtensionFields(base: Schema, defaultState: Val.Struct, children: ValueModel[]) {\n    const props = new Set<string>();\n    for (const field of base.activeMembers) {\n        props.add(camelize(field.name));\n    }\n\n    function addProperties(object: null | Val.Struct) {\n        if (!object || object === Object.prototype) {\n            return;\n        }\n\n        const descriptors = Object.getOwnPropertyDescriptors(object);\n\n        for (const name in descriptors) {\n            if (props.has(name) || name === \"constructor\") {\n                continue;\n            }\n\n            if (!props.has(name)) {\n                props.add(name);\n\n                const field = new FieldModel({\n                    name,\n                    type: \"any\",\n\n                    access: new Access({\n                        readPriv: Access.Privilege.View,\n                        writePriv: Access.Privilege.Operate,\n                    }),\n                });\n\n                const descriptor = descriptors[name];\n                if (!descriptor.writable && !descriptor.set) {\n                    field.quality = \"F\";\n                }\n\n                children.push(field);\n            }\n        }\n\n        addProperties(Object.getPrototypeOf(object));\n    }\n\n    addProperties(defaultState);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,mBAAiF;AACjF,oBAAyB;AAIzB,4BAA+B;AAC/B,oBAAuB;AAZvB;AAAA;AAAA;AAAA;AAAA;AA2BO,SAAS,mBAAmB,SAAqD;AACpF,QAAM,UAAU,QAAQ,UAAU,qBAAO;AAGzC,QAAM,WAAW,QAAQ,SAAS,IAAI,WAAS,MAAM,MAAM,CAAC;AAG5D,qBAAmB,SAAS,IAAI,QAAQ,MAAM,GAAG,QAAQ;AAGzD,MAAI;AACJ,MAAI,mBAAmB,2BAAc;AACjC,aAAS,IAAI,0BAAa;AAAA,MACtB,GAAG;AAAA,MACH,MAAM,OAAG,wBAAS,QAAQ,IAAI,IAAI,CAAC;AAAA,MACnC;AAAA,IACJ,CAAC;AAAA,EACL,OAAO;AACH,aAAS,IAAI,2BAAc;AAAA,MACvB,GAAG;AAAA,MACH,MAAM,QAAQ,QAAQ;AAAA,MACtB,MAAM,OAAG,wBAAS,QAAQ,IAAI,IAAI,CAAC;AAAA,MACnC;AAAA,IACJ,CAAC;AAAA,EACL;AAEA,SAAO,OAAO;AAEd,SAAO,IAAI,qCAAe,MAAM;AACpC;AAqBA,SAAS,mBAAmB,MAAc,cAA0B,UAAwB;AACxF,QAAM,QAAQ,oBAAI,IAAY;AAC9B,aAAW,SAAS,KAAK,eAAe;AACpC,UAAM,QAAI,wBAAS,MAAM,IAAI,CAAC;AAAA,EAClC;AAEA,WAAS,cAAc,QAA2B;AAC9C,QAAI,CAAC,UAAU,WAAW,OAAO,WAAW;AACxC;AAAA,IACJ;AAEA,UAAM,cAAc,OAAO,0BAA0B,MAAM;AAE3D,eAAW,QAAQ,aAAa;AAC5B,UAAI,MAAM,IAAI,IAAI,KAAK,SAAS,eAAe;AAC3C;AAAA,MACJ;AAEA,UAAI,CAAC,MAAM,IAAI,IAAI,GAAG;AAClB,cAAM,IAAI,IAAI;AAEd,cAAM,QAAQ,IAAI,wBAAW;AAAA,UACzB;AAAA,UACA,MAAM;AAAA,UAEN,QAAQ,IAAI,oBAAO;AAAA,YACf,UAAU,oBAAO,UAAU;AAAA,YAC3B,WAAW,oBAAO,UAAU;AAAA,UAChC,CAAC;AAAA,QACL,CAAC;AAED,cAAM,aAAa,YAAY,IAAI;AACnC,YAAI,CAAC,WAAW,YAAY,CAAC,WAAW,KAAK;AACzC,gBAAM,UAAU;AAAA,QACpB;AAEA,iBAAS,KAAK,KAAK;AAAA,MACvB;AAAA,IACJ;AAEA,kBAAc,OAAO,eAAe,MAAM,CAAC;AAAA,EAC/C;AAEA,gBAAc,YAAY;AAC9B;",
  "names": []
}
