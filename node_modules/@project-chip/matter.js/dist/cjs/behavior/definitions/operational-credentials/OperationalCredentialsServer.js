"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OperationalCredentialsServer_exports = {};
__export(OperationalCredentialsServer_exports, {
  OperationalCredentialsServer: () => OperationalCredentialsServer
});
module.exports = __toCommonJS(OperationalCredentialsServer_exports);
var import_CertificateManager = require("../../../certificate/CertificateManager.js");
var import_Cluster = require("../../../cluster/Cluster.js");
var import_AccessControlCluster = require("../../../cluster/definitions/AccessControlCluster.js");
var import_OperationalCredentialsCluster = require("../../../cluster/definitions/OperationalCredentialsCluster.js");
var import_FailsafeContext = require("../../../common/FailsafeContext.js");
var import_FailsafeTimer = require("../../../common/FailsafeTimer.js");
var import_MatterError = require("../../../common/MatterError.js");
var import_ValidationError = require("../../../common/ValidationError.js");
var import_Crypto = require("../../../crypto/Crypto.js");
var import_FabricIndex = require("../../../datatype/FabricIndex.js");
var import_Fabric = require("../../../fabric/Fabric.js");
var import_FabricManager = require("../../../fabric/FabricManager.js");
var import_Logger = require("../../../log/Logger.js");
var import_StatusCode = require("../../../protocol/interaction/StatusCode.js");
var import_SecureSession = require("../../../session/SecureSession.js");
var import_TlvBoolean = require("../../../tlv/TlvBoolean.js");
var import_TlvObject = require("../../../tlv/TlvObject.js");
var import_TlvString = require("../../../tlv/TlvString.js");
var import_Val = require("../../state/Val.js");
var import_CommissioningBehavior = require("../../system/commissioning/CommissioningBehavior.js");
var import_ProductDescriptionServer = require("../../system/product-description/ProductDescriptionServer.js");
var import_AccessControlServer = require("../access-control/AccessControlServer.js");
var import_DeviceCertification = require("./DeviceCertification.js");
var import_OperationalCredentialsBehavior = require("./OperationalCredentialsBehavior.js");
var import_OperationalCredentialsTypes = require("./OperationalCredentialsTypes.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("OperationalCredentials");
import_OperationalCredentialsCluster.OperationalCredentials.Cluster.commands = {
  ...import_OperationalCredentialsCluster.OperationalCredentials.Cluster.commands,
  attestationRequest: (0, import_Cluster.Command)(
    0,
    (0, import_TlvObject.TlvObject)({ attestationNonce: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString) }),
    1,
    import_OperationalCredentialsCluster.OperationalCredentials.TlvAttestationResponse,
    { invokeAcl: import_Cluster.AccessLevel.Administer }
  ),
  csrRequest: (0, import_Cluster.Command)(
    4,
    (0, import_TlvObject.TlvObject)({
      csrNonce: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString),
      isForUpdateNoc: (0, import_TlvObject.TlvOptionalField)(1, import_TlvBoolean.TlvBoolean)
    }),
    5,
    import_OperationalCredentialsCluster.OperationalCredentials.TlvCsrResponse,
    { invokeAcl: import_Cluster.AccessLevel.Administer }
  )
};
class OperationalCredentialsServer extends import_OperationalCredentialsBehavior.OperationalCredentialsBehavior {
  initialize() {
    if (this.state.supportedFabrics === void 0) {
      this.state.supportedFabrics = 254;
    }
    this.state.commissionedFabrics = this.state.fabrics.length;
    this.reactTo(this.endpoint.lifecycle.online, this.#nodeOnline);
  }
  async attestationRequest({ attestationNonce }) {
    if (attestationNonce.length !== 32) {
      throw new import_StatusCode.StatusResponseError("Invalid attestation nonce length", import_StatusCode.StatusCode.InvalidCommand);
    }
    const certification = await this.getCertification();
    const elements = import_OperationalCredentialsTypes.TlvAttestation.encode({
      declaration: certification.declaration,
      attestationNonce,
      timestamp: 0
    });
    return {
      attestationElements: elements,
      attestationSignature: certification.sign(this.session, elements)
    };
  }
  async csrRequest({ csrNonce, isForUpdateNoc }) {
    if (csrNonce.length !== 32) {
      throw new import_StatusCode.StatusResponseError("Invalid csr nonce length", import_StatusCode.StatusCode.InvalidCommand);
    }
    if (isForUpdateNoc && this.session.isPase) {
      throw new import_StatusCode.StatusResponseError(
        "csrRequest for UpdateNoc received on a PASE session.",
        import_StatusCode.StatusCode.InvalidCommand
      );
    }
    const failsafeContext = this.session.context.failsafeContext;
    if (failsafeContext.fabricIndex !== void 0) {
      throw new import_StatusCode.StatusResponseError(
        `csrRequest received after ${failsafeContext.forUpdateNoc ? "UpdateNOC" : "AddNOC"} already invoked.`,
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    const certification = await this.getCertification();
    const certSigningRequest = failsafeContext.createCertificateSigningRequest(
      isForUpdateNoc ?? false,
      this.session.id
    );
    const nocsrElements = import_OperationalCredentialsTypes.TlvCertSigningRequest.encode({ certSigningRequest, csrNonce });
    return { nocsrElements, attestationSignature: certification.sign(this.session, nocsrElements) };
  }
  async certificateChainRequest({ certificateType }) {
    const certification = await this.getCertification();
    switch (certificateType) {
      case import_OperationalCredentialsCluster.OperationalCredentials.CertificateChainType.DacCertificate:
        return { certificate: certification.certificate };
      case import_OperationalCredentialsCluster.OperationalCredentials.CertificateChainType.PaiCertificate:
        return { certificate: certification.intermediateCertificate };
      default:
        throw new import_StatusCode.StatusResponseError(
          `Unsupported certificate type: ${certificateType}`,
          import_StatusCode.StatusCode.InvalidCommand
        );
    }
  }
  #mapNocErrors(error) {
    if (error instanceof import_FailsafeTimer.MatterFabricConflictError) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.FabricConflict,
        debugText: error.message
      };
    } else if (error instanceof import_FabricManager.FabricTableFullError) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.TableFull,
        debugText: error.message
      };
    } else if (error instanceof import_Crypto.CryptoVerifyError || error instanceof import_CertificateManager.CertificateError || error instanceof import_ValidationError.ValidationError || error instanceof import_MatterError.UnexpectedDataError) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.InvalidNoc,
        debugText: error.message
      };
    } else if (error instanceof import_Fabric.PublicKeyError) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.InvalidPublicKey,
        debugText: error.message
      };
    } else if (error instanceof import_FailsafeContext.MatterFabricInvalidAdminSubjectError) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.InvalidAdminSubject,
        debugText: error.message
      };
    }
    throw error;
  }
  async addNoc({
    nocValue,
    icacValue,
    ipkValue,
    caseAdminSubject,
    adminVendorId
  }) {
    const failsafeContext = this.session.context.failsafeContext;
    if (failsafeContext.fabricIndex !== void 0) {
      throw new import_StatusCode.StatusResponseError(
        `addNoc received after ${failsafeContext.forUpdateNoc ? "UpdateNOC" : "AddNOC"} already invoked.`,
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    if (!failsafeContext.hasRootCert) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.InvalidNoc,
        debugText: "Root certificate not found."
      };
    }
    if (failsafeContext.csrSessionId !== this.session.id) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.MissingCsr,
        debugText: "CSR not found in failsafe context."
      };
    }
    if (failsafeContext.forUpdateNoc) {
      throw new import_StatusCode.StatusResponseError(
        `addNoc received after csr request was invoked for UpdateNOC.`,
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    const state = this.state;
    if (state.commissionedFabrics >= state.supportedFabrics) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.TableFull,
        debugText: `No more fabrics can be added because limit ${state.supportedFabrics} reached.`
      };
    }
    let fabric;
    try {
      fabric = await failsafeContext.buildFabric({
        nocValue,
        icacValue,
        adminVendorId,
        ipkValue,
        caseAdminSubject
      });
    } catch (error) {
      logger.info("Building fabric for addNoc failed", error);
      return this.#mapNocErrors(error);
    }
    const aclCluster = this.agent.get(import_AccessControlServer.AccessControlServer);
    aclCluster.state.acl.push({
      fabricIndex: fabric.fabricIndex,
      privilege: import_AccessControlCluster.AccessControl.AccessControlEntryPrivilege.Administer,
      authMode: import_AccessControlCluster.AccessControl.AccessControlEntryAuthMode.Case,
      subjects: [caseAdminSubject],
      targets: null
      // entire node
    });
    await failsafeContext.addFabric(fabric);
    try {
      if (this.session.isPase) {
        logger.debug(`Add Fabric ${fabric.fabricIndex} to PASE session ${this.session.name}.`);
        this.session.addAssociatedFabric(fabric);
      }
      const existingFabricIndex = this.state.fabrics.findIndex((f) => f.fabricIndex === fabric.fabricIndex);
      const existingNocIndex = this.state.nocs.findIndex((n) => n.fabricIndex === fabric.fabricIndex);
      if (existingFabricIndex !== -1 || existingNocIndex !== -1) {
        throw new import_MatterError.MatterFlowError(
          `FabricIndex ${fabric.fabricIndex} already exists in state. This should not happen.`
        );
      }
    } catch (e) {
      await fabric.remove(this.session.id);
      throw e;
    }
    logger.info(`addNoc success, adminVendorId ${adminVendorId}, caseAdminSubject ${caseAdminSubject}`);
    return {
      statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.Ok,
      fabricIndex: fabric.fabricIndex
    };
  }
  async updateNoc({ nocValue, icacValue }) {
    (0, import_SecureSession.assertSecureSession)(this.session);
    const device = this.session.context;
    const timedOp = device.failsafeContext;
    if (timedOp.fabricIndex !== void 0) {
      throw new import_StatusCode.StatusResponseError(
        `updateNoc received after ${timedOp.forUpdateNoc ? "UpdateNOC" : "AddNOC"} already invoked.`,
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    if (timedOp.forUpdateNoc) {
      throw new import_StatusCode.StatusResponseError(
        `addNoc received after csr request was invoked for UpdateNOC.`,
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    if (timedOp.hasRootCert) {
      throw new import_StatusCode.StatusResponseError(
        "Trusted root certificate added in this session which is now allowed for UpdateNOC.",
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    if (!timedOp.forUpdateNoc) {
      throw new import_StatusCode.StatusResponseError("csrRequest not invoked for UpdateNOC.", import_StatusCode.StatusCode.ConstraintError);
    }
    if (this.session.associatedFabric.fabricIndex !== timedOp.associatedFabric?.fabricIndex) {
      throw new import_StatusCode.StatusResponseError(
        "Fabric of this session and the failsafe context do not match.",
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    try {
      const updateFabric = await timedOp.buildUpdatedFabric(nocValue, icacValue);
      await timedOp.updateFabric(updateFabric);
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.Ok,
        fabricIndex: updateFabric.fabricIndex
      };
    } catch (error) {
      logger.info("Building fabric for updateNoc failed", error);
      return this.#mapNocErrors(error);
    }
  }
  async updateFabricLabel({ label }) {
    const fabric = this.session.associatedFabric;
    const currentFabricIndex = fabric.fabricIndex;
    const device = this.session.context;
    const conflictingLabelFabric = device.getFabrics().find((f) => f.label === label && f.fabricIndex !== currentFabricIndex);
    if (conflictingLabelFabric !== void 0) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.LabelConflict,
        debugText: `Label ${label} already used by fabric ${conflictingLabelFabric.fabricIndex}`
      };
    }
    await fabric.setLabel(label);
    return { statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.Ok, fabricIndex: fabric.fabricIndex };
  }
  async removeFabric({ fabricIndex }) {
    const device = this.session.context;
    const fabric = device.getFabricByIndex(fabricIndex);
    if (fabric === void 0) {
      return {
        statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.InvalidFabricIndex,
        debugText: `Fabric ${fabricIndex} not found`
      };
    }
    await fabric.remove(this.session.id);
    return {
      statusCode: import_OperationalCredentialsCluster.OperationalCredentials.NodeOperationalCertStatus.Ok,
      fabricIndex
    };
  }
  addTrustedRootCertificate({ rootCaCertificate }) {
    const failsafeContext = this.session.context.failsafeContext;
    if (failsafeContext.hasRootCert) {
      throw new import_StatusCode.StatusResponseError(
        "Trusted root certificate already added in this FailSafe context.",
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    if (failsafeContext.fabricIndex !== void 0) {
      throw new import_StatusCode.StatusResponseError(
        `Cannot add trusted root certificates after ${failsafeContext.forUpdateNoc ? "UpdateNOC" : "AddNOC"}.`,
        import_StatusCode.StatusCode.ConstraintError
      );
    }
    try {
      failsafeContext.setRootCert(rootCaCertificate);
    } catch (error) {
      logger.info("setting root certificate failed", error);
      if (error instanceof import_Crypto.CryptoVerifyError || error instanceof import_CertificateManager.CertificateError || error instanceof import_ValidationError.ValidationError || error instanceof import_MatterError.UnexpectedDataError) {
        throw new import_StatusCode.StatusResponseError(error.message, import_StatusCode.StatusCode.InvalidCommand);
      }
      throw error;
    }
    const fabrics = this.endpoint.env.get(import_FabricManager.FabricManager).getFabrics();
    const trustedRootCertificates = fabrics.map((fabric) => fabric.rootCert);
    trustedRootCertificates.push(rootCaCertificate);
    this.state.trustedRootCertificates = trustedRootCertificates;
  }
  async #updateFabrics() {
    const fabrics = this.endpoint.env.get(import_FabricManager.FabricManager).getFabrics();
    this.state.fabrics = fabrics.map((fabric) => ({
      fabricId: fabric.fabricId,
      label: fabric.label,
      nodeId: fabric.nodeId,
      rootPublicKey: fabric.rootPublicKey,
      vendorId: fabric.rootVendorId,
      fabricIndex: fabric.fabricIndex
    }));
    this.state.nocs = fabrics.map((fabric) => ({
      noc: fabric.operationalCert,
      icac: fabric.intermediateCACert ?? null,
      fabricIndex: fabric.fabricIndex
    }));
    this.state.trustedRootCertificates = fabrics.map((fabric) => fabric.rootCert);
    this.state.commissionedFabrics = fabrics.length;
    await this.context.transaction.commit();
  }
  async getCertification() {
    const certification = this.internal.certification ?? (this.internal.certification = new import_DeviceCertification.DeviceCertification(
      this.state.certification,
      this.agent.get(import_ProductDescriptionServer.ProductDescriptionServer).state
    ));
    await certification.construction;
    return certification;
  }
  async #handleAddedFabric({ fabricIndex }) {
    await this.#updateFabrics();
    this.agent.get(import_CommissioningBehavior.CommissioningBehavior).handleFabricChange(fabricIndex, import_FabricManager.FabricAction.Added);
  }
  async #handleUpdatedFabric({ fabricIndex }) {
    await this.#updateFabrics();
    this.agent.get(import_CommissioningBehavior.CommissioningBehavior).handleFabricChange(fabricIndex, import_FabricManager.FabricAction.Updated);
  }
  async #handleRemovedFabric({ fabricIndex }) {
    await this.#updateFabrics();
    this.agent.get(import_CommissioningBehavior.CommissioningBehavior).handleFabricChange(fabricIndex, import_FabricManager.FabricAction.Removed);
  }
  async #handleFailsafeClosed() {
    await this.#updateFabrics();
  }
  async #nodeOnline() {
    const fabricManager = this.endpoint.env.get(import_FabricManager.FabricManager);
    this.reactTo(fabricManager.events.added, this.#handleAddedFabric, { lock: true });
    this.reactTo(fabricManager.events.updated, this.#handleUpdatedFabric, { lock: true });
    this.reactTo(fabricManager.events.deleted, this.#handleRemovedFabric, { lock: true });
    this.reactTo(fabricManager.events.failsafeClosed, this.#handleFailsafeClosed, { lock: true });
    await this.#updateFabrics();
  }
}
((OperationalCredentialsServer2) => {
  class Internal {
    certification;
    commissionedFabric;
  }
  OperationalCredentialsServer2.Internal = Internal;
  class State extends import_OperationalCredentialsBehavior.OperationalCredentialsBehavior.State {
    /**
     * Device certification information.
     *
     * Device certification provides a cryptographic certificate that asserts the official status of a device.
     * Production consumer-facing devices are certified by the CSA.
     *
     * Development devices and those intended for personal use may use a development certificate.  This is the
     * default if you do not provide an official certification in {@link ServerOptions.certification}.
     */
    certification = void 0;
    [import_Val.Val.properties](_endpoint, session) {
      return {
        get currentFabricIndex() {
          return session.fabric ?? import_FabricIndex.FabricIndex.NO_FABRIC;
        }
      };
    }
  }
  OperationalCredentialsServer2.State = State;
})(OperationalCredentialsServer || (OperationalCredentialsServer = {}));
//# sourceMappingURL=OperationalCredentialsServer.js.map
