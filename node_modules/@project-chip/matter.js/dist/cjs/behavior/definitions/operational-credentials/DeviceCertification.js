"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var DeviceCertification_exports = {};
__export(DeviceCertification_exports, {
  DeviceCertification: () => DeviceCertification
});
module.exports = __toCommonJS(DeviceCertification_exports);
var import_AttestationCertificateManager = require("../../../certificate/AttestationCertificateManager.js");
var import_CertificationDeclarationManager = require("../../../certificate/CertificationDeclarationManager.js");
var import_MatterError = require("../../../common/MatterError.js");
var import_Crypto = require("../../../crypto/Crypto.js");
var import_Key = require("../../../crypto/Key.js");
var import_ByteArray = require("../../../util/ByteArray.js");
var import_Construction = require("../../../util/Construction.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class DeviceCertification {
  #privateKey;
  #certificate;
  #intermediateCertificate;
  #declaration;
  #construction;
  get construction() {
    return this.#construction;
  }
  get certificate() {
    return this.#assertInitialized().certificate;
  }
  get intermediateCertificate() {
    return this.#assertInitialized().intermediateCertificate;
  }
  get declaration() {
    return this.#assertInitialized().declaration;
  }
  constructor(config, product) {
    if (typeof config === "function") {
      const configProvider = config;
      this.#construction = (0, import_Construction.Construction)(this, async () => {
        this.#initializeFromConfig(await configProvider());
      });
      return;
    }
    this.#construction = (0, import_Construction.Construction)(this, () => {
    });
    if (config === void 0) {
      if (product === void 0) {
        throw new import_MatterError.ImplementationError(`Cannot generate device certification without product information`);
      }
      const paa = new import_AttestationCertificateManager.AttestationCertificateManager(product.vendorId);
      const { keyPair: dacKeyPair, dac } = paa.getDACert(product.productId);
      config = {
        privateKey: (0, import_Key.PrivateKey)(dacKeyPair.privateKey),
        certificate: dac,
        intermediateCertificate: paa.getPAICert(),
        declaration: import_CertificationDeclarationManager.CertificationDeclarationManager.generate(product.vendorId, product.productId)
      };
    }
    this.#initializeFromConfig(config);
  }
  #initializeFromConfig(config) {
    this.#privateKey = config.privateKey instanceof import_ByteArray.ByteArray ? (0, import_Key.PrivateKey)(config.privateKey) : config.privateKey;
    this.#certificate = config.certificate;
    this.#intermediateCertificate = config.intermediateCertificate;
    this.#declaration = config.declaration;
  }
  sign(session, data) {
    return import_Crypto.Crypto.sign(this.#assertInitialized().privateKey, [data, session.attestationChallengeKey]);
  }
  /**
   * Makes sure that the device certification is initialized and construction is completed and returns "Non-undefined"
   * values
   */
  #assertInitialized() {
    this.#construction.assert();
    if (this.#certificate === void 0 || this.#intermediateCertificate === void 0 || this.#declaration === void 0 || this.#privateKey === void 0) {
      throw new import_MatterError.InternalError(
        `Device certification not initialized while trying to access it. This should never happen.`
      );
    }
    return {
      certificate: this.#certificate,
      intermediateCertificate: this.#intermediateCertificate,
      declaration: this.#declaration,
      privateKey: this.#privateKey
    };
  }
}
//# sourceMappingURL=DeviceCertification.js.map
