{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/switch/SwitchServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClusterType } from \"../../../cluster/ClusterType.js\";\nimport { Switch } from \"../../../cluster/definitions/SwitchCluster.js\";\nimport { FieldElement } from \"../../../model/elements/FieldElement.js\";\nimport { ClusterModel } from \"../../../model/index.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { Time, Timer } from \"../../../time/Time.js\";\nimport { Observable } from \"../../../util/Observable.js\";\nimport { ActionContext } from \"../../context/ActionContext.js\";\nimport { SwitchBehavior } from \"./SwitchBehavior.js\";\n\nconst SwitchServerBase = SwitchBehavior.for(Switch.Complete).with(\n    Switch.Feature.LatchingSwitch,\n    Switch.Feature.MomentarySwitch,\n    Switch.Feature.MomentarySwitchRelease,\n    Switch.Feature.MomentarySwitchLongPress,\n    Switch.Feature.MomentarySwitchMultiPress,\n);\n\n// Enhance Schema to define conformance for some of the additional state attributes\nconst schema = SwitchServerBase.schema?.clone() as ClusterModel;\nschema.add(\n    FieldElement({ name: \"longPressDelay\", type: \"uint32\", quality: \"M\", conformance: \"MSL\" }),\n    FieldElement({ name: \"multiPressDelay\", type: \"uint32\", quality: \"M\", conformance: \"MSM\" }),\n    FieldElement({ name: \"momentaryNeutralPosition\", type: \"uint8\", quality: \"O\", conformance: \"MS\" }),\n);\n\n/**\n * This is the default server implementation of {@link SwitchBehavior}.\n *\n * This implementation includes all features of {@link WindowCovering.Cluster} and implements all mandatory commands.\n * You should use {@link WindowCoveringServer.with} to specialize the class for the features your implementation\n * supports.\n *\n * To support all features and events the implementation adds some custom state attributes that can - or are required\n * to - be used. These are:\n * * `rawPosition` - The raw position of the switch. This is the position as reported by the device and is not yet\n *  debounced. If the position is already debounced, just set the `currentPosition` attribute. The debouncing uses the\n *  `debounceDelay` attribute value as timeframe in milliseconds and sets the `currentPosition` attribute when the value\n *  is stable for this timeframe.\n * * `debounceDelay` - The timeframe in milliseconds to wait until a newly reported position is considered stable.\n * * `longPressDelay` - The timeframe in milliseconds to wait until a position is considered \"long\" pressed. This\n *  attribute is REQUIRED if the device supports the Momentary Switch LongPress (MSL) feature.\n * * `multiPressDelay` - The timeframe in milliseconds starting with a stable release to detect multi-presses. This\n *  attribute is REQUIRED if the device supports the Momentary Switch MultiPress (MSM) feature.\n * * `momentaryNeutralPosition` - The number of the position considered as the neutral position for the momentary switch.\n *  This defaults to position 0 but can be changed by settings this attribute. it is available as soon as the Momentary\n *  Switch (MS) feature is used.\n */\nexport class SwitchServerLogic extends SwitchServerBase {\n    protected declare internal: SwitchServerLogic.Internal;\n    declare state: SwitchServerLogic.State;\n    declare events: SwitchServerLogic.Events;\n    schema = schema;\n\n    override initialize() {\n        this.state.rawPosition = this.state.currentPosition;\n        this.internal.currentUnstablePosition = this.state.currentPosition;\n        this.internal.previouslyReportedPosition = this.state.currentPosition;\n\n        // Validate positions set to respect constraints, TODO: Remove with 1.3 update\n        this.reactTo(this.events.rawPosition$Changing, this.#assertPositionInRange);\n        this.reactTo(this.events.currentPosition$Changing, this.#assertPositionInRange);\n\n        // Debounce raw position changes\n        this.reactTo(this.events.rawPosition$Changed, this.#debounceRawPosition);\n\n        // Handle switch position changes\n        this.reactTo(this.events.currentPosition$Changed, this.#handleSwitchPositionChange);\n    }\n\n    // TODO remove when Validator logic can assess that with 1.3 introduction\n    #assertPositionInRange(position: number) {\n        if (position < 0 || position >= this.state.numberOfPositions) {\n            throw new StatusResponseError(`Position ${position} invalid`, StatusCode.ConstraintError);\n        }\n    }\n\n    #debounceRawPosition(newPosition: number) {\n        // When a debounce delay is set then we debounce the raw position, else we set the current position immediately\n        if (this.state.debounceDelay !== 0) {\n            this.internal.debounceTimer?.stop();\n\n            this.internal.currentUnstablePosition = newPosition;\n            this.internal.debounceTimer = Time.getTimer(\n                \"debounce\",\n                this.state.debounceDelay,\n                this.callback(this.#setCurrentPositionAfterDebounce),\n            ).start();\n        } else {\n            this.state.currentPosition = newPosition;\n        }\n    }\n\n    #setCurrentPositionAfterDebounce() {\n        this.state.currentPosition = this.internal.currentUnstablePosition;\n    }\n\n    #handleSwitchPositionChange(newPosition: number) {\n        // Latching Switch\n        if (this.features.latchingSwitch) {\n            // This event SHALL be generated, when the latching switch is moved to a new position.\n            this.events.switchLatched?.emit({ newPosition }, this.context);\n            return;\n        }\n\n        // Momentary Switch\n        if (newPosition !== this.state.momentaryNeutralPosition) {\n            // This event SHALL be generated, when the momentary switch starts to be pressed.\n            this.events.initialPress?.emit({ newPosition }, this.context);\n        }\n\n        if (this.features.momentarySwitchLongPress) {\n            if (newPosition === this.state.momentaryNeutralPosition) {\n                if (this.internal.longPressTimer?.isRunning) {\n                    // If the server supports the Momentary Switch LongPress (MSL) feature, this event SHALL be generated\n                    // when the switch is released if no LongPress event had been generated since the previous InitialPress\n                    // event.\n                    this.events.shortRelease?.emit(\n                        { previousPosition: this.internal.previouslyReportedPosition },\n                        this.context,\n                    );\n                } else if (this.internal.currentIsLongPress) {\n                    // This event SHALL be generated, when the momentary switch has been released (after debouncing) and\n                    // after having been pressed for a long time, i.e. this event SHALL be generated when the switch is\n                    // released if a LongPress event has been generated since the previous InitialPress event.\n                    this.events.longRelease?.emit(\n                        { previousPosition: this.internal.previouslyReportedPosition },\n                        this.context,\n                    );\n                }\n            }\n\n            this.internal.longPressTimer?.stop();\n            this.internal.currentIsLongPress = false;\n            this.internal.currentLongPressPosition = null;\n\n            if (newPosition !== this.state.momentaryNeutralPosition) {\n                this.internal.currentLongPressPosition = newPosition;\n                this.internal.longPressTimer = Time.getTimer(\n                    \"longPress\",\n                    this.state.longPressDelay,\n                    this.callback(this.#handleLongPress),\n                ).start();\n            }\n        } else if (this.features.momentarySwitchRelease && newPosition === this.state.momentaryNeutralPosition) {\n            // If the server does not support the Momentary Switch LongPress (MSL) feature, this event SHALL be generated\n            // when the switch is released - even when the switch was pressed for a long time.\n            this.events.shortRelease?.emit(\n                { previousPosition: this.internal.previouslyReportedPosition },\n                this.context,\n            );\n        }\n\n        if (this.features.momentarySwitchMultiPress) {\n            if (this.internal.multiPressTimer?.isRunning && newPosition !== this.state.momentaryNeutralPosition) {\n                // The Button is at the same position as the time before, so it is a multiPress\n                // Increment the number of presses\n                this.internal.currentNumberOfPressesCounter++;\n\n                // Emit MultiPressOngoing event\n                this.events.multiPressOngoing?.emit(\n                    {\n                        newPosition,\n                        currentNumberOfPressesCounted: this.internal.currentNumberOfPressesCounter,\n                    },\n                    this.context,\n                );\n\n                // TODO: Handle the case that there are more presses then we can handle maxNumberOfPresses\n                //  Specs do not tell anything about that so ignore for now\n            }\n            this.internal.multiPressTimer?.stop();\n\n            this.internal.multiPressTimer = Time.getTimer(\n                \"multiPress\",\n                this.state.multiPressDelay,\n                this.callback(this.#handleMultiPressComplete),\n            ).start();\n            if (this.internal.previouslyReportedPosition !== this.state.momentaryNeutralPosition) {\n                this.internal.previousMultiPressPosition = this.internal.previouslyReportedPosition;\n            }\n        }\n        // Store the currently processed position to be used as \"previous\" in some events\n        this.internal.previouslyReportedPosition = newPosition;\n    }\n\n    // Method is called by a timer, so no change to the position for longPressDelay\n    #handleLongPress() {\n        if (this.internal.currentLongPressPosition === null) {\n            return;\n        }\n        // This event SHALL be generated, when the momentary switch has been pressed for a \"long\" time.\n        this.events.longPress?.emit({ newPosition: this.internal.currentLongPressPosition }, this.context);\n        this.internal.currentIsLongPress = true;\n    }\n\n    #handleMultiPressComplete() {\n        if (this.internal.previousMultiPressPosition === null) {\n            return;\n        }\n        this.events.multiPressComplete?.emit(\n            {\n                previousPosition: this.internal.previousMultiPressPosition,\n                totalNumberOfPressesCounted: this.internal.currentNumberOfPressesCounter,\n            },\n            this.context,\n        );\n\n        // Reset the number of presses\n        this.internal.currentNumberOfPressesCounter = 1;\n        this.internal.previousMultiPressPosition = null;\n    }\n\n    override async [Symbol.asyncDispose]() {\n        this.internal.debounceTimer?.stop();\n        this.internal.longPressTimer?.stop();\n        this.internal.multiPressTimer?.stop();\n        await super[Symbol.asyncDispose]?.();\n    }\n}\n\nexport namespace SwitchServerLogic {\n    export class Internal {\n        /** Timer to debounce the raw position. */\n        debounceTimer?: Timer;\n\n        /** Timer to detect a long press. */\n        longPressTimer?: Timer;\n\n        /** Timer to detect multi presses. */\n        multiPressTimer?: Timer;\n\n        /** Counter to count the number of presses. */\n        currentNumberOfPressesCounter: number = 1;\n\n        /** Position previously reported in events. */\n        previouslyReportedPosition: number = 0;\n\n        /** Position of the previous multi press. */\n        previousMultiPressPosition: number | null = null;\n\n        /** Position of the current long press. */\n        currentLongPressPosition: number | null = null;\n\n        /** Flag to indicate if the current press is a long press. */\n        currentIsLongPress: boolean = false;\n\n        /** Position of the current unstable position which is debounced */\n        currentUnstablePosition: number = 0;\n    }\n\n    export class State extends SwitchServerBase.State {\n        /** Raw position of the switch. Set this to debounce the value. */\n        rawPosition: number = 0;\n\n        /**\n         * Debounce Delay to wait until a newly reported raw position is considered stable and written to the\n         * currentPosition attribue.\n         */\n        debounceDelay: number = 0;\n\n        /** Time to wait until a value is considered \"long\" pressed */\n        longPressDelay: number = 0;\n\n        /** Timeframe starting with a stable release to detect multi-presses. */\n        multiPressDelay: number = 0;\n\n        /** Number of the position considered as the neutral position for the momentary switch. */\n        momentaryNeutralPosition: number = 0;\n    }\n\n    /** Enhance the relevant events for rawPosition attribute. */\n    export class Events extends SwitchServerBase.Events {\n        rawPosition$Changed = Observable<[value: number, oldValue: number, context?: ActionContext]>();\n        rawPosition$Changing = Observable<[value: number, oldValue: number, context?: ActionContext]>();\n    }\n}\n\n// Reset all Features\nexport class SwitchServer extends SwitchServerLogic.for(ClusterType(Switch.Base)) {}\n"],
  "mappings": "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",
  "names": ["SwitchServerLogic"]
}
