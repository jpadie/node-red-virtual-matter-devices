/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterType } from "../../../cluster/ClusterType.js";
import { Switch } from "../../../cluster/definitions/SwitchCluster.js";
import { ClusterModel } from "../../../model/index.js";
import { Timer } from "../../../time/Time.js";
import { Observable } from "../../../util/Observable.js";
import { ActionContext } from "../../context/ActionContext.js";
declare const SwitchServerBase: import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").ClusterComposer.WithFeatures<Switch.Complete, readonly [Switch.Feature.LatchingSwitch, Switch.Feature.MomentarySwitch, Switch.Feature.MomentarySwitchRelease, Switch.Feature.MomentarySwitchLongPress, Switch.Feature.MomentarySwitchMultiPress]>, import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<Switch.Complete, import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 59;
    readonly name: "Switch";
    readonly revision: 1;
    readonly features: {
        readonly latchingSwitch: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitch: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitchRelease: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitchLongPress: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitchMultiPress: import("../../../schema/BitmapSchema.js").BitFlag;
    };
    readonly attributes: {
        readonly numberOfPositions: import("../../../cluster/Cluster.js").FixedAttribute<number, any>;
        readonly currentPosition: import("../../../cluster/Cluster.js").Attribute<number, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
        };
        readonly component: {
            readonly attributes: {
                readonly multiPressMax: import("../../../cluster/Cluster.js").FixedAttribute<number, any>;
            };
            readonly events: {
                readonly multiPressOngoing: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                    currentNumberOfPressesCounted: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
                readonly multiPressComplete: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    previousPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                    totalNumberOfPressesCounted: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly switchLatched: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly initialPress: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
        };
        readonly component: {
            readonly events: {
                readonly longPress: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
                readonly longRelease: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    previousPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
        };
        readonly component: {
            readonly events: {
                readonly shortRelease: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    previousPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
            readonly momentarySwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: false;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }];
}>, typeof import("../../cluster/ClusterBehavior.js").ClusterBehavior, {
    components: never[];
}>, {
    components: never[];
}>, {
    components: never[];
}>;
/**
 * This is the default server implementation of {@link SwitchBehavior}.
 *
 * This implementation includes all features of {@link WindowCovering.Cluster} and implements all mandatory commands.
 * You should use {@link WindowCoveringServer.with} to specialize the class for the features your implementation
 * supports.
 *
 * To support all features and events the implementation adds some custom state attributes that can - or are required
 * to - be used. These are:
 * * `rawPosition` - The raw position of the switch. This is the position as reported by the device and is not yet
 *  debounced. If the position is already debounced, just set the `currentPosition` attribute. The debouncing uses the
 *  `debounceDelay` attribute value as timeframe in milliseconds and sets the `currentPosition` attribute when the value
 *  is stable for this timeframe.
 * * `debounceDelay` - The timeframe in milliseconds to wait until a newly reported position is considered stable.
 * * `longPressDelay` - The timeframe in milliseconds to wait until a position is considered "long" pressed. This
 *  attribute is REQUIRED if the device supports the Momentary Switch LongPress (MSL) feature.
 * * `multiPressDelay` - The timeframe in milliseconds starting with a stable release to detect multi-presses. This
 *  attribute is REQUIRED if the device supports the Momentary Switch MultiPress (MSM) feature.
 * * `momentaryNeutralPosition` - The number of the position considered as the neutral position for the momentary switch.
 *  This defaults to position 0 but can be changed by settings this attribute. it is available as soon as the Momentary
 *  Switch (MS) feature is used.
 */
export declare class SwitchServerLogic extends SwitchServerBase {
    #private;
    protected internal: SwitchServerLogic.Internal;
    state: SwitchServerLogic.State;
    events: SwitchServerLogic.Events;
    schema: ClusterModel;
    initialize(): void;
    [Symbol.asyncDispose](): Promise<void>;
}
export declare namespace SwitchServerLogic {
    class Internal {
        /** Timer to debounce the raw position. */
        debounceTimer?: Timer;
        /** Timer to detect a long press. */
        longPressTimer?: Timer;
        /** Timer to detect multi presses. */
        multiPressTimer?: Timer;
        /** Counter to count the number of presses. */
        currentNumberOfPressesCounter: number;
        /** Position previously reported in events. */
        previouslyReportedPosition: number;
        /** Position of the previous multi press. */
        previousMultiPressPosition: number | null;
        /** Position of the current long press. */
        currentLongPressPosition: number | null;
        /** Flag to indicate if the current press is a long press. */
        currentIsLongPress: boolean;
        /** Position of the current unstable position which is debounced */
        currentUnstablePosition: number;
    }
    class State extends SwitchServerBase.State {
        /** Raw position of the switch. Set this to debounce the value. */
        rawPosition: number;
        /**
         * Debounce Delay to wait until a newly reported raw position is considered stable and written to the
         * currentPosition attribue.
         */
        debounceDelay: number;
        /** Time to wait until a value is considered "long" pressed */
        longPressDelay: number;
        /** Timeframe starting with a stable release to detect multi-presses. */
        multiPressDelay: number;
        /** Number of the position considered as the neutral position for the momentary switch. */
        momentaryNeutralPosition: number;
    }
    /** Enhance the relevant events for rawPosition attribute. */
    class Events extends SwitchServerBase.Events {
        rawPosition$Changed: Observable<[value: number, oldValue: number, context?: ActionContext | undefined], void>;
        rawPosition$Changing: Observable<[value: number, oldValue: number, context?: ActionContext | undefined], void>;
    }
}
declare const SwitchServer_base: import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 59;
    readonly name: "Switch";
    readonly revision: 1;
    readonly features: {
        readonly latchingSwitch: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitch: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitchRelease: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitchLongPress: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly momentarySwitchMultiPress: import("../../../schema/BitmapSchema.js").BitFlag;
    };
    readonly attributes: {
        readonly numberOfPositions: import("../../../cluster/Cluster.js").FixedAttribute<number, any>;
        readonly currentPosition: import("../../../cluster/Cluster.js").Attribute<number, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
        };
        readonly component: {
            readonly attributes: {
                readonly multiPressMax: import("../../../cluster/Cluster.js").FixedAttribute<number, any>;
            };
            readonly events: {
                readonly multiPressOngoing: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                    currentNumberOfPressesCounted: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
                readonly multiPressComplete: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    previousPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                    totalNumberOfPressesCounted: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly switchLatched: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly initialPress: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
        };
        readonly component: {
            readonly events: {
                readonly longPress: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    newPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
                readonly longRelease: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    previousPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
        };
        readonly component: {
            readonly events: {
                readonly shortRelease: import("../../../cluster/Cluster.js").Event<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    previousPosition: import("../../../tlv/TlvObject.js").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
            readonly momentarySwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: false;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }];
}>, typeof SwitchServerLogic, {
    components: never[];
}>;
export declare class SwitchServer extends SwitchServer_base {
}
export {};
//# sourceMappingURL=SwitchServer.d.ts.map