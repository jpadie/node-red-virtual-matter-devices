{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/on-off/OnOffServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { OnOff } from \"../../../cluster/definitions/OnOffCluster.js\";\nimport { GeneralDiagnostics } from \"../../../cluster/definitions/index.js\";\nimport { RootEndpoint } from \"../../../endpoint/definitions/system/RootEndpoint.js\";\nimport { Time, Timer } from \"../../../time/Time.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { GeneralDiagnosticsBehavior } from \"../general-diagnostics/GeneralDiagnosticsBehavior.js\";\nimport { OnOffBehavior } from \"./OnOffBehavior.js\";\n\nconst Base = OnOffBehavior.with(OnOff.Feature.Lighting);\n\n/**\n * This is the default server implementation of {@link OnOffBehavior}.\n *\n * This implementation includes all features of {@link OnOff.Cluster} and automatically enables the \"Level Control\n * for Lighting\" Feature. You should use {@link OnOffServer.with} to specialize the class for the features your\n * implementation supports. Alternatively you can extend this class and override the methods you need to change or add\n * mandatory commands.\n *\n * The \"OffOnly\" feature is automatically supported because the commands are disabled by conformance.\n * The default implementation do not contain any logic for the DeadFrontBehavior feature because this is very use case\n * specific, so this needs to be implemented by the device implementor as needed.\n */\nexport class OnOffServer extends Base {\n    protected declare internal: OnOffServer.Internal;\n\n    override initialize() {\n        if (this.features.lighting && this.#getBootReason() !== GeneralDiagnostics.BootReason.SoftwareUpdateCompleted) {\n            const startUpOnOffValue = this.state.startUpOnOff ?? null;\n            const currentOnOffStatus = this.state.onOff;\n            if (startUpOnOffValue !== null) {\n                const targetOnOffValue =\n                    startUpOnOffValue === OnOff.StartUpOnOff.Toggle\n                        ? !currentOnOffStatus\n                        : startUpOnOffValue === OnOff.StartUpOnOff.On;\n                if (targetOnOffValue !== currentOnOffStatus) {\n                    this.state.onOff = targetOnOffValue;\n                }\n            }\n        }\n    }\n\n    override async [Symbol.asyncDispose]() {\n        this.internal.timedOnTimer?.stop();\n        this.internal.delayedOffTimer?.stop();\n        await super[Symbol.asyncDispose]?.();\n    }\n\n    override on(): MaybePromise<void> {\n        this.state.onOff = true;\n        if (this.features.lighting) {\n            if (!this.timedOnTimer.isRunning) {\n                if (this.delayedOffTimer.isRunning) {\n                    this.delayedOffTimer.stop();\n                }\n                this.state.offWaitTime = 0;\n            }\n        }\n    }\n\n    override off(): MaybePromise<void> {\n        this.state.onOff = false;\n        if (this.features.lighting) {\n            if (this.timedOnTimer.isRunning) {\n                this.timedOnTimer.stop();\n                if ((this.state.offWaitTime ?? 0) > 0) {\n                    this.delayedOffTimer.start();\n                }\n            }\n            this.state.onTime = 0;\n        }\n    }\n\n    /**\n     * Default implementation notes:\n     * This method uses the on/off methods when timed actions should occur. This means that it is enough to override\n     * on() and off() with custom control logic.\n     */\n    override toggle(): MaybePromise<void> {\n        if (this.state.onOff) {\n            return this.off();\n        } else {\n            return this.on();\n        }\n    }\n\n    /**\n     * Default implementation notes:\n     * * This implementation ignores the effect and just calls off().\n     * * Global Scene Control is not supported yet.\n     */\n    override offWithEffect(): MaybePromise<void> {\n        if (this.state.globalSceneControl) {\n            // TODO Store state in global scene\n            this.state.globalSceneControl = false;\n        }\n        return this.off();\n    }\n\n    /**\n     * Default implementation notes:\n     * * Global Scene Control is not supported yet, so the device is just turned on.\n     */\n    override onWithRecallGlobalScene(): MaybePromise<void> {\n        if (this.state.globalSceneControl) {\n            return;\n        }\n        // TODO Recall global scene to set onOff accordingly\n        this.state.globalSceneControl = true;\n        if (this.state.onTime === 0) {\n            this.state.offWaitTime = 0;\n        }\n        return this.on();\n    }\n\n    /**\n     * Default implementation notes:\n     * * This method uses the on/off methods when timed actions should occur. This means that it is enough to override\n     * on() and off() with custom control logic.\n     */\n    override onWithTimedOff({ onOffControl, offWaitTime, onTime }: OnOff.OnWithTimedOffRequest): MaybePromise<void> {\n        if (onOffControl.acceptOnlyWhenOn && !this.state.onOff) {\n            return;\n        }\n\n        if (this.delayedOffTimer.isRunning && !this.state.onOff) {\n            // We are already in \"delayed off state\".  This means offWaitTime > 0 and the device is off now\n            this.state.offWaitTime = Math.min(offWaitTime ?? 0, this.state.offWaitTime ?? 0);\n            return;\n        }\n\n        this.state.onTime = Math.max(onTime ?? 0, this.state.onTime ?? 0);\n        this.state.offWaitTime = offWaitTime;\n        if (this.state.onTime !== 0 && this.state.offWaitTime !== 0) {\n            // Specs talk about 0xffff aka \"uint16 overflow\", we set to 0 if negative\n            this.timedOnTimer.start();\n        }\n        return this.on();\n    }\n\n    protected get timedOnTimer() {\n        let timer = this.internal.timedOnTimer;\n        if (timer === undefined) {\n            timer = this.internal.timedOnTimer = Time.getPeriodicTimer(\n                \"Timed on\",\n                100,\n                this.callback(this.#timedOnTick),\n            );\n        }\n        return timer;\n    }\n\n    async #timedOnTick() {\n        let time = (this.state.onTime ?? 0) - 1;\n        if (time <= 0) {\n            time = 0;\n            this.internal.timedOnTimer?.stop();\n            this.state.offWaitTime = 0;\n            await this.off();\n        }\n        this.state.onTime = time;\n    }\n\n    protected get delayedOffTimer() {\n        let timer = this.internal.delayedOffTimer;\n        if (timer === undefined) {\n            timer = this.internal.delayedOffTimer = Time.getTimer(\n                \"Delayed off\",\n                100,\n                this.callback(this.#delayedOffTick),\n            );\n        }\n        return timer;\n    }\n\n    #delayedOffTick() {\n        let time = (this.state.offWaitTime ?? 0) - 1;\n        if (time <= 0) {\n            time = 0;\n            this.internal.delayedOffTimer?.stop(); // Delayed off ended\n        }\n        this.state.offWaitTime = time;\n    }\n\n    #getBootReason() {\n        const rootEndpoint = this.endpoint.ownerOfType(RootEndpoint);\n        if (rootEndpoint !== undefined && rootEndpoint.behaviors.has(GeneralDiagnosticsBehavior)) {\n            return rootEndpoint.stateOf(GeneralDiagnosticsBehavior).bootReason;\n        }\n    }\n}\n\nexport namespace OnOffServer {\n    export class Internal {\n        timedOnTimer?: Timer;\n        delayedOffTimer?: Timer;\n    }\n}\n"],
  "mappings": "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",
  "names": ["OnOffServer"]
}
