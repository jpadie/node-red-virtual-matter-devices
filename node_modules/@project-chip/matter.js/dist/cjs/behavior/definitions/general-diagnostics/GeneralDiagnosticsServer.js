"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var GeneralDiagnosticsServer_exports = {};
__export(GeneralDiagnosticsServer_exports, {
  GeneralDiagnosticsServer: () => GeneralDiagnosticsServer
});
module.exports = __toCommonJS(GeneralDiagnosticsServer_exports);
var import_GeneralDiagnosticsCluster = require("../../../cluster/definitions/GeneralDiagnosticsCluster.js");
var import_MatterError = require("../../../common/MatterError.js");
var import_CommandId = require("../../../datatype/CommandId.js");
var import_MdnsService = require("../../../environment/MdnsService.js");
var import_Logger = require("../../../log/Logger.js");
var import_FieldElement = require("../../../model/elements/FieldElement.js");
var import_InteractionProtocol = require("../../../protocol/interaction/InteractionProtocol.js");
var import_InteractionServer = require("../../../protocol/interaction/InteractionServer.js");
var import_StatusCode = require("../../../protocol/interaction/StatusCode.js");
var import_Time = require("../../../time/Time.js");
var import_ByteArray = require("../../../util/ByteArray.js");
var import_Ip = require("../../../util/Ip.js");
var import_Val = require("../../state/Val.js");
var import_NetworkServer = require("../../system/network/NetworkServer.js");
var import_NetworkCommissioningServer = require("../network-commissioning/NetworkCommissioningServer.js");
var import_GeneralDiagnosticsBehavior = require("./GeneralDiagnosticsBehavior.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("GeneralDiagnosticsServer");
const Base = import_GeneralDiagnosticsBehavior.GeneralDiagnosticsBehavior.with(import_GeneralDiagnosticsCluster.GeneralDiagnostics.Feature.DataModelTest);
const schema = Base.schema?.clone();
schema.add((0, import_FieldElement.FieldElement)({ name: "totalOperationalHoursCounter", type: "uint64", quality: "N" }));
class GeneralDiagnosticsServer extends Base {
  schema = schema;
  initialize() {
    if (this.state.testEventTriggersEnabled === void 0) {
      this.state.testEventTriggersEnabled = false;
    } else if (this.state.testEventTriggersEnabled) {
      if (this.state.deviceTestEnableKey.every((byte) => byte === 0)) {
        throw new import_MatterError.ImplementationError("Test event triggers are enabled but no deviceTestEnableKey is set.");
      }
      logger.warn("Test event triggers are enabled. Make sure to disable them in production.");
    }
    if (this.state.rebootCount === void 0) {
      this.state.rebootCount = 0;
    } else {
      this.state.rebootCount++;
    }
    const lifecycle = this.endpoint.lifecycle;
    if (lifecycle.online !== void 0) {
      this.reactTo(lifecycle.online, this.#online, { lock: true });
    }
    if (this.events.activeHardwareFaults$Changed !== void 0) {
      this.reactTo(this.events.activeHardwareFaults$Changed, this.#triggerActiveHardwareFaultsChangedEvent);
    }
    if (this.events.activeRadioFaults$Changed !== void 0) {
      this.reactTo(this.events.activeRadioFaults$Changed, this.#triggerActiveRadioFaultsChangedEvent);
    }
    if (this.events.activeNetworkFaults$Changed !== void 0) {
      this.reactTo(this.events.activeNetworkFaults$Changed, this.#triggerActiveNetworkFaultsChangedEvent);
    }
  }
  #validateTestEnabledKey(enableKey) {
    if (enableKey.every((byte) => byte === 0)) {
      throw new import_StatusCode.StatusResponseError("Invalid test enable key, all zeros", import_StatusCode.StatusCode.ConstraintError);
    }
    enableKey.forEach((byte, index) => {
      if (byte !== this.state.deviceTestEnableKey[index]) {
        throw new import_StatusCode.StatusResponseError("Invalid test enable key", import_StatusCode.StatusCode.ConstraintError);
      }
    });
  }
  testEventTrigger({ eventTrigger, enableKey }) {
    this.#validateTestEnabledKey(enableKey);
    this.triggerTestEvent(eventTrigger);
  }
  triggerTestEvent(eventTrigger) {
    throw new import_StatusCode.StatusResponseError(`Unsupported test event trigger ${eventTrigger}`, import_StatusCode.StatusCode.InvalidCommand);
  }
  timeSnapshot() {
    const time = import_Time.Time.nowMs();
    return {
      systemTimeMs: time - this.internal.bootUpTime,
      posixTimeMs: time
    };
  }
  payloadTestRequest({
    enableKey,
    value,
    count
  }) {
    this.#validateTestEnabledKey(enableKey);
    if (!this.state.testEventTriggersEnabled) {
      throw new import_StatusCode.StatusResponseError("Test event triggers are disabled", import_StatusCode.StatusCode.ConstraintError);
    }
    const payload = new import_ByteArray.ByteArray(count).fill(value);
    const responseSize = import_InteractionProtocol.TlvInvokeResponse.encode({
      suppressResponse: false,
      interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION,
      moreChunkedMessages: true,
      invokeResponses: [
        {
          command: {
            commandPath: {
              endpointId: this.endpoint.number,
              clusterId: import_GeneralDiagnosticsCluster.GeneralDiagnostics.Complete.id,
              commandId: (0, import_CommandId.CommandId)(4)
              // Hardcode for now
            },
            commandRef: 0,
            commandFields: import_GeneralDiagnosticsCluster.GeneralDiagnostics.TlvPayloadTestResponse.encodeTlv({
              payload
            })
          }
        }
      ]
    }).length;
    const exchange = this.context.exchange;
    if (exchange === void 0) {
      throw new import_MatterError.ImplementationError(`Illegal operation outside exchange context`);
    }
    if (responseSize > exchange.maxPayloadSize) {
      throw new import_StatusCode.StatusResponseError("Response too large", import_StatusCode.StatusCode.ResourceExhausted);
    }
    return {
      payload
    };
  }
  /**
   * Register a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the
   * HardwareFaultChanged event. Make sure to clear the fault when it is resolved.
   * This method requires that the activeHardwareFaults attribute is activated when the cluster gets initialized.
   *
   * @param faultType The hardware fault to register.
   */
  registerHardwareFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeHardwareFaults");
    const list = currentFaults.filter((fault) => fault !== faultType);
    list.push(faultType);
    this.state.activeHardwareFaults = list;
  }
  /**
   * Clear a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the
   * HardwareFaultChanged event.
   *
   * @param faultType The hardware fault to clear.
   */
  clearHardwareFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeHardwareFaults");
    this.state.activeHardwareFaults = currentFaults.filter((fault) => fault !== faultType);
  }
  #triggerActiveHardwareFaultsChangedEvent(current, previous) {
    this.events.hardwareFaultChange?.emit(
      {
        current,
        previous
      },
      this.context
    );
  }
  /**
   * Register a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the
   * RadioFaultChanged event. Make sure to clear the fault when it is resolved.
   * This method requires that the activeRadioFaults attribute is activated when the cluster gets initialized.
   *
   * @param faultType The radio fault to register.
   */
  registerRadioFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeRadioFaults");
    const list = currentFaults.filter((fault) => fault !== faultType);
    list.push(faultType);
    this.state.activeRadioFaults = list;
  }
  /**
   * Clear a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the
   * RadioFaultChanged event.
   *
   * @param faultType The radio fault to clear.
   */
  clearRadioFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeRadioFaults");
    this.state.activeRadioFaults = currentFaults.filter((fault) => fault !== faultType);
  }
  #triggerActiveRadioFaultsChangedEvent(current, previous) {
    this.events.radioFaultChange?.emit(
      {
        current,
        previous
      },
      this.context
    );
  }
  /**
   * Register a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the
   * NetworkFaultChanged event. Make sure to clear the fault when it is resolved.
   * This method requires that the activeNetworkFaults attribute is activated when the cluster gets initialized.
   *
   * @param faultType The network fault to register.
   */
  registerNetworkFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeNetworkFaults");
    const list = currentFaults.filter((fault) => fault !== faultType);
    list.push(faultType);
    this.state.activeNetworkFaults = list;
  }
  /**
   * Clear a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the
   * NetworkFaultChanged event.
   *
   * @param faultType The network fault to clear.
   */
  clearNetworkFault(faultType) {
    const currentFaults = this.requireAttributeEnabled("activeNetworkFaults");
    this.state.activeNetworkFaults = currentFaults.filter((fault) => fault !== faultType);
  }
  #triggerActiveNetworkFaultsChangedEvent(current, previous) {
    this.events.networkFaultChange?.emit(
      {
        current,
        previous
      },
      this.context
    );
  }
  async #online() {
    this.events.bootReason.emit(
      { bootReason: this.state.bootReason ?? import_GeneralDiagnosticsCluster.GeneralDiagnostics.BootReason.Unspecified },
      this.context
    );
    this.internal.bootUpTime = import_Time.Time.nowMs();
    this.internal.lastTotalOperationalHoursCounterUpdateTime = import_Time.Time.nowMs();
    this.internal.lastTotalOperationalHoursTimer = import_Time.Time.getPeriodicTimer(
      "GeneralDiagnostics.operationalHours",
      5 * 6e4,
      this.callback(this.#updateTotalOperationalHoursCounter)
    ).start();
    await this.#updateNetworkList();
  }
  #updateTotalOperationalHoursCounter() {
    const now = import_Time.Time.nowMs();
    const elapsedTime = now - this.internal.lastTotalOperationalHoursCounterUpdateTime;
    this.state.totalOperationalHoursCounter = this.state.totalOperationalHoursCounter + elapsedTime;
    this.internal.lastTotalOperationalHoursCounterUpdateTime = now;
  }
  async #updateNetworkList() {
    const mdnsService = this.endpoint.env.get(import_MdnsService.MdnsService);
    const mdnsLimitedToNetworkInterfaces = mdnsService.limitedToNetInterface;
    const networkRuntime = this.endpoint.behaviors.internalsOf(import_NetworkServer.NetworkServer).runtime;
    const systemNetworkInterfaces = await networkRuntime.getNetworkInterfaces();
    let networkType = import_GeneralDiagnosticsCluster.GeneralDiagnostics.InterfaceType.Ethernet;
    if (this.endpoint.behaviors.has(import_NetworkCommissioningServer.NetworkCommissioningServer)) {
      const networkCommissioning = this.agent.get(import_NetworkCommissioningServer.NetworkCommissioningServer);
      if ("wiFiNetworkInterface" in networkCommissioning.features && networkCommissioning.features.wiFiNetworkInterface) {
        networkType = import_GeneralDiagnosticsCluster.GeneralDiagnostics.InterfaceType.WiFi;
      } else if ("threadNetworkInterface" in networkCommissioning.features && networkCommissioning.features.threadNetworkInterface) {
        networkType = import_GeneralDiagnosticsCluster.GeneralDiagnostics.InterfaceType.Thread;
      }
    }
    const isOperationalReachable = mdnsLimitedToNetworkInterfaces === void 0 ? () => true : (name) => {
      return name === mdnsLimitedToNetworkInterfaces;
    };
    this.state.networkInterfaces = systemNetworkInterfaces.filter(({ mac }) => mac !== "00:00:00:00:00:00").sort(({ name: nameA }, { name: nameB }) => {
      if (isOperationalReachable(nameA) && !isOperationalReachable(nameB)) {
        return -1;
      }
      if (!isOperationalReachable(nameA) && isOperationalReachable(nameB)) {
        return 1;
      }
      return 0;
    }).slice(0, 8).map(({ name, mac, ipV4, ipV6, type }) => ({
      name,
      isOperational: isOperationalReachable(name),
      offPremiseServicesReachableIPv4: null,
      // null means unknown or not supported
      offPremiseServicesReachableIPv6: null,
      // null means unknown or not supported
      hardwareAddress: import_ByteArray.ByteArray.fromHex(mac.replace(/[^\da-fA-F]/g, "")),
      iPv4Addresses: ipV4.slice(0, 4).map((ip) => (0, import_Ip.iPv4ToByteArray)(ip)),
      iPv6Addresses: ipV6.slice(0, 8).map((ip) => (0, import_Ip.iPv6ToByteArray)(ip)),
      type: type ?? networkType
    }));
  }
  async [Symbol.asyncDispose]() {
    this.internal.lastTotalOperationalHoursTimer?.stop();
    this.#updateTotalOperationalHoursCounter();
    await super[Symbol.asyncDispose]?.();
  }
}
((GeneralDiagnosticsServer2) => {
  class Internal {
    /** Remember the bootUp time for the device. */
    bootUpTime = import_Time.Time.nowMs();
    /** Last time the total operational hours counter was updated. */
    lastTotalOperationalHoursCounterUpdateTime = import_Time.Time.nowMs();
    /** Timer to update the total operational hours counter every 5 minutes. */
    lastTotalOperationalHoursTimer;
  }
  GeneralDiagnosticsServer2.Internal = Internal;
  class State extends Base.State {
    /** Internal counter of the total operational hours, counted in seconds, updated every 5 minutes. */
    totalOperationalHoursCounter = 0;
    /** The TestEnableKey set for this device for the test commands. Default means "not enabled"." */
    deviceTestEnableKey = new import_ByteArray.ByteArray(16).fill(0);
    [import_Val.Val.properties](endpoint, _session) {
      return {
        /**
         * Dynamically calculate the upTime. This is ok because the attribute is not send out via subscriptions
         * anyway.
         */
        get upTime() {
          const bootUpTime = endpoint.behaviors.internalsOf(GeneralDiagnosticsServer2).bootUpTime;
          return Math.round((import_Time.Time.nowMs() - bootUpTime) / 1e3);
        },
        /**
         * Dynamically calculate the operating Hours from our internal counter. This is ok because the attribute
         * is not send out via subscriptions anyway.
         */
        get totalOperationalHours() {
          const lastTotalOperationalHoursCounterUpdateTime = endpoint.behaviors.internalsOf(
            GeneralDiagnosticsServer2
          ).lastTotalOperationalHoursCounterUpdateTime;
          const totalOperationalHoursCounter = endpoint.stateOf(GeneralDiagnosticsServer2).totalOperationalHoursCounter;
          return Math.floor(
            (import_Time.Time.nowMs() - lastTotalOperationalHoursCounterUpdateTime + totalOperationalHoursCounter) / (60 * 6e4)
          );
        }
      };
    }
  }
  GeneralDiagnosticsServer2.State = State;
})(GeneralDiagnosticsServer || (GeneralDiagnosticsServer = {}));
//# sourceMappingURL=GeneralDiagnosticsServer.js.map
