/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterType } from "../../../cluster/ClusterType.js";
import { ModeSelect } from "../../../cluster/definitions/ModeSelectCluster.js";
declare const ModeSelectServerBase: import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").ClusterComposer.WithFeatures<ModeSelect.Cluster, readonly [ModeSelect.Feature]>, import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<ModeSelect.Cluster, import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../cluster/ClusterBehavior.js").ClusterBehavior, import("./ModeSelectInterface.js").ModeSelectInterface>, import("./ModeSelectInterface.js").ModeSelectInterface>, import("./ModeSelectInterface.js").ModeSelectInterface>;
/**
 * This is the default server implementation of {@link ModeSelectBehavior}.
 *
 * This implementation supports StartupMode and OnMode handling, when the OnOff feature is activated. You should use
 * {@link ModeSelectServer.with} to specialize the class for the features your implementation supports. Alternatively
 * you can extend this class and override the methods you need.
 *
 * It should be sufficient to use the class without changes and just react on the currentMode changed events.
 */
export declare class ModeSelectServerLogic extends ModeSelectServerBase {
    #private;
    initialize(): void;
    changeToMode({ newMode }: ModeSelect.ChangeToModeRequest): void;
}
declare const ModeSelectServer_base: import("../../cluster/ClusterBehavior.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 80;
    readonly name: "ModeSelect";
    readonly revision: 2;
    readonly features: {
        readonly onOff: import("../../../schema/BitmapSchema.js").BitFlag;
    };
    readonly attributes: {
        readonly description: import("../../../cluster/Cluster.js").FixedAttribute<string, any>;
        readonly standardNamespace: import("../../../cluster/Cluster.js").FixedAttribute<number | null, any>;
        readonly supportedModes: import("../../../cluster/Cluster.js").FixedAttribute<import("../../../tlv/TlvObject.js").TypeFromFields<{
            label: import("../../../tlv/TlvObject.js").FieldType<string>;
            mode: import("../../../tlv/TlvObject.js").FieldType<number>;
            semanticTags: import("../../../tlv/TlvObject.js").FieldType<import("../../../tlv/TlvObject.js").TypeFromFields<{
                mfgCode: import("../../../tlv/TlvObject.js").FieldType<import("../../../datatype/VendorId.js").VendorId>;
                value: import("../../../tlv/TlvObject.js").FieldType<number>;
            }>[]>;
        }>[], any>;
        readonly currentMode: import("../../../cluster/Cluster.js").Attribute<number, any>;
        readonly startUpMode: import("../../../cluster/Cluster.js").OptionalWritableAttribute<number | null, any>;
    };
    readonly commands: {
        readonly changeToMode: import("../../../cluster/Cluster.js").Command<import("../../../tlv/TlvObject.js").TypeFromFields<{
            newMode: import("../../../tlv/TlvObject.js").FieldType<number>;
        }>, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly onOff: true;
        };
        readonly component: {
            readonly attributes: {
                readonly onMode: import("../../../cluster/Cluster.js").WritableAttribute<number | null, any>;
            };
        };
    }];
}>, typeof ModeSelectServerLogic, import("./ModeSelectInterface.js").ModeSelectInterface>;
export declare class ModeSelectServer extends ModeSelectServer_base {
}
export {};
//# sourceMappingURL=ModeSelectServer.d.ts.map