{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/access-control/AccessControlServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AccessLevel } from \"../../../cluster/Cluster.js\";\nimport { AccessControl as AccessControlTypes } from \"../../../cluster/definitions/AccessControlCluster.js\";\nimport { InternalError } from \"../../../common/MatterError.js\";\nimport { CaseAuthenticatedTag } from \"../../../datatype/CaseAuthenticatedTag.js\";\nimport { ClusterId } from \"../../../datatype/ClusterId.js\";\nimport { DeviceTypeId } from \"../../../datatype/DeviceTypeId.js\";\nimport { EndpointNumber } from \"../../../datatype/EndpointNumber.js\";\nimport { GroupId } from \"../../../datatype/GroupId.js\";\nimport { NodeId } from \"../../../datatype/NodeId.js\";\nimport { EndpointInterface } from \"../../../endpoint/EndpointInterface.js\";\nimport { FabricManager } from \"../../../fabric/FabricManager.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { NodeLifecycle } from \"../../../node/NodeLifecycle.js\";\nimport { AccessControlManager, IncomingSubjectDescriptor } from \"../../../protocol/interaction/AccessControlManager.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { TlvType } from \"../../../tlv/TlvCodec.js\";\nimport { TlvTaggedList } from \"../../../tlv/TlvObject.js\";\nimport { deepCopy } from \"../../../util/DeepCopy.js\";\nimport { isDeepEqual } from \"../../../util/DeepEqual.js\";\nimport { AccessControl } from \"../../AccessControl.js\";\nimport { ActionContext } from \"../../context/ActionContext.js\";\nimport { AccessControlBehavior } from \"./AccessControlBehavior.js\";\n\nconst logger = Logger.get(\"AccessControlServer\");\n\n/**\n * This is the default server implementation of AccessControlBehavior.\n */\nexport class AccessControlServer extends AccessControlBehavior {\n    declare internal: AccessControlServer.Internal;\n\n    override initialize() {\n        this.reactTo(this.events.acl$Changing, this.#validateAccessControlListChanges); // Enhanced Validation\n        this.reactTo(this.events.acl$Changed, this.#handleAccessControlListChange); // Event handling for changes\n        if (\n            this.state.extension !== undefined &&\n            this.events.extension$Changing !== undefined &&\n            this.events.extension$Changed !== undefined\n        ) {\n            this.reactTo(this.events.extension$Changing, this.#validateAccessControlExtensionChanges); // Enhanced Validation\n            this.reactTo(this.events.extension$Changed, this.#handleAccessControlExtensionChange); // Event handling for changes\n        }\n\n        const lifecycle = this.endpoint.lifecycle as NodeLifecycle;\n\n        if (lifecycle.online !== undefined) {\n            this.reactTo(lifecycle.online, this.#online);\n        }\n    }\n\n    #online() {\n        // Handle Backward compatibility to Matter.js before 0.9.1 and add the missing ACL entry if no entry was set\n        // so far by the controller\n        const fabrics = this.endpoint.env.get(FabricManager).getFabrics();\n        const acl = deepCopy(this.state.acl);\n        const originalAclLength = acl.length;\n        for (const fabric of fabrics) {\n            if (!acl.some(entry => entry.fabricIndex === fabric.fabricIndex)) {\n                acl.push({\n                    fabricIndex: fabric.fabricIndex,\n                    privilege: AccessControlTypes.AccessControlEntryPrivilege.Administer,\n                    authMode: AccessControlTypes.AccessControlEntryAuthMode.Case,\n                    subjects: [fabric.rootNodeId],\n                    targets: null, // entire node\n                });\n                logger.warn(\n                    \"Added missing ACL entry for fabric\",\n                    fabric.fabricIndex,\n                    \"for Node ID\",\n                    fabric.rootNodeId,\n                    \". This should only happen once after upgrading to matter.js 0.9.1\",\n                );\n            }\n        }\n        if (acl.length > originalAclLength) {\n            this.state.acl = acl;\n        }\n\n        logger.info(\"initializing ACL manager with ACL\", acl);\n        this.internal.aclManager = new AccessControlManager(\n            acl,\n            (aclList, aclEntry, subjectDesc, endpoint, clusterId) =>\n                this.extensionEntryAccessCheck(\n                    aclList as unknown as AccessControlTypes.AccessControlEntry[],\n                    aclEntry as unknown as AccessControlTypes.AccessControlEntry,\n                    subjectDesc,\n                    endpoint,\n                    clusterId,\n                ),\n        );\n\n        this.reactTo(this.events.acl$Changed, this.#updateAccessControlList);\n    }\n\n    #validateAccessControlListChanges(value: AccessControlTypes.AccessControlEntry[]) {\n        // TODO: This might be not really correct for local ACL changes because there the session fabric could be\n        //  different which would lead to missing validation of the relevant entries\n        const relevantFabricIndex = this.context.session?.associatedFabric.fabricIndex;\n\n        if (relevantFabricIndex === undefined) {\n            return;\n        }\n        const fabricAcls = value.filter(entry => entry.fabricIndex === relevantFabricIndex);\n        if (fabricAcls.length > this.state.accessControlEntriesPerFabric) {\n            throw new StatusResponseError(\"AccessControlEntriesPerFabric exceeded\", StatusCode.ResourceExhausted);\n        }\n\n        for (const entry of fabricAcls) {\n            const { privilege, subjects, targets, authMode } = entry;\n            if (subjects !== null && subjects.length > this.state.subjectsPerAccessControlEntry) {\n                throw new StatusResponseError(\"SubjectsPerAccessControlEntry exceeded\", StatusCode.ResourceExhausted);\n            }\n\n            if (targets !== null && targets.length > this.state.targetsPerAccessControlEntry) {\n                throw new StatusResponseError(\"TargetsPerAccessControlEntry exceeded\", StatusCode.ResourceExhausted);\n            }\n\n            if (authMode === AccessControlTypes.AccessControlEntryAuthMode.Pase) {\n                throw new StatusResponseError(\"AuthMode for ACL must not be PASE\", StatusCode.ConstraintError);\n            } else if (authMode === AccessControlTypes.AccessControlEntryAuthMode.Case) {\n                if (subjects !== null) {\n                    for (const subject of subjects) {\n                        if (NodeId.isCaseAuthenticatedTag(subject)) {\n                            const cat = NodeId.extractAsCaseAuthenticatedTag(subject);\n                            if (CaseAuthenticatedTag.getVersion(cat) === 0) {\n                                throw new StatusResponseError(\n                                    \"CaseAuthenticatedTag version 0 is not allowed\",\n                                    StatusCode.ConstraintError,\n                                );\n                            }\n                        } else if (!NodeId.isOperationalNodeId(subject)) {\n                            throw new StatusResponseError(\n                                \"Subject must be a valid OperationalNodeId or CaseAuthenticatedTag\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                    }\n                }\n            } else if (authMode === AccessControlTypes.AccessControlEntryAuthMode.Group) {\n                if (privilege === AccessControlTypes.AccessControlEntryPrivilege.Administer) {\n                    throw new StatusResponseError(\n                        \"Group ACLs must not have Administer privilege\",\n                        StatusCode.ConstraintError,\n                    );\n                }\n\n                if (subjects !== null) {\n                    for (const subject of subjects) {\n                        if (GroupId(subject) === GroupId.UNSPECIFIED_GROUP_ID) {\n                            throw new StatusResponseError(\n                                \"Subject must be a valid GroupId for Group ACLs\",\n                                StatusCode.ConstraintError,\n                            );\n                        }\n                    }\n                }\n                // TODO For Group authentication, the Group ID identifies the required group, as defined in the Group Key Management Cluster.\n            }\n\n            if (targets !== null) {\n                for (const target of targets) {\n                    const { cluster, endpoint, deviceType } = target;\n                    if (deviceType !== null && endpoint !== null) {\n                        throw new StatusResponseError(\n                            \"DeviceType and Endpoint are mutually exclusive\",\n                            StatusCode.ConstraintError,\n                        );\n                    }\n                    if (cluster === null && endpoint === null && deviceType === null) {\n                        throw new StatusResponseError(\"At least one field must be present\", StatusCode.ConstraintError);\n                    }\n                    if (cluster !== null && !ClusterId.isValid(cluster)) {\n                        throw new StatusResponseError(\"Cluster must be a valid ClusterId\", StatusCode.ConstraintError);\n                    }\n                    if (endpoint !== null && !EndpointNumber.isValid(endpoint)) {\n                        throw new StatusResponseError(\n                            \"Endpoint must be a valid OperationalNodeId\",\n                            StatusCode.ConstraintError,\n                        );\n                    }\n                    if (deviceType !== null && !DeviceTypeId.isValid(deviceType)) {\n                        throw new StatusResponseError(\n                            \"DeviceType must be a valid DeviceType\",\n                            StatusCode.ConstraintError,\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    #handleAccessControlListChange(\n        value: AccessControlTypes.AccessControlEntry[],\n        oldValue: AccessControlTypes.AccessControlEntry[],\n    ) {\n        if (this.internal.aclManager === undefined) {\n            return; // Too early to send events\n        }\n        const { session } = this.context;\n\n        // TODO: This might be not really correct for local ACL changes because there the session fabric could be\n        //  different which would lead to missing events\n        const relevantFabricIndex = session?.associatedFabric.fabricIndex;\n\n        if (relevantFabricIndex === undefined || this.events.accessControlEntryChanged === undefined) {\n            return;\n        }\n        const adminPasscodeId = session === undefined || session?.isPase ? 0 : null;\n        const adminNodeId = adminPasscodeId === null ? session?.associatedFabric.rootNodeId : null;\n        if (adminNodeId === undefined) {\n            // Should never happen\n            return;\n        }\n        const fabricAcls = value.filter(entry => entry.fabricIndex === relevantFabricIndex);\n        const oldFabricAcls = oldValue.filter(entry => entry.fabricIndex === relevantFabricIndex);\n\n        let i = 0;\n        for (; i < fabricAcls.length; i++) {\n            if (!isDeepEqual(fabricAcls[i], oldFabricAcls[i])) {\n                const changeType =\n                    oldFabricAcls[i] === undefined\n                        ? AccessControlTypes.ChangeType.Added\n                        : fabricAcls[i] === undefined\n                          ? AccessControlTypes.ChangeType.Removed\n                          : AccessControlTypes.ChangeType.Changed;\n                this.events.accessControlEntryChanged.emit(\n                    {\n                        changeType,\n                        adminNodeId,\n                        adminPasscodeId,\n                        latestValue:\n                            (changeType === AccessControlTypes.ChangeType.Removed ? oldFabricAcls[i] : fabricAcls[i]) ??\n                            null,\n                        fabricIndex: relevantFabricIndex,\n                    },\n                    this.context,\n                );\n            }\n        }\n        if (oldFabricAcls.length > i) {\n            for (let j = oldFabricAcls.length - 1; j >= i; j--) {\n                this.events.accessControlEntryChanged.emit(\n                    {\n                        changeType: AccessControlTypes.ChangeType.Removed,\n                        adminNodeId,\n                        adminPasscodeId,\n                        latestValue: oldValue[j],\n                        fabricIndex: relevantFabricIndex,\n                    },\n                    this.context,\n                );\n            }\n        }\n    }\n\n    #validateAccessControlExtensionChanges(value: AccessControlTypes.AccessControlExtension[]) {\n        // TODO: This might be not really correct for local ACL changes because there the session fabric could be\n        //  different which would lead to missing validation of the relevant entries\n        const relevantFabricIndex = this.context.session?.associatedFabric.fabricIndex;\n\n        if (relevantFabricIndex === undefined) {\n            return;\n        }\n\n        const fabricExtensions = value.filter(entry => entry.fabricIndex === relevantFabricIndex);\n\n        if (fabricExtensions.length === 0) {\n            return;\n        }\n        if (fabricExtensions.length > 1) {\n            throw new StatusResponseError(\"Extension list must contain a single entry\", StatusCode.ConstraintError);\n        }\n\n        // we have exactly one entry\n        this.extensionEntryValidator(fabricExtensions[0]);\n    }\n\n    #handleAccessControlExtensionChange(\n        value: AccessControlTypes.AccessControlExtension[],\n        oldValue: AccessControlTypes.AccessControlExtension[],\n    ) {\n        if (this.internal.aclManager === undefined) {\n            return; // Too early to send events\n        }\n        const { session } = this.context;\n\n        // TODO: This might be not really correct for local ACL changes because there the session fabric could be\n        //  different which would lead to missing events of the relevant entries\n        const relevantFabricIndex = session?.associatedFabric.fabricIndex;\n\n        if (relevantFabricIndex === undefined || this.events.accessControlExtensionChanged === undefined) {\n            return;\n        }\n        const adminPasscodeId = session === undefined || session?.isPase ? 0 : null;\n        const adminNodeId = adminPasscodeId === null ? session?.associatedFabric.rootNodeId : null;\n        if (adminNodeId === undefined) {\n            // Should never happen\n            return;\n        }\n\n        const fabricExtensions = value.filter(entry => entry.fabricIndex === relevantFabricIndex);\n        const oldFabricExtensions = oldValue.filter(entry => entry.fabricIndex === relevantFabricIndex);\n\n        const changeType =\n            fabricExtensions.length > oldFabricExtensions.length\n                ? AccessControlTypes.ChangeType.Added\n                : fabricExtensions.length < oldFabricExtensions.length\n                  ? AccessControlTypes.ChangeType.Removed\n                  : AccessControlTypes.ChangeType.Changed;\n\n        this.events.accessControlExtensionChanged.emit(\n            {\n                changeType,\n                adminNodeId,\n                adminPasscodeId,\n                latestValue:\n                    (changeType === AccessControlTypes.ChangeType.Removed\n                        ? oldFabricExtensions[0]\n                        : fabricExtensions[0]) ?? null,\n                fabricIndex: relevantFabricIndex,\n            },\n            this.context,\n        );\n    }\n\n    /**\n     * Implements the access control check for the given context, location and endpoint and is called by the\n     * InteractionServer. The method returns the list of granted Access privileges for the given context, location and\n     * endpoint.\n     */\n    accessLevelsFor(\n        context: ActionContext,\n        location: AccessControl.Location,\n        endpoint?: EndpointInterface,\n    ): AccessLevel[] {\n        if (location.cluster === undefined) {\n            // Without a cluster, internal behaviors are only accessible internally so this is an irrelevant placeholder\n            logger.warn(\"Access control check without cluster, returning View access level\");\n            return [AccessLevel.View];\n        }\n        if (context.session === undefined) {\n            // Without a session, we can't determine access levels\n            logger.warn(\"Access control check without session, returning View access level\");\n            return [AccessLevel.View];\n        }\n        if (endpoint === undefined) {\n            // Without an endpoint, we can't determine access levels, ???\n            logger.warn(\"Access control check without endpoint, returning View access level\");\n            return [AccessLevel.View];\n        }\n\n        return this.aclManager.getGrantedPrivileges(context.session, endpoint, location.cluster);\n    }\n\n    /**\n     * This method allows to implement the validation of manufacturer specific ACL extensions when an extension entry is\n     * added or changed. The default implementation checks whether the extension is a valid TLV and possible to decode.\n     *\n     * In case of an Error throws StatusResponseError.\n     *\n     * Override this method in your own behavior to implement custom validation.\n     */\n    protected extensionEntryValidator(extension: AccessControlTypes.AccessControlExtension) {\n        const { data } = extension;\n        if (data.length < 2 || data[0] !== TlvType.List || data[data.length - 1] !== TlvType.EndOfContainer) {\n            // Easier to check that way that it is an Listen without any tags in general\n            throw new StatusResponseError(\"Extension must be a valid TLV\", StatusCode.ConstraintError);\n        }\n        try {\n            TlvTaggedList({} /* No fields, sufficient for validation */, true).decode(data);\n        } catch (error) {\n            logger.debug(`Extension TLV decoding failed:`, error);\n            throw new StatusResponseError(\"Extension must be a valid TLV\", StatusCode.ConstraintError);\n        }\n    }\n\n    /**\n     * This method allows to implement the validation of manufacturer specific ACL extensions when access control is\n     * checked to decide if access is allowed or not.\n     * The default implementation always returns true. Override this method in your own behavior to implement custom\n     * validation.\n     */\n    protected extensionEntryAccessCheck(\n        _aclList: AccessControlTypes.AccessControlEntry[],\n        _aclEntry: AccessControlTypes.AccessControlEntry,\n        _subjectDesc: IncomingSubjectDescriptor,\n        _endpoint: EndpointInterface,\n        _clusterId: ClusterId,\n    ) {\n        return true;\n    }\n\n    /**\n     * The AccessControlManager instance that is used to manage the ACL for this behavior.\n     */\n    get aclManager() {\n        if (this.internal.aclManager === undefined) {\n            throw new InternalError(\"ACL manager not initialized yet\");\n        }\n        return this.internal.aclManager;\n    }\n\n    #updateAccessControlList(acl: AccessControlTypes.AccessControlEntry[]) {\n        if (!this.aclUpdateDelayed) {\n            logger.info(\"ACL updated, updating ACL manager\", acl);\n            this.aclManager.updateAccessControlList(deepCopy(acl));\n        } else {\n            logger.info(\"ACL updated, but ACL manager update is delayed\", acl);\n            this.internal.delayedAclData = acl;\n        }\n    }\n\n    /**\n     * If set to true, the ACL will not be updated immediately when it changes, but only when the `aclUpdateDelayed`\n     * property is set to false again.\n     * This is a hack to prevent the ACL from updating while we are in the middle of a write transaction and will be\n     * removed again once we somehow handle relevant sub transactions.\n     */\n    get aclUpdateDelayed() {\n        return this.internal.aclUpdateDelayed;\n    }\n\n    /**\n     * If set to true, the ACL will not be updated immediately when it changes, but only when the `aclUpdateDelayed`\n     * property is set to false again.\n     * This is a hack to prevent the ACL from updating while we are in the middle of a write transaction and will be\n     * removed again once we somehow handle relevant sub transactions.\n     */\n    set aclUpdateDelayed(value: boolean) {\n        logger.info(\"Setting ACL update delayed to\", value);\n        if (!value) {\n            this.#updateDelayedAccessControlList();\n        }\n        this.internal.aclUpdateDelayed = value;\n    }\n\n    #updateDelayedAccessControlList() {\n        if (this.internal.delayedAclData === undefined) {\n            return;\n        }\n        const delayedData = deepCopy(this.internal.delayedAclData);\n        this.internal.delayedAclData = undefined;\n        logger.info(\"Updating ACL manager with ACL\", delayedData);\n        this.aclManager.updateAccessControlList(delayedData);\n    }\n}\n\nexport namespace AccessControlServer {\n    export class Internal {\n        /** AccessControlManager instance that is used to manage the ACL checks for this device. */\n        aclManager?: AccessControlManager;\n\n        /** If set to true ACL updates are delayed while in a write transaction. More details see getter/setter above. */\n        aclUpdateDelayed = false;\n\n        /** Latest delayed data of acl */\n        delayedAclData?: AccessControlTypes.AccessControlEntry[];\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,qBAA4B;AAC5B,kCAAoD;AACpD,yBAA8B;AAC9B,kCAAqC;AACrC,uBAA0B;AAC1B,0BAA6B;AAC7B,4BAA+B;AAC/B,qBAAwB;AACxB,oBAAuB;AAEvB,2BAA8B;AAC9B,oBAAuB;AAEvB,kCAAgE;AAChE,wBAAgD;AAChD,sBAAwB;AACxB,uBAA8B;AAC9B,sBAAyB;AACzB,uBAA4B;AAG5B,mCAAsC;AA3BtC;AAAA;AAAA;AAAA;AAAA;AA6BA,MAAM,SAAS,qBAAO,IAAI,qBAAqB;AAKxC,MAAM,4BAA4B,mDAAsB;AAAA,EAGlD,aAAa;AAClB,SAAK,QAAQ,KAAK,OAAO,cAAc,KAAK,iCAAiC;AAC7E,SAAK,QAAQ,KAAK,OAAO,aAAa,KAAK,8BAA8B;AACzE,QACI,KAAK,MAAM,cAAc,UACzB,KAAK,OAAO,uBAAuB,UACnC,KAAK,OAAO,sBAAsB,QACpC;AACE,WAAK,QAAQ,KAAK,OAAO,oBAAoB,KAAK,sCAAsC;AACxF,WAAK,QAAQ,KAAK,OAAO,mBAAmB,KAAK,mCAAmC;AAAA,IACxF;AAEA,UAAM,YAAY,KAAK,SAAS;AAEhC,QAAI,UAAU,WAAW,QAAW;AAChC,WAAK,QAAQ,UAAU,QAAQ,KAAK,OAAO;AAAA,IAC/C;AAAA,EACJ;AAAA,EAEA,UAAU;AAGN,UAAM,UAAU,KAAK,SAAS,IAAI,IAAI,kCAAa,EAAE,WAAW;AAChE,UAAM,UAAM,0BAAS,KAAK,MAAM,GAAG;AACnC,UAAM,oBAAoB,IAAI;AAC9B,eAAW,UAAU,SAAS;AAC1B,UAAI,CAAC,IAAI,KAAK,WAAS,MAAM,gBAAgB,OAAO,WAAW,GAAG;AAC9D,YAAI,KAAK;AAAA,UACL,aAAa,OAAO;AAAA,UACpB,WAAW,4BAAAA,cAAmB,4BAA4B;AAAA,UAC1D,UAAU,4BAAAA,cAAmB,2BAA2B;AAAA,UACxD,UAAU,CAAC,OAAO,UAAU;AAAA,UAC5B,SAAS;AAAA;AAAA,QACb,CAAC;AACD,eAAO;AAAA,UACH;AAAA,UACA,OAAO;AAAA,UACP;AAAA,UACA,OAAO;AAAA,UACP;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,IAAI,SAAS,mBAAmB;AAChC,WAAK,MAAM,MAAM;AAAA,IACrB;AAEA,WAAO,KAAK,qCAAqC,GAAG;AACpD,SAAK,SAAS,aAAa,IAAI;AAAA,MAC3B;AAAA,MACA,CAAC,SAAS,UAAU,aAAa,UAAU,cACvC,KAAK;AAAA,QACD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACR;AAEA,SAAK,QAAQ,KAAK,OAAO,aAAa,KAAK,wBAAwB;AAAA,EACvE;AAAA,EAEA,kCAAkC,OAAgD;AAG9E,UAAM,sBAAsB,KAAK,QAAQ,SAAS,iBAAiB;AAEnE,QAAI,wBAAwB,QAAW;AACnC;AAAA,IACJ;AACA,UAAM,aAAa,MAAM,OAAO,WAAS,MAAM,gBAAgB,mBAAmB;AAClF,QAAI,WAAW,SAAS,KAAK,MAAM,+BAA+B;AAC9D,YAAM,IAAI,sCAAoB,0CAA0C,6BAAW,iBAAiB;AAAA,IACxG;AAEA,eAAW,SAAS,YAAY;AAC5B,YAAM,EAAE,WAAW,UAAU,SAAS,SAAS,IAAI;AACnD,UAAI,aAAa,QAAQ,SAAS,SAAS,KAAK,MAAM,+BAA+B;AACjF,cAAM,IAAI,sCAAoB,0CAA0C,6BAAW,iBAAiB;AAAA,MACxG;AAEA,UAAI,YAAY,QAAQ,QAAQ,SAAS,KAAK,MAAM,8BAA8B;AAC9E,cAAM,IAAI,sCAAoB,yCAAyC,6BAAW,iBAAiB;AAAA,MACvG;AAEA,UAAI,aAAa,4BAAAA,cAAmB,2BAA2B,MAAM;AACjE,cAAM,IAAI,sCAAoB,qCAAqC,6BAAW,eAAe;AAAA,MACjG,WAAW,aAAa,4BAAAA,cAAmB,2BAA2B,MAAM;AACxE,YAAI,aAAa,MAAM;AACnB,qBAAW,WAAW,UAAU;AAC5B,gBAAI,qBAAO,uBAAuB,OAAO,GAAG;AACxC,oBAAM,MAAM,qBAAO,8BAA8B,OAAO;AACxD,kBAAI,iDAAqB,WAAW,GAAG,MAAM,GAAG;AAC5C,sBAAM,IAAI;AAAA,kBACN;AAAA,kBACA,6BAAW;AAAA,gBACf;AAAA,cACJ;AAAA,YACJ,WAAW,CAAC,qBAAO,oBAAoB,OAAO,GAAG;AAC7C,oBAAM,IAAI;AAAA,gBACN;AAAA,gBACA,6BAAW;AAAA,cACf;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,WAAW,aAAa,4BAAAA,cAAmB,2BAA2B,OAAO;AACzE,YAAI,cAAc,4BAAAA,cAAmB,4BAA4B,YAAY;AACzE,gBAAM,IAAI;AAAA,YACN;AAAA,YACA,6BAAW;AAAA,UACf;AAAA,QACJ;AAEA,YAAI,aAAa,MAAM;AACnB,qBAAW,WAAW,UAAU;AAC5B,oBAAI,wBAAQ,OAAO,MAAM,uBAAQ,sBAAsB;AACnD,oBAAM,IAAI;AAAA,gBACN;AAAA,gBACA,6BAAW;AAAA,cACf;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MAEJ;AAEA,UAAI,YAAY,MAAM;AAClB,mBAAW,UAAU,SAAS;AAC1B,gBAAM,EAAE,SAAS,UAAU,WAAW,IAAI;AAC1C,cAAI,eAAe,QAAQ,aAAa,MAAM;AAC1C,kBAAM,IAAI;AAAA,cACN;AAAA,cACA,6BAAW;AAAA,YACf;AAAA,UACJ;AACA,cAAI,YAAY,QAAQ,aAAa,QAAQ,eAAe,MAAM;AAC9D,kBAAM,IAAI,sCAAoB,sCAAsC,6BAAW,eAAe;AAAA,UAClG;AACA,cAAI,YAAY,QAAQ,CAAC,2BAAU,QAAQ,OAAO,GAAG;AACjD,kBAAM,IAAI,sCAAoB,qCAAqC,6BAAW,eAAe;AAAA,UACjG;AACA,cAAI,aAAa,QAAQ,CAAC,qCAAe,QAAQ,QAAQ,GAAG;AACxD,kBAAM,IAAI;AAAA,cACN;AAAA,cACA,6BAAW;AAAA,YACf;AAAA,UACJ;AACA,cAAI,eAAe,QAAQ,CAAC,iCAAa,QAAQ,UAAU,GAAG;AAC1D,kBAAM,IAAI;AAAA,cACN;AAAA,cACA,6BAAW;AAAA,YACf;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,+BACI,OACA,UACF;AACE,QAAI,KAAK,SAAS,eAAe,QAAW;AACxC;AAAA,IACJ;AACA,UAAM,EAAE,QAAQ,IAAI,KAAK;AAIzB,UAAM,sBAAsB,SAAS,iBAAiB;AAEtD,QAAI,wBAAwB,UAAa,KAAK,OAAO,8BAA8B,QAAW;AAC1F;AAAA,IACJ;AACA,UAAM,kBAAkB,YAAY,UAAa,SAAS,SAAS,IAAI;AACvE,UAAM,cAAc,oBAAoB,OAAO,SAAS,iBAAiB,aAAa;AACtF,QAAI,gBAAgB,QAAW;AAE3B;AAAA,IACJ;AACA,UAAM,aAAa,MAAM,OAAO,WAAS,MAAM,gBAAgB,mBAAmB;AAClF,UAAM,gBAAgB,SAAS,OAAO,WAAS,MAAM,gBAAgB,mBAAmB;AAExF,QAAI,IAAI;AACR,WAAO,IAAI,WAAW,QAAQ,KAAK;AAC/B,UAAI,KAAC,8BAAY,WAAW,CAAC,GAAG,cAAc,CAAC,CAAC,GAAG;AAC/C,cAAM,aACF,cAAc,CAAC,MAAM,SACf,4BAAAA,cAAmB,WAAW,QAC9B,WAAW,CAAC,MAAM,SAChB,4BAAAA,cAAmB,WAAW,UAC9B,4BAAAA,cAAmB,WAAW;AAC1C,aAAK,OAAO,0BAA0B;AAAA,UAClC;AAAA,YACI;AAAA,YACA;AAAA,YACA;AAAA,YACA,cACK,eAAe,4BAAAA,cAAmB,WAAW,UAAU,cAAc,CAAC,IAAI,WAAW,CAAC,MACvF;AAAA,YACJ,aAAa;AAAA,UACjB;AAAA,UACA,KAAK;AAAA,QACT;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,cAAc,SAAS,GAAG;AAC1B,eAAS,IAAI,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;AAChD,aAAK,OAAO,0BAA0B;AAAA,UAClC;AAAA,YACI,YAAY,4BAAAA,cAAmB,WAAW;AAAA,YAC1C;AAAA,YACA;AAAA,YACA,aAAa,SAAS,CAAC;AAAA,YACvB,aAAa;AAAA,UACjB;AAAA,UACA,KAAK;AAAA,QACT;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,uCAAuC,OAAoD;AAGvF,UAAM,sBAAsB,KAAK,QAAQ,SAAS,iBAAiB;AAEnE,QAAI,wBAAwB,QAAW;AACnC;AAAA,IACJ;AAEA,UAAM,mBAAmB,MAAM,OAAO,WAAS,MAAM,gBAAgB,mBAAmB;AAExF,QAAI,iBAAiB,WAAW,GAAG;AAC/B;AAAA,IACJ;AACA,QAAI,iBAAiB,SAAS,GAAG;AAC7B,YAAM,IAAI,sCAAoB,8CAA8C,6BAAW,eAAe;AAAA,IAC1G;AAGA,SAAK,wBAAwB,iBAAiB,CAAC,CAAC;AAAA,EACpD;AAAA,EAEA,oCACI,OACA,UACF;AACE,QAAI,KAAK,SAAS,eAAe,QAAW;AACxC;AAAA,IACJ;AACA,UAAM,EAAE,QAAQ,IAAI,KAAK;AAIzB,UAAM,sBAAsB,SAAS,iBAAiB;AAEtD,QAAI,wBAAwB,UAAa,KAAK,OAAO,kCAAkC,QAAW;AAC9F;AAAA,IACJ;AACA,UAAM,kBAAkB,YAAY,UAAa,SAAS,SAAS,IAAI;AACvE,UAAM,cAAc,oBAAoB,OAAO,SAAS,iBAAiB,aAAa;AACtF,QAAI,gBAAgB,QAAW;AAE3B;AAAA,IACJ;AAEA,UAAM,mBAAmB,MAAM,OAAO,WAAS,MAAM,gBAAgB,mBAAmB;AACxF,UAAM,sBAAsB,SAAS,OAAO,WAAS,MAAM,gBAAgB,mBAAmB;AAE9F,UAAM,aACF,iBAAiB,SAAS,oBAAoB,SACxC,4BAAAA,cAAmB,WAAW,QAC9B,iBAAiB,SAAS,oBAAoB,SAC5C,4BAAAA,cAAmB,WAAW,UAC9B,4BAAAA,cAAmB,WAAW;AAE1C,SAAK,OAAO,8BAA8B;AAAA,MACtC;AAAA,QACI;AAAA,QACA;AAAA,QACA;AAAA,QACA,cACK,eAAe,4BAAAA,cAAmB,WAAW,UACxC,oBAAoB,CAAC,IACrB,iBAAiB,CAAC,MAAM;AAAA,QAClC,aAAa;AAAA,MACjB;AAAA,MACA,KAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBACI,SACA,UACA,UACa;AACb,QAAI,SAAS,YAAY,QAAW;AAEhC,aAAO,KAAK,mEAAmE;AAC/E,aAAO,CAAC,2BAAY,IAAI;AAAA,IAC5B;AACA,QAAI,QAAQ,YAAY,QAAW;AAE/B,aAAO,KAAK,mEAAmE;AAC/E,aAAO,CAAC,2BAAY,IAAI;AAAA,IAC5B;AACA,QAAI,aAAa,QAAW;AAExB,aAAO,KAAK,oEAAoE;AAChF,aAAO,CAAC,2BAAY,IAAI;AAAA,IAC5B;AAEA,WAAO,KAAK,WAAW,qBAAqB,QAAQ,SAAS,UAAU,SAAS,OAAO;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUU,wBAAwB,WAAsD;AACpF,UAAM,EAAE,KAAK,IAAI;AACjB,QAAI,KAAK,SAAS,KAAK,KAAK,CAAC,MAAM,wBAAQ,QAAQ,KAAK,KAAK,SAAS,CAAC,MAAM,wBAAQ,gBAAgB;AAEjG,YAAM,IAAI,sCAAoB,iCAAiC,6BAAW,eAAe;AAAA,IAC7F;AACA,QAAI;AACA,0CAAc,CAAC,GAA8C,IAAI,EAAE,OAAO,IAAI;AAAA,IAClF,SAAS,OAAO;AACZ,aAAO,MAAM,kCAAkC,KAAK;AACpD,YAAM,IAAI,sCAAoB,iCAAiC,6BAAW,eAAe;AAAA,IAC7F;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,0BACN,UACA,WACA,cACA,WACA,YACF;AACE,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,aAAa;AACb,QAAI,KAAK,SAAS,eAAe,QAAW;AACxC,YAAM,IAAI,iCAAc,iCAAiC;AAAA,IAC7D;AACA,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EAEA,yBAAyB,KAA8C;AACnE,QAAI,CAAC,KAAK,kBAAkB;AACxB,aAAO,KAAK,qCAAqC,GAAG;AACpD,WAAK,WAAW,4BAAwB,0BAAS,GAAG,CAAC;AAAA,IACzD,OAAO;AACH,aAAO,KAAK,kDAAkD,GAAG;AACjE,WAAK,SAAS,iBAAiB;AAAA,IACnC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,mBAAmB;AACnB,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,iBAAiB,OAAgB;AACjC,WAAO,KAAK,iCAAiC,KAAK;AAClD,QAAI,CAAC,OAAO;AACR,WAAK,gCAAgC;AAAA,IACzC;AACA,SAAK,SAAS,mBAAmB;AAAA,EACrC;AAAA,EAEA,kCAAkC;AAC9B,QAAI,KAAK,SAAS,mBAAmB,QAAW;AAC5C;AAAA,IACJ;AACA,UAAM,kBAAc,0BAAS,KAAK,SAAS,cAAc;AACzD,SAAK,SAAS,iBAAiB;AAC/B,WAAO,KAAK,iCAAiC,WAAW;AACxD,SAAK,WAAW,wBAAwB,WAAW;AAAA,EACvD;AACJ;AAAA,CAEO,CAAUC,yBAAV;AAAA,EACI,MAAM,SAAS;AAAA;AAAA,IAElB;AAAA;AAAA,IAGA,mBAAmB;AAAA;AAAA,IAGnB;AAAA,EACJ;AATO,EAAAA,qBAAM;AAAA,GADA;",
  "names": ["AccessControlTypes", "AccessControlServer"]
}
