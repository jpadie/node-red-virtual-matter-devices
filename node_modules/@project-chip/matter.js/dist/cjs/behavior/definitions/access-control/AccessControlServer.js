"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AccessControlServer_exports = {};
__export(AccessControlServer_exports, {
  AccessControlServer: () => AccessControlServer
});
module.exports = __toCommonJS(AccessControlServer_exports);
var import_Cluster = require("../../../cluster/Cluster.js");
var import_AccessControlCluster = require("../../../cluster/definitions/AccessControlCluster.js");
var import_MatterError = require("../../../common/MatterError.js");
var import_CaseAuthenticatedTag = require("../../../datatype/CaseAuthenticatedTag.js");
var import_ClusterId = require("../../../datatype/ClusterId.js");
var import_DeviceTypeId = require("../../../datatype/DeviceTypeId.js");
var import_EndpointNumber = require("../../../datatype/EndpointNumber.js");
var import_GroupId = require("../../../datatype/GroupId.js");
var import_NodeId = require("../../../datatype/NodeId.js");
var import_FabricManager = require("../../../fabric/FabricManager.js");
var import_Logger = require("../../../log/Logger.js");
var import_AccessControlManager = require("../../../protocol/interaction/AccessControlManager.js");
var import_StatusCode = require("../../../protocol/interaction/StatusCode.js");
var import_TlvCodec = require("../../../tlv/TlvCodec.js");
var import_TlvObject = require("../../../tlv/TlvObject.js");
var import_DeepCopy = require("../../../util/DeepCopy.js");
var import_DeepEqual = require("../../../util/DeepEqual.js");
var import_AccessControlBehavior = require("./AccessControlBehavior.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("AccessControlServer");
class AccessControlServer extends import_AccessControlBehavior.AccessControlBehavior {
  initialize() {
    this.reactTo(this.events.acl$Changing, this.#validateAccessControlListChanges);
    this.reactTo(this.events.acl$Changed, this.#handleAccessControlListChange);
    if (this.state.extension !== void 0 && this.events.extension$Changing !== void 0 && this.events.extension$Changed !== void 0) {
      this.reactTo(this.events.extension$Changing, this.#validateAccessControlExtensionChanges);
      this.reactTo(this.events.extension$Changed, this.#handleAccessControlExtensionChange);
    }
    const lifecycle = this.endpoint.lifecycle;
    if (lifecycle.online !== void 0) {
      this.reactTo(lifecycle.online, this.#online);
    }
  }
  #online() {
    const fabrics = this.endpoint.env.get(import_FabricManager.FabricManager).getFabrics();
    const acl = (0, import_DeepCopy.deepCopy)(this.state.acl);
    const originalAclLength = acl.length;
    for (const fabric of fabrics) {
      if (!acl.some((entry) => entry.fabricIndex === fabric.fabricIndex)) {
        acl.push({
          fabricIndex: fabric.fabricIndex,
          privilege: import_AccessControlCluster.AccessControl.AccessControlEntryPrivilege.Administer,
          authMode: import_AccessControlCluster.AccessControl.AccessControlEntryAuthMode.Case,
          subjects: [fabric.rootNodeId],
          targets: null
          // entire node
        });
        logger.warn(
          "Added missing ACL entry for fabric",
          fabric.fabricIndex,
          "for Node ID",
          fabric.rootNodeId,
          ". This should only happen once after upgrading to matter.js 0.9.1"
        );
      }
    }
    if (acl.length > originalAclLength) {
      this.state.acl = acl;
    }
    logger.info("initializing ACL manager with ACL", acl);
    this.internal.aclManager = new import_AccessControlManager.AccessControlManager(
      acl,
      (aclList, aclEntry, subjectDesc, endpoint, clusterId) => this.extensionEntryAccessCheck(
        aclList,
        aclEntry,
        subjectDesc,
        endpoint,
        clusterId
      )
    );
    this.reactTo(this.events.acl$Changed, this.#updateAccessControlList);
  }
  #validateAccessControlListChanges(value) {
    const relevantFabricIndex = this.context.session?.associatedFabric.fabricIndex;
    if (relevantFabricIndex === void 0) {
      return;
    }
    const fabricAcls = value.filter((entry) => entry.fabricIndex === relevantFabricIndex);
    if (fabricAcls.length > this.state.accessControlEntriesPerFabric) {
      throw new import_StatusCode.StatusResponseError("AccessControlEntriesPerFabric exceeded", import_StatusCode.StatusCode.ResourceExhausted);
    }
    for (const entry of fabricAcls) {
      const { privilege, subjects, targets, authMode } = entry;
      if (subjects !== null && subjects.length > this.state.subjectsPerAccessControlEntry) {
        throw new import_StatusCode.StatusResponseError("SubjectsPerAccessControlEntry exceeded", import_StatusCode.StatusCode.ResourceExhausted);
      }
      if (targets !== null && targets.length > this.state.targetsPerAccessControlEntry) {
        throw new import_StatusCode.StatusResponseError("TargetsPerAccessControlEntry exceeded", import_StatusCode.StatusCode.ResourceExhausted);
      }
      if (authMode === import_AccessControlCluster.AccessControl.AccessControlEntryAuthMode.Pase) {
        throw new import_StatusCode.StatusResponseError("AuthMode for ACL must not be PASE", import_StatusCode.StatusCode.ConstraintError);
      } else if (authMode === import_AccessControlCluster.AccessControl.AccessControlEntryAuthMode.Case) {
        if (subjects !== null) {
          for (const subject of subjects) {
            if (import_NodeId.NodeId.isCaseAuthenticatedTag(subject)) {
              const cat = import_NodeId.NodeId.extractAsCaseAuthenticatedTag(subject);
              if (import_CaseAuthenticatedTag.CaseAuthenticatedTag.getVersion(cat) === 0) {
                throw new import_StatusCode.StatusResponseError(
                  "CaseAuthenticatedTag version 0 is not allowed",
                  import_StatusCode.StatusCode.ConstraintError
                );
              }
            } else if (!import_NodeId.NodeId.isOperationalNodeId(subject)) {
              throw new import_StatusCode.StatusResponseError(
                "Subject must be a valid OperationalNodeId or CaseAuthenticatedTag",
                import_StatusCode.StatusCode.ConstraintError
              );
            }
          }
        }
      } else if (authMode === import_AccessControlCluster.AccessControl.AccessControlEntryAuthMode.Group) {
        if (privilege === import_AccessControlCluster.AccessControl.AccessControlEntryPrivilege.Administer) {
          throw new import_StatusCode.StatusResponseError(
            "Group ACLs must not have Administer privilege",
            import_StatusCode.StatusCode.ConstraintError
          );
        }
        if (subjects !== null) {
          for (const subject of subjects) {
            if ((0, import_GroupId.GroupId)(subject) === import_GroupId.GroupId.UNSPECIFIED_GROUP_ID) {
              throw new import_StatusCode.StatusResponseError(
                "Subject must be a valid GroupId for Group ACLs",
                import_StatusCode.StatusCode.ConstraintError
              );
            }
          }
        }
      }
      if (targets !== null) {
        for (const target of targets) {
          const { cluster, endpoint, deviceType } = target;
          if (deviceType !== null && endpoint !== null) {
            throw new import_StatusCode.StatusResponseError(
              "DeviceType and Endpoint are mutually exclusive",
              import_StatusCode.StatusCode.ConstraintError
            );
          }
          if (cluster === null && endpoint === null && deviceType === null) {
            throw new import_StatusCode.StatusResponseError("At least one field must be present", import_StatusCode.StatusCode.ConstraintError);
          }
          if (cluster !== null && !import_ClusterId.ClusterId.isValid(cluster)) {
            throw new import_StatusCode.StatusResponseError("Cluster must be a valid ClusterId", import_StatusCode.StatusCode.ConstraintError);
          }
          if (endpoint !== null && !import_EndpointNumber.EndpointNumber.isValid(endpoint)) {
            throw new import_StatusCode.StatusResponseError(
              "Endpoint must be a valid OperationalNodeId",
              import_StatusCode.StatusCode.ConstraintError
            );
          }
          if (deviceType !== null && !import_DeviceTypeId.DeviceTypeId.isValid(deviceType)) {
            throw new import_StatusCode.StatusResponseError(
              "DeviceType must be a valid DeviceType",
              import_StatusCode.StatusCode.ConstraintError
            );
          }
        }
      }
    }
  }
  #handleAccessControlListChange(value, oldValue) {
    if (this.internal.aclManager === void 0) {
      return;
    }
    const { session } = this.context;
    const relevantFabricIndex = session?.associatedFabric.fabricIndex;
    if (relevantFabricIndex === void 0 || this.events.accessControlEntryChanged === void 0) {
      return;
    }
    const adminPasscodeId = session === void 0 || session?.isPase ? 0 : null;
    const adminNodeId = adminPasscodeId === null ? session?.associatedFabric.rootNodeId : null;
    if (adminNodeId === void 0) {
      return;
    }
    const fabricAcls = value.filter((entry) => entry.fabricIndex === relevantFabricIndex);
    const oldFabricAcls = oldValue.filter((entry) => entry.fabricIndex === relevantFabricIndex);
    let i = 0;
    for (; i < fabricAcls.length; i++) {
      if (!(0, import_DeepEqual.isDeepEqual)(fabricAcls[i], oldFabricAcls[i])) {
        const changeType = oldFabricAcls[i] === void 0 ? import_AccessControlCluster.AccessControl.ChangeType.Added : fabricAcls[i] === void 0 ? import_AccessControlCluster.AccessControl.ChangeType.Removed : import_AccessControlCluster.AccessControl.ChangeType.Changed;
        this.events.accessControlEntryChanged.emit(
          {
            changeType,
            adminNodeId,
            adminPasscodeId,
            latestValue: (changeType === import_AccessControlCluster.AccessControl.ChangeType.Removed ? oldFabricAcls[i] : fabricAcls[i]) ?? null,
            fabricIndex: relevantFabricIndex
          },
          this.context
        );
      }
    }
    if (oldFabricAcls.length > i) {
      for (let j = oldFabricAcls.length - 1; j >= i; j--) {
        this.events.accessControlEntryChanged.emit(
          {
            changeType: import_AccessControlCluster.AccessControl.ChangeType.Removed,
            adminNodeId,
            adminPasscodeId,
            latestValue: oldValue[j],
            fabricIndex: relevantFabricIndex
          },
          this.context
        );
      }
    }
  }
  #validateAccessControlExtensionChanges(value) {
    const relevantFabricIndex = this.context.session?.associatedFabric.fabricIndex;
    if (relevantFabricIndex === void 0) {
      return;
    }
    const fabricExtensions = value.filter((entry) => entry.fabricIndex === relevantFabricIndex);
    if (fabricExtensions.length === 0) {
      return;
    }
    if (fabricExtensions.length > 1) {
      throw new import_StatusCode.StatusResponseError("Extension list must contain a single entry", import_StatusCode.StatusCode.ConstraintError);
    }
    this.extensionEntryValidator(fabricExtensions[0]);
  }
  #handleAccessControlExtensionChange(value, oldValue) {
    if (this.internal.aclManager === void 0) {
      return;
    }
    const { session } = this.context;
    const relevantFabricIndex = session?.associatedFabric.fabricIndex;
    if (relevantFabricIndex === void 0 || this.events.accessControlExtensionChanged === void 0) {
      return;
    }
    const adminPasscodeId = session === void 0 || session?.isPase ? 0 : null;
    const adminNodeId = adminPasscodeId === null ? session?.associatedFabric.rootNodeId : null;
    if (adminNodeId === void 0) {
      return;
    }
    const fabricExtensions = value.filter((entry) => entry.fabricIndex === relevantFabricIndex);
    const oldFabricExtensions = oldValue.filter((entry) => entry.fabricIndex === relevantFabricIndex);
    const changeType = fabricExtensions.length > oldFabricExtensions.length ? import_AccessControlCluster.AccessControl.ChangeType.Added : fabricExtensions.length < oldFabricExtensions.length ? import_AccessControlCluster.AccessControl.ChangeType.Removed : import_AccessControlCluster.AccessControl.ChangeType.Changed;
    this.events.accessControlExtensionChanged.emit(
      {
        changeType,
        adminNodeId,
        adminPasscodeId,
        latestValue: (changeType === import_AccessControlCluster.AccessControl.ChangeType.Removed ? oldFabricExtensions[0] : fabricExtensions[0]) ?? null,
        fabricIndex: relevantFabricIndex
      },
      this.context
    );
  }
  /**
   * Implements the access control check for the given context, location and endpoint and is called by the
   * InteractionServer. The method returns the list of granted Access privileges for the given context, location and
   * endpoint.
   */
  accessLevelsFor(context, location, endpoint) {
    if (location.cluster === void 0) {
      logger.warn("Access control check without cluster, returning View access level");
      return [import_Cluster.AccessLevel.View];
    }
    if (context.session === void 0) {
      logger.warn("Access control check without session, returning View access level");
      return [import_Cluster.AccessLevel.View];
    }
    if (endpoint === void 0) {
      logger.warn("Access control check without endpoint, returning View access level");
      return [import_Cluster.AccessLevel.View];
    }
    return this.aclManager.getGrantedPrivileges(context.session, endpoint, location.cluster);
  }
  /**
   * This method allows to implement the validation of manufacturer specific ACL extensions when an extension entry is
   * added or changed. The default implementation checks whether the extension is a valid TLV and possible to decode.
   *
   * In case of an Error throws StatusResponseError.
   *
   * Override this method in your own behavior to implement custom validation.
   */
  extensionEntryValidator(extension) {
    const { data } = extension;
    if (data.length < 2 || data[0] !== import_TlvCodec.TlvType.List || data[data.length - 1] !== import_TlvCodec.TlvType.EndOfContainer) {
      throw new import_StatusCode.StatusResponseError("Extension must be a valid TLV", import_StatusCode.StatusCode.ConstraintError);
    }
    try {
      (0, import_TlvObject.TlvTaggedList)({}, true).decode(data);
    } catch (error) {
      logger.debug(`Extension TLV decoding failed:`, error);
      throw new import_StatusCode.StatusResponseError("Extension must be a valid TLV", import_StatusCode.StatusCode.ConstraintError);
    }
  }
  /**
   * This method allows to implement the validation of manufacturer specific ACL extensions when access control is
   * checked to decide if access is allowed or not.
   * The default implementation always returns true. Override this method in your own behavior to implement custom
   * validation.
   */
  extensionEntryAccessCheck(_aclList, _aclEntry, _subjectDesc, _endpoint, _clusterId) {
    return true;
  }
  /**
   * The AccessControlManager instance that is used to manage the ACL for this behavior.
   */
  get aclManager() {
    if (this.internal.aclManager === void 0) {
      throw new import_MatterError.InternalError("ACL manager not initialized yet");
    }
    return this.internal.aclManager;
  }
  #updateAccessControlList(acl) {
    if (!this.aclUpdateDelayed) {
      logger.info("ACL updated, updating ACL manager", acl);
      this.aclManager.updateAccessControlList((0, import_DeepCopy.deepCopy)(acl));
    } else {
      logger.info("ACL updated, but ACL manager update is delayed", acl);
      this.internal.delayedAclData = acl;
    }
  }
  /**
   * If set to true, the ACL will not be updated immediately when it changes, but only when the `aclUpdateDelayed`
   * property is set to false again.
   * This is a hack to prevent the ACL from updating while we are in the middle of a write transaction and will be
   * removed again once we somehow handle relevant sub transactions.
   */
  get aclUpdateDelayed() {
    return this.internal.aclUpdateDelayed;
  }
  /**
   * If set to true, the ACL will not be updated immediately when it changes, but only when the `aclUpdateDelayed`
   * property is set to false again.
   * This is a hack to prevent the ACL from updating while we are in the middle of a write transaction and will be
   * removed again once we somehow handle relevant sub transactions.
   */
  set aclUpdateDelayed(value) {
    logger.info("Setting ACL update delayed to", value);
    if (!value) {
      this.#updateDelayedAccessControlList();
    }
    this.internal.aclUpdateDelayed = value;
  }
  #updateDelayedAccessControlList() {
    if (this.internal.delayedAclData === void 0) {
      return;
    }
    const delayedData = (0, import_DeepCopy.deepCopy)(this.internal.delayedAclData);
    this.internal.delayedAclData = void 0;
    logger.info("Updating ACL manager with ACL", delayedData);
    this.aclManager.updateAccessControlList(delayedData);
  }
}
((AccessControlServer2) => {
  class Internal {
    /** AccessControlManager instance that is used to manage the ACL checks for this device. */
    aclManager;
    /** If set to true ACL updates are delayed while in a write transaction. More details see getter/setter above. */
    aclUpdateDelayed = false;
    /** Latest delayed data of acl */
    delayedAclData;
  }
  AccessControlServer2.Internal = Internal;
})(AccessControlServer || (AccessControlServer = {}));
//# sourceMappingURL=AccessControlServer.js.map
