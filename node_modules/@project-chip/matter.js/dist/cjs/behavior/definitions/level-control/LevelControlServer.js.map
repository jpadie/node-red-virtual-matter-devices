{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/level-control/LevelControlServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LevelControl } from \"../../../cluster/definitions/LevelControlCluster.js\";\nimport { GeneralDiagnostics } from \"../../../cluster/definitions/index.js\";\nimport { RootEndpoint } from \"../../../endpoint/definitions/system/RootEndpoint.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { StatusCode, StatusResponseError } from \"../../../protocol/interaction/StatusCode.js\";\nimport { TypeFromPartialBitSchema } from \"../../../schema/BitmapSchema.js\";\nimport { Time, Timer } from \"../../../time/Time.js\";\nimport { cropValueRange } from \"../../../util/Number.js\";\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { ColorControlServer } from \"../color-control/ColorControlServer.js\";\nimport { GeneralDiagnosticsBehavior } from \"../general-diagnostics/GeneralDiagnosticsBehavior.js\";\nimport { OnOffServer } from \"../on-off/OnOffServer.js\";\nimport { LevelControlBehavior } from \"./LevelControlBehavior.js\";\n\nconst logger = Logger.get(\"LevelControlServer\");\n\nconst LevelControlLogicBase = LevelControlBehavior.with(LevelControl.Feature.OnOff, LevelControl.Feature.Lighting);\n\n/**\n * This is the default server implementation of {@link LevelControlBehavior}.\n *\n * This implementation includes all features of {@link LevelControl.Cluster} and implements all mandatory commands. The\n * On-Off Feature is automatically turned on as defined by the matter specification.\n * You should use {@link LevelControlServer.with} to specialize the class for the features your implementation supports.\n *\n * This default implementation also handles the OnOff cluster dependency and the ColorControl dependency as defined by\n * the Matter specification automatically.\n *\n * This implementation ignores by default all transition times and sets the level immediately. Alternatively, you can\n * set the `managedTransitionTimeHandling` state attribute to true to have matter.js manage transition times by\n * changing the level value step-wise every second. This might be an intermediate solution if you develop\n * independently of defined hardware.\n *\n * If you develop for a specific hardware you should extend the {@link LevelControlServer} class and implement the\n * following methods to natively use device features to correctly support the transition times. For this the default\n * implementation uses special protected methods which are used by the real commands and are only responsible for the\n * actual value change logic. The benefit of this structure is that basic data validations and options checks are\n * already done and you can focus on the actual hardware interaction:\n * * {@link LevelControlServerLogic.moveToLevelLogic} Logic to move the value to a defined level with a transition time\n * * {@link LevelControlServerLogic.moveLogic} Logic to move the value up or down with a defined rate\n * * {@link LevelControlServerLogic.stepLogic} Logic to step the value up or down with a defined step size and transition\n * * {@link LevelControlServerLogic.stopLogic} Logic to stop any currently running transitions\n * * {@link LevelControlServerLogic.handleOnOffChange} Logic to handle dimming to onLevel when device got turned on by connected OnOff cluster\n *\n * If you add own implementation you can use:\n * * {@link LevelControlServerLogic.setLevel} to set the level attribute including automatic handling of the onoff dependency\n * * {@link LevelControlServerLogic.setRemainingTime} to set the remaining time attribute when Lighting feature is enabled\n *\n * All overridable methods except setRemainingTime can be implemented sync or async by returning a Promise.\n */\nexport class LevelControlServerLogic extends LevelControlLogicBase {\n    protected declare internal: LevelControlServerLogic.Internal;\n    declare state: LevelControlServerLogic.State;\n\n    /** Returns the minimum level, including feature specific fallback value handling. */\n    get minLevel() {\n        return this.state.minLevel ?? (this.features.lighting ? 1 : 0);\n    }\n\n    /** Returns the maximum level, including feature specific fallback value handling. */\n    get maxLevel() {\n        return this.state.maxLevel ?? 0xfe;\n    }\n\n    /**\n     * The current level value as number.\n     * Throws an StatusResponse Error when null!\n     */\n    get currentLevel(): number {\n        if (this.state.currentLevel === null) {\n            throw new StatusResponseError(\n                \"The currentLevel value is null, so we cannot operate on it.\",\n                StatusCode.Failure,\n            );\n        }\n        return this.state.currentLevel;\n    }\n\n    override initialize() {\n        if (this.state.managedTransitionTimeHandling) {\n            this.internal.transitionIntervalTimer = Time.getPeriodicTimer(\n                \"LevelControl.step/move\",\n                1000,\n                this.callback(this.#stepIntervalTick),\n            );\n        }\n\n        if (this.features.lighting) {\n            if (this.state.currentLevel === 0) {\n                logger.warn(\n                    `The currentLevel value of ${this.state.currentLevel} is invalid according to Matter specification. The value must not be 0.`,\n                );\n            }\n            if (this.minLevel !== 1) {\n                logger.warn(\n                    `The minLevel value of ${this.minLevel} is invalid according to Matter specification. The value should be 1.`,\n                );\n            }\n            if (this.maxLevel !== 0xfe) {\n                logger.warn(\n                    `The maxLevel value of ${this.maxLevel} is invalid according to Matter specification. The value should be 254.`,\n                );\n            }\n\n            if (this.#getBootReason() !== GeneralDiagnostics.BootReason.SoftwareUpdateCompleted) {\n                const startUpLevelValue = this.state.startUpCurrentLevel ?? null;\n                const currentLevelValue = this.state.currentLevel;\n                let targetLevelValue: number | null;\n                switch (startUpLevelValue) {\n                    case 0:\n                        targetLevelValue = this.minLevel;\n                        break;\n                    case null:\n                        targetLevelValue = currentLevelValue;\n                        break;\n                    default:\n                        targetLevelValue = startUpLevelValue;\n                        break;\n                }\n                if (targetLevelValue !== currentLevelValue) {\n                    this.state.currentLevel = targetLevelValue;\n                }\n            }\n        }\n\n        if (this.features.onOff && this.agent.has(OnOffServer)) {\n            this.reactTo(this.agent.get(OnOffServer).events.onOff$Changed, this.handleOnOffChange);\n        }\n    }\n\n    /**\n     * Default implementation notes:\n     * This method ignores the transition time provided by the command or settings and just sets the level to the\n     * requested value. After the options and value checks it uses the {@link moveToLevelLogic} method to set the level.\n     * If you want to implement own logic just override {@link moveToLevelLogic} with is also used for {@link moveToLevelWithOnOff}.\n     */\n    override moveToLevel({ level, transitionTime, optionsMask, optionsOverride }: LevelControl.MoveToLevelRequest) {\n        const effectiveOptions = this.#calculateEffectiveOptions(optionsMask, optionsOverride);\n        if (!this.#optionsAllowExecution(effectiveOptions)) {\n            return;\n        }\n\n        this.#assertLevelValue(level);\n\n        return this.moveToLevelLogic(level, transitionTime, false, effectiveOptions);\n    }\n\n    /**\n     * Default implementation notes:\n     * This method ignores the transition time provided by the command or settings and just sets the level to the\n     * requested value. After the options and value checks it uses the {@link moveToLevelLogic} method to set the level.\n     * If you want to implement own logic just override {@link moveToLevelLogic} with is also used for {@link moveToLevel}.\n     */\n    override moveToLevelWithOnOff({ level, transitionTime }: LevelControl.MoveToLevelRequest) {\n        this.#assertLevelValue(level);\n\n        return this.moveToLevelLogic(level, transitionTime, true);\n    }\n\n    /**\n     * Default implementation of the moveToLevel logic. When a transition time is specified the implementation uses a\n     * step based logic to manage the move. It also checks if the level is within the min and max level range and sets\n     * the level accordingly. The method uses {@link setLevel} to set the level and handle the on/off state if the method\n     * is called by a *WithOnOff command.\n     *\n     * @param level Level to set\n     * @param transitionTime Transition time, ignored in this default implementation\n     * @param withOnOff true if the method is called by a *WithOnOff command\n     * @param options Options for the command\n     * @protected\n     */\n    protected moveToLevelLogic(\n        level: number,\n        transitionTime: number | null,\n        withOnOff: boolean,\n        options: TypeFromPartialBitSchema<typeof LevelControl.Options> = {},\n    ) {\n        // Determine effective transition time\n        const transitionTimeValue = transitionTime ?? this.state.onOffTransitionTime ?? null;\n\n        // Adjust target level\n        level = cropValueRange(level, this.minLevel, this.maxLevel);\n\n        // If we should move to the new level as fast as possible ...\n        if (\n            !this.state.managedTransitionTimeHandling ||\n            transitionTimeValue === null ||\n            transitionTimeValue === 0 ||\n            this.currentLevel === level\n        ) {\n            this.setRemainingTime(0);\n            return this.setLevel(level, withOnOff, options);\n        }\n\n        // Else calculate a rate by second and manage the transition\n        const effectiveRate = Math.ceil(((level - this.currentLevel) / transitionTimeValue) * 10);\n        return this.#initiateTransition(effectiveRate, withOnOff, level, options);\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link moveLogic} method to set the level.\n     * If you want to implement own logic just override {@link moveLogic} with is also used for {@link moveWithOnOff}.\n     * The logic is implemented as follows: When no move rate is provided and also no default move rate is set, the\n     * server will move as fast as possible, so we set to min/max directly. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second.\n     */\n    override move({ moveMode, rate, optionsMask, optionsOverride }: LevelControl.MoveRequest) {\n        const effectiveOptions = this.#calculateEffectiveOptions(optionsMask, optionsOverride);\n        if (!this.#optionsAllowExecution(effectiveOptions)) {\n            return;\n        }\n\n        return this.moveLogic(moveMode, rate, false, effectiveOptions);\n    }\n\n    /**\n     * Default implementation notes:\n     * This implementation uses the {@link moveLogic} method to set the level.\n     * If you want to implement own logic just override {@link moveLogic} with is also used for {@link move}.\n     * The logic is implemented as follows: When no move rate is provided and also no default move rate is set, the\n     * server will move as fast as possible, so we set to min/max directly. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second.\n     */\n    override moveWithOnOff({ moveMode, rate }: LevelControl.MoveRequest) {\n        return this.moveLogic(moveMode, rate, true);\n    }\n\n    /**\n     * Default implementation of the move logic. When no move rate is provided and also no default move rate is set, the\n     * server will move as fast as possible, so it is set to min/max directly. Else the step logic is applied and the\n     * level is increased or decreased by the step size every second. The method uses {@link setLevel} to set the level\n     * and handle the on/off state if the method is called by a *WithOnOff command.\n     *\n     * @param moveMode Mode (Up/Down) of the move action\n     * @param rate Rate of the move action, null if no rate is provided and the default should be used\n     * @param withOnOff true if the method is called by a *WithOnOff command\n     * @param options Options for the command\n     * @protected\n     */\n    protected moveLogic(\n        moveMode: LevelControl.MoveMode,\n        rate: number | null,\n        withOnOff: boolean,\n        options: TypeFromPartialBitSchema<typeof LevelControl.Options> = {},\n    ) {\n        const effectiveRate = rate ?? this.state.defaultMoveRate ?? null;\n        if (!this.state.managedTransitionTimeHandling || effectiveRate === null || effectiveRate === 0) {\n            // If null rate is requested and also no default rate is set, we should move as fast as possible, so we set\n            // to min/max value directly. If rate 0 is requested no change on level should be done.\n            const level =\n                effectiveRate === 0\n                    ? this.currentLevel\n                    : moveMode === LevelControl.MoveMode.Up\n                      ? this.maxLevel\n                      : this.minLevel;\n            this.setRemainingTime(0);\n            return this.setLevel(level, withOnOff, options);\n        }\n        return this.#initiateTransition(\n            effectiveRate * (moveMode === LevelControl.MoveMode.Up ? 1 : -1),\n            withOnOff,\n            undefined,\n            options,\n        );\n    }\n\n    /**\n     * Default implementation notes:\n     * After the options checks it uses the {@link stepLogic} method to set the level.\n     * If you want to implement own logic just override {@link stepLogic} with is also used for {@link stepWithOnOff}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set to currentlevel +/- stepSize directly. Else the step logic is applied and the level is\n     * increased or decreased by the step size every transition time interval.\n     */\n    override step({ stepMode, stepSize, transitionTime, optionsMask, optionsOverride }: LevelControl.StepRequest) {\n        const effectiveOptions = this.#calculateEffectiveOptions(optionsMask, optionsOverride);\n        if (!this.#optionsAllowExecution(effectiveOptions)) {\n            return;\n        }\n        return this.stepLogic(stepMode, stepSize, transitionTime, false, effectiveOptions);\n    }\n\n    /**\n     * Default implementation notes:\n     * This implementation uses the {@link stepLogic} method to set the level.\n     * If you want to implement own logic just override {@link stepLogic} with is also used for {@link step}.\n     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as\n     * possible, so we set to min/max directly. Else the step logic is applied and the level is increased or decreased\n     * by the step size every transition time interval.\n     */\n    override stepWithOnOff({ stepMode, stepSize, transitionTime }: LevelControl.StepRequest) {\n        return this.stepLogic(stepMode, stepSize, transitionTime, true);\n    }\n\n    /**\n     * Default implementation of the step logic. When no transition time is provided, the server will move as fast as\n     * possible, so it is set to min/max directly. Else the level is increased or decreased by the step size every\n     * second. The method uses {@link setLevel} to set the level and handle the on/off state if the method is called\n     * by a *WithOnOff command. The remaining time is updated with every step.\n     *\n     * @param stepMode Mode (Up/Down) of the step action\n     * @param stepSize Size of the step action\n     * @param transitionTime Time of the step action in 10th of a second\n     * @param withOnOff true if the method is called by a *WithOnOff command\n     * @param options Options for the command\n     * @protected\n     */\n    protected stepLogic(\n        stepMode: LevelControl.StepMode,\n        stepSize: number,\n        transitionTime: number | null,\n        withOnOff: boolean,\n        options: TypeFromPartialBitSchema<typeof LevelControl.Options> = {},\n    ) {\n        const targetLevel = cropValueRange(\n            stepMode === LevelControl.StepMode.Up ? this.currentLevel + stepSize : this.currentLevel - stepSize,\n            this.minLevel,\n            this.maxLevel,\n        );\n\n        if (!this.state.managedTransitionTimeHandling || transitionTime === null || transitionTime === 0) {\n            // If null/0 transitionTime is requested we should move as fast as possible, so we set to min/max value directly\n            this.setRemainingTime(0);\n            return this.setLevel(targetLevel, withOnOff, options);\n        }\n\n        const effectiveRate =\n            Math.ceil((stepSize / transitionTime) * 10) * (stepMode === LevelControl.StepMode.Up ? 1 : -1);\n\n        return this.#initiateTransition(effectiveRate, withOnOff, targetLevel, options);\n    }\n\n    override stop({ optionsMask, optionsOverride }: LevelControl.StopRequest) {\n        const effectiveOptions = this.#calculateEffectiveOptions(optionsMask, optionsOverride);\n        if (!this.#optionsAllowExecution(effectiveOptions)) {\n            return;\n        }\n\n        return this.stopLogic(effectiveOptions);\n    }\n\n    override stopWithOnOff() {\n        return this.stopLogic();\n    }\n\n    /**\n     * Default implementation of the stop logic. This stops any level transitions currently appening and sets the\n     * remaining time to 0.\n     *\n     * @protected\n     */\n    protected stopLogic(_options: TypeFromPartialBitSchema<typeof LevelControl.Options> = {}): MaybePromise<void> {\n        this.internal.transitionIntervalTimer?.stop();\n        this.setRemainingTime(0);\n    }\n\n    /**\n     * Method to set the remaining time attribute when Lighting feature is enabled.\n     *\n     * @param remainingTime Remaining time in 1/10th of a second\n     * @protected\n     */\n    protected setRemainingTime(remainingTime: number) {\n        if (!this.features.lighting) {\n            return;\n        }\n        this.state.remainingTime = remainingTime;\n    }\n\n    /**\n     * Default implementation of the logic to set the level including the handing of the on/off state when one of the\n     * *WithOnOff commands is called. This implementation checks if the level is at the minLevel and the device is on,\n     * it will turn off the device. If the level is above the minLevel and the device is off, it will turn on the device.\n     *\n     * @param level Level which is set by the command\n     * @param withOnOff true if the method is called by a *WithOnOff command\n     * @param options Options for the command\n     * @protected\n     */\n    protected setLevel(\n        level: number,\n        withOnOff: boolean,\n        options: TypeFromPartialBitSchema<typeof LevelControl.Options> = {},\n    ): MaybePromise<void> {\n        const onOffServer =\n            this.features.onOff && withOnOff && this.agent.has(OnOffServer) ? this.agent.get(OnOffServer) : undefined;\n\n        if (onOffServer !== undefined && level === this.minLevel && onOffServer.state.onOff) {\n            const offPromise = onOffServer.off();\n            return MaybePromise.then(offPromise, () => {\n                this.state.currentLevel = level;\n            });\n        }\n\n        this.state.currentLevel = level;\n\n        let colorSyncResult;\n        // Sync color temperature with level if the feature is enabled and the option is set\n        if (this.features.lighting && options.coupleColorTempToLevel && this.agent.has(ColorControlServer)) {\n            colorSyncResult = this.agent.get(ColorControlServer).syncColorTemperatureWithLevel(level);\n        }\n\n        if (onOffServer !== undefined && level > this.minLevel && !onOffServer.state.onOff) {\n            return MaybePromise.then(colorSyncResult, () => onOffServer.on());\n        } else {\n            return colorSyncResult;\n        }\n    }\n\n    #calculateEffectiveOptions(\n        optionsMask: TypeFromPartialBitSchema<typeof LevelControl.Options>,\n        optionsOverride: TypeFromPartialBitSchema<typeof LevelControl.Options>,\n    ): TypeFromPartialBitSchema<typeof LevelControl.Options> {\n        const options = this.state.options ?? {};\n        return {\n            executeIfOff: optionsMask.executeIfOff ? optionsOverride.executeIfOff : options.executeIfOff,\n            coupleColorTempToLevel: this.features.lighting\n                ? optionsMask.coupleColorTempToLevel\n                    ? optionsOverride.coupleColorTempToLevel\n                    : options.coupleColorTempToLevel\n                : false,\n        };\n    }\n\n    #optionsAllowExecution(options: TypeFromPartialBitSchema<typeof LevelControl.Options>) {\n        return (\n            options.executeIfOff ||\n            !this.features.onOff ||\n            !this.agent.has(OnOffServer) ||\n            this.agent.get(OnOffServer).state.onOff\n        );\n    }\n\n    #assertLevelValue(level: number) {\n        if (level < this.minLevel) {\n            throw new StatusResponseError(\n                `The level value of ${level} is invalid. It must be greater or equal to ${this.minLevel}.`,\n                StatusCode.ConstraintError,\n            );\n        }\n        if (level > this.maxLevel) {\n            throw new StatusResponseError(\n                `The level value of ${level} is invalid. It must be less or equal to ${this.maxLevel}.`,\n                StatusCode.ConstraintError,\n            );\n        }\n    }\n\n    /**\n     * This is the default implementation of the required interaction with the OnOff cluster on the same endpoint when\n     * the onOff feature is used.\n     * This implementation just sets the current level to the onLevel value when the device is turned on. Other fading\n     * up/down logic required by the {@link MatterSpecification.v12.Cluster} \u00A71.6.4.1.1 needs to be implemented in a\n     * specialized class if needed.\n     *\n     * @param onOff The new onOff state\n     * @protected\n     */\n    protected handleOnOffChange(onOff: boolean) {\n        if (!onOff || this.state.onLevel === null) {\n            return;\n        }\n        this.state.currentLevel = this.state.onLevel;\n    }\n\n    #initiateTransition(\n        stepSize: number,\n        withOnOff: boolean,\n        targetLevel?: number,\n        options: TypeFromPartialBitSchema<typeof LevelControl.Options> = {},\n    ) {\n        this.internal.transitionIntervalTimer?.stop();\n\n        this.internal.currentTransitionData = {\n            changeRate: stepSize,\n            withOnOff,\n            targetLevel,\n            options,\n        };\n        logger.debug(`Starting transition interval with changeRate: ${this.internal.currentTransitionData.changeRate}`);\n        this.internal.transitionIntervalTimer?.start();\n        // Re-Set the current level as start level for the step interval to handle OnOff state changes\n        return this.setLevel(this.currentLevel, withOnOff, options);\n    }\n\n    async #stepIntervalTick() {\n        if (this.internal.currentTransitionData === undefined || this.state.currentLevel === null) {\n            this.internal.transitionIntervalTimer?.stop();\n            return;\n        }\n        const { changeRate, withOnOff, targetLevel, options } = this.internal.currentTransitionData;\n        const newLevel = this.state.currentLevel + changeRate;\n        if (newLevel <= this.minLevel) {\n            logger.debug(`Stopping transition interval at minLevel: ${this.minLevel}.`);\n            await this.setLevel(this.minLevel, withOnOff, options);\n            this.internal.transitionIntervalTimer?.stop();\n            this.setRemainingTime(0);\n        } else if (newLevel >= this.maxLevel) {\n            logger.debug(`Stopping transition interval at maxLevel: ${this.maxLevel}.`);\n            await this.setLevel(this.maxLevel, withOnOff, options);\n            this.internal.transitionIntervalTimer?.stop();\n            this.setRemainingTime(0);\n        } else {\n            // Check if we reached the targetLevel if there is one\n            if (targetLevel !== undefined) {\n                if (changeRate > 0 && newLevel >= targetLevel) {\n                    logger.debug(`Stopping transition interval at targetLevel: ${targetLevel}.`);\n                    await this.setLevel(targetLevel, withOnOff, options);\n                    this.internal.transitionIntervalTimer?.stop();\n                    this.setRemainingTime(0);\n                    return;\n                } else if (changeRate < 0 && newLevel <= targetLevel) {\n                    logger.debug(`Stopping transition interval at targetLevel: ${targetLevel}.`);\n                    await this.setLevel(targetLevel, withOnOff, options);\n                    this.internal.transitionIntervalTimer?.stop();\n                    this.setRemainingTime(0);\n                    return;\n                }\n            }\n            logger.debug(`Setting new level in transition interval: ${newLevel}.`);\n            await this.setLevel(newLevel, withOnOff, options);\n\n            // There is no definition on how often the remaining time should be updated, so we update it with every step\n            if (changeRate > 0) {\n                this.setRemainingTime(\n                    Math.floor(Math.ceil(((targetLevel ?? this.maxLevel) - newLevel) / changeRate) * 10),\n                );\n            } else {\n                this.setRemainingTime(\n                    Math.floor(Math.ceil((newLevel - (targetLevel ?? this.minLevel)) / -changeRate) * 10),\n                );\n            }\n        }\n    }\n\n    #getBootReason() {\n        const rootEndpoint = this.endpoint.ownerOfType(RootEndpoint);\n        if (rootEndpoint !== undefined && rootEndpoint.behaviors.has(GeneralDiagnosticsBehavior)) {\n            return rootEndpoint.stateOf(GeneralDiagnosticsBehavior).bootReason;\n        }\n    }\n\n    override async [Symbol.asyncDispose]() {\n        this.internal.transitionIntervalTimer?.stop();\n        await super[Symbol.asyncDispose]?.();\n    }\n}\n\nexport namespace LevelControlServerLogic {\n    export class Internal {\n        /** Timer for the managed transition */\n        transitionIntervalTimer?: Timer;\n\n        /** Structure to store the data of the current managed transition */\n        currentTransitionData?: {\n            changeRate: number;\n            withOnOff: boolean;\n            targetLevel?: number;\n            options?: TypeFromPartialBitSchema<typeof LevelControl.Options>;\n        };\n    }\n\n    export class State extends LevelControlLogicBase.State {\n        /**\n         * The default implementation always set the target level immediately and so ignores all transition times\n         * requested or configured.\n         * Set this to true to manage transition times by changing the level value step wise every second. This is in\n         * most cases not the best way because hardware supporting levels usually have ways to specify the change rate\n         * or target value and transition time.\n         */\n        managedTransitionTimeHandling = false;\n    }\n\n    export declare const ExtensionInterface: {\n        moveToLevelLogic(level: number, transitionTime: number | null, withOnOff: boolean): MaybePromise<void>;\n        moveLogic(moveMode: LevelControl.MoveMode, rate: number | null, withOnOff: boolean): MaybePromise<void>;\n        stepLogic(\n            stepMode: LevelControl.StepMode,\n            stepSize: number,\n            transitionTime: number | null,\n            withOnOff: boolean,\n        ): MaybePromise<void>;\n        stopLogic(): MaybePromise<void>;\n        setLevel(level: number, withOnOff: boolean): MaybePromise<void>;\n        setRemainingTime(remainingTime: number): void;\n        handleOnOffChange(onOff: boolean): void;\n    };\n}\n\n// We had turned on some more features to provide da default implementation, but export the cluster with default\n// Features again.\nexport class LevelControlServer extends LevelControlServerLogic.with(LevelControl.Feature.OnOff) {}\n"],
  "mappings": "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",
  "names": ["LevelControlServerLogic"]
}
