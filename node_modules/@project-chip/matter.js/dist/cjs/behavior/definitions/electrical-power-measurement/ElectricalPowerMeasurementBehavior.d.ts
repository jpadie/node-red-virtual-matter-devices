/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { ElectricalPowerMeasurement } from "../../../cluster/definitions/ElectricalPowerMeasurementCluster.js";
import { ClusterBehavior } from "../../cluster/ClusterBehavior.js";
import { ClusterType } from "../../../cluster/ClusterType.js";
/**
 * ElectricalPowerMeasurementBehavior is the base class for objects that support interaction with {@link
 * ElectricalPowerMeasurement.Cluster}.
 *
 * ElectricalPowerMeasurement.Cluster requires you to enable one or more optional features. You can do so using {@link
 * ElectricalPowerMeasurementBehavior.with}.
 */
export declare const ElectricalPowerMeasurementBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 144;
    readonly name: "ElectricalPowerMeasurement";
    readonly revision: 1;
    readonly features: {
        readonly directCurrent: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly alternatingCurrent: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly polyphasePower: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly harmonics: import("../../../schema/BitmapSchema.js").BitFlag;
        readonly powerQuality: import("../../../schema/BitmapSchema.js").BitFlag;
    };
    readonly attributes: {
        readonly powerMode: import("../../../cluster/Cluster.js").Attribute<ElectricalPowerMeasurement.PowerMode, any>;
        readonly numberOfMeasurementTypes: import("../../../cluster/Cluster.js").FixedAttribute<number, any>;
        readonly accuracy: import("../../../cluster/Cluster.js").FixedAttribute<import("../../../tlv/TlvObject.js").TypeFromFields<{
            measurementType: import("../../../tlv/TlvObject.js").FieldType<import("../../../cluster/export.js").MeasurementType>;
            measured: import("../../../tlv/TlvObject.js").FieldType<boolean>;
            minMeasuredValue: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
            maxMeasuredValue: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
            accuracyRanges: import("../../../tlv/TlvObject.js").FieldType<import("../../../tlv/TlvObject.js").TypeFromFields<{
                rangeMin: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
                rangeMax: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
                percentMax: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                percentMin: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                percentTypical: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                fixedMax: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
                fixedMin: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
                fixedTypical: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
            }>[]>;
        }>[], any>;
        readonly ranges: import("../../../cluster/Cluster.js").OptionalAttribute<import("../../../tlv/TlvObject.js").TypeFromFields<{
            measurementType: import("../../../tlv/TlvObject.js").FieldType<import("../../../cluster/export.js").MeasurementType>;
            min: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
            max: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
            startTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
            endTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
            minTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
            maxTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
            startSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
            endSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
            minSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
            maxSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
        }>[], any>;
        readonly voltage: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
        readonly activeCurrent: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
        readonly activePower: import("../../../cluster/Cluster.js").Attribute<number | bigint | null, any>;
    };
    readonly events: {
        readonly measurementPeriodRanges: import("../../../cluster/Cluster.js").OptionalEvent<import("../../../tlv/TlvObject.js").TypeFromFields<{
            ranges: import("../../../tlv/TlvObject.js").FieldType<import("../../../tlv/TlvObject.js").TypeFromFields<{
                measurementType: import("../../../tlv/TlvObject.js").FieldType<import("../../../cluster/export.js").MeasurementType>;
                min: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
                max: import("../../../tlv/TlvObject.js").FieldType<number | bigint>;
                startTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                endTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                minTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                maxTimestamp: import("../../../tlv/TlvObject.js").OptionalFieldType<number>;
                startSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
                endSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
                minSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
                maxSystime: import("../../../tlv/TlvObject.js").OptionalFieldType<number | bigint>;
            }>[]>;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly alternatingCurrent: true;
        };
        readonly component: {
            readonly attributes: {
                readonly reactiveCurrent: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly apparentCurrent: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly reactivePower: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly apparentPower: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly rmsVoltage: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly rmsCurrent: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly rmsPower: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly frequency: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
                readonly powerFactor: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly harmonics: true;
        };
        readonly component: {
            readonly attributes: {
                readonly harmonicCurrents: import("../../../cluster/Cluster.js").Attribute<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    order: import("../../../tlv/TlvObject.js").FieldType<number>;
                    measurement: import("../../../tlv/TlvObject.js").FieldType<number | bigint | null>;
                }>[] | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly powerQuality: true;
        };
        readonly component: {
            readonly attributes: {
                readonly harmonicPhases: import("../../../cluster/Cluster.js").Attribute<import("../../../tlv/TlvObject.js").TypeFromFields<{
                    order: import("../../../tlv/TlvObject.js").FieldType<number>;
                    measurement: import("../../../tlv/TlvObject.js").FieldType<number | bigint | null>;
                }>[] | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly polyphasePower: true;
        };
        readonly component: {
            readonly attributes: {
                readonly neutralCurrent: import("../../../cluster/Cluster.js").OptionalAttribute<number | bigint | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly polyphasePower: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly harmonics: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly powerQuality: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly directCurrent: false;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }];
}>, typeof ClusterBehavior, {
    components: never[];
}>;
type ElectricalPowerMeasurementBehaviorType = InstanceType<typeof ElectricalPowerMeasurementBehavior>;
export interface ElectricalPowerMeasurementBehavior extends ElectricalPowerMeasurementBehaviorType {
}
type StateType = InstanceType<typeof ElectricalPowerMeasurementBehavior.State>;
export declare namespace ElectricalPowerMeasurementBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=ElectricalPowerMeasurementBehavior.d.ts.map