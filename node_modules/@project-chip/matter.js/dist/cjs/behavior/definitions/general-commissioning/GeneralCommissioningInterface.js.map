{
  "version": 3,
  "sources": ["../../../../../src/behavior/definitions/general-commissioning/GeneralCommissioningInterface.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MaybePromise } from \"../../../util/Promises.js\";\nimport { GeneralCommissioning } from \"../../../cluster/definitions/GeneralCommissioningCluster.js\";\n\nexport namespace GeneralCommissioningInterface {\n    export interface Base {\n        /**\n         * Success or failure of this command shall be communicated by the ArmFailSafeResponse command, unless some\n         * data model validations caused a failure status code to be issued during the processing of the command.\n         *\n         * If the fail-safe timer is not currently armed, the commissioning window is open, and the command was\n         * received over a CASE session, the command shall leave the current fail-safe state unchanged and immediately\n         * respond with an ArmFailSafeResponse containing an ErrorCode value of BusyWithOtherAdmin. This is done to\n         * allow commissioners, which use PASE connections, the opportunity to use the failsafe during the relatively\n         * short commissioning window.\n         *\n         * Otherwise, the command shall arm or re-arm the \"fail-safe timer\" with an expiry time set for a duration of\n         * ExpiryLengthSeconds, or disarm it, depending on the situation:\n         *\n         *   \u2022 If ExpiryLengthSeconds is 0 and the fail-safe timer was already armed and the accessing fabric matches\n         *     the Fabric currently associated with the fail-safe context, then the fail-safe timer\n         *\n         * shall be immediately expired (see further below for side-effects of expiration).\n         *\n         *   \u2022 If ExpiryLengthSeconds is 0 and the fail-safe timer was not armed, then this command invocation shall\n         *     lead to a success response with no side-effects against the fail-safe context.\n         *\n         *   \u2022 If ExpiryLengthSeconds is non-zero and the fail-safe timer was not currently armed, then the fail-safe\n         *     timer shall be armed for that duration.\n         *\n         *   \u2022 If ExpiryLengthSeconds is non-zero and the fail-safe timer was currently armed, and the accessing Fabric\n         *     matches the fail-safe context\u2019s associated Fabric, then the fail-safe timer shall be re- armed to expire\n         *     in ExpiryLengthSeconds.\n         *\n         *   \u2022 Otherwise, the command shall leave the current fail-safe state unchanged and immediately respond with\n         *     ArmFailSafeResponse containing an ErrorCode value of BusyWithOtherAdmin, indicating a likely conflict\n         *     between commissioners.\n         *\n         * The value of the Breadcrumb field shall be written to the Breadcrumb Attribute on successful execution of\n         * the command.\n         *\n         * If the receiver restarts unexpectedly (e.g., power interruption, software crash, or other reset) the\n         * receiver shall behave as if the fail-safe timer expired and perform the sequence of clean-up steps listed\n         * below.\n         *\n         * On successful execution of the command, the ErrorCode field of the ArmFailSafeResponse shall be set to OK.\n         *\n         * ### Fail Safe Context\n         *\n         * When first arming the fail-safe timer, a 'Fail Safe Context' shall be created on the receiver, to track the\n         * following state information while the fail-safe is armed:\n         *\n         *   \u2022 The fail-safe timer duration.\n         *\n         *   \u2022 The state of all Network Commissioning Networks attribute configurations, to allow recovery of\n         *     connectivity after Fail-Safe expiry.\n         *\n         *   \u2022 Whether an AddNOC command or UpdateNOC command has taken place.\n         *\n         *   \u2022 A Fabric Index for the fabric-scoping of the context, starting at the accessing fabric index for the\n         *     ArmFailSafe command, and updated with the Fabric Index associated with an AddNOC command or an UpdateNOC\n         *     command being invoked successfully during the ongoing Fail-Safe timer period.\n         *\n         *   \u2022 The operational credentials associated with any Fabric whose configuration is affected by the UpdateNOC\n         *     command.\n         *\n         *   \u2022 Optionally: the previous state of non-fabric-scoped data that is mutated during the fail-safe period.\n         *\n         * Note the following to assist in understanding the above state-keeping, which summarizes other normative\n         * requirements in the respective sections:\n         *\n         *   \u2022 The AddNOC command can only be invoked once per contiguous non-expiring fail-safe timer period, and only\n         *     if no UpdateNOC command was previously processed within the same fail-safe timer period.\n         *\n         *   \u2022 The UpdateNOC command can only be invoked once per contiguous non-expiring fail-safe timer period, can\n         *     only be invoked over a CASE session, and only if no AddNOC command was previously processed in the same\n         *     fail-safe timer period.\n         *\n         * On creation of the Fail Safe Context a second timer shall be created to expire at\n         * MaxCumulativeFailsafeSeconds as specified in BasicCommissioningInfo. This Cumulative Fail Safe Context timer\n         * (CFSC timer) serves to limit the lifetime of any particular Fail Safe Context; it shall NOT be extended or\n         * modified on subsequent invocations of ArmFailSafe associated with this Fail Safe Context. Upon expiry of the\n         * CFSC timer, the receiver shall execute cleanup behavior equivalent to that of fail-safe timer expiration as\n         * detailed in Section 11.10.6.2.2, \u201CBehavior on expiry of Fail-Safe timer\u201D. Termination of the session prior\n         * to the expiration of that timer for any reason (including a successful end of commissioning or an expiry of\n         * a fail-safe timer) shall also delete the CFSC timer.\n         *\n         * ### Behavior on expiry of Fail-Safe timer\n         *\n         * If the fail-safe timer expires before the CommissioningComplete command is successfully invoked, the\n         * following sequence of clean-up steps shall be executed, in order, by the receiver:\n         *\n         *   1. Terminate any open PASE secure session by clearing any associated Secure Session Context at the Server.\n         *\n         *   2. Revoke the temporary administrative privileges granted to any open PASE session (see Section 6.6.2.8,\n         *       \u201CBootstrapping of the Access Control Cluster\u201D) at the Server.\n         *\n         *   3. If an AddNOC or UpdateNOC command has been successfully invoked, terminate all CASE sessions associated\n         *       with the Fabric whose Fabric Index is recorded in the Fail-Safe context (see Section 11.10.6.2,\n         *       \u201CArmFailSafe Command\u201D) by clearing any associated Secure Session Context at the Server.\n         *\n         *   4. Reset the configuration of all Network Commissioning Networks attribute to their state prior to the\n         *       Fail-Safe being armed.\n         *\n         *   5. If an UpdateNOC command had been successfully invoked, revert the state of operational key pair, NOC\n         *       and ICAC for that Fabric to the state prior to the Fail-Safe timer being armed, for the Fabric Index\n         *       that was the subject of the UpdateNOC command.\n         *\n         *   6. If an AddNOC command had been successfully invoked, achieve the equivalent effect of invoking the\n         *       RemoveFabric command against the Fabric Index stored in the Fail-Safe Context for the Fabric Index\n         *       that was the subject of the AddNOC command. This shall remove all associations to that Fabric\n         *       including all fabric-scoped data, and may possibly factory-reset the device depending on current\n         *       device state. This shall only apply to Fabrics added during the fail-safe period as the result of the\n         *       AddNOC command.\n         *\n         *   7. If the CSRRequest command had been successfully invoked, but no AddNOC or UpdateNOC command had been\n         *       successfully invoked, then the new operational key pair temporarily generated for the purposes of NOC\n         *       addition or update (see Node Operational CSR Procedure) shall be removed as it is no longer needed.\n         *\n         *   8. Remove any RCACs added by the AddTrustedRootCertificate command that are not currently referenced by\n         *       any entry in the Fabrics attribute.\n         *\n         *   9. Reset the Breadcrumb attribute to zero.\n         *\n         *   10. Optionally: if no factory-reset resulted from the previous steps, it is recommended that the\n         *\n         * Node rollback the state of all non fabric-scoped data present in the Fail-Safe context.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.10.6.2\n         */\n        armFailSafe(request: GeneralCommissioning.ArmFailSafeRequest): MaybePromise<GeneralCommissioning.ArmFailSafeResponse>;\n\n        /**\n         * This shall add or update the regulatory configuration in the RegulatoryConfig Attribute to the value\n         * provided in the NewRegulatoryConfig field.\n         *\n         * Success or failure of this command shall be communicated by the SetRegulatoryConfigResponse command, unless\n         * some data model validations caused a failure status code to be issued during the processing of the command.\n         *\n         * The CountryCode field shall conforms to ISO 3166-1 alpha-2 and shall be used to set the Location attribute\n         * reflected by the Basic Information Cluster.\n         *\n         * If the server limits some of the values (e.g. locked to a particular country, with no regulatory data for\n         * others), then setting regulatory information outside a valid country or location shall still set the\n         * Location attribute reflected by the Basic Information Cluster configuration, but the\n         * SetRegulatoryConfigResponse replied shall have the ErrorCode field set to ValueOutsideRange error.\n         *\n         * If the LocationCapability attribute is not Indoor/Outdoor and the NewRegulatoryConfig value received does\n         * not match either the Indoor or Outdoor fixed value in LocationCapability, then the\n         * SetRegulatoryConfigResponse replied shall have the ErrorCode field set to ValueOutsideRange error and the\n         * RegulatoryConfig attribute and associated internal radio configuration shall remain unchanged.\n         *\n         * If the LocationCapability attribute is set to Indoor/Outdoor, then the RegulatoryConfig attribute shall be\n         * set to match the NewRegulatoryConfig field.\n         *\n         * On successful execution of the command, the ErrorCode field of the SetRegulatoryConfigResponse shall be set\n         * to OK.\n         *\n         * The Breadcrumb field shall be used to atomically set the Breadcrumb attribute on success of this command,\n         * when SetRegulatoryConfigResponse has the ErrorCode field set to OK. If the command fails, the Breadcrumb\n         * attribute shall be left unchanged.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.10.6.4\n         */\n        setRegulatoryConfig(request: GeneralCommissioning.SetRegulatoryConfigRequest): MaybePromise<GeneralCommissioning.SetRegulatoryConfigResponse>;\n\n        /**\n         * This command has no data.\n         *\n         * Success or failure of this command shall be communicated by the CommissioningCompleteResponse command,\n         * unless some data model validations caused a failure status code to be issued during the processing of the\n         * command.\n         *\n         * This command signals the Server that the Commissioner or Administrator has successfully completed all steps\n         * needed during the Fail-Safe period, such as commissioning (see Section 5.5, \u201CCommissioning Flows\u201D) or other\n         * Administrator operations requiring usage of the Fail Safe timer. It ensures that the Server is configured in\n         * a state such that it still has all necessary elements to be fully operable within a Fabric, such as ACL\n         * entries (see Access Control Cluster) and operational credentials (see Section 6.4, \u201CNode Operational\n         * Credentials Specification\u201D), and that the Node is reach\n         *\n         * able using CASE (see Section 4.14.2, \u201CCertificate Authenticated Session Establishment (CASE)\u201D) over an\n         * operational network.\n         *\n         * An ErrorCode of NoFailSafe shall be responded to the invoker if the CommissioningComplete command was\n         * received when no Fail-Safe context exists.\n         *\n         * This command is fabric-scoped, so cannot be issued over a session that does not have an associated fabric,\n         * i.e. over PASE session prior to an AddNOC command. In addition, this command is only permitted over CASE and\n         * must be issued by a node associated with the ongoing Fail-Safe context. An ErrorCode of\n         * InvalidAuthentication shall be responded to the invoker if the CommissioningComplete command was received\n         * outside a CASE session (e.g., over Group messaging, or PASE session after AddNOC), or if the accessing\n         * fabric is not the one associated with the ongoing Fail-Safe context.\n         *\n         * This command shall only result in success with an ErrorCode value of OK in the CommissioningCompleteResponse\n         * if received over a CASE session and the accessing fabric index matches the Fabric Index associated with the\n         * current Fail-Safe context. In other words:\n         *\n         *   \u2022 If no AddNOC command had been successfully invoked, the CommissioningComplete command must originate\n         *     from the Fabric that initiated the Fail-Safe context.\n         *\n         *   \u2022 After an AddNOC command has been successfully invoked, the CommissioningComplete command must originate\n         *     from the Fabric which was joined through the execution of that command, which updated the Fail-Safe\n         *     context\u2019s Fabric Index.\n         *\n         * On successful execution of the CommissioningComplete command, where the CommissioningCompleteResponse has an\n         * ErrorCode of OK, the following actions shall be undertaken on the Server:\n         *\n         *   1. The Fail-Safe timer associated with the current Fail-Safe context shall be disarmed.\n         *\n         *   2. The commissioning window at the Server shall be closed.\n         *\n         *   3. Any temporary administrative privileges automatically granted to any open PASE session shall be revoked\n         *      (see Section 6.6.2.8, \u201CBootstrapping of the Access Control Cluster\u201D).\n         *\n         *   4. The Secure Session Context of any PASE session still established at the Server shall be cleared.\n         *\n         *   5. The Breadcrumb attribute shall be reset to zero.\n         *\n         * After receipt of a CommissioningCompleteResponse with an ErrorCode value of OK, a client cannot expect any\n         * previously established PASE session to still be usable, due to the server having cleared such sessions.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 11.10.6.6\n         */\n        commissioningComplete(): MaybePromise<GeneralCommissioning.CommissioningCompleteResponse>;\n    }\n}\n\nexport type GeneralCommissioningInterface = { components: [{ flags: {}, methods: GeneralCommissioningInterface.Base }] };\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
