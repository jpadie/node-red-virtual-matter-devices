"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AdministratorCommissioningServer_exports = {};
__export(AdministratorCommissioningServer_exports, {
  AdministratorCommissioningServer: () => AdministratorCommissioningServer
});
module.exports = __toCommonJS(AdministratorCommissioningServer_exports);
var import_Cluster = require("../../../cluster/Cluster.js");
var import_AdministratorCommissioningCluster = require("../../../cluster/definitions/AdministratorCommissioningCluster.js");
var import_FailsafeContext = require("../../../common/FailsafeContext.js");
var import_MatterError = require("../../../common/MatterError.js");
var import_Logger = require("../../../log/Logger.js");
var import_StatusCode = require("../../../protocol/interaction/StatusCode.js");
var import_PaseServer = require("../../../session/pase/PaseServer.js");
var import_Time = require("../../../time/Time.js");
var import_TlvNumber = require("../../../tlv/TlvNumber.js");
var import_TlvObject = require("../../../tlv/TlvObject.js");
var import_TlvString = require("../../../tlv/TlvString.js");
var import_NetworkServer = require("../../system/network/NetworkServer.js");
var import_AdministratorCommissioningBehavior = require("./AdministratorCommissioningBehavior.js");
var import_AdministratorCommissioningConstants = require("./AdministratorCommissioningConstants.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import_AdministratorCommissioningCluster.AdministratorCommissioning.Cluster.commands = {
  ...import_AdministratorCommissioningCluster.AdministratorCommissioning.Cluster.commands,
  openCommissioningWindow: (0, import_Cluster.Command)(
    0,
    (0, import_TlvObject.TlvObject)({
      commissioningTimeout: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
      pakePasscodeVerifier: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvByteString),
      discriminator: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16.bound({ max: 4095 })),
      iterations: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt32),
      salt: (0, import_TlvObject.TlvField)(4, import_TlvString.TlvByteString)
    }),
    0,
    import_Cluster.TlvNoResponse,
    {
      invokeAcl: import_Cluster.AccessLevel.Administer,
      timed: true
    }
  )
};
const logger = import_Logger.Logger.get("AdministratorCommissioningServer");
class AdministratorCommissioningServer extends import_AdministratorCommissioningBehavior.AdministratorCommissioningBehavior {
  /**
   * This method opens an Enhanced Commissioning Window (A dynamic passcode is used which was provided by the caller).
   */
  async openCommissioningWindow({
    pakePasscodeVerifier,
    discriminator,
    iterations,
    salt,
    commissioningTimeout
  }) {
    if (pakePasscodeVerifier.length !== import_AdministratorCommissioningConstants.PAKE_PASSCODE_VERIFIER_LENGTH) {
      throw new import_StatusCode.StatusResponseError(
        "PAKE Passcode verifier length is invalid.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.PakeParameterError
      );
    }
    if (iterations < 1e3 || iterations > 1e5) {
      throw new import_StatusCode.StatusResponseError(
        "PAKE iterations invalid.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.PakeParameterError
      );
    }
    if (salt.length < 16 || salt.length > 32) {
      throw new import_StatusCode.StatusResponseError(
        "PAKE salt has invalid length.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.PakeParameterError
      );
    }
    const device = this.session?.context;
    this.#assertCommissioningWindowRequirements(commissioningTimeout, device);
    this.#initializeCommissioningWindow(
      commissioningTimeout,
      import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen
    );
    await device.allowEnhancedCommissioning(
      discriminator,
      import_PaseServer.PaseServer.fromVerificationValue(pakePasscodeVerifier, { iterations, salt }),
      this.callback(this.#endCommissioning)
    );
  }
  /** This method opens a Basic Commissioning Window. The default passcode is used. */
  async openBasicCommissioningWindow({
    commissioningTimeout
  }) {
    const device = this.session.context;
    this.#assertCommissioningWindowRequirements(commissioningTimeout, device);
    this.#initializeCommissioningWindow(
      commissioningTimeout,
      import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen
    );
    await device.allowBasicCommissioning(this.callback(this.#endCommissioning));
  }
  /** This method is used to revoke a commissioning window. */
  async revokeCommissioning() {
    if (this.internal.commissioningWindowTimeout === void 0) {
      throw new import_StatusCode.StatusResponseError(
        "No commissioning window is opened that could be revoked.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.WindowNotOpen
      );
    }
    logger.debug("Revoking commissioning window.");
    await this.#closeCommissioningWindow();
    if (this.endpoint.env.has(import_FailsafeContext.FailsafeContext)) {
      const failsafeContext = this.endpoint.env.get(import_FailsafeContext.FailsafeContext);
      if (failsafeContext) {
        await failsafeContext.close();
      }
    }
  }
  /**
   * Called whenever a Commissioning/Announcement Window is opened by this cluster. This method starts the timer and
   * adjusts the needed attributes.
   */
  #initializeCommissioningWindow(commissioningTimeout, windowStatus) {
    if (this.internal.commissioningWindowTimeout !== void 0) {
      throw new import_MatterError.InternalError("Commissioning window already initialized.");
    }
    logger.debug(
      `Commissioning window timer started for ${commissioningTimeout} seconds for ${this.context.session?.name}.`
    );
    this.internal.commissioningWindowTimeout = import_Time.Time.getTimer(
      "Commissioning timeout",
      commissioningTimeout * 1e3,
      this.callback(this.#commissioningTimeout)
    ).start();
    const adminFabric = this.session.associatedFabric;
    this.state.windowStatus = windowStatus;
    this.state.adminFabricIndex = adminFabric.fabricIndex;
    this.state.adminVendorId = adminFabric.rootVendorId;
    const removeCallback = this.callback(this.#fabricRemovedCallback);
    this.internal.stopMonitoringFabricForRemoval = () => {
      adminFabric.deleteRemoveCallback(removeCallback);
    };
    this.session.associatedFabric.addRemoveCallback(removeCallback);
  }
  /**
   * This method validates if a commissioning window can be opened and throws various exceptions in case of failures.
   */
  #assertCommissioningWindowRequirements(commissioningTimeout, device) {
    if (this.internal.commissioningWindowTimeout !== void 0) {
      throw new import_StatusCode.StatusResponseError(
        "A commissioning window is already opened.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.Busy
      );
    }
    if (commissioningTimeout > import_AdministratorCommissioningConstants.MAXIMUM_COMMISSIONING_TIMEOUT_S) {
      throw new import_StatusCode.StatusResponseError(
        `Commissioning timeout must not exceed ${import_AdministratorCommissioningConstants.MAXIMUM_COMMISSIONING_TIMEOUT_S} seconds.`,
        import_StatusCode.StatusCode.InvalidCommand
      );
    }
    if (commissioningTimeout < import_AdministratorCommissioningConstants.MINIMUM_COMMISSIONING_TIMEOUT_S) {
      throw new import_StatusCode.StatusResponseError(
        `Commissioning timeout must not be lower then ${import_AdministratorCommissioningConstants.MINIMUM_COMMISSIONING_TIMEOUT_S} seconds.`,
        import_StatusCode.StatusCode.InvalidCommand
      );
    }
    if (device.isFailsafeArmed()) {
      throw new import_StatusCode.StatusResponseError(
        "Failsafe timer armed, assume commissioning in progress.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.Busy
      );
    }
  }
  /**
   * This method is used internally when the commissioning window timer expires or the commissioning was completed.
   */
  #endCommissioning() {
    logger.debug("End commissioning window.");
    if (this.internal.commissioningWindowTimeout !== void 0) {
      this.internal.commissioningWindowTimeout.stop();
      this.internal.commissioningWindowTimeout = void 0;
    }
    this.internal.stopMonitoringFabricForRemoval?.();
    this.state.adminFabricIndex = null;
    this.state.windowStatus = import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
    this.state.adminFabricIndex = null;
    this.state.adminVendorId = null;
  }
  /**
   * Closes the commissioning window per the matter specification.
   */
  async #closeCommissioningWindow() {
    this.callback(this.#endCommissioning);
    await this.agent.get(import_NetworkServer.NetworkServer).endCommissioning();
  }
  /**
   * Close commissioning window on timeout when there's nobody to await the resulting promise
   * */
  #commissioningTimeout() {
    this.endpoint.env.runtime.add(this.#closeCommissioningWindow());
  }
  /**
   * Invoked when fabric is removed.
   */
  #fabricRemovedCallback() {
    this.state.adminFabricIndex = null;
    this.internal.stopMonitoringFabricForRemoval?.();
  }
  /**
   * Clean up resources and stop the timer when the behavior is destroyed.
   */
  [Symbol.asyncDispose]() {
    if (this.internal.commissioningWindowTimeout !== void 0) {
      this.internal.commissioningWindowTimeout.stop();
      this.internal.commissioningWindowTimeout = void 0;
    }
  }
}
((AdministratorCommissioningServer2) => {
  class Internal {
    commissioningWindowTimeout;
    stopMonitoringFabricForRemoval;
  }
  AdministratorCommissioningServer2.Internal = Internal;
  class State extends import_AdministratorCommissioningBehavior.AdministratorCommissioningBehavior.State {
    // Spec doesn't declare a default here so set manually
    windowStatus = import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
  }
  AdministratorCommissioningServer2.State = State;
})(AdministratorCommissioningServer || (AdministratorCommissioningServer = {}));
//# sourceMappingURL=AdministratorCommissioningServer.js.map
