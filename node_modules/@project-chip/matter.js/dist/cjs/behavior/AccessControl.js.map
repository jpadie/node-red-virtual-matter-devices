{
  "version": 3,
  "sources": ["../../../src/behavior/AccessControl.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AccessLevel } from \"../cluster/Cluster.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { FabricIndex } from \"../datatype/FabricIndex.js\";\nimport { SubjectId } from \"../datatype/SubjectId.js\";\nimport { Access } from \"../model/aspects/index.js\";\nimport { DataModelPath } from \"../model/definitions/DataModelPath.js\";\nimport { ElementTag } from \"../model/index.js\";\nimport { ValueModel } from \"../model/models/index.js\";\nimport { StatusCode } from \"../protocol/interaction/StatusCode.js\";\nimport { InvokeError, ReadError, SchemaImplementationError, WriteError } from \"./errors.js\";\nimport { Schema } from \"./supervision/Schema.js\";\n\nconst cache = new WeakMap<Schema, AccessControl>();\n\n/**\n * Enforces access control for a specific schema.\n */\nexport interface AccessControl {\n    /**\n     * Operational access control metadata.\n     */\n    limits: AccessControl.Limits;\n\n    /**\n     * Assert read is authorized.\n     */\n    authorizeRead: AccessControl.Assertion;\n\n    /**\n     * Determine if read is authorized.\n     */\n    mayRead: AccessControl.Verification;\n\n    /**\n     * Assert write is authorized.\n     */\n    authorizeWrite: AccessControl.Assertion;\n\n    /**\n     * Determine if write is authorized.\n     */\n    mayWrite: AccessControl.Verification;\n\n    /**\n     * Assert invoke is authorized.\n     */\n    authorizeInvoke: AccessControl.Assertion;\n\n    /**\n     * Determine if invoke is authorized.\n     */\n    mayInvoke: AccessControl.Verification;\n}\n\n/**\n * Obtain an enforcer for specific schema.\n *\n * This is central to security.  Implementation is explicit, all objects are involved are frozen and cache is stored as\n * module-private.\n *\n * Pure function; returned value is cached.\n */\nexport function AccessControl(schema: Schema) {\n    let enforcer = cache.get(schema);\n    if (enforcer === undefined) {\n        enforcer = enforcerFor(schema);\n    }\n    return enforcer;\n}\n\nexport namespace AccessControl {\n    /**\n     * Operational access control metadata for a schema.\n     */\n    export interface Limits {\n        readonly readable: boolean;\n        readonly readLevel: AccessLevel;\n\n        readonly writable: boolean;\n        readonly writeLevel: AccessLevel;\n\n        readonly fabricScoped: boolean;\n        readonly fabricSensitive: boolean;\n\n        readonly timed: boolean;\n    }\n\n    /**\n     * A function that asserts access control requirements are met.\n     */\n    export type Assertion = (session: Session, location: Location) => void;\n\n    /**\n     * A function that returns true if access control requirements are met.\n     */\n    export type Verification = (session: Session, location: Location) => boolean;\n\n    /**\n     * Metadata that varies with position in the data model.\n     */\n    export interface Location {\n        /**\n         * The diagnostic path to the location.\n         */\n        path: DataModelPath;\n\n        /**\n         * The owning behavior.\n         */\n        cluster?: ClusterId;\n\n        /**\n         * The fabric that owns the data subtree.  Undefined or {@link FabricIndex.NO_FABRIC} disables fabric\n         * enforcement.\n         */\n        owningFabric?: FabricIndex;\n\n        /**\n         * The access levels already retrieved for this location. With this subtree elements can access the same\n         * access levels without re-evaluating.\n         */\n        accessLevels?: AccessLevel[];\n    }\n\n    /**\n     * Authorization metadata that varies with session.\n     */\n    export interface Session {\n        /**\n         * Checks if the authorized client has a certain Access Privilege granted.\n         */\n        authorizedFor(desiredAccessLevel: AccessLevel, location?: Location): boolean;\n\n        /**\n         * The fabric of the authorized client.\n         */\n        readonly fabric?: FabricIndex;\n\n        /**\n         * The authenticated {@link SubjectId} for online sessions.\n         */\n        readonly subject?: SubjectId;\n\n        /**\n         * If this is true, fabric-scoped lists are filtered to the accessing\n         * fabric.\n         */\n        readonly fabricFiltered?: boolean;\n\n        /**\n         * If this is true a timed transaction is in effect.\n         */\n        readonly timed?: boolean;\n\n        /**\n         * If this is true then data access levels are not enforced.  Datatypes and command-related access controls are\n         * active.\n         */\n        readonly command?: boolean;\n\n        /**\n         * If this is true then access levels are not enforced and all values are read/write.  Datatypes are still\n         * enforced.\n         *\n         * Tracks \"offline\" rather than \"online\" because this makes the safer mode (full enforcement) the default.\n         */\n        offline?: boolean;\n    }\n}\n\nObject.freeze(AccessControl);\n\nfunction enforcerFor(schema: Schema): AccessControl {\n    if (schema.tag === ElementTag.Command) {\n        return commandEnforcerFor(schema);\n    }\n    return dataEnforcerFor(schema);\n}\n\nfunction dataEnforcerFor(schema: Schema): AccessControl {\n    const limits = limitsFor(schema);\n\n    let mayRead: AccessControl.Verification = (session, location) => {\n        if (session.offline || session.command) {\n            return true;\n        }\n\n        return session.authorizedFor(limits.readLevel, location);\n    };\n\n    let mayWrite: AccessControl.Verification = (session, location) => {\n        if (session.offline || session.command) {\n            return true;\n        }\n\n        return session.authorizedFor(limits.writeLevel, location);\n    };\n\n    let authorizeRead: AccessControl.Assertion = (session, location) => {\n        if (session.offline || session.command) {\n            return;\n        }\n\n        if (session.authorizedFor(limits.readLevel, location)) {\n            return;\n        }\n\n        throw new ReadError(location, \"Permission denied\", StatusCode.UnsupportedAccess);\n    };\n\n    let authorizeWrite: AccessControl.Assertion = (session, location) => {\n        if (session.offline || session.command) {\n            return;\n        }\n\n        if (session.authorizedFor(limits.writeLevel, location)) {\n            return;\n        }\n\n        throw new WriteError(location, \"Permission denied\", StatusCode.UnsupportedAccess);\n    };\n\n    if (limits.timed) {\n        const wrappedAuthorizeWrite = authorizeWrite;\n        const wrappedMayWrite = mayWrite;\n\n        authorizeWrite = (session, location) => {\n            if (!session.offline && !session.timed) {\n                throw new WriteError(\n                    location,\n                    \"Permission denied because interaction is not timed\",\n                    StatusCode.NeedsTimedInteraction,\n                );\n            }\n            wrappedAuthorizeWrite?.(session, location);\n        };\n\n        mayWrite = (session, location) => {\n            if (!session.offline && !session.timed) {\n                return false;\n            }\n\n            return wrappedMayWrite(session, location);\n        };\n    }\n\n    if (limits.fabricSensitive) {\n        const wrappedAuthorizeRead = authorizeRead;\n        const wrappedMayRead = mayRead;\n        const wrappedAuthorizeWrite = authorizeWrite;\n        const wrappedMayWrite = mayWrite;\n\n        authorizeRead = (session, location) => {\n            if (session.offline || session.command) {\n                return;\n            }\n\n            if (session.fabricFiltered) {\n                if (session.fabric === undefined) {\n                    throw new ReadError(\n                        location,\n                        \"Permission denied: No accessing fabric\",\n                        StatusCode.UnsupportedAccess,\n                    );\n                }\n\n                if (location?.owningFabric && location.owningFabric !== session.fabric) {\n                    throw new ReadError(\n                        location,\n                        \"Permission denied: Owning/accessing fabric mismatch\",\n                        StatusCode.UnsupportedAccess,\n                    );\n                }\n            }\n\n            wrappedAuthorizeRead(session, location);\n        };\n\n        mayRead = (session, location) => {\n            if (session.offline || session.command) {\n                return true;\n            }\n\n            if (session.fabric === undefined) {\n                return false;\n            }\n\n            if (location?.owningFabric && location.owningFabric !== session.fabric) {\n                return false;\n            }\n\n            return wrappedMayRead(session, location);\n        };\n\n        authorizeWrite = (session, location) => {\n            if (session.offline || session.command) {\n                return;\n            }\n\n            if (session.fabric === undefined) {\n                throw new WriteError(location, \"Permission denied: No accessing fabric\", StatusCode.UnsupportedAccess);\n            }\n\n            if (location?.owningFabric && location.owningFabric !== session.fabric) {\n                throw new WriteError(location, \"Permission denied: Owning/accessing fabric mismatch\");\n            }\n\n            wrappedAuthorizeWrite(session, location);\n        };\n\n        mayWrite = (session, location) => {\n            if (session.offline || session.command) {\n                return true;\n            }\n\n            if (session.fabric === undefined) {\n                return false;\n            }\n\n            if (location?.owningFabric && location.owningFabric !== session.fabric) {\n                return false;\n            }\n\n            return wrappedMayWrite(session, location);\n        };\n    }\n\n    if (!limits.readable) {\n        authorizeRead = (session, location) => {\n            if (session.offline || session.command) {\n                return;\n            }\n\n            throw new ReadError(location, \"Permission defined: Value is write-only\");\n        };\n\n        mayRead = session => {\n            return !!session.offline || !!session.command;\n        };\n    }\n\n    if (!limits.writable) {\n        authorizeWrite = (session, location) => {\n            if (session.offline || session.command) {\n                return;\n            }\n            throw new WriteError(location, \"Permission denied: Value is read-only\");\n        };\n\n        mayWrite = session => {\n            return !!session.offline || !!session.command;\n        };\n    }\n\n    return Object.freeze({\n        limits,\n        authorizeRead,\n        mayRead,\n        authorizeWrite,\n        mayWrite,\n\n        authorizeInvoke(_session: AccessControl.Session, location: AccessControl.Location) {\n            throw new SchemaImplementationError(location, \"Permission denied: Invoke request but non-command schema\");\n        },\n\n        mayInvoke() {\n            return false;\n        },\n    } satisfies AccessControl);\n}\n\nfunction commandEnforcerFor(schema: Schema): AccessControl {\n    const limits = limitsFor(schema);\n    const timed = schema.effectiveAccess.timed;\n    const fabric = schema.effectiveAccess.fabric;\n\n    return {\n        limits,\n\n        authorizeRead(_session, location) {\n            throw new SchemaImplementationError(location, \"Permission denied: Read request but command schema\");\n        },\n\n        mayRead() {\n            return false;\n        },\n\n        authorizeWrite(_session, location) {\n            throw new SchemaImplementationError(location, \"Permission denied: Write request but command schema\");\n        },\n\n        mayWrite() {\n            return false;\n        },\n\n        authorizeInvoke(session, location) {\n            if (session.offline) {\n                return;\n            }\n\n            if (!session.command) {\n                throw new InvokeError(location, \"Invoke attempt without command context\");\n            }\n\n            if (timed && !session.timed) {\n                throw new InvokeError(\n                    location,\n                    \"Invoke attempt without required timed context\",\n                    StatusCode.TimedRequestMismatch,\n                );\n            }\n\n            if (fabric && session.fabric === undefined) {\n                throw new WriteError(location, \"Permission denied: No accessing fabric\", StatusCode.UnsupportedAccess);\n            }\n\n            if (session.authorizedFor(limits.writeLevel, location)) {\n                return;\n            }\n\n            throw new InvokeError(location, \"Permission denied\", StatusCode.UnsupportedAccess);\n        },\n\n        mayInvoke(session, location) {\n            if (session.offline) {\n                return true;\n            }\n\n            if (!session.command) {\n                return false;\n            }\n\n            if (timed && !session.timed) {\n                return false;\n            }\n\n            if (fabric && session.fabric === undefined) {\n                return false;\n            }\n\n            return session.authorizedFor(limits.writeLevel, location);\n        },\n    };\n}\n\nfunction limitsFor(schema: Schema) {\n    const access = schema.effectiveAccess;\n    const quality = schema instanceof ValueModel ? schema.effectiveQuality : undefined;\n\n    // Special handling for fixed values - we treat any property owned by a fixed value as also read-only\n    let fixed = quality?.fixed;\n    for (let s = schema.parent; !fixed && s instanceof ValueModel; s = s.parent) {\n        if (s.effectiveQuality.fixed) {\n            fixed = true;\n        }\n    }\n\n    const limits: AccessControl.Limits = Object.freeze({\n        readable: access.readable,\n        writable: access.writable && !fixed,\n        fabricScoped: access.fabric === Access.Fabric.Scoped || access.fabric === Access.Fabric.Sensitive,\n        fabricSensitive: access.fabric === Access.Fabric.Sensitive,\n        timed: access.timed === true,\n\n        // Official Matter defaults are View for read and Operate for write. However, the schema's effective access\n        // should already have these defaults.  Here we just adopt minimum needed rights as a safe fallback access level.\n        readLevel: access.readPriv === undefined ? AccessLevel.View : Access.PrivilegeLevel[access.readPriv],\n        writeLevel: access.writePriv === undefined ? AccessLevel.Operate : Access.PrivilegeLevel[access.writePriv],\n    });\n\n    return limits;\n}\n"],
  "mappings": "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",
  "names": []
}
