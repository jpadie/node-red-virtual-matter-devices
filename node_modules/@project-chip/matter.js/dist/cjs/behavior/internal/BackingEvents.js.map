{
  "version": 3,
  "sources": ["../../../../src/behavior/internal/BackingEvents.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type { Endpoint } from \"../../endpoint/Endpoint.js\";\nimport { GeneratedClass } from \"../../util/GeneratedClass.js\";\nimport { EventEmitter, Observable, ObservableProxy } from \"../../util/Observable.js\";\nimport { BehaviorBacking } from \"./BehaviorBacking.js\";\n\ntype Implementation = new (target: EventEmitter) => EventEmitter;\n\nconst EventCache = new WeakMap<new (...args: unknown[]) => unknown, Implementation>();\n\n/**\n * Generates a BehaviorBacking.events implementation.\n *\n * The actual {@link EventEmitter} for the behavior is owned by the Endpoint.  For the behavior backing we create a\n * separate EventEmitter that proxies to the one owned by the Endpoint.\n *\n * We do this because while the API for behavior.events vs endpoint.events.behaviorId is identical, the lifecycle of\n * observers is different.  Observers registered on the behavior deregister whenever the backing closes, but observers\n * registered on the endpoint remain registered for the lifetime of the {@link Endpoint}.\n */\nexport function BackingEvents(backing: BehaviorBacking): EventEmitter {\n    const target = backing.endpoint.eventsOf(backing.type);\n\n    const constructor = target.constructor as new (...args: unknown[]) => unknown;\n\n    let Implementation = EventCache.get(constructor);\n\n    if (Implementation === undefined) {\n        Implementation = EventEmitterProxy(target);\n        EventCache.set(constructor, Implementation);\n    }\n\n    return new Implementation(target);\n}\n\nconst TARGET = Symbol(\"target\");\n\n/**\n * Generates a proxy {@link EventEmitter} for the given {@link EventEmitter} instance.\n *\n * This is a {@link Proxy} that automatically adds {@link ObservableProxy} properties for events on reference.\n */\nfunction EventEmitterProxy(instance: EventEmitter) {\n    const descriptors = {} as PropertyDescriptorMap;\n\n    for (const key in instance) {\n        const property = Symbol(key);\n\n        descriptors[key] = {\n            get(this: { [TARGET]: Record<string, Observable>; [property]: Observable }) {\n                let observable = this[property];\n                if (observable === undefined) {\n                    observable = this[property] = new ObservableProxy(this[TARGET][key]);\n                }\n                return observable;\n            },\n        };\n    }\n\n    return GeneratedClass({\n        name: `${instance.constructor.name}$Proxy`,\n        base: EventEmitter,\n        instanceDescriptors: descriptors,\n\n        initialize(this: { [TARGET]: EventEmitter }, target: EventEmitter) {\n            this[TARGET] = target;\n        },\n    }) as Implementation;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,4BAA+B;AAC/B,wBAA0D;AAR1D;AAAA;AAAA;AAAA;AAAA;AAaA,MAAM,aAAa,oBAAI,QAA6D;AAY7E,SAAS,cAAc,SAAwC;AAClE,QAAM,SAAS,QAAQ,SAAS,SAAS,QAAQ,IAAI;AAErD,QAAM,cAAc,OAAO;AAE3B,MAAI,iBAAiB,WAAW,IAAI,WAAW;AAE/C,MAAI,mBAAmB,QAAW;AAC9B,qBAAiB,kBAAkB,MAAM;AACzC,eAAW,IAAI,aAAa,cAAc;AAAA,EAC9C;AAEA,SAAO,IAAI,eAAe,MAAM;AACpC;AAEA,MAAM,SAAS,OAAO,QAAQ;AAO9B,SAAS,kBAAkB,UAAwB;AAC/C,QAAM,cAAc,CAAC;AAErB,aAAW,OAAO,UAAU;AACxB,UAAM,WAAW,OAAO,GAAG;AAE3B,gBAAY,GAAG,IAAI;AAAA,MACf,MAA4E;AACxE,YAAI,aAAa,KAAK,QAAQ;AAC9B,YAAI,eAAe,QAAW;AAC1B,uBAAa,KAAK,QAAQ,IAAI,IAAI,kCAAgB,KAAK,MAAM,EAAE,GAAG,CAAC;AAAA,QACvE;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAEA,aAAO,sCAAe;AAAA,IAClB,MAAM,GAAG,SAAS,YAAY,IAAI;AAAA,IAClC,MAAM;AAAA,IACN,qBAAqB;AAAA,IAErB,WAA6C,QAAsB;AAC/D,WAAK,MAAM,IAAI;AAAA,IACnB;AAAA,EACJ,CAAC;AACL;",
  "names": []
}
