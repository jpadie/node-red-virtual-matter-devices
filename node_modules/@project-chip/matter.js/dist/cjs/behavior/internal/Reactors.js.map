{
  "version": 3,
  "sources": ["../../../../src/behavior/internal/Reactors.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError, InternalError } from \"../../common/MatterError.js\";\nimport { Endpoint } from \"../../endpoint/Endpoint.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport type { Observable, Observer } from \"../../util/Observable.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { Reactor } from \"../Reactor.js\";\nimport { ActionContext } from \"../context/ActionContext.js\";\nimport { Contextual } from \"../context/Contextual.js\";\nimport { NodeActivity } from \"../context/NodeActivity.js\";\nimport { OfflineContext } from \"../context/server/OfflineContext.js\";\nimport { Resource } from \"../state/transaction/Resource.js\";\nimport type { BehaviorBacking } from \"./BehaviorBacking.js\";\n\nconst logger = Logger.get(\"Reactors\");\n\n/**\n * Used by BehaviorBacking to manage reactors and reactions.\n */\nexport class Reactors {\n    #backing: BehaviorBacking;\n    #backings = new Set<ReactorBacking<any, any>>();\n    #destructionComplete?: () => void;\n\n    constructor(backing: BehaviorBacking) {\n        this.#backing = backing;\n    }\n\n    get backing() {\n        return this.#backing;\n    }\n\n    async close() {\n        for (const reactor of this.#backings) {\n            await reactor.close();\n        }\n\n        if (this.#backings.size) {\n            return new Promise<void>(resolve => (this.#destructionComplete = resolve));\n        }\n    }\n\n    add<O extends Observable<any[], any>>(\n        observable: O,\n        reactor: Reactor<Parameters<O[\"emit\"]>, ReturnType<O[\"emit\"]>>,\n        options?: Reactor.Options,\n    ) {\n        // Deduplicate reactors\n        for (const backing of this.#backings) {\n            if (backing.is(observable, reactor)) {\n                return;\n            }\n        }\n\n        // Install\n        this.#backings.add(new ReactorBacking(this, observable, reactor, options ?? {}));\n    }\n\n    remove(backing: ReactorBacking<any, any>) {\n        this.#backings.delete(backing);\n        if (!this.#backings.size) {\n            this.#destructionComplete?.();\n        }\n    }\n\n    get resource() {\n        return this.#backing.datasource;\n    }\n}\n\n/**\n * Implementation of a single reactor.\n */\nclass ReactorBacking<T extends any[], R> {\n    #owner: Reactors;\n    #endpoint: Endpoint;\n    #listener: Observer<T, R>;\n    #reactor: Reactor<T, Awaited<R>>;\n    #observable: Observable<T, R>;\n    #offline?: boolean;\n    #closing?: boolean;\n    #lock?: Iterable<Resource>;\n    #deferred = Array<() => Promise<void>>();\n    #trampoline?: Promise<void>;\n    #resolveTrampoline?: () => void;\n    #nodeActivity?: NodeActivity;\n    #activity?: NodeActivity.Activity;\n\n    constructor(\n        reactors: Reactors,\n        observable: Observable<T, R>,\n        reactor: Reactor,\n        { offline, once, lock }: Reactor.Options,\n    ) {\n        this.#owner = reactors;\n        this.#endpoint = reactors.backing.endpoint;\n        this.#observable = observable;\n        this.#offline = offline;\n        this.#reactor = reactor;\n\n        if (lock) {\n            if (lock === true) {\n                lock = [reactors.resource];\n            } else if (!Array.isArray(lock)) {\n                lock = [lock];\n            }\n            this.#lock = lock as Resource[];\n        }\n\n        const reactorListener = ((...args: T) => {\n            let resolution: MaybePromise<unknown>;\n            let rejection: any;\n\n            let alreadyReacting = true;\n\n            try {\n                if (!this.#trampoline) {\n                    alreadyReacting = false;\n\n                    if (!this.#nodeActivity) {\n                        this.#nodeActivity = this.#endpoint.env.get(NodeActivity);\n                    }\n\n                    this.#activity = this.#nodeActivity.begin(this.toString());\n\n                    this.#trampoline = new Promise<void>(resolve => {\n                        this.#resolveTrampoline = () => {\n                            resolve();\n                            this.#trampoline = undefined;\n                        };\n                    });\n                }\n\n                if (once) {\n                    // In \"once\" mode we stop listening immediately and destroy ourselves once the reaction completes\n                    resolution = this.#reactOnce(args);\n                } else if (alreadyReacting) {\n                    // An ongoing reaction means we must wait our turn\n                    resolution = this.#reactDeferred(args);\n                } else {\n                    // No ongoing reaction so react immediately\n                    resolution = this.#react(args);\n                }\n            } catch (e) {\n                // An error here means a synchronous reactor that was not trampolined crashed.  We cannot just throw\n                // because there may have been additional reactions triggered by the synchronous reactor so we still\n                // need the trampoline\n                e = this.#augmentError(e);\n                if (this.#observable.isAsync) {\n                    // Async observable with sync reactor\n                    resolution = Promise.reject(e);\n                } else {\n                    // Sync observable with sync reactor\n                    rejection = e;\n                }\n            }\n\n            if (!alreadyReacting) {\n                if (MaybePromise.is(resolution)) {\n                    // Do not catch resolution errors, they are passed to the emitter.  Do initiate the trampoline once\n                    // they complete\n                    void Promise.resolve(resolution)\n                        .finally(this.#afterReaction.bind(this))\n\n                        // If resolution rejects, the error will pass through our finally and crash the process unless\n                        // we catch it here.  #afterReaction cannot throw (see comments there)\n                        .catch(() => {});\n                } else {\n                    this.#afterReaction();\n                }\n            }\n\n            if (rejection) {\n                throw rejection;\n            }\n\n            // Ensure resolution is a promise (or not) based on expectation of emitter\n            if (this.#observable.isAsync) {\n                // Async observable - convert to promise\n                resolution = Promise.resolve(resolution);\n            } else if (MaybePromise.is(resolution)) {\n                // Sync observable with async reactor - reactor cannot return a value to emitter\n                resolution.then(undefined, this.#unhandledError.bind(this));\n                resolution = undefined;\n            }\n\n            return resolution;\n        }) as Observer<T, R>;\n\n        observable.on((this.#listener = reactorListener));\n    }\n\n    is(observable: Observable<unknown[], unknown>, reactor: Reactor) {\n        return this.#observable === observable && this.#reactor === reactor && !this.#closing;\n    }\n\n    close() {\n        if (!this.#closing) {\n            this.#close();\n        }\n\n        return this.#trampoline;\n    }\n\n    toString() {\n        const reactorName = this.#reactor.name ? `.${this.#reactor.name}` : \"\";\n        return `reactor<${this.#owner.backing}${reactorName}>`;\n    }\n\n    #unhandledError(error: unknown) {\n        if (!(error instanceof Error)) {\n            error = new Error(`${error}`);\n        }\n        logger.error(\"Unhandled\", this.#augmentError(error));\n    }\n\n    #close() {\n        this.#observable.off(this.#listener);\n        this.#closing = true;\n        if (this.#trampoline) {\n            this.#trampoline = this.#trampoline.finally(() => this.#owner.remove(this));\n        } else {\n            this.#owner.remove(this);\n        }\n    }\n\n    /**\n     * Trampoline the next reaction or resolve the trampoline promise.\n     *\n     * Note - this method *cannot* throw because we invoke it within a finally that may be on a rejected promise.\n     * Errors on that promise must be caught by the emitter.  But the finally also creates a promise and *that* promise\n     * will throw if the original promise is rejected, which requires us to have a catch() on the finally promise or\n     * the promise will crash with an unhandled error.\n     */\n    #afterReaction() {\n        try {\n            if (this.#deferred.length) {\n                const next = this.#deferred.shift() as () => Promise<void>;\n\n                void next()\n                    .catch(e => {\n                        // Reactors should not throw because they have error handling.  So any error here is internal\n                        logger.error(\"Internal error invoking next reactor\", e);\n                    })\n                    .finally(this.#afterReaction.bind(this));\n\n                return;\n            }\n\n            this.#resolveTrampoline?.();\n            this.#activity?.[Symbol.dispose]();\n            this.#activity = undefined;\n        } catch (e) {\n            logger.error(\"Internal error after final reaction\", e);\n        }\n    }\n\n    /**\n     * Invoke a single reactor when no other reactor is active.\n     *\n     * If the reaction is asynchronous it is tracked via {@link #reactAsync}.\n     */\n    #react(args: T): MaybePromise<Awaited<R> | undefined> {\n        let context: undefined | ActionContext;\n        if (!this.#offline) {\n            context = Contextual.contextOf(args[args.length - 1]);\n        }\n\n        // If the emitter's context is available, execute in that\n        //\n        // TODO - if emitter doesn't await promise, things will probably go wrong so async reactors need to use the\n        // offline option.  Can probably enforce that with types but right now we just throw an error at runtime\n        if (context) {\n            const result = this.#reactWithContext(context, this.#owner.backing, args);\n\n            if (MaybePromise.is(result) && !this.#observable.isAsync) {\n                throw new ImplementationError(\n                    `${this} returned a Promise but the observable is synchronous; you must set the \"offline\" option so this reactor runs with a dedicated transaction`,\n                );\n            }\n\n            return result;\n        }\n\n        // Otherwise run in independent context and errors do not interfere with emitter\n        try {\n            let purpose = \"react\";\n            if (this.#reactor.name) {\n                purpose = `${purpose}<${this.#reactor.name}>`;\n            }\n\n            const reactor = (context: ActionContext) => {\n                return this.#reactWithContext(context, this.#owner.backing, args);\n            };\n\n            // We use OfflineContext directly rather than via this.#endpoint.act because act() is unavailable during\n            // construction and destruction\n            //\n            // Also, do not inject activity here.  No reason to have both the reactor and the context registered\n            let result: MaybePromise<Awaited<R> | undefined> = OfflineContext.act(this.toString(), undefined, reactor);\n\n            if (MaybePromise.is(result)) {\n                result = result.then(undefined, this.#unhandledError.bind(this)) as PromiseLike<undefined>;\n            }\n            return result;\n        } catch (e) {\n            this.#unhandledError(e);\n        }\n    }\n\n    /**\n     * Invoked by the listener when there are already ongoing reactions.\n     *\n     * Installs a trampoline function and returns a placeholder promise.  The trampolined functions are always async\n     * regardless of the emitter and listener because by necessity they do not act immediately.\n     */\n    #reactDeferred(args: T): MaybePromise<unknown> {\n        return new Promise((resolve, reject) => {\n            const deferredReaction = async () => {\n                try {\n                    const result = await this.#react(args);\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n\n            this.#deferred.push(deferredReaction);\n        });\n    }\n\n    /**\n     * React in \"once\" mode -- react then close.\n     */\n    #reactOnce(args: T): MaybePromise<R | undefined> {\n        this.#observable.off(this.#listener);\n\n        let isAsync = false;\n        try {\n            const result = this.#react(args);\n\n            // If reaction is async, wait until it completes to close\n            if (MaybePromise.is(result)) {\n                isAsync = true;\n\n                // Do not use this.close() here because it will result in cyclical promises since close() waits on the\n                // reaction.  this.#close() does not return a promise so is safe\n                return Promise.resolve(result).finally(() => this.#close()) as PromiseLike<undefined>;\n            }\n\n            return result;\n        } finally {\n            // If reaction is not async, close immediately\n            if (!isAsync) {\n                // Close should not be async\n                void this.close();\n            }\n        }\n    }\n\n    /**\n     * Invoked by #react once it obtains a context.\n     */\n    #reactWithContext(context: ActionContext, backing: BehaviorBacking, args: T): MaybePromise<Awaited<R> | undefined> {\n        if (this.#lock) {\n            return this.#lockThenReact(context, backing, args);\n        }\n\n        return this.#reactWithLocks(context, backing, args);\n    }\n\n    /**\n     * Grab locks if so configured before performing reaction.\n     */\n    async #lockThenReact(context: ActionContext, backing: BehaviorBacking, args: T): Promise<Awaited<R> | undefined> {\n        if (!this.#lock) {\n            throw new InternalError(\"No locks to acquire\");\n        }\n\n        await context.transaction.addResources(...this.#lock);\n        await context.transaction.begin();\n\n        for (const resource of context.transaction.resources) {\n            if (resource.lockedBy !== context.transaction) {\n                throw new InternalError(`Lock of ${resource} should be held by ${this} but is not`);\n            }\n        }\n\n        return await this.#reactWithLocks(context, backing, args);\n    }\n\n    /**\n     * Invoke the actual reactor.\n     */\n    #reactWithLocks(context: ActionContext, backing: BehaviorBacking, args: T): MaybePromise<Awaited<R> | undefined> {\n        const agent = context.agentFor(this.#endpoint);\n\n        // Do not use Agent.get because it will throw during initialization\n        const behavior = backing.createBehavior(agent, backing.type);\n\n        return this.#reactor.apply(behavior, args);\n    }\n\n    /**\n     * Detail the reactor in error messages for errors triggered during reaction.\n     */\n    #augmentError(cause: any) {\n        if (!(cause instanceof Error)) {\n            cause = new Error(cause.toString());\n        }\n\n        cause.message = `Error in ${this}: ${cause.message}`;\n\n        return cause;\n    }\n}\n"],
  "mappings": "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",
  "names": ["context"]
}
