{
  "version": 3,
  "sources": ["../../../../src/behavior/internal/ClusterServerBacking.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Attribute, Command, Event, TlvNoResponse } from \"../../cluster/Cluster.js\";\nimport {\n    AttributeServer,\n    createAttributeServer as ConstructAttributeServer,\n} from \"../../cluster/server/AttributeServer.js\";\nimport { ClusterServer } from \"../../cluster/server/ClusterServer.js\";\nimport { ClusterDatasource } from \"../../cluster/server/ClusterServerTypes.js\";\nimport { CommandServer } from \"../../cluster/server/CommandServer.js\";\nimport { EventServer } from \"../../cluster/server/EventServer.js\";\nimport { Message } from \"../../codec/MessageCodec.js\";\nimport { ImplementationError, InternalError } from \"../../common/MatterError.js\";\nimport type { EndpointServer } from \"../../endpoint/EndpointServer.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { CommandModel, ElementTag } from \"../../model/index.js\";\nimport { SecureSession } from \"../../session/SecureSession.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { camelize } from \"../../util/String.js\";\nimport { isObject } from \"../../util/Type.js\";\nimport { AccessControl } from \"../AccessControl.js\";\nimport { Behavior } from \"../Behavior.js\";\nimport type { ClusterBehavior } from \"../cluster/ClusterBehavior.js\";\nimport { ClusterEvents } from \"../cluster/ClusterEvents.js\";\nimport { GlobalAttributeState } from \"../cluster/ClusterState.js\";\nimport { ValidatedElements } from \"../cluster/ValidatedElements.js\";\nimport { Contextual } from \"../context/Contextual.js\";\nimport { Val } from \"../state/Val.js\";\nimport { StructManager } from \"../state/managed/values/StructManager.js\";\nimport { Status } from \"../state/transaction/Status.js\";\nimport { ServerBehaviorBacking } from \"./ServerBacking.js\";\n\nconst logger = Logger.get(\"Behavior\");\n\n/**\n * Backing for cluster behaviors on servers.\n *\n * TODO - refactor element server management after we remove the old API\n */\nexport class ClusterServerBacking extends ServerBehaviorBacking {\n    #server: EndpointServer;\n    #clusterServer?: ClusterServer;\n\n    get clusterServer() {\n        return this.#clusterServer;\n    }\n\n    get runtime() {\n        return this.#server.endpoint.env.runtime;\n    }\n\n    get server() {\n        return this.#server;\n    }\n\n    override get type() {\n        return super.type as ClusterBehavior.Type;\n    }\n\n    constructor(server: EndpointServer, type: ClusterBehavior.Type) {\n        super(server.endpoint, type);\n        this.#server = server;\n    }\n\n    protected override invokeInitializer(behavior: Behavior, options?: Behavior.Options) {\n        const { id, name, attributes, commands, events } = this.type.cluster;\n\n        if (!options) {\n            options = {};\n        }\n\n        const clusterServer = (this.#clusterServer = {\n            id,\n            name,\n            datasource: this.#createClusterDatasource(),\n            attributes: {},\n            commands: {},\n            events: {},\n        });\n\n        const result = super.invokeInitializer(behavior, options);\n\n        const createClusterServer = () => {\n            // Event list is optional because it is provisional so we must set the default value manually\n            (behavior.state as GlobalAttributeState).eventList = [];\n\n            // Validate elements and determine which are applicable\n            const elements = new ValidatedElements(this.type, behavior);\n            elements.report();\n\n            // Attribute servers.  Include global attributes as well as cluster attributes\n            this.#configureServers(\n                elements.attributes,\n                attributes,\n                clusterServer.attributes,\n                behavior,\n                [\"attributeList\"],\n                createAttributeServer,\n            );\n\n            // Command servers\n            this.#configureServers(\n                elements.commands,\n                commands,\n                clusterServer.commands,\n                behavior,\n                [\"acceptedCommandList\", \"generatedCommandList\"],\n                createCommandServer,\n            );\n\n            // Event servers\n            this.#configureServers(\n                elements.events,\n                events,\n                clusterServer.events,\n                behavior,\n                [\"eventList\"],\n                createEventServer,\n            );\n\n            // Install the cluster server into the EndpointServer\n            this.#server.addClusterServer(clusterServer);\n        };\n\n        if (MaybePromise.is(result)) {\n            return result.then(createClusterServer);\n        }\n\n        createClusterServer();\n    }\n\n    protected override get datasourceOptions() {\n        return {\n            ...super.datasourceOptions,\n            cluster: this.type.cluster.id,\n        };\n    }\n\n    /**\n     * Create the {@link ClusterDatasource} that adapts the Behavior API to the AttributeServer API.\n     */\n    #createClusterDatasource(): ClusterDatasource {\n        const eventHandler = this.eventHandler;\n        const datasource = this.datasource;\n\n        return {\n            get version() {\n                return datasource.version;\n            },\n\n            get eventHandler() {\n                return eventHandler;\n            },\n\n            // We handle change management ourselves\n            changed() {},\n\n            // We handle version management ourselves\n            increaseVersion() {\n                return datasource.version;\n            },\n        };\n    }\n\n    /**\n     * Configure the servers for a set of elements (attributes, commands or events).\n     */\n    #configureServers<T, S>(\n        names: Iterable<string>,\n        definitions: Record<string, T>,\n        servers: Record<string, S>,\n        behavior: Behavior,\n        attributeNames: [\"attributeList\"] | [\"acceptedCommandList\", \"generatedCommandList\"] | [\"eventList\"],\n        addServer: (\n            name: string,\n            definition: T,\n            backing: ClusterServerBacking,\n            behavior: Behavior,\n        ) => { ids: number[]; server: S },\n    ) {\n        const collectedIds = Array<Set<number>>();\n        attributeNames.forEach(() => collectedIds.push(new Set()));\n\n        // Create a server for each supported element and record the ID\n        for (const name of names) {\n            const definition = definitions[name];\n            const { ids, server } = addServer(name, definition, this, behavior);\n            ids.forEach((id, index) => collectedIds[index].add(id));\n            servers[name] = server;\n        }\n\n        // Set the global attribute detailing supported elements\n        attributeNames.forEach((attributeName, index) => {\n            (behavior.state as Record<string, number[]>)[attributeName] = [...collectedIds[index].values()];\n        });\n    }\n}\n\nfunction createAttributeServer(\n    name: string,\n    definition: Attribute<any, any>,\n    backing: ClusterServerBacking,\n    behavior: Behavior,\n) {\n    function getter(_session: any, _endpoint: any, _isFabricFiltered: any, message?: Message) {\n        if (!message) {\n            // If there is no message this is getLocal\n            return (backing.datasource.view as Val.Struct)[name];\n        }\n\n        const behavior = behaviorFor(backing, message);\n\n        behavior.context.activity?.frame(`read ${name}`);\n\n        const trace = behavior.context.trace;\n        if (trace) {\n            trace.path = backing.path.at(name);\n        }\n\n        logger.debug(\"Read\", Diagnostic.strong(`${backing}.state.${name}`), \"via\", behavior.context.transaction.via);\n\n        const state = behavior.state as Val.Struct;\n\n        StructManager.assertDirectReadAuthorized(state, name);\n\n        if (trace) {\n            trace.output = state[name];\n        }\n\n        return state[name];\n    }\n\n    function setter(value: any, _session: any, _endpoint: any, message?: Message) {\n        const behavior = behaviorFor(backing, message);\n\n        behavior.context.activity?.frame(`write ${name}`);\n\n        logger.info(\"Write\", Diagnostic.strong(`${backing}.state.${name}`), \"via\", behavior.context.transaction.via);\n\n        const trace = behavior.context.trace;\n        if (trace) {\n            trace.path = backing.path.at(name);\n            trace.input = value;\n        }\n\n        const state = behavior.state as Val.Struct;\n\n        state[name] = value;\n\n        // If the transaction is a write transaction, report that\n        // the attribute is updated\n        return behavior.context.transaction?.status === Status.Exclusive;\n    }\n\n    const server = ConstructAttributeServer(\n        backing.type.cluster,\n        definition,\n        name,\n        (behavior.state as Val.Struct)[name],\n        backing.clusterServer!.datasource!,\n        getter,\n        setter,\n    );\n\n    // Wire events (FixedAttributeServer is not an AttributeServer so we skip that)\n    if (server instanceof AttributeServer) {\n        const observable = (backing.events as any)[`${name}$Changed`] as ClusterEvents.AttributeObservable | undefined;\n        observable?.on((_value, _oldValue, context) => {\n            const session = context.session;\n            if (session instanceof SecureSession) {\n                server.updated(session);\n            } else {\n                server.updatedLocal();\n            }\n        });\n    }\n\n    server.assignToEndpoint(backing.server);\n\n    return {\n        ids: [definition.id],\n        server,\n    };\n}\n\nfunction createCommandServer(name: string, definition: Command<any, any, any>, backing: ClusterServerBacking) {\n    // TODO: Introduce nicer ways to get command incl caching and such, aka \"make api suck less\"\n    const schema = backing.type.schema?.member(camelize(name, true), [ElementTag.Command]) as CommandModel | undefined;\n    if (schema === undefined) {\n        throw new ImplementationError(`There is no metadata for command ${name}`);\n    }\n    const access = AccessControl(schema);\n\n    const handler = (request: unknown, _session: unknown, message: Message) => {\n        let requestDiagnostic: unknown;\n        if (isObject(request)) {\n            requestDiagnostic = Diagnostic.dict(request);\n        } else if (request !== undefined) {\n            requestDiagnostic = request;\n        } else {\n            requestDiagnostic = Diagnostic.weak(\"(no payload)\");\n        }\n\n        const behavior = behaviorFor(backing, message);\n\n        const path = backing.path.at(name);\n\n        const trace = behavior.context.trace;\n        if (trace) {\n            trace.path = backing.path.at(name);\n            trace.input = request;\n        }\n\n        logger.info(\"Invoke\", Diagnostic.strong(path.toString()), behavior.context.transaction.via, requestDiagnostic);\n\n        access.authorizeInvoke(behavior.context, {\n            path,\n            cluster: behavior.cluster.id,\n        });\n\n        let isAsync = false;\n        let activity: undefined | Disposable;\n        let result: unknown;\n        try {\n            activity = behavior.context?.activity?.frame(`invoke ${name}`);\n\n            result = (behavior as unknown as Record<string, (arg: unknown) => unknown>)[name](request);\n\n            if (MaybePromise.is(result)) {\n                isAsync = true;\n                result = Promise.resolve(result)\n                    .then(result => {\n                        if (trace) {\n                            trace.output = result;\n                        }\n                        return result;\n                    })\n                    .finally(() => activity?.[Symbol.dispose]());\n            } else if (trace) {\n                trace.output = result;\n            }\n        } finally {\n            if (!isAsync) {\n                activity?.[Symbol.dispose]();\n            }\n        }\n\n        return result;\n    };\n\n    const server = new CommandServer(\n        definition.requestId,\n        definition.responseId,\n        name,\n        definition.requestSchema,\n        definition.responseSchema,\n        definition.timed,\n        definition.invokeAcl,\n        handler,\n    );\n\n    // Eliminate redundant diagnostic messages\n    server.debug = () => {};\n\n    const ids = [definition.requestId];\n    if (definition.responseSchema !== TlvNoResponse) {\n        ids.push(definition.responseId);\n    }\n    return {\n        ids,\n        server,\n    };\n}\n\nfunction createEventServer(name: string, definition: Event<any, any>, backing: ClusterServerBacking) {\n    const observable = (backing.events as any)[name] as ClusterEvents.EventObservable;\n\n    const server = new EventServer(\n        definition.id,\n        backing.type.cluster.id,\n        name,\n        definition.schema,\n        definition.priority,\n        definition.readAcl,\n    );\n\n    observable?.on((payload, _context) => {\n        const maybePromise = server.triggerEvent(payload);\n        if (MaybePromise.is(maybePromise)) {\n            backing.runtime.add(maybePromise);\n        }\n    });\n\n    server.assignToEndpoint(backing.server);\n    const promise = server.bindToEventHandler(backing.eventHandler);\n    if (MaybePromise.is(promise)) {\n        // Current code structure means this should never happen.  Refactor after removal of old API will resolve this\n        throw new InternalError(\"Event handler binding returned a promise\");\n    }\n\n    return {\n        ids: [definition.id],\n        server,\n    };\n}\n\nfunction behaviorFor(backing: ClusterServerBacking, message: Message | undefined) {\n    const context = Contextual.contextOf(message);\n    if (!context) {\n        throw new InternalError(\"Message context not installed\");\n    }\n\n    const agent = context.agentFor(backing.endpoint);\n\n    return agent.get(backing.type);\n}\n"],
  "mappings": "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",
  "names": ["behavior", "ConstructAttributeServer", "result"]
}
