/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { IdentifyServer as BaseIdentifyServer } from "../../../behavior/definitions/identify/IdentifyServer.js";
import { MutableEndpoint } from "../../type/MutableEndpoint.js";
import { Identity } from "../../../util/Type.js";
/**
 * A Window Covering Controller is a device that controls an automatic window covering.
 *
 * @see {@link MatterSpecification.v13.Device} ยง 8.4
 */
export interface WindowCoveringControllerDevice extends Identity<typeof WindowCoveringControllerDeviceDefinition> {
}
export declare namespace WindowCoveringControllerRequirements {
    /**
     * The Identify cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link IdentifyServer} for convenience.
     */
    const IdentifyServer: typeof BaseIdentifyServer;
    /**
     * The WindowCovering cluster is required by the Matter specification.
     *
     * We provide this alias to the default implementation {@link WindowCoveringBehavior} for convenience.
     */
    const WindowCoveringBehavior: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
        readonly id: 258;
        readonly name: "WindowCovering";
        readonly revision: 5;
        readonly features: {
            readonly lift: import("../../../schema/BitmapSchema.js").BitFlag;
            readonly tilt: import("../../../schema/BitmapSchema.js").BitFlag;
            readonly positionAwareLift: import("../../../schema/BitmapSchema.js").BitFlag;
            readonly absolutePosition: import("../../../schema/BitmapSchema.js").BitFlag;
            readonly positionAwareTilt: import("../../../schema/BitmapSchema.js").BitFlag;
        };
        readonly attributes: {
            readonly type: import("../../../cluster/Cluster.js").FixedAttribute<import("../../../cluster/export.js").WindowCovering.WindowCoveringType, any>;
            readonly configStatus: import("../../../cluster/Cluster.js").Attribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                operational: import("../../../schema/BitmapSchema.js").BitFlag;
                onlineReserved: import("../../../schema/BitmapSchema.js").BitFlag;
                liftMovementReversed: import("../../../schema/BitmapSchema.js").BitFlag;
                liftPositionAware: import("../../../schema/BitmapSchema.js").BitFlag;
                tiltPositionAware: import("../../../schema/BitmapSchema.js").BitFlag;
                liftEncoderControlled: import("../../../schema/BitmapSchema.js").BitFlag;
                tiltEncoderControlled: import("../../../schema/BitmapSchema.js").BitFlag;
            }>, any>;
            readonly operationalStatus: import("../../../cluster/Cluster.js").Attribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                global: import("../../../schema/BitmapSchema.js").BitFieldEnum<import("../../../cluster/export.js").WindowCovering.MovementStatus>;
                lift: import("../../../schema/BitmapSchema.js").BitFieldEnum<import("../../../cluster/export.js").WindowCovering.MovementStatus>;
                tilt: import("../../../schema/BitmapSchema.js").BitFieldEnum<import("../../../cluster/export.js").WindowCovering.MovementStatus>;
            }>, any>;
            readonly endProductType: import("../../../cluster/Cluster.js").FixedAttribute<import("../../../cluster/export.js").WindowCovering.EndProductType, any>;
            readonly mode: import("../../../cluster/Cluster.js").WritableAttribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                motorDirectionReversed: import("../../../schema/BitmapSchema.js").BitFlag;
                calibrationMode: import("../../../schema/BitmapSchema.js").BitFlag;
                maintenanceMode: import("../../../schema/BitmapSchema.js").BitFlag;
                ledFeedback: import("../../../schema/BitmapSchema.js").BitFlag;
            }>, any>;
            readonly safetyStatus: import("../../../cluster/Cluster.js").OptionalAttribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                remoteLockout: import("../../../schema/BitmapSchema.js").BitFlag;
                tamperDetection: import("../../../schema/BitmapSchema.js").BitFlag;
                failedCommunication: import("../../../schema/BitmapSchema.js").BitFlag;
                positionFailure: import("../../../schema/BitmapSchema.js").BitFlag;
                thermalProtection: import("../../../schema/BitmapSchema.js").BitFlag;
                obstacleDetected: import("../../../schema/BitmapSchema.js").BitFlag;
                power: import("../../../schema/BitmapSchema.js").BitFlag;
                stopInput: import("../../../schema/BitmapSchema.js").BitFlag;
                motorJammed: import("../../../schema/BitmapSchema.js").BitFlag;
                hardwareFailure: import("../../../schema/BitmapSchema.js").BitFlag;
                manualOperation: import("../../../schema/BitmapSchema.js").BitFlag;
                protection: import("../../../schema/BitmapSchema.js").BitFlag;
            }>, any>;
        };
        readonly commands: {
            readonly upOrOpen: import("../../../cluster/Cluster.js").Command<void, void, any>;
            readonly downOrClose: import("../../../cluster/Cluster.js").Command<void, void, any>;
            readonly stopMotion: import("../../../cluster/Cluster.js").Command<void, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly lift: true;
                readonly positionAwareLift: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly physicalClosedLimitLift: import("../../../cluster/Cluster.js").OptionalFixedAttribute<number, any>;
                    readonly currentPositionLift: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                    readonly installedOpenLimitLift: import("../../../cluster/Cluster.js").Attribute<number, any>;
                    readonly installedClosedLimitLift: import("../../../cluster/Cluster.js").Attribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
                readonly positionAwareTilt: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly physicalClosedLimitTilt: import("../../../cluster/Cluster.js").OptionalFixedAttribute<number, any>;
                    readonly currentPositionTilt: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                    readonly installedOpenLimitTilt: import("../../../cluster/Cluster.js").Attribute<number, any>;
                    readonly installedClosedLimitTilt: import("../../../cluster/Cluster.js").Attribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly lift: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly numberOfActuationsLift: import("../../../cluster/Cluster.js").OptionalAttribute<number, any>;
                };
                readonly commands: {
                    readonly goToLiftPercentage: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                        liftPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly numberOfActuationsTilt: import("../../../cluster/Cluster.js").OptionalAttribute<number, any>;
                };
                readonly commands: {
                    readonly goToTiltPercentage: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                        tiltPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly lift: true;
                readonly positionAwareLift: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly currentPositionLiftPercentage: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                    readonly targetPositionLiftPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                    readonly currentPositionLiftPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                };
                readonly commands: {
                    readonly goToLiftPercentage: import("../../../cluster/Cluster.js").Command<import("../../../tlv/TlvObject.js").TypeFromFields<{
                        liftPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
                readonly positionAwareTilt: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly currentPositionTiltPercentage: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                    readonly targetPositionTiltPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                    readonly currentPositionTiltPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                };
                readonly commands: {
                    readonly goToTiltPercentage: import("../../../cluster/Cluster.js").Command<import("../../../tlv/TlvObject.js").TypeFromFields<{
                        tiltPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly lift: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly commands: {
                    readonly goToLiftValue: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                        liftValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly commands: {
                    readonly goToTiltValue: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                        tiltValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly positionAwareLift: true;
                readonly lift: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly positionAwareTilt: true;
                readonly tilt: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly lift: false;
                readonly tilt: false;
            };
            readonly component: false;
        }];
    }>, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/window-covering/WindowCoveringInterface.js").WindowCoveringInterface>, import("../../../behavior/definitions/window-covering/WindowCoveringInterface.js").WindowCoveringInterface>;
    /**
     * The Identify cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link IdentifyBehavior} for convenience.
     */
    const IdentifyBehavior: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").Identify.Cluster, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/identify/IdentifyInterface.js").IdentifyInterface>, import("../../../behavior/definitions/identify/IdentifyInterface.js").IdentifyInterface>;
    /**
     * The Groups cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link GroupsBehavior} for convenience.
     */
    const GroupsBehavior: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").Groups.Cluster, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/groups/GroupsInterface.js").GroupsInterface>, import("../../../behavior/definitions/groups/GroupsInterface.js").GroupsInterface>;
    /**
     * The ScenesManagement cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link ScenesManagementBehavior} for convenience.
     */
    const ScenesManagementBehavior: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").ScenesManagement.Cluster, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/scenes-management/ScenesManagementInterface.js").ScenesManagementInterface>, import("../../../behavior/definitions/scenes-management/ScenesManagementInterface.js").ScenesManagementInterface>;
    /**
     * An implementation for each server cluster supported by the endpoint per the Matter specification.
     */
    const server: {
        optional: {
            Identify: typeof BaseIdentifyServer;
        };
        mandatory: {};
    };
    /**
     * A definition for each client cluster supported by the endpoint per the Matter specification.
     */
    const client: {
        mandatory: {
            WindowCovering: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
                readonly id: 258;
                readonly name: "WindowCovering";
                readonly revision: 5;
                readonly features: {
                    readonly lift: import("../../../schema/BitmapSchema.js").BitFlag;
                    readonly tilt: import("../../../schema/BitmapSchema.js").BitFlag;
                    readonly positionAwareLift: import("../../../schema/BitmapSchema.js").BitFlag;
                    readonly absolutePosition: import("../../../schema/BitmapSchema.js").BitFlag;
                    readonly positionAwareTilt: import("../../../schema/BitmapSchema.js").BitFlag;
                };
                readonly attributes: {
                    readonly type: import("../../../cluster/Cluster.js").FixedAttribute<import("../../../cluster/export.js").WindowCovering.WindowCoveringType, any>;
                    readonly configStatus: import("../../../cluster/Cluster.js").Attribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                        operational: import("../../../schema/BitmapSchema.js").BitFlag;
                        onlineReserved: import("../../../schema/BitmapSchema.js").BitFlag;
                        liftMovementReversed: import("../../../schema/BitmapSchema.js").BitFlag;
                        liftPositionAware: import("../../../schema/BitmapSchema.js").BitFlag;
                        tiltPositionAware: import("../../../schema/BitmapSchema.js").BitFlag;
                        liftEncoderControlled: import("../../../schema/BitmapSchema.js").BitFlag;
                        tiltEncoderControlled: import("../../../schema/BitmapSchema.js").BitFlag;
                    }>, any>;
                    readonly operationalStatus: import("../../../cluster/Cluster.js").Attribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                        global: import("../../../schema/BitmapSchema.js").BitFieldEnum<import("../../../cluster/export.js").WindowCovering.MovementStatus>;
                        lift: import("../../../schema/BitmapSchema.js").BitFieldEnum<import("../../../cluster/export.js").WindowCovering.MovementStatus>;
                        tilt: import("../../../schema/BitmapSchema.js").BitFieldEnum<import("../../../cluster/export.js").WindowCovering.MovementStatus>;
                    }>, any>;
                    readonly endProductType: import("../../../cluster/Cluster.js").FixedAttribute<import("../../../cluster/export.js").WindowCovering.EndProductType, any>;
                    readonly mode: import("../../../cluster/Cluster.js").WritableAttribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                        motorDirectionReversed: import("../../../schema/BitmapSchema.js").BitFlag;
                        calibrationMode: import("../../../schema/BitmapSchema.js").BitFlag;
                        maintenanceMode: import("../../../schema/BitmapSchema.js").BitFlag;
                        ledFeedback: import("../../../schema/BitmapSchema.js").BitFlag;
                    }>, any>;
                    readonly safetyStatus: import("../../../cluster/Cluster.js").OptionalAttribute<import("../../../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                        remoteLockout: import("../../../schema/BitmapSchema.js").BitFlag;
                        tamperDetection: import("../../../schema/BitmapSchema.js").BitFlag;
                        failedCommunication: import("../../../schema/BitmapSchema.js").BitFlag;
                        positionFailure: import("../../../schema/BitmapSchema.js").BitFlag;
                        thermalProtection: import("../../../schema/BitmapSchema.js").BitFlag;
                        obstacleDetected: import("../../../schema/BitmapSchema.js").BitFlag;
                        power: import("../../../schema/BitmapSchema.js").BitFlag;
                        stopInput: import("../../../schema/BitmapSchema.js").BitFlag;
                        motorJammed: import("../../../schema/BitmapSchema.js").BitFlag;
                        hardwareFailure: import("../../../schema/BitmapSchema.js").BitFlag;
                        manualOperation: import("../../../schema/BitmapSchema.js").BitFlag;
                        protection: import("../../../schema/BitmapSchema.js").BitFlag;
                    }>, any>;
                };
                readonly commands: {
                    readonly upOrOpen: import("../../../cluster/Cluster.js").Command<void, void, any>;
                    readonly downOrClose: import("../../../cluster/Cluster.js").Command<void, void, any>;
                    readonly stopMotion: import("../../../cluster/Cluster.js").Command<void, void, any>;
                };
                readonly extensions: readonly [{
                    readonly flags: {
                        readonly lift: true;
                        readonly positionAwareLift: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly physicalClosedLimitLift: import("../../../cluster/Cluster.js").OptionalFixedAttribute<number, any>;
                            readonly currentPositionLift: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                            readonly installedOpenLimitLift: import("../../../cluster/Cluster.js").Attribute<number, any>;
                            readonly installedClosedLimitLift: import("../../../cluster/Cluster.js").Attribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                        readonly positionAwareTilt: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly physicalClosedLimitTilt: import("../../../cluster/Cluster.js").OptionalFixedAttribute<number, any>;
                            readonly currentPositionTilt: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                            readonly installedOpenLimitTilt: import("../../../cluster/Cluster.js").Attribute<number, any>;
                            readonly installedClosedLimitTilt: import("../../../cluster/Cluster.js").Attribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly lift: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly numberOfActuationsLift: import("../../../cluster/Cluster.js").OptionalAttribute<number, any>;
                        };
                        readonly commands: {
                            readonly goToLiftPercentage: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                                liftPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly numberOfActuationsTilt: import("../../../cluster/Cluster.js").OptionalAttribute<number, any>;
                        };
                        readonly commands: {
                            readonly goToTiltPercentage: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                                tiltPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly lift: true;
                        readonly positionAwareLift: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly currentPositionLiftPercentage: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                            readonly targetPositionLiftPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                            readonly currentPositionLiftPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                        };
                        readonly commands: {
                            readonly goToLiftPercentage: import("../../../cluster/Cluster.js").Command<import("../../../tlv/TlvObject.js").TypeFromFields<{
                                liftPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                        readonly positionAwareTilt: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly currentPositionTiltPercentage: import("../../../cluster/Cluster.js").OptionalAttribute<number | null, any>;
                            readonly targetPositionTiltPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                            readonly currentPositionTiltPercent100ths: import("../../../cluster/Cluster.js").Attribute<number | null, any>;
                        };
                        readonly commands: {
                            readonly goToTiltPercentage: import("../../../cluster/Cluster.js").Command<import("../../../tlv/TlvObject.js").TypeFromFields<{
                                tiltPercent100thsValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly lift: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly commands: {
                            readonly goToLiftValue: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                                liftValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly commands: {
                            readonly goToTiltValue: import("../../../cluster/Cluster.js").OptionalCommand<import("../../../tlv/TlvObject.js").TypeFromFields<{
                                tiltValue: import("../../../tlv/TlvObject.js").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly positionAwareLift: true;
                        readonly lift: false;
                    };
                    readonly component: false;
                }, {
                    readonly flags: {
                        readonly positionAwareTilt: true;
                        readonly tilt: false;
                    };
                    readonly component: false;
                }, {
                    readonly flags: {
                        readonly lift: false;
                        readonly tilt: false;
                    };
                    readonly component: false;
                }];
            }>, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/window-covering/WindowCoveringInterface.js").WindowCoveringInterface>, import("../../../behavior/definitions/window-covering/WindowCoveringInterface.js").WindowCoveringInterface>;
        };
        optional: {
            Identify: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").Identify.Cluster, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/identify/IdentifyInterface.js").IdentifyInterface>, import("../../../behavior/definitions/identify/IdentifyInterface.js").IdentifyInterface>;
            Groups: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").Groups.Cluster, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/groups/GroupsInterface.js").GroupsInterface>, import("../../../behavior/definitions/groups/GroupsInterface.js").GroupsInterface>;
            ScenesManagement: import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/export.js").ScenesManagement.Cluster, import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior.Type<import("../../../cluster/ClusterType.js").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../../../behavior/cluster/ClusterBehavior.js").ClusterBehavior, import("../../../behavior/definitions/scenes-management/ScenesManagementInterface.js").ScenesManagementInterface>, import("../../../behavior/definitions/scenes-management/ScenesManagementInterface.js").ScenesManagementInterface>;
        };
    };
}
export declare const WindowCoveringControllerDeviceDefinition: MutableEndpoint.With<import("../../type/EndpointType.js").EndpointType.For<{
    readonly name: "WindowCoveringController";
    readonly deviceType: 515;
    readonly deviceRevision: 3;
    readonly requirements: typeof WindowCoveringControllerRequirements;
    readonly behaviors: {};
}>, {}>;
export declare const WindowCoveringControllerDevice: WindowCoveringControllerDevice;
//# sourceMappingURL=WindowCoveringControllerDevice.d.ts.map