{
  "version": 3,
  "sources": ["../../../../src/endpoint/type/SemanticNamespace.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Semtag } from \"../../cluster/globals/Semtag.js\";\nimport { VendorId } from \"../../datatype/VendorId.js\";\n\n/**\n * A Matter \"semantic namespace\" is a discrete set of {@link Semtag} definitions.\n */\nexport type SemanticNamespace = Record<string, Semtag>;\n\n/**\n * Define a new semantic namespace.\n */\nexport function SemanticNamespace<const T extends SemanticNamespace.Definition>(definition: T) {\n    const result = {} as Record<string, Semtag>;\n\n    const { tags } = definition;\n    const namespaceId = definition.id;\n    const mfgCode = definition.mfgCode ? VendorId(definition.mfgCode) : null;\n\n    for (const key in tags) {\n        const { id: tag, label } = definition.tags[key];\n\n        result[key] = {\n            namespaceId,\n            mfgCode,\n            tag,\n            label,\n        };\n    }\n\n    return result as SemanticNamespace.Of<T>;\n}\n\nexport namespace SemanticNamespace {\n    export interface Definition {\n        id: number;\n        mfgCode?: number;\n        tags: {\n            [name: string]: { id: number; label: string };\n        };\n    }\n\n    export type Of<T extends Definition> = {\n        [name in keyof T[\"tags\"]]: Semtag;\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,sBAAyB;AAPzB;AAAA;AAAA;AAAA;AAAA;AAiBO,SAAS,kBAAgE,YAAe;AAC3F,QAAM,SAAS,CAAC;AAEhB,QAAM,EAAE,KAAK,IAAI;AACjB,QAAM,cAAc,WAAW;AAC/B,QAAM,UAAU,WAAW,cAAU,0BAAS,WAAW,OAAO,IAAI;AAEpE,aAAW,OAAO,MAAM;AACpB,UAAM,EAAE,IAAI,KAAK,MAAM,IAAI,WAAW,KAAK,GAAG;AAE9C,WAAO,GAAG,IAAI;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO;AACX;",
  "names": []
}
