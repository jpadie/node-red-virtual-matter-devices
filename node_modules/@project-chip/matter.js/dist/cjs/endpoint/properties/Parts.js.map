{
  "version": 3,
  "sources": ["../../../../src/endpoint/properties/Parts.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Lifecycle } from \"../../common/Lifecycle.js\";\nimport { ImplementationError } from \"../../common/MatterError.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { IdentityConflictError, IdentityService } from \"../../node/server/IdentityService.js\";\nimport { Construction } from \"../../util/Construction.js\";\nimport { BasicSet, MutableSet, ObservableSet } from \"../../util/Set.js\";\nimport { Agent } from \"../Agent.js\";\nimport { Endpoint } from \"../Endpoint.js\";\nimport { EndpointPartsError, PartNotFoundError } from \"../errors.js\";\nimport { EndpointType } from \"../type/EndpointType.js\";\nimport { EndpointLifecycle } from \"./EndpointLifecycle.js\";\n\nconst logger = Logger.get(\"Parts\");\n\n/**\n * Manages parent-child relationship between endpoints.\n *\n * You can manipulate child parts using {@link MutableSet} interface.\n *\n * Notifications of structural change bubble via {@link Endpoint.lifecycle.changed}.\n */\nexport class Parts implements MutableSet<Endpoint, Endpoint | Agent>, ObservableSet<Endpoint> {\n    #bubbleChange: (type: EndpointLifecycle.Change, endpoint: Endpoint) => void;\n    #children = new BasicSet<Endpoint>();\n    #endpoint: Endpoint;\n\n    constructor(endpoint: Endpoint) {\n        this.#endpoint = endpoint;\n        const lifecycle = this.#endpoint.lifecycle;\n        this.#bubbleChange = (type, endpoint) => lifecycle.bubble(type, endpoint);\n    }\n\n    add(child: Endpoint.Definition | Agent) {\n        const endpoint = this.#endpointFor(child);\n\n        // Setting endpoint.owner also invokes add() so make sure we don't recurse\n        if (this.has(endpoint)) {\n            return;\n        }\n\n        if (endpoint.lifecycle.hasId) {\n            this.assertIdAvailable(endpoint.id, endpoint);\n        }\n\n        // Insertion validation is only possible in a fully configured node. If we are not yet installed then an\n        // ancestor will handle validation when we installed\n        if (this.#endpoint.lifecycle.isReady) {\n            this.#validateInsertion(endpoint, endpoint);\n        }\n\n        this.#children.add(endpoint);\n        endpoint.owner = this.#endpoint;\n\n        endpoint.lifecycle.changed.on((type, endpoint) => this.#bubbleChange(type, endpoint));\n        endpoint.lifecycle.destroyed.once(() => {\n            this.delete(endpoint);\n        });\n\n        // If the part is already fully initialized we initialize the child now\n        if (this.#endpoint.lifecycle.isPartsReady) {\n            if (!endpoint.construction.isErrorHandled) {\n                endpoint.construction.onError(error => logger.error(`Error initializing ${this.#endpoint}:`, error));\n            }\n\n            endpoint.construction.start();\n        }\n\n        return endpoint;\n    }\n\n    delete(child: Endpoint | Agent) {\n        const endpoint = this.#endpointFor(child);\n\n        if (!this.#children.delete(this.#endpointFor(child))) {\n            return false;\n        }\n\n        const childLifeCycle = endpoint.lifecycle;\n        childLifeCycle.changed.off(this.#bubbleChange);\n\n        this.#children.delete(endpoint);\n\n        return true;\n    }\n\n    clear() {\n        this.#children.clear();\n    }\n\n    get(id: string) {\n        for (const child of this.#children) {\n            if (child.maybeId === id) {\n                return child;\n            }\n        }\n    }\n\n    require(id: string) {\n        const part = this.get(id);\n\n        if (part === undefined) {\n            throw new PartNotFoundError(`Endpoint ${this.#endpoint} has no part ${id}`);\n        }\n\n        return part;\n    }\n\n    #get(id: string) {\n        for (const child of this.#children) {\n            if (child.maybeId === id) {\n                return child;\n            }\n        }\n    }\n\n    has(identity: string | Endpoint | Agent) {\n        if (typeof identity === \"string\") {\n            for (const child of this.#children) {\n                if (child.maybeId === identity) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return this.#children.has(this.#endpointFor(identity));\n    }\n\n    indexOf(child: Endpoint | Agent) {\n        const endpoint = this.#endpointFor(child);\n        let index = 0;\n\n        for (const other of this.#children) {\n            if (endpoint === other) {\n                return index;\n            }\n            index++;\n        }\n\n        return -1;\n    }\n\n    get added() {\n        return this.#children.added;\n    }\n\n    get deleted() {\n        return this.#children.deleted;\n    }\n\n    get size() {\n        return this.#children.size;\n    }\n\n    [Symbol.iterator]() {\n        return this.#children[Symbol.iterator]();\n    }\n\n    /**\n     * Confirm availability of an ID amongst the endpoint's children.\n     */\n    assertIdAvailable(id: string, endpoint: Endpoint) {\n        const other = this.#get(id);\n        if (other && other !== endpoint) {\n            throw new IdentityConflictError(`${other} is already defined; endpoint IDs must be unique within parent`);\n        }\n    }\n\n    /**\n     * Initialize all uninitialized Parts.\n     *\n     * Invoked automatically by the owner after behaviors initialize.\n     */\n    initialize() {\n        // Sanity check\n        if (!this.#endpoint.lifecycle.isReady) {\n            throw new ImplementationError(`Cannot initialize parts because endpoint is not ready`);\n        }\n\n        // Our only purpose is to initialize child parts\n        const onPartsReady = () => this.#endpoint.lifecycle.change(EndpointLifecycle.Change.PartsReady);\n        if (!this.size) {\n            onPartsReady();\n            return;\n        }\n\n        // Initiate initialization of all parts\n        for (const endpoint of this) {\n            const isInactive = endpoint.construction.status === Lifecycle.Status.Inactive;\n            if (isInactive || endpoint.construction.status === Lifecycle.Status.Initializing) {\n                endpoint.construction.onError(error => {\n                    // We always log startup errors as an AggregateError could lead to some deeply nested, confusing\n                    // error hierarchies.  For essential endpoints we then throw EndpointPartsError for the owner\n                    // that lists the parts that crashed\n                    logger.error(`Error initializing ${endpoint}:`, error);\n                });\n\n                if (isInactive) {\n                    endpoint.construction.start();\n                }\n            }\n        }\n\n        // Wait for parts to initialize.  Throws if any essential parts crashed\n        const onPartsCrashed = (errored: Iterable<Endpoint>) => {\n            const essential = [...errored].filter(endpoint => endpoint.lifecycle.isEssential);\n            if (essential.length) {\n                return new EndpointPartsError(essential);\n            }\n        };\n        let promise = Construction.all(this, onPartsCrashed);\n\n        // Once parts are initialized we consider the endpoint \"tree ready\"\n        if (promise) {\n            promise = promise.then(onPartsReady);\n        } else {\n            onPartsReady();\n        }\n\n        return promise;\n    }\n\n    /**\n     * Soft-reset all parts.  Invoked automatically by the owner on reset.\n     */\n    async reset() {\n        for (const endpoint of this) {\n            await endpoint.reset();\n        }\n    }\n\n    /**\n     * Destroy all parts.  Invoked automatically by the owner on destroy.\n     */\n    async close() {\n        for (const endpoint of this) {\n            await endpoint.close();\n        }\n    }\n\n    #validateInsertion(forefather: Endpoint, endpoint: Endpoint, usedNumbers?: Set<number>) {\n        if (endpoint.lifecycle.hasNumber) {\n            this.#endpoint.env.get(IdentityService).assertNumberAvailable(endpoint.number, endpoint);\n            if (usedNumbers?.has(endpoint.number)) {\n                throw new IdentityConflictError(\n                    `Cannot add endpoint ${forefather} because descendents have conflicting definitions for endpoint number ${endpoint.number}`,\n                );\n            }\n        }\n\n        if (!endpoint.hasParts) {\n            return;\n        }\n\n        const children = endpoint.parts;\n        if (!children.size) {\n            return;\n        }\n\n        // We cannot rely on index to track identity of incoming endopint hierarchy because the entries are not yet\n        // present in the index\n        if (!usedNumbers) {\n            usedNumbers = new Set();\n        }\n        if (endpoint.lifecycle.hasNumber) {\n            usedNumbers.add(endpoint.number);\n        }\n\n        for (const child of children) {\n            this.#validateInsertion(forefather, child, usedNumbers);\n        }\n    }\n\n    #endpointFor(child: Endpoint.Definition | Agent) {\n        if (child instanceof Agent) {\n            child = child.endpoint;\n        }\n\n        if (!(child instanceof Endpoint)) {\n            if ((child as any).type) {\n                (child as any).owner = this.#endpoint;\n            } else {\n                child = {\n                    type: child as EndpointType,\n                    owner: this.#endpoint,\n                };\n            }\n        }\n\n        return Endpoint.partFor(child);\n    }\n}\n"],
  "mappings": "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",
  "names": ["endpoint"]
}
