{
  "version": 3,
  "sources": ["../../../../src/endpoint/properties/Behaviors.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Behavior } from \"../../behavior/Behavior.js\";\nimport type { ClusterBehavior } from \"../../behavior/cluster/ClusterBehavior.js\";\nimport { ValidatedElements } from \"../../behavior/cluster/ValidatedElements.js\";\nimport { ActionContext } from \"../../behavior/context/ActionContext.js\";\nimport { ActionTracer } from \"../../behavior/context/ActionTracer.js\";\nimport { NodeActivity } from \"../../behavior/context/NodeActivity.js\";\nimport { OfflineContext } from \"../../behavior/context/server/OfflineContext.js\";\nimport { DescriptorServer } from \"../../behavior/definitions/descriptor/DescriptorServer.js\";\nimport { BehaviorBacking } from \"../../behavior/internal/BehaviorBacking.js\";\nimport { Val } from \"../../behavior/state/Val.js\";\nimport { Transaction } from \"../../behavior/state/transaction/Transaction.js\";\nimport { ClusterType } from \"../../cluster/ClusterType.js\";\nimport { Lifecycle, UninitializedDependencyError } from \"../../common/Lifecycle.js\";\nimport { ImplementationError, InternalError, ReadOnlyError } from \"../../common/MatterError.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { FeatureSet } from \"../../model/index.js\";\nimport { Construction } from \"../../util/Construction.js\";\nimport { EventEmitter } from \"../../util/Observable.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { camelize, describeList } from \"../../util/String.js\";\nimport type { Agent } from \"../Agent.js\";\nimport type { Endpoint } from \"../Endpoint.js\";\nimport { EndpointVariableService } from \"../EndpointVariableService.js\";\nimport { BehaviorInitializationError, EndpointBehaviorsError } from \"../errors.js\";\nimport { EndpointInitializer } from \"./EndpointInitializer.js\";\nimport { EndpointLifecycle } from \"./EndpointLifecycle.js\";\nimport type { SupportedBehaviors } from \"./SupportedBehaviors.js\";\n\nconst logger = Logger.get(\"Behaviors\");\n\n/**\n * This class manages {@link Behavior} instances owned by a {@link Endpoint}.\n */\nexport class Behaviors {\n    #endpoint: Endpoint;\n    #supported: SupportedBehaviors;\n    #backings: Record<string, BehaviorBacking> = {};\n    #options: Record<string, object | undefined>;\n\n    /**\n     * The {@link SupportedBehaviors} of the {@link Endpoint}.\n     */\n    get supported() {\n        return this.#supported;\n    }\n\n    get status() {\n        const status = {} as Record<string, Lifecycle.Status>;\n        for (const key in this.#supported) {\n            status[key] = this.#backings[key]?.status ?? Lifecycle.Status.Inactive;\n        }\n        return status;\n    }\n\n    get [Diagnostic.value]() {\n        return Diagnostic.lifecycleList(this.status);\n    }\n\n    get detailedDiagnostic() {\n        return Object.entries(this.#supported).map(([name, type]) => {\n            const backing = this.#backings[name];\n\n            const result = [Diagnostic(backing?.status ?? Lifecycle.Status.Inactive, name)];\n\n            const cluster = clusterOf(type);\n            if (!cluster) {\n                return result;\n            }\n\n            const elementDiagnostic = Array<unknown>();\n\n            const elements = new ValidatedElements(type as ClusterBehavior.Type);\n\n            const features = new FeatureSet(cluster.supportedFeatures);\n            if (features.size) {\n                elementDiagnostic.push([Diagnostic.strong(\"features\"), features]);\n            }\n\n            if (elements.attributes.size) {\n                elementDiagnostic.push([Diagnostic.strong(\"attributes\"), elements.attributes]);\n            }\n            if (elements.commands.size) {\n                elementDiagnostic.push([Diagnostic.strong(\"commands\"), elements.commands]);\n            }\n            if (elements.events.size) {\n                elementDiagnostic.push([Diagnostic.strong(\"events\"), elements.events]);\n            }\n\n            if (elementDiagnostic.length) {\n                result.push(Diagnostic.list(elementDiagnostic));\n            }\n\n            return result;\n        });\n    }\n\n    constructor(endpoint: Endpoint, options: Record<string, object | undefined>) {\n        const { type } = endpoint;\n        if (typeof type?.behaviors !== \"object\") {\n            throw new ImplementationError('EndpointType \"behaviors\" must be an array of Behavior.Type instances');\n        }\n\n        this.#endpoint = endpoint;\n        this.#supported = type.behaviors;\n        this.#options = options;\n\n        // DescriptorBehavior is unequivocally mandatory\n        if (!this.#supported.descriptor) {\n            this.#supported.descriptor = DescriptorServer;\n        }\n\n        for (const id in this.#supported) {\n            const type = this.#supported[id];\n            if (!(type.prototype instanceof Behavior)) {\n                throw new ImplementationError(`${endpoint}.${id}\" is not a Behavior.Type`);\n            }\n            if (typeof type.id !== \"string\") {\n                throw new ImplementationError(`${endpoint}.${id} has no ID`);\n            }\n            this.#augmentEndpoint(type);\n        }\n    }\n\n    /**\n     * Activate any behaviors designated for immediate activation.  Returns a promise iff any behaviors have ongoing\n     * initialization.\n     *\n     * Throws an error if any behavior crashes, but we allow all behaviors to settle before throwing.  The goal is to\n     * surface multiple configuration errors and prevent inconsistent state caused by partial initialization.\n     */\n    initialize(): MaybePromise {\n        // Sanity check\n        if (!this.#endpoint.lifecycle.isInstalled) {\n            throw new ImplementationError(`Cannot initialize behaviors because endpoint is not installed`);\n        }\n\n        // Initialization action.  We initialize all behaviors in the same transaction\n        const initializeBehaviors = (context: ActionContext) => {\n            const agent = context.agentFor(this.#endpoint);\n\n            // Activate behaviors\n            //\n            // TODO - add a timeout on behavior initialization\n            for (const type of Object.values(this.supported)) {\n                if (type.early) {\n                    this.activate(type, agent);\n                }\n            }\n\n            // Wait for all behaviors to initialize\n            return Construction.all(\n                {\n                    [Symbol.iterator]: () => {\n                        return Object.values(this.#backings)[Symbol.iterator]();\n                    },\n                },\n\n                causes => new EndpointBehaviorsError(causes),\n            );\n        };\n\n        // Initialize instrumentation\n        const activity = this.#endpoint.env.get(NodeActivity);\n        const trace: ActionTracer.Action | undefined = this.#endpoint.env.has(ActionTracer)\n            ? { type: ActionTracer.ActionType.Initialize }\n            : undefined;\n\n        // Perform initialization\n        let promise = OfflineContext.act(`initialize<${this.#endpoint}>`, activity, initializeBehaviors, { trace });\n\n        // Once behaviors are ready the endpoint we consider the endpoint \"ready\"\n        const onReady = () => {\n            this.#endpoint.lifecycle.change(EndpointLifecycle.Change.Ready);\n\n            if (trace) {\n                trace.path = this.#endpoint.path;\n                this.#endpoint.env.get(ActionTracer).record(trace);\n            }\n        };\n        if (promise) {\n            promise = promise.then(onReady);\n        } else {\n            onReady();\n        }\n\n        return promise;\n    }\n\n    /**\n     * Does the {@link Endpoint} support a specified behavior?\n     */\n    has<T extends Behavior.Type>(type: T) {\n        const myType = this.#supported[type.id];\n        return myType === type || myType?.supports(type);\n    }\n\n    /**\n     * Add behavior support dynamically at runtime.  Typically called via {@link Agent.require}.\n     */\n    require<T extends Behavior.Type>(type: T, options?: Behavior.Options<T>) {\n        if (options) {\n            this.#options[type.id] = options;\n        }\n\n        if (this.#supported[type.id]) {\n            if (!this.has(type)) {\n                throw new ImplementationError(\n                    `Cannot require ${this.#endpoint}.${type.id} because incompatible implementation already exists`,\n                );\n            }\n            return;\n        }\n\n        if (this.#supported === this.#endpoint.type.behaviors) {\n            this.#supported = { ...this.#supported };\n        }\n        this.#supported[type.id] = type;\n\n        this.#augmentEndpoint(type);\n\n        this.#endpoint.lifecycle.change(EndpointLifecycle.Change.ServersChanged);\n\n        if (type.early && this.#endpoint.lifecycle.isInstalled) {\n            this.#activateLate(type);\n        }\n    }\n\n    /**\n     * Create a behavior synchronously.  Fails if the behavior is not fully initialized.\n     */\n    createSync(type: Behavior.Type, agent: Agent) {\n        const behavior = this.createMaybeAsync(type, agent);\n\n        if (MaybePromise.is(behavior)) {\n            throw new ImplementationError(\n                `Synchronous access to ${this.#endpoint}.${type.id} is impossible because it is still initializing`,\n            );\n        }\n\n        return behavior;\n    }\n\n    /**\n     * Create a behavior asynchronously.  Waits for the behavior to complete initialization.\n     */\n    async createAsync(type: Behavior.Type, agent: Agent) {\n        return MaybePromise.then(\n            () => this.createMaybeAsync(type, agent),\n            undefined,\n            e => {\n                // We log the actual error produced by the backing.  Here we want the error to present as crashed\n                // access with a proper stack trace\n                const backing = this.#backings[type.id];\n                if (!backing) {\n                    throw e;\n                }\n                backing.construction.assert(backing.toString());\n            },\n        );\n    }\n\n    /**\n     * Create a behavior, possibly asynchronously.\n     *\n     * This method returns a {@link Promise} only if await is necessary so the behavior can be used immediately if\n     * possible.\n     */\n    createMaybeAsync(type: Behavior.Type, agent: Agent): MaybePromise<Behavior> {\n        this.activate(type, agent);\n        const backing = this.#backings[type.id];\n\n        // On first activation the backing will create the behavior to initialize.  Otherwise we need to create now.\n        // This function obtains the behavior in both cases\n        const getBehavior = () => {\n            if (agent.isLoaded(type)) {\n                return agent.get(type);\n            }\n            return backing.createBehavior(agent, type);\n        };\n\n        // If the backing initializes asynchronously, return a promise that returns the behavior when initialized\n        if (backing.construction.status === Lifecycle.Status.Initializing) {\n            return backing.construction\n                .then(() => getBehavior())\n                .catch(() => {\n                    // The backing logs the actual error so here the error should just throw \"unavailable due to crash\"\n                    backing.construction.assert(backing.toString());\n\n                    // Shouldn't get here but catch result type needs to be a behavior\n                    return getBehavior();\n                });\n        }\n\n        // Synchronous construction; first a sanity check\n        backing.construction.assert(backing.toString());\n\n        // Return the behavior instance\n        return getBehavior();\n    }\n\n    /**\n     * Activate a behavior.\n     *\n     * Semantically identical to createAsync() but does not return a {@link Promise} or throw an error.\n     *\n     * Behaviors that fail initialization will be marked with crashed {@link status}.\n     */\n    activate(type: Behavior.Type, agent: Agent) {\n        let backing = this.#backings[type.id];\n\n        if (!backing) {\n            backing = this.#createBacking(type, agent);\n        }\n    }\n\n    /**\n     * Determine if a specified behavior is supported and active.\n     */\n    isActive(type: Behavior.Type) {\n        const backing = this.#backings[type.id];\n        return !!backing && backing.type.supports(type);\n    }\n\n    /**\n     * Destroy all behaviors that are initialized (have backings present).  The object may be reused after close.\n     */\n    async close() {\n        const dispose = async (context: ActionContext) => {\n            const agent = context.agentFor(this.#endpoint);\n\n            let destroyNow = new Set(Object.keys(this.#backings));\n            while (destroyNow.size) {\n                for (const key in this.#backings) {\n                    const dependencies = this.#backings[key].type.dependencies;\n\n                    if (!dependencies) {\n                        continue;\n                    }\n\n                    for (const type of dependencies) {\n                        destroyNow.delete(type.id);\n                    }\n\n                    if (!destroyNow.size) {\n                        throw new ImplementationError(\"Cannot destroy behaviors due to circular dependency\");\n                    }\n                }\n\n                for (const id of destroyNow) {\n                    await this.#backings[id].close(agent);\n                    delete this.#backings[id];\n                }\n\n                destroyNow = new Set(Object.keys(this.#backings));\n            }\n\n            // Commit any state changes that occurred during destruction\n            const transaction = agent.context.transaction;\n            if (transaction.status === Transaction.Status.Exclusive) {\n                await transaction.commit();\n            }\n        };\n\n        await OfflineContext.act(`close<${this.#endpoint}>`, this.#endpoint.env.get(NodeActivity), dispose);\n    }\n\n    /**\n     * Ensure a set of behavior requirements are met.  Throws an error detailing missing requirements.\n     */\n    validateRequirements(requirements?: SupportedBehaviors) {\n        if (!requirements) {\n            return;\n        }\n\n        const missing = Array<string>();\n        for (const requirement of Object.values(requirements)) {\n            let name = camelize(requirement.name, true);\n\n            if (this.#endpoint.behaviors.has(requirement)) {\n                continue;\n            }\n\n            // For ClusterBehaviors, accept any behavior that supports the cluster.  Could confirm features too but\n            // doesn't currently\n            const cluster = clusterOf(requirement);\n            if (cluster) {\n                const other = this.#endpoint.behaviors.supported[requirement.id];\n\n                if (clusterOf(other)?.id === cluster.id) {\n                    continue;\n                }\n\n                name = `${name} (0x${cluster.id.toString(16)})`;\n            }\n\n            missing.push(name);\n        }\n\n        if (missing.length) {\n            throw new ImplementationError(\n                `${this.#endpoint} is missing required behaviors: ${describeList(\"and\", ...missing)}`,\n            );\n        }\n    }\n\n    /**\n     * Obtain default values for a behavior.  This is state values as present when the behavior is first initialized for\n     * a new endpoint.\n     */\n    defaultsFor(type: Behavior.Type) {\n        let defaults: Val.Struct | undefined;\n\n        // Set defaults from options\n        const options = this.#options[type.id];\n        if (options) {\n            for (const key in type.defaults) {\n                if (key in options) {\n                    if (!defaults) {\n                        defaults = {};\n                    }\n                    defaults[key] = (options as Val.Struct)[key];\n                }\n            }\n        }\n\n        // Set defaults from environmental configuration\n        const varService = this.#endpoint.env.get(EndpointVariableService);\n        const vars = varService.forBehaviorInstance(this.#endpoint, type);\n        if (vars !== undefined) {\n            defaults = { ...defaults, ...(type.supervisor.cast(vars) as Val.Struct) };\n        }\n\n        return defaults;\n    }\n\n    /**\n     * Access internal state for a {@link Behavior}.\n     *\n     * Internal state is not stable API and not intended for consumption outside of the behavior.  However it is not\n     * truly private and may be accessed by tightly coupled implementation.\n     *\n     * As this API is intended for use by \"friendly\" code, it does not perform the same initialization assertions as\n     * does access to {@link Behavior.State} and {@link Behavior.Events}.\n     */\n    internalsOf<T extends Behavior.Type>(type: T) {\n        let backing = this.#backings[type.id];\n        if (!backing) {\n            this.#activateLate(type);\n            backing = this.#backings[type.id];\n            if (backing === undefined) {\n                throw new InternalError(`Behavior ${this.#endpoint}.${type.id} late activation did not create backing`);\n            }\n        }\n        return backing.getInternal() as InstanceType<T[\"Internal\"]>;\n    }\n\n    #activateLate(type: Behavior.Type) {\n        const result = OfflineContext.act(\"behavior-late-activation\", this.#endpoint.env.get(NodeActivity), context =>\n            this.activate(type, context.agentFor(this.#endpoint)),\n        );\n\n        if (MaybePromise.is(result)) {\n            result.then(undefined, error => {\n                // The backing should handle its own errors so if present assume this is a commit error and crash the\n                // backing.  If there's no backing then there shouldn't be a promise so this is effectively an internal\n                // error\n                const backing = this.#backings[type.id];\n                if (backing) {\n                    logger.error(`Error initializing ${backing}`, error);\n                } else {\n                    logger.error(`Unexpected rejection initializing ${type.name}`, error);\n                }\n            });\n        }\n    }\n\n    /**\n     * Obtain a backing for an endpoint shortcut.\n     */\n    #backingFor(container: string, type: Behavior.Type) {\n        if (this.#endpoint.construction.status !== Lifecycle.Status.Initializing) {\n            this.#endpoint.construction.assert(this.#endpoint.toString(), `behavior ${type.id}`);\n        }\n\n        let backing = this.#backings[type.id];\n        if (!backing) {\n            try {\n                this.#activateLate(type);\n            } catch (e) {\n                logger.warn(`Cannot initialize ${container}.${type.id} until node is initialized: ${e}`);\n                throw new UninitializedDependencyError(\n                    `${container}.${type.id}`,\n                    \"is not available until node is initialized, you may await node.construction to avoid this error\",\n                );\n            }\n            backing = this.#backings[type.id];\n            if (backing === undefined) {\n                throw new InternalError(`Behavior ${this.#endpoint}.${type.id} late activation did not create backing`);\n            }\n        }\n        return backing;\n    }\n\n    #createBacking(type: Behavior.Type, agent: Agent) {\n        // Ensure the type is supported.  If it is, we instantiate with our type rather than the specified type because\n        // our type might be an extension\n        const myType = this.#getBehaviorType(type);\n        if (!myType) {\n            throw new BehaviorInitializationError(`Initializing ${this.#endpoint}.${type.id}: Unsupported behavior`);\n        }\n\n        const backing = this.#endpoint.env.get(EndpointInitializer).createBacking(this.#endpoint, myType);\n        this.#backings[type.id] = backing;\n        backing.construction.start(agent);\n\n        return backing;\n    }\n\n    #getBehaviorType(type: Behavior.Type) {\n        const myType = this.#supported[type.id];\n\n        if (myType === undefined) {\n            return myType;\n        }\n\n        if (typeof myType !== \"function\" || !(myType.prototype instanceof Behavior)) {\n            throw new ImplementationError(`Endpoint behavior \"${type.id}\" implementation is not a Behavior`);\n        }\n\n        return myType;\n    }\n\n    /**\n     * Updates endpoint \"state\" and \"events\" properties to include properties for our implementations.\n     */\n    #augmentEndpoint(type: Behavior.Type) {\n        Object.defineProperty(this.#endpoint.state, type.id, {\n            get: () => {\n                return this.#backingFor(\"state\", type).stateView;\n            },\n\n            set() {\n                throw new ReadOnlyError('The \"state\" property is read-only; you must use set() to modify state');\n            },\n\n            enumerable: true,\n        });\n\n        let events: undefined | EventEmitter;\n        Object.defineProperty(this.#endpoint.events, type.id, {\n            get: () => {\n                if (!events) {\n                    events = new type.Events();\n                }\n                return events;\n            },\n\n            enumerable: true,\n        });\n    }\n}\n\nfunction clusterOf(behavior?: Behavior.Type): ClusterType | undefined {\n    return (behavior as ClusterBehavior.Type)?.cluster;\n}\n"],
  "mappings": "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",
  "names": ["type"]
}
