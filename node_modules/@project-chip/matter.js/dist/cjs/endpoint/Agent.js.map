{
  "version": 3,
  "sources": ["../../../src/endpoint/Agent.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Behavior } from \"../behavior/Behavior.js\";\nimport { ActionContext } from \"../behavior/context/ActionContext.js\";\nimport { DescriptorBehavior } from \"../behavior/definitions/descriptor/DescriptorBehavior.js\";\nimport { GeneratedClass } from \"../util/GeneratedClass.js\";\nimport { MaybePromise } from \"../util/Promises.js\";\nimport type { Endpoint } from \"./Endpoint.js\";\nimport type { SupportedBehaviors } from \"./properties/SupportedBehaviors.js\";\nimport { EndpointType } from \"./type/EndpointType.js\";\n\nexport const INSTALL_BEHAVIOR = Symbol(\"install-behavior\");\n\n/**\n * An Agent offers interaction with a single endpoint.  This is the operational interface to endpoints.  It is separate\n * from the {@link Endpoint} because the agent is context-aware and may be bound to a specific fabric.\n *\n * An endpoint agent manages one or more {@link Behavior} instances that implement a discrete subset of the agent's\n * functionality.\n *\n * Each endpoint agent has an associated {@link Agent.Type} that defines each {@link Behavior.Type} the endpoint\n * supports.\n *\n * {@link Agent.Type} is a permanent feature of an endpoint but agent instances themselves are transitory and there is\n * no guarantee they will exist beyond the lifecycle of a single transaction.\n */\nexport class Agent {\n    #endpoint: Endpoint;\n    #context: ActionContext;\n    #behaviors = {} as Record<string, Behavior>;\n\n    constructor(endpoint: Endpoint, context: ActionContext) {\n        this.#endpoint = endpoint;\n        this.#context = context;\n    }\n\n    /**\n     * Access the {@link Endpoint} this agent acts on behalf of.\n     */\n    get endpoint() {\n        return this.#endpoint;\n    }\n\n    /**\n     * Access an {@link Agent} for this agent's owner.\n     */\n    get owner(): Agent | undefined {\n        if (this.#endpoint.owner === undefined) {\n            return undefined;\n        }\n        return this.context.agentFor(this.#endpoint.owner);\n    }\n\n    /**\n     * Access the agent's {@link ActionContext}.\n     */\n    get context() {\n        return this.#context;\n    }\n\n    /**\n     * Test to see if a {@link Behavior.Type} is supported by this agent.\n     */\n    has<BehaviorT extends Behavior.Type>(type: BehaviorT): this is InstanceType<BehaviorT> {\n        return this.#endpoint.behaviors.has(type);\n    }\n\n    /**\n     * Obtain a {@link Behavior} supported by this agent.  Throws an error if the {@link Behavior.Type} isn't supported\n     * or is still initializing.\n     *\n     * You may also access behaviors using normal property access, e.g. `agent.descriptor` is the same as\n     * `agent.get(DescriptorBehavior)`.\n     *\n     * Property access is available in TypeScript when the set of behaviors is defined statically.\n     */\n    get<T extends Behavior.Type>(type: T) {\n        let behavior = this.#behaviors[type.id];\n        if (!behavior) {\n            behavior = this.#endpoint.behaviors.createSync(type, this);\n        }\n        return behavior as InstanceType<T>;\n    }\n\n    /**\n     * Obtain a behavior supported by this agent.  Throws an error if the {@link Behavior.Type} isn't supported.  Waits\n     * if the behavior is not yet initialized.\n     */\n    load<T extends Behavior.Type>(type: T): MaybePromise<InstanceType<T>> {\n        const behavior = this.#behaviors[type.id];\n        if (behavior) {\n            return behavior as InstanceType<T>;\n        }\n\n        return this.#endpoint.behaviors.createMaybeAsync(type, this) as MaybePromise<InstanceType<T>>;\n    }\n\n    /**\n     * Trigger initialization of a supported {@link Behavior.Type}.\n     *\n     * Functionally identical to {@link load} but has no return value and errors are logged rathjer than thrown.\n     */\n    activate(type: Behavior.Type) {\n        this.#endpoint.behaviors.activate(type, this);\n    }\n\n    /**\n     * Add support for a {@link Behavior.Type}.\n     */\n    require<T extends Behavior.Type>(type: T, options?: Behavior.Options<T>) {\n        this.#endpoint.behaviors.require(type, options);\n    }\n\n    /**\n     * Determine whether a behavior is loaded (does not validate class, only by ID).\n     */\n    isLoaded(type: Behavior.Type) {\n        return this.#behaviors[type.id] !== undefined;\n    }\n\n    toString() {\n        return this.#endpoint.toString();\n    }\n\n    /**\n     * Create a new {@link Agent} that supports the specified behaviors.\n     */\n    static for<T extends EndpointType>(type: EndpointType, behaviors: SupportedBehaviors) {\n        const props = {} as PropertyDescriptorMap;\n        Object.values(behaviors).forEach(behavior => {\n            props[behavior.id] = {\n                get(this: Agent) {\n                    return this.get(behavior);\n                },\n\n                enumerable: true,\n            };\n        });\n\n        return GeneratedClass({\n            name: `${type.name}Agent`,\n            base: Agent,\n            instanceDescriptors: props,\n        }) as Agent.Type<T>;\n    }\n\n    [INSTALL_BEHAVIOR](behavior: Behavior) {\n        this.#behaviors[(behavior.constructor as Behavior.Type).id] = behavior;\n    }\n}\n\nexport namespace Agent {\n    /**\n     * Static type for {@link Agent} with a property for each statically defined behavior.\n     *\n     * Behaviors available at construction time are available as instance properties.  You must use {@link Agent.get} or\n     * {@link Agent.require} to acquire behaviors added via {@link Agent.require}.\n     */\n    export interface Type<T extends EndpointType = EndpointType.Empty> {\n        new (endpoint: Endpoint, context: ActionContext): Instance<T>;\n    }\n\n    export type Instance<T extends EndpointType = EndpointType.Empty> = Agent & {\n        readonly [K in keyof T[\"behaviors\"] & string]: InstanceType<T[\"behaviors\"][K]>;\n    } & {\n        readonly descriptor: DescriptorBehavior;\n    };\n\n    /**\n     * Internal interface used by Behavior's constructor to install.\n     */\n    export interface Internal {\n        [INSTALL_BEHAVIOR](behavior: Behavior): void;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA,4BAA+B;AAT/B;AAAA;AAAA;AAAA;AAAA;AAeO,MAAM,mBAAmB,OAAO,kBAAkB;AAelD,MAAM,MAAM;AAAA,EACf;AAAA,EACA;AAAA,EACA,aAAa,CAAC;AAAA,EAEd,YAAY,UAAoB,SAAwB;AACpD,SAAK,YAAY;AACjB,SAAK,WAAW;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAW;AACX,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAA2B;AAC3B,QAAI,KAAK,UAAU,UAAU,QAAW;AACpC,aAAO;AAAA,IACX;AACA,WAAO,KAAK,QAAQ,SAAS,KAAK,UAAU,KAAK;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACV,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAqC,MAAkD;AACnF,WAAO,KAAK,UAAU,UAAU,IAAI,IAAI;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,IAA6B,MAAS;AAClC,QAAI,WAAW,KAAK,WAAW,KAAK,EAAE;AACtC,QAAI,CAAC,UAAU;AACX,iBAAW,KAAK,UAAU,UAAU,WAAW,MAAM,IAAI;AAAA,IAC7D;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAA8B,MAAwC;AAClE,UAAM,WAAW,KAAK,WAAW,KAAK,EAAE;AACxC,QAAI,UAAU;AACV,aAAO;AAAA,IACX;AAEA,WAAO,KAAK,UAAU,UAAU,iBAAiB,MAAM,IAAI;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,MAAqB;AAC1B,SAAK,UAAU,UAAU,SAAS,MAAM,IAAI;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,QAAiC,MAAS,SAA+B;AACrE,SAAK,UAAU,UAAU,QAAQ,MAAM,OAAO;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAAqB;AAC1B,WAAO,KAAK,WAAW,KAAK,EAAE,MAAM;AAAA,EACxC;AAAA,EAEA,WAAW;AACP,WAAO,KAAK,UAAU,SAAS;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,IAA4B,MAAoB,WAA+B;AAClF,UAAM,QAAQ,CAAC;AACf,WAAO,OAAO,SAAS,EAAE,QAAQ,cAAY;AACzC,YAAM,SAAS,EAAE,IAAI;AAAA,QACjB,MAAiB;AACb,iBAAO,KAAK,IAAI,QAAQ;AAAA,QAC5B;AAAA,QAEA,YAAY;AAAA,MAChB;AAAA,IACJ,CAAC;AAED,eAAO,sCAAe;AAAA,MAClB,MAAM,GAAG,KAAK,IAAI;AAAA,MAClB,MAAM;AAAA,MACN,qBAAqB;AAAA,IACzB,CAAC;AAAA,EACL;AAAA,EAEA,CAAC,gBAAgB,EAAE,UAAoB;AACnC,SAAK,WAAY,SAAS,YAA8B,EAAE,IAAI;AAAA,EAClE;AACJ;",
  "names": []
}
