{
  "version": 3,
  "sources": ["../../../../src/endpoint/storage/DatasourceStore.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Val } from \"../../behavior/state/Val.js\";\nimport { Datasource } from \"../../behavior/state/managed/Datasource.js\";\nimport { Participant } from \"../../behavior/state/transaction/Participant.js\";\nimport { Transaction } from \"../../behavior/state/transaction/Transaction.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport type { PartStore } from \"./PartStore.js\";\n\ninterface StorageParticipant extends Participant {\n    mutations?: Record<string, Val.Struct>;\n}\n\n/**\n * Factory function for the default implementation of {@link Datasource.Store}.\n *\n * Performs read & write for non-volatile values for a single behavior via the {@link PartStore} interface.\n */\nexport function DatasourceStore(partStore: PartStore, behaviorId: string): Datasource.Store {\n    return {\n        initialValues: partStore.initialValues[behaviorId],\n\n        async set(transaction: Transaction, values: Val.Struct) {\n            const participant = participantFor(transaction, partStore);\n            if (!participant.mutations) {\n                participant.mutations = {};\n            }\n            const behaviorMutations = participant.mutations[behaviorId];\n            if (behaviorMutations) {\n                Object.assign(behaviorMutations, values);\n            } else {\n                participant.mutations[behaviorId] = { ...values };\n            }\n        },\n    };\n}\n\n/**\n * We create a single participant per storage/transaction pair.  This function handles setup and retrieval of this\n * participant.\n */\nfunction participantFor(transaction: Transaction, partStore: PartStore) {\n    let participant = transaction.getParticipant(partStore) as StorageParticipant | undefined;\n    if (participant) {\n        return participant;\n    }\n\n    participant = {\n        role: partStore,\n\n        mutations: undefined,\n\n        toString() {\n            return partStore.toString();\n        },\n\n        commit1(): MaybePromise {\n            // Persistence serves phase one commit; values are added directly to\n            // the journal so nothing necessary here\n        },\n\n        async commit2() {\n            if (this.mutations) {\n                await partStore.set(this.mutations);\n            }\n        },\n\n        rollback(): MaybePromise {\n            delete this.mutations;\n        },\n    };\n\n    transaction.addParticipants(participant);\n\n    return participant;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBO,SAAS,gBAAgB,WAAsB,YAAsC;AACxF,SAAO;AAAA,IACH,eAAe,UAAU,cAAc,UAAU;AAAA,IAEjD,MAAM,IAAI,aAA0B,QAAoB;AACpD,YAAM,cAAc,eAAe,aAAa,SAAS;AACzD,UAAI,CAAC,YAAY,WAAW;AACxB,oBAAY,YAAY,CAAC;AAAA,MAC7B;AACA,YAAM,oBAAoB,YAAY,UAAU,UAAU;AAC1D,UAAI,mBAAmB;AACnB,eAAO,OAAO,mBAAmB,MAAM;AAAA,MAC3C,OAAO;AACH,oBAAY,UAAU,UAAU,IAAI,EAAE,GAAG,OAAO;AAAA,MACpD;AAAA,IACJ;AAAA,EACJ;AACJ;AAMA,SAAS,eAAe,aAA0B,WAAsB;AACpE,MAAI,cAAc,YAAY,eAAe,SAAS;AACtD,MAAI,aAAa;AACb,WAAO;AAAA,EACX;AAEA,gBAAc;AAAA,IACV,MAAM;AAAA,IAEN,WAAW;AAAA,IAEX,WAAW;AACP,aAAO,UAAU,SAAS;AAAA,IAC9B;AAAA,IAEA,UAAwB;AAAA,IAGxB;AAAA,IAEA,MAAM,UAAU;AACZ,UAAI,KAAK,WAAW;AAChB,cAAM,UAAU,IAAI,KAAK,SAAS;AAAA,MACtC;AAAA,IACJ;AAAA,IAEA,WAAyB;AACrB,aAAO,KAAK;AAAA,IAChB;AAAA,EACJ;AAEA,cAAY,gBAAgB,WAAW;AAEvC,SAAO;AACX;",
  "names": []
}
