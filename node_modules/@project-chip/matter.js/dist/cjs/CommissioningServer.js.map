{
  "version": 3,
  "sources": ["../../src/CommissioningServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterDevice } from \"./MatterDevice.js\";\nimport { MatterNode } from \"./MatterNode.js\";\nimport { DeviceCertification } from \"./behavior/definitions/operational-credentials/DeviceCertification.js\";\nimport { ProductDescription } from \"./behavior/system/product-description/ProductDescription.js\";\nimport { Ble } from \"./ble/Ble.js\";\nimport { AttestationCertificateManager } from \"./certificate/AttestationCertificateManager.js\";\nimport { CertificationDeclarationManager } from \"./certificate/CertificationDeclarationManager.js\";\nimport { ClusterType } from \"./cluster/ClusterType.js\";\nimport { ClusterClientObj } from \"./cluster/client/ClusterClientTypes.js\";\nimport { AccessControl } from \"./cluster/definitions/AccessControlCluster.js\";\nimport {\n    AdministratorCommissioning,\n    AdministratorCommissioningCluster,\n} from \"./cluster/definitions/AdministratorCommissioningCluster.js\";\nimport { BasicInformationCluster } from \"./cluster/definitions/BasicInformationCluster.js\";\nimport {\n    GeneralCommissioning,\n    GeneralCommissioningCluster,\n} from \"./cluster/definitions/GeneralCommissioningCluster.js\";\nimport { GeneralDiagnostics, GeneralDiagnosticsCluster } from \"./cluster/definitions/GeneralDiagnosticsCluster.js\";\nimport { GroupKeyManagementCluster } from \"./cluster/definitions/GroupKeyManagementCluster.js\";\nimport { OperationalCredentialsCluster } from \"./cluster/definitions/OperationalCredentialsCluster.js\";\nimport { createDefaultAccessControlClusterServer } from \"./cluster/server/AccessControlServer.js\";\nimport { AdministratorCommissioningHandler } from \"./cluster/server/AdministratorCommissioningServer.js\";\nimport {\n    genericFabricScopedAttributeGetterFromFabric,\n    genericFabricScopedAttributeSetterForFabric,\n} from \"./cluster/server/AttributeServer.js\";\nimport { ClusterServer } from \"./cluster/server/ClusterServer.js\";\nimport {\n    AttributeInitialValues,\n    ClusterDatasource,\n    ClusterServerHandlers,\n    ClusterServerObj,\n} from \"./cluster/server/ClusterServerTypes.js\";\nimport { GeneralCommissioningClusterHandler } from \"./cluster/server/GeneralCommissioningServer.js\";\nimport { createDefaultGeneralDiagnosticsClusterServer } from \"./cluster/server/GeneralDiagnosticsServer.js\";\nimport { GroupKeyManagementClusterHandler } from \"./cluster/server/GroupKeyManagementServer.js\";\nimport { OperationalCredentialsClusterHandler } from \"./cluster/server/OperationalCredentialsServer.js\";\nimport { ImplementationError, InternalError, NoProviderError } from \"./common/MatterError.js\";\nimport { Crypto } from \"./crypto/Crypto.js\";\nimport { EndpointNumber } from \"./datatype/EndpointNumber.js\";\nimport { FabricIndex } from \"./datatype/FabricIndex.js\";\nimport { VendorId } from \"./datatype/VendorId.js\";\nimport { Aggregator } from \"./device/Aggregator.js\";\nimport { Device, RootEndpoint } from \"./device/Device.js\";\nimport { Endpoint } from \"./device/Endpoint.js\";\nimport { LegacyInteractionServer } from \"./device/LegacyInteractionServer.js\";\nimport { EndpointInterface } from \"./endpoint/EndpointInterface.js\";\nimport { Fabric } from \"./fabric/Fabric.js\";\nimport { Logger } from \"./log/Logger.js\";\nimport { MdnsBroadcaster } from \"./mdns/MdnsBroadcaster.js\";\nimport { MdnsInstanceBroadcaster } from \"./mdns/MdnsInstanceBroadcaster.js\";\nimport { MdnsScanner } from \"./mdns/MdnsScanner.js\";\nimport { Specification } from \"./model/definitions/Specification.js\";\nimport { Network } from \"./net/Network.js\";\nimport { UdpInterface } from \"./net/UdpInterface.js\";\nimport { EventHandler } from \"./protocol/interaction/EventHandler.js\";\nimport { InteractionEndpointStructure } from \"./protocol/interaction/InteractionEndpointStructure.js\";\nimport { TypeFromBitSchema, TypeFromPartialBitSchema } from \"./schema/BitmapSchema.js\";\nimport {\n    CommissioningFlowType,\n    DiscoveryCapabilitiesBitmap,\n    DiscoveryCapabilitiesSchema,\n    ManualPairingCodeCodec,\n    QrPairingCodeCodec,\n} from \"./schema/PairingCodeSchema.js\";\nimport { PaseClient } from \"./session/pase/PaseClient.js\";\nimport { SyncStorage } from \"./storage/Storage.js\";\nimport { StorageContext } from \"./storage/StorageContext.js\";\nimport { SupportedStorageTypes } from \"./storage/StringifyTools.js\";\nimport { ByteArray } from \"./util/ByteArray.js\";\nimport { NamedHandler } from \"./util/NamedHandler.js\";\n\nconst logger = Logger.get(\"CommissioningServer\");\n\nexport const FORBIDDEN_PASSCODES = [\n    0, 11111111, 22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999, 12345678, 87654321,\n];\n\n/**\n * Represents device pairing information.\n */\nexport interface DevicePairingInformation {\n    manualPairingCode: string;\n    qrPairingCode: string;\n}\n\n/**\n * Constructor options for a CommissioningServer device\n * Beside the general options it also contains the data for the BasicInformation cluster which is added automatically\n * and allows to override the certificates used for the OperationalCredentials cluster\n */\nexport interface CommissioningServerOptions {\n    /** Port of the server, normally automatically managed. */\n    port?: number;\n\n    /** IPv4 listener address, defaults to all interfaces.*/\n    listeningAddressIpv4?: string;\n\n    /** IPv6 listener address, defaults to all interfaces.*/\n    listeningAddressIpv6?: string;\n\n    /** The device name to be used for the BasicInformation cluster. */\n    deviceName: string;\n\n    /** The device type to be used for the BasicInformation cluster. */\n    deviceType: number;\n\n    /** The next endpoint ID to be assigned to a new endpoint. */\n    nextEndpointId?: number;\n\n    /** The passcode/pin of the device to use for initial commissioning. */\n    passcode?: number;\n\n    /** The Discriminator to use for initial commissioning. */\n    discriminator?: number;\n\n    /** The Flow type of the Commissioning flow used in announcements. */\n    flowType?: CommissioningFlowType;\n\n    /** Optional Vendor specific additional BLE Advertisement data. */\n    additionalBleAdvertisementData?: ByteArray;\n\n    /** Should the device directly be announced automatically by the MatterServer of manually via announce(). */\n    delayedAnnouncement?: boolean;\n\n    /**\n     * Optional maximum subscription interval to use for sending subscription reports. It will be used if not too low\n     * and inside the range requested by the connected controller.\n     */\n    subscriptionMaxIntervalSeconds?: number;\n\n    /**\n     * Optional minimum subscription interval to use for sending subscription reports. It will be used when other\n     * calculated values are smaller than it. Use this to make sure your device hardware can handle the load and to set\n     * limits.\n     */\n    subscriptionMinIntervalSeconds?: number;\n\n    /**\n     * Optional subscription randomization window to use for sending subscription reports. This specifies a window in\n     * seconds from which a random part is added to the calculated maximum interval to make sure that devices that get\n     * powered on in parallel not all send at the same timepoint.\n     */\n    subscriptionRandomizationWindowSeconds?: number;\n\n    /**\n     * Device details to be used for the BasicInformation cluster. Some of the values are initialized with defaults if\n     * not set here.\n     */\n    basicInformation:\n        | {\n              vendorId: number;\n              vendorName: string;\n              productId: number;\n              productName: string;\n          }\n        | AttributeInitialValues<typeof BasicInformationCluster.attributes>;\n\n    /**\n     * Vendor specific certificates to be used for the OperationalCredentials cluster. If not set Test certificates\n     * (official Chip tool test Root certificate is used) are generated automatically.\n     */\n    certificates?: DeviceCertification.Definition;\n\n    /**\n     * Optional configuration for the GeneralCommissioning cluster. If not set the default values are used.\n     * Use these options to limit the allowed countries for regulatory configuration.\n     */\n    generalCommissioning?: Partial<AttributeInitialValues<typeof GeneralCommissioningCluster.attributes>> & {\n        allowCountryCodeChange?: boolean; // Default true if not set\n        countryCodeWhitelist?: string[]; // Default all countries are allowed\n    };\n\n    /**\n     * This callback is called when the device is commissioned or decommissioned to a fabric/controller. The provided\n     * fabricIndex can be used together with getCommissionedFabricInformation() to get more details about the fabric\n     * (or if this fabricIndex is missing it was deleted).\n     */\n    commissioningChangedCallback?: (fabricIndex: FabricIndex) => void;\n\n    /**\n     * This callback is called when sessions to the device are established, closed or subscriptions get added or\n     * removed. The provided fabricIndex can be used together with getActiveSessionInformation() to get more details\n     * about the open sessions and their status.\n     */\n    activeSessionsChangedCallback?: (fabricIndex: FabricIndex) => void;\n}\n\n/**\n * Commands exposed by the CommissioningServer\n */\nexport type CommissioningServerCommands = {\n    /** Provide a means for certification tests to trigger some test-plan-specific events. */\n    testEventTrigger: ClusterServerHandlers<typeof GeneralDiagnosticsCluster>[\"testEventTrigger\"];\n};\n\n// TODO decline using set/getRootClusterClient\n// TODO Decline cluster access after announced/paired\n\n/**\n * A CommissioningServer node represent a matter node that can be paired with a controller and runs on a defined port on the\n * host\n */\nexport class CommissioningServer extends MatterNode {\n    private ipv4Disabled?: boolean;\n    private port?: number;\n    private readonly passcode: number;\n    private readonly discriminator: number;\n    private readonly flowType: CommissioningFlowType;\n    private readonly productDescription: ProductDescription;\n\n    private storage?: StorageContext<SyncStorage>;\n    private endpointStructureStorage?: StorageContext<SyncStorage>;\n    private mdnsScanner?: MdnsScanner;\n    private mdnsBroadcaster?: MdnsBroadcaster;\n    private mdnsInstanceBroadcaster?: MdnsInstanceBroadcaster;\n\n    private deviceInstance?: MatterDevice;\n    private eventHandler?: EventHandler;\n    private endpointStructure: InteractionEndpointStructure;\n    private interactionServer?: LegacyInteractionServer;\n\n    protected readonly rootEndpoint = new RootEndpoint();\n\n    private nextEndpointId: EndpointNumber;\n\n    readonly delayedAnnouncement?: boolean;\n\n    private readonly commandHandler = new NamedHandler<CommissioningServerCommands>();\n\n    /**\n     * Creates a new CommissioningServer node and add all needed Root clusters\n     *\n     * @param options The options for the CommissioningServer node\n     */\n    constructor(private readonly options: CommissioningServerOptions) {\n        super();\n        const {\n            port,\n            passcode,\n            discriminator,\n            flowType,\n            nextEndpointId,\n            delayedAnnouncement,\n            basicInformation: { vendorId: vendorIdNumber, productId },\n            generalCommissioning,\n        } = options;\n        this.port = port;\n        if (passcode !== undefined && FORBIDDEN_PASSCODES.includes(passcode)) {\n            throw new ImplementationError(`Passcode ${passcode} is not allowed.`);\n        }\n        this.passcode = passcode ?? PaseClient.generateRandomPasscode();\n        this.discriminator = discriminator ?? PaseClient.generateRandomDiscriminator();\n        this.flowType = flowType ?? CommissioningFlowType.Standard;\n        this.nextEndpointId = EndpointNumber(nextEndpointId ?? 1);\n        this.delayedAnnouncement = delayedAnnouncement;\n\n        const vendorId = VendorId(vendorIdNumber);\n\n        // Set the required basicInformation and respect the provided values\n        // TODO Get the defaults from the cluster meta details\n        const basicInformationAttributes: AttributeInitialValues<typeof BasicInformationCluster.attributes> = {\n            dataModelRevision: Specification.DATA_MODEL_REVISION,\n            nodeLabel: \"\",\n            hardwareVersion: 0,\n            hardwareVersionString: \"0\",\n            location: \"XX\",\n            localConfigDisabled: false,\n            softwareVersion: 1,\n            softwareVersionString: \"v1\",\n            capabilityMinima: {\n                caseSessionsPerFabric: 3, // TODO get that limit from Sessionmanager or such or sync with it, add limit? Just a minima?\n                subscriptionsPerFabric: 3, // TODO get that limit from Interactionserver? Respect it? It is just a minima?\n            },\n            serialNumber: `matter.js-${Crypto.get().getRandomData(4).toHex()}`,\n            specificationVersion: Specification.SPECIFICATION_VERSION,\n            maxPathsPerInvoke: 1,\n\n            ...options.basicInformation,\n\n            vendorId, // Just for TS\n        };\n\n        const reachabilitySupported = basicInformationAttributes.reachable !== undefined;\n        // Add basic Information cluster to root directly because it is not allowed to be changed afterward\n        const basicInformationCluster = ClusterServer(\n            BasicInformationCluster,\n            basicInformationAttributes,\n            {},\n            {\n                startUp: true,\n                shutDown: true,\n                reachableChanged: reachabilitySupported,\n                leave: true,\n            },\n        );\n        this.rootEndpoint.addClusterServer(basicInformationCluster);\n\n        if (reachabilitySupported) {\n            basicInformationCluster.subscribeReachableAttribute(newValue =>\n                basicInformationCluster.triggerReachableChangedEvent?.({ reachableNewValue: newValue }),\n            );\n        }\n\n        // Use provided certificates for OperationalCredentialsCluster or generate own ones\n        let { certificates } = options;\n        if (certificates == undefined) {\n            const paa = new AttestationCertificateManager(vendorId);\n            const { keyPair: dacKeyPair, dac } = paa.getDACert(productId);\n            const declaration = CertificationDeclarationManager.generate(vendorId, productId);\n\n            certificates = {\n                privateKey: dacKeyPair.privateKey,\n                certificate: dac,\n                intermediateCertificate: paa.getPAICert(),\n                declaration,\n            };\n        }\n\n        this.productDescription = {\n            name: options.deviceName,\n            deviceType: options.deviceType,\n            vendorId: vendorId,\n            productId: productId,\n        };\n\n        // Add Operational credentials cluster to root directly because it is not allowed to be changed afterward\n        // TODO Get the defaults from the cluster meta details\n        this.rootEndpoint.addClusterServer(\n            ClusterServer(\n                OperationalCredentialsCluster,\n                {\n                    nocs: [],\n                    fabrics: [],\n                    supportedFabrics: 254, // maximum number of fabrics. Also FabricBuilder uses 254 as max!\n                    commissionedFabrics: 0,\n                    trustedRootCertificates: [],\n                    currentFabricIndex: FabricIndex.NO_FABRIC,\n                },\n                OperationalCredentialsClusterHandler(certificates, this.productDescription),\n            ),\n        );\n\n        // TODO Get the defaults from the cluster meta details\n        this.rootEndpoint.addClusterServer(\n            ClusterServer(\n                GeneralCommissioningCluster,\n                {\n                    breadcrumb: generalCommissioning?.breadcrumb ?? BigInt(0),\n                    basicCommissioningInfo: generalCommissioning?.basicCommissioningInfo ?? {\n                        failSafeExpiryLengthSeconds: 60 /* 1min */,\n                        maxCumulativeFailsafeSeconds: 900 /* Recommended according to Specs */,\n                    },\n                    regulatoryConfig:\n                        generalCommissioning?.regulatoryConfig ?? GeneralCommissioning.RegulatoryLocationType.Outdoor, // Default is the most restrictive one\n                    locationCapability:\n                        generalCommissioning?.locationCapability ??\n                        GeneralCommissioning.RegulatoryLocationType.IndoorOutdoor,\n                    supportsConcurrentConnection: generalCommissioning?.supportsConcurrentConnection ?? true,\n                },\n                GeneralCommissioningClusterHandler({\n                    allowCountryCodeChange: generalCommissioning?.allowCountryCodeChange ?? true,\n                    countryCodeWhitelist: generalCommissioning?.countryCodeWhitelist ?? undefined,\n                }),\n            ),\n        );\n\n        // TODO Get the defaults from the cluster meta details\n        this.rootEndpoint.addClusterServer(createDefaultAccessControlClusterServer());\n\n        // TODO Get the defaults from the cluster meta details\n        this.rootEndpoint.addClusterServer(\n            ClusterServer(\n                GroupKeyManagementCluster,\n                {\n                    groupKeyMap: [],\n                    groupTable: [],\n                    maxGroupsPerFabric: 0, // TODO: Increase once we add group support, for now only IPK is supported\n                    maxGroupKeysPerFabric: 1,\n                },\n                GroupKeyManagementClusterHandler(),\n            ),\n        );\n\n        this.rootEndpoint.addClusterServer(\n            ClusterServer(\n                AdministratorCommissioningCluster,\n                {\n                    windowStatus: AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen,\n                    adminFabricIndex: null,\n                    adminVendorId: null,\n                },\n                AdministratorCommissioningHandler(),\n            ),\n        );\n\n        this.endpointStructure = new InteractionEndpointStructure();\n\n        // We must register this event before creating an InteractionServer so\n        // we initialize endpoint datasources before the InteractionServer\n        // processes events\n        this.endpointStructure.change.on(() => {\n            if (this.storage === undefined || this.eventHandler === undefined) {\n                throw new InternalError(\"Endpoint structure reports change prior to server initialization\");\n            }\n\n            for (const endpoint of this.endpointStructure.endpoints.values()) {\n                for (const cluster of (endpoint as Endpoint).getAllClusterServers()) {\n                    new CommissioningServerClusterDatasource(endpoint, cluster, this.storage, this.eventHandler);\n                }\n            }\n        });\n    }\n\n    /**\n     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterServer to get or undefined if not existing\n     */\n    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined {\n        return this.rootEndpoint.getClusterServer(cluster);\n    }\n\n    /**\n     * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterClient object to add\n     */\n    addRootClusterClient<const T extends ClusterType>(cluster: ClusterClientObj<T>) {\n        this.rootEndpoint.addClusterClient(cluster);\n    }\n\n    /**\n     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param cluster ClusterClient to get or undefined if not existing\n     */\n    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined {\n        return this.rootEndpoint.getClusterClient(cluster);\n    }\n\n    /**\n     * Get the root endpoint of the node.\n     */\n    getRootEndpoint() {\n        return this.rootEndpoint;\n    }\n\n    /**\n     * Add a child endpoint to the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param endpoint Endpoint to add\n     * @protected\n     */\n    protected addEndpoint(endpoint: Endpoint) {\n        this.rootEndpoint.addChildEndpoint(endpoint);\n    }\n\n    /**\n     * Get a child endpoint from the root endpoint. This is mainly used internally and not needed to be called by the user.\n     *\n     * @param endpointId Endpoint ID of the child endpoint to get\n     * @protected\n     */\n    protected getChildEndpoint(endpointId: EndpointNumber): Endpoint | undefined {\n        return this.rootEndpoint.getChildEndpoint(endpointId);\n    }\n\n    /**\n     * Add a new cluster server to the root endpoint\n     * BasicInformationCluster and OperationalCredentialsCluster cannot be added via this method because they are\n     * added in the constructor\n     *\n     * @param cluster\n     */\n    addRootClusterServer<const T extends ClusterType>(cluster: ClusterServerObj<T>) {\n        if (cluster.id === BasicInformationCluster.id) {\n            throw new ImplementationError(\n                \"BasicInformationCluster cannot be modified, provide all details in constructor options!\",\n            );\n        }\n        if (cluster.id === OperationalCredentialsCluster.id) {\n            throw new ImplementationError(\n                \"OperationalCredentialsCluster cannot be modified, provide the certificates in constructor options!\",\n            );\n        }\n        this.rootEndpoint.addClusterServer(cluster);\n    }\n\n    /**\n     * Advertise the node via all available interfaces (Ethernet/MDNS, BLE, ...) and start the commissioning process\n     *\n     * @param limitTo Limit the advertisement to the given discovery capabilities. Default is to advertise on ethernet\n     *                and BLE if configured\n     */\n    async advertise(limitTo?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>) {\n        if (\n            this.mdnsBroadcaster === undefined ||\n            this.mdnsScanner === undefined ||\n            this.storage === undefined ||\n            this.eventHandler === undefined ||\n            this.endpointStructureStorage === undefined ||\n            this.port === undefined\n        ) {\n            throw new ImplementationError(\"Add the node to the Matter instance before!\");\n        }\n\n        if (this.interactionServer !== undefined && this.deviceInstance !== undefined) {\n            logger.debug(\"Device already initialized, just advertise the instance again ...\");\n            await this.deviceInstance.announce();\n            return;\n        }\n\n        this.mdnsInstanceBroadcaster = this.mdnsBroadcaster.createInstanceBroadcaster(this.port);\n\n        this.rootEndpoint.addClusterServer(await createDefaultGeneralDiagnosticsClusterServer(this.commandHandler));\n\n        const basicInformation = this.getRootClusterServer(BasicInformationCluster);\n        if (basicInformation == undefined) {\n            throw new ImplementationError(\"BasicInformationCluster needs to be set!\");\n        }\n\n        this.interactionServer = new LegacyInteractionServer({\n            endpointStructure: this.endpointStructure,\n            subscriptionOptions: {\n                maxIntervalSeconds: this.options.subscriptionMaxIntervalSeconds,\n                minIntervalSeconds: this.options.subscriptionMinIntervalSeconds,\n                randomizationWindowSeconds: this.options.subscriptionRandomizationWindowSeconds,\n            },\n            maxPathsPerInvoke: basicInformation.getMaxPathsPerInvokeAttribute(),\n        });\n\n        this.nextEndpointId = this.endpointStructureStorage.get(\"nextEndpointId\", this.nextEndpointId);\n\n        this.assignEndpointIds(); // Make sure to have unique endpoint ids\n        this.rootEndpoint.updatePartsList(); // initialize parts list of all Endpoint objects with final IDs\n        this.rootEndpoint.setStructureChangedCallback(() => this.updateStructure()); // Make sure we get structure changes\n\n        this.endpointStructure.initializeFromEndpoint(this.rootEndpoint);\n\n        // TODO adjust later and refactor MatterDevice\n        const deviceInstance = await MatterDevice.create(\n            this.storage.createContext(\"SessionManager\"),\n            this.storage.createContext(\"FabricManager\"),\n            () => ({\n                productDescription: this.productDescription,\n                passcode: this.passcode,\n                discriminator: this.discriminator,\n                flowType: this.flowType,\n                additionalBleAdvertisementData: this.options.additionalBleAdvertisementData,\n\n                // We don't use this\n                ble: false,\n            }),\n            basicInformation.getCapabilityMinimaAttribute().caseSessionsPerFabric, // Internally it is \"Session and Node\", so we support even more\n            (fabricIndex: FabricIndex) => {\n                const fabricsCount = this.deviceInstance?.getFabrics().length ?? 0;\n                if (fabricsCount === 1) {\n                    // When first Fabric is added (aka initial commissioning) and we did not advertised on MDNS before, add broadcaster now\n                    // TODO Refactor this out when we remove MatterDevice class\n                    if (\n                        this.mdnsInstanceBroadcaster !== undefined &&\n                        !this.deviceInstance?.hasBroadcaster(this.mdnsInstanceBroadcaster)\n                    ) {\n                        this.deviceInstance?.addBroadcaster(this.mdnsInstanceBroadcaster);\n                    }\n                }\n                if (fabricsCount === 0) {\n                    // When last fabric gets deleted we do a factory reset\n                    this.factoryReset()\n                        .then(() => this.options.commissioningChangedCallback?.(fabricIndex))\n                        .catch(error => logger.error(\"Error while doing factory reset of the device\", error));\n                } else {\n                    this.options.commissioningChangedCallback?.(fabricIndex);\n                }\n            },\n            (fabricIndex: FabricIndex) => this.options.activeSessionsChangedCallback?.(fabricIndex),\n            { maxPathsPerInvoke: this.interactionServer.maxPathsPerInvoke },\n        );\n        deviceInstance.addTransportInterface(\n            await UdpInterface.create(Network.get(), \"udp6\", this.port, this.options.listeningAddressIpv6),\n        );\n        deviceInstance.addScanner(this.mdnsScanner);\n        deviceInstance.addProtocolHandler(this.interactionServer);\n        this.deviceInstance = deviceInstance;\n        if (!this.ipv4Disabled) {\n            deviceInstance.addTransportInterface(\n                await UdpInterface.create(Network.get(), \"udp4\", this.port, this.options.listeningAddressIpv4),\n            );\n        }\n\n        if (this.isCommissioned()) {\n            // Handle Backward compatibility to Matter.js before 0.9.1 and add the missing ACL entry if no entry was set\n            // so far by the controller\n            const fabrics = deviceInstance.getFabrics();\n            for (const fabric of fabrics) {\n                if (\n                    genericFabricScopedAttributeGetterFromFabric<AccessControl.AccessControlEntry[] | undefined>(\n                        fabric,\n                        AccessControl.Cluster,\n                        \"acl\",\n                        undefined,\n                    ) === undefined\n                ) {\n                    genericFabricScopedAttributeSetterForFabric(fabric, AccessControl.Cluster, \"acl\", [\n                        {\n                            fabricIndex: fabric.fabricIndex,\n                            privilege: AccessControl.AccessControlEntryPrivilege.Administer,\n                            authMode: AccessControl.AccessControlEntryAuthMode.Case,\n                            subjects: [fabric.rootNodeId],\n                            targets: null, // entire node\n                        },\n                    ]);\n                    logger.warn(\n                        \"Added missing ACL entry for fabric\",\n                        fabric.fabricIndex,\n                        \"for Node ID\",\n                        fabric.rootNodeId,\n                        \". This should only happen once after upgrading to matter.js 0.9.1\",\n                    );\n                }\n            }\n\n            limitTo = { onIpNetwork: true }; // If already commissioned the device is on network already\n        } else {\n            // BLE or SoftAP only relevant when not commissioned yet\n            try {\n                const ble = Ble.get();\n                deviceInstance.addTransportInterface(ble.getBlePeripheralInterface());\n                if (limitTo === undefined || limitTo.ble) {\n                    deviceInstance.addBroadcaster(ble.getBleBroadcaster(this.options.additionalBleAdvertisementData));\n                }\n            } catch (error) {\n                NoProviderError.accept(error);\n                logger.debug(\"Ble not enabled\");\n            }\n        }\n\n        if (limitTo === undefined || limitTo.onIpNetwork) {\n            deviceInstance.addBroadcaster(this.mdnsInstanceBroadcaster);\n        }\n\n        await deviceInstance.start();\n\n        // Send required events\n        basicInformation.triggerStartUpEvent({ softwareVersion: basicInformation.getSoftwareVersionAttribute() });\n\n        const generalDiagnostics = this.getRootClusterServer(GeneralDiagnosticsCluster);\n        if (generalDiagnostics !== undefined) {\n            this.getRootClusterServer(GeneralDiagnosticsCluster)?.triggerBootReasonEvent({\n                bootReason: generalDiagnostics.getBootReasonAttribute?.() ?? GeneralDiagnostics.BootReason.Unspecified,\n            });\n        }\n    }\n\n    updateStructure() {\n        logger.debug(\"Endpoint structure got updated ...\");\n        this.assignEndpointIds(); // Make sure to have unique endpoint ids\n        this.rootEndpoint.updatePartsList(); // update parts list of all Endpoint objects with final IDs\n        this.endpointStructure.initializeFromEndpoint(this.rootEndpoint); // Reinitialize the interaction server structure\n    }\n\n    getNextEndpointId(increase = true) {\n        if (increase) {\n            this.nextEndpointId++;\n        }\n        return this.nextEndpointId;\n    }\n\n    assignEndpointIds() {\n        const rootUniqueIdPrefix = this.rootEndpoint.determineUniqueID();\n        this.initializeEndpointIdsFromStorage(this.rootEndpoint, rootUniqueIdPrefix);\n        this.fillAndStoreEndpointIds(this.rootEndpoint, rootUniqueIdPrefix);\n        this.endpointStructureStorage?.set(\"nextEndpointId\", this.nextEndpointId);\n    }\n\n    private initializeEndpointIdsFromStorage(endpoint: Endpoint, parentUniquePrefix = \"\") {\n        if (this.endpointStructureStorage === undefined) {\n            throw new ImplementationError(\"Storage manager must be initialized to enable initialization from storage.\");\n        }\n        const endpoints = endpoint.getChildEndpoints();\n        for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {\n            let endpointUniquePrefix = parentUniquePrefix;\n            const endpoint = endpoints[endpointIndex];\n            const thisUniqueId = endpoint.determineUniqueID();\n            if (thisUniqueId === undefined) {\n                if (endpoint.number === undefined) {\n                    logger.debug(\n                        `No unique id found for endpoint on index ${endpointIndex} / device ${endpoint.name} - using index as unique identifier!`,\n                    );\n                }\n                endpointUniquePrefix += `${endpointUniquePrefix === \"\" ? \"\" : \"-\"}index_${endpointIndex}`;\n            } else {\n                endpointUniquePrefix += `${endpointUniquePrefix === \"\" ? \"\" : \"-\"}${thisUniqueId}`;\n            }\n\n            if (endpoint.number === undefined) {\n                if (this.endpointStructureStorage.has(endpointUniquePrefix)) {\n                    endpoint.number = this.endpointStructureStorage.get<EndpointNumber>(endpointUniquePrefix);\n                    logger.debug(\n                        `Restored endpoint id ${endpoint.number} for endpoint with ${endpointUniquePrefix} / device ${endpoint.name} from storage`,\n                    );\n                }\n            }\n            if (endpoint.number !== undefined && endpoint.number > this.nextEndpointId) {\n                this.nextEndpointId = EndpointNumber(endpoint.number + 1);\n            }\n            this.initializeEndpointIdsFromStorage(endpoint, endpointUniquePrefix);\n        }\n    }\n\n    private fillAndStoreEndpointIds(endpoint: Endpoint, parentUniquePrefix = \"\") {\n        if (this.endpointStructureStorage === undefined) {\n            throw new ImplementationError(\"endpointStructureStorage not set!\");\n        }\n        const endpoints = endpoint.getChildEndpoints();\n        for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {\n            let endpointUniquePrefix = parentUniquePrefix;\n            endpoint = endpoints[endpointIndex];\n            const thisUniqueId = endpoint.determineUniqueID();\n            if (thisUniqueId === undefined) {\n                endpointUniquePrefix += `${endpointUniquePrefix === \"\" ? \"\" : \"-\"}index_${endpointIndex}`;\n            } else {\n                endpointUniquePrefix += `${endpointUniquePrefix === \"\" ? \"\" : \"-\"}${thisUniqueId}`;\n            }\n\n            if (endpoint.number === undefined) {\n                endpoint.number = EndpointNumber(this.nextEndpointId++);\n                this.endpointStructureStorage.set(endpointUniquePrefix, endpoint.number);\n                logger.debug(\n                    `Assigned endpoint id ${endpoint.number} for endpoint with ${endpointUniquePrefix} / device ${endpoint.name} and stored it`,\n                );\n            }\n            this.fillAndStoreEndpointIds(endpoint, endpointUniquePrefix);\n        }\n    }\n\n    /**\n     * Return info if the device is paired with at least one controller\n     */\n    isCommissioned(): boolean {\n        return this.deviceInstance?.isCommissioned() ?? false;\n    }\n\n    /**\n     * Return the pairing information for the device\n     */\n    getPairingCode(\n        discoveryCapabilities?: TypeFromBitSchema<typeof DiscoveryCapabilitiesBitmap>,\n    ): DevicePairingInformation {\n        const basicInformation = this.getRootClusterServer(BasicInformationCluster);\n        if (basicInformation == undefined) {\n            throw new ImplementationError(\"BasicInformationCluster needs to be set!\");\n        }\n\n        const vendorId = basicInformation.attributes.vendorId.getLocal();\n        const productId = basicInformation.attributes.productId.getLocal();\n\n        let bleEnabled = false;\n        try {\n            bleEnabled = !!Ble.get();\n        } catch (error) {\n            // only ignore NoProviderError cases\n            NoProviderError.accept(error);\n        }\n\n        const qrPairingCode = QrPairingCodeCodec.encode([\n            {\n                version: 0,\n                vendorId: vendorId,\n                productId,\n                flowType: this.flowType,\n                discriminator: this.discriminator,\n                passcode: this.passcode,\n                discoveryCapabilities: DiscoveryCapabilitiesSchema.encode(\n                    discoveryCapabilities ?? {\n                        ble: bleEnabled,\n                        onIpNetwork: true,\n                    },\n                ),\n            },\n        ]);\n\n        return {\n            manualPairingCode: ManualPairingCodeCodec.encode({\n                discriminator: this.discriminator,\n                passcode: this.passcode,\n            }),\n            qrPairingCode,\n        };\n    }\n\n    /**\n     * Set the MDNS Scanner instance. Should be only used internally\n     *\n     * @param mdnsScanner MdnsScanner instance\n     */\n    setMdnsScanner(mdnsScanner: MdnsScanner) {\n        this.mdnsScanner = mdnsScanner;\n    }\n\n    /**\n     * Set the MDNS Broadcaster instance. Should be only used internally\n     *\n     * @param mdnsBroadcaster MdnsBroadcaster instance\n     */\n    setMdnsBroadcaster(mdnsBroadcaster: MdnsBroadcaster) {\n        if (this.port === undefined) {\n            throw new ImplementationError(\"Port must be set before setting the MDNS broadcaster!\");\n        }\n        this.mdnsBroadcaster = mdnsBroadcaster;\n    }\n\n    /**\n     * Set the StorageManager instance. Should be only used internally\n     * @param storage\n     */\n    async setStorage(storage: StorageContext<SyncStorage>) {\n        this.storage = storage;\n        this.endpointStructureStorage = this.storage.createContext(\"EndpointStructure\");\n        this.eventHandler = await EventHandler.create(this.storage.createContext(\"EventHandler\"));\n    }\n\n    /**\n     * Add a new device to the node\n     *\n     * @param device Device or Aggregator instance to add\n     */\n    addDevice(device: Device | Aggregator) {\n        this.addEndpoint(device);\n    }\n\n    /**\n     * Return the port the device is listening on\n     */\n    getPort(): number | undefined {\n        return this.port;\n    }\n\n    /** Set the port the device is listening on. Can only be called before the device is initialized. */\n    setPort(port: number) {\n        if (port === this.port) return;\n        if (this.deviceInstance !== undefined || this.mdnsInstanceBroadcaster !== undefined) {\n            throw new ImplementationError(\"Port cannot be changed after device is initialized!\");\n        }\n        this.port = port;\n    }\n\n    /**\n     * Close network connections of the device and stop responding to requests\n     */\n    async close() {\n        this.rootEndpoint.getClusterServer(BasicInformationCluster)?.triggerShutDownEvent?.();\n        await this.interactionServer?.close();\n        this.interactionServer = undefined;\n        this.endpointStructure.close();\n        await this.deviceInstance?.close();\n        this.deviceInstance = undefined;\n        await this.mdnsInstanceBroadcaster?.close();\n        this.mdnsInstanceBroadcaster = undefined;\n    }\n\n    async factoryReset() {\n        if (this.storage === undefined) {\n            throw new ImplementationError(\n                \"Storage not initialized. The instance was not added to a Matter instance yet.\",\n            );\n        }\n        const wasStarted = this.interactionServer !== undefined || this.deviceInstance !== undefined;\n        let fabrics = new Array<Fabric>();\n        if (wasStarted) {\n            fabrics = this.isCommissioned() ? (this.deviceInstance?.getFabrics() ?? []) : [];\n            await this.close();\n        }\n\n        this.storage.clearAll();\n\n        if (wasStarted) {\n            await this.advertise();\n            fabrics.forEach(fabric => this.options.commissioningChangedCallback?.(fabric.fabricIndex));\n        }\n        logger.info(`The device was factory reset${wasStarted ? \" and restarted\" : \"\"}.`);\n    }\n\n    /**\n     * Add a new command handler for the given command\n     *\n     * @param command Command to add the handler for\n     * @param handler Handler function to add\n     */\n    addCommandHandler<K extends keyof CommissioningServerCommands>(\n        command: K,\n        handler: CommissioningServerCommands[K],\n    ) {\n        this.commandHandler.addHandler(command, handler);\n    }\n\n    /**\n     * Remove a command handler for the given command\n     *\n     * @param command Command to remove the handler for\n     * @param handler Handler function to remove\n     */\n    removeCommandHandler<K extends keyof CommissioningServerCommands>(\n        command: K,\n        handler: CommissioningServerCommands[K],\n    ) {\n        this.commandHandler.removeHandler(command, handler);\n    }\n\n    /**\n     * Set the reachability of the commissioning server aka \"the main matter device\". This call only has effect when\n     * the reachability flag was set in the BasicInformationCluster or in the BasicInformation data in the constructor!\n     *\n     * @param reachable true if reachable, false otherwise\n     */\n    setReachability(reachable: boolean) {\n        const basicInformationCluster = this.getRootClusterServer(BasicInformationCluster);\n        if (basicInformationCluster === undefined) {\n            throw new ImplementationError(\"BasicInformationCluster needs to be set!\");\n        }\n        if (basicInformationCluster.attributes.reachable !== undefined) {\n            basicInformationCluster.setReachableAttribute(reachable);\n        }\n    }\n\n    /** used internally by MatterServer to initialize the state of the device. */\n    initialize(ipv4Disabled: boolean) {\n        if (this.ipv4Disabled !== undefined && this.ipv4Disabled !== ipv4Disabled) {\n            throw new ImplementationError(\n                \"Changing the IPv4 disabled flag after starting the device is not supported.\",\n            );\n        }\n        this.ipv4Disabled = ipv4Disabled;\n    }\n\n    /** Starts the Matter device and advertises it. */\n    async start() {\n        if (this.ipv4Disabled === undefined) {\n            throw new ImplementationError(\"Add the device to the MatterServer first.\");\n        }\n        if (this.delayedAnnouncement !== true) {\n            return this.advertise();\n        }\n    }\n\n    /**\n     * Get some basic details of all Fabrics the server is commissioned to.\n     *\n     * @param fabricIndex Optional fabric index to filter for. If not set all fabrics are returned.\n     */\n    getCommissionedFabricInformation(fabricIndex?: FabricIndex) {\n        if (!this.isCommissioned()) return [];\n        const allFabrics = this.deviceInstance?.getFabrics() ?? [];\n        const fabrics = fabricIndex === undefined ? allFabrics : allFabrics.filter(f => f.fabricIndex === fabricIndex);\n        return fabrics.map(fabric => fabric.externalInformation) ?? [];\n    }\n\n    /**\n     * Get some basic details of all currently active sessions.\n     *\n     * @param fabricIndex Optional fabric index to filter for. If not set all sessions are returned.\n     */\n    getActiveSessionInformation(fabricIndex?: FabricIndex) {\n        if (!this.isCommissioned()) return [];\n        const allSessions = this.deviceInstance?.getActiveSessionInformation() ?? [];\n        return allSessions.filter(({ fabric }) => fabricIndex === undefined || fabric?.fabricIndex === fabricIndex);\n    }\n}\n\nclass CommissioningServerClusterDatasource implements ClusterDatasource<SyncStorage> {\n    #version: number;\n    #clusterDescription: string;\n    #storage: StorageContext<SyncStorage>;\n    #eventHandler: EventHandler;\n\n    constructor(\n        endpoint: EndpointInterface,\n        cluster: ClusterServerObj,\n        storage: StorageContext<SyncStorage>,\n        eventHandler: EventHandler<SyncStorage>,\n    ) {\n        this.#eventHandler = eventHandler;\n        this.#clusterDescription = `cluster ${cluster.name} (${cluster.id})`;\n        this.#storage = storage = storage.createContext(`Cluster-${endpoint.number}-${cluster.id}`);\n\n        this.#version = cluster.datasource?.version ?? Crypto.getRandomUInt32();\n\n        for (const attributeName in cluster.attributes) {\n            const attribute = cluster.attributes[attributeName];\n            if (!attribute) {\n                // Shouldn't be possible\n                continue;\n            }\n            if (!this.#storage.has(attributeName)) continue;\n            try {\n                const value = storage.get<any>(attributeName);\n                logger.debug(`Restoring attribute ${attributeName} (${attribute.id}) in ${this.#clusterDescription}`);\n                attribute.init(value);\n            } catch (error) {\n                logger.warn(\n                    `Failed to restore attribute ${attributeName} (${attribute.id}) in ${this.#clusterDescription}`,\n                    error,\n                );\n                storage.delete(attribute.name); // Storage broken so we should delete it\n            }\n        }\n\n        cluster.datasource = this;\n    }\n\n    get version() {\n        return this.#version;\n    }\n\n    get eventHandler() {\n        return this.#eventHandler;\n    }\n\n    increaseVersion(): number {\n        if (this.#version === 0xffffffff) {\n            this.#version = -1;\n        }\n        return ++this.#version;\n    }\n\n    changed(attributeName: string, value: SupportedStorageTypes) {\n        if (value === undefined) return;\n        logger.debug(`Storing attribute ${attributeName} in ${this.#clusterDescription}`);\n        this.#storage?.set(attributeName, value);\n    }\n}\n"],
  "mappings": "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",
  "names": ["endpoint"]
}
