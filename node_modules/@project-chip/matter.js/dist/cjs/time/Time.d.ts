/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic } from "../log/Diagnostic.js";
export type TimerCallback = () => any;
export declare abstract class Time {
    static get: () => Time;
    abstract now(): Date;
    static readonly now: () => Date;
    abstract nowMs(): number;
    static readonly nowMs: () => number;
    /** Returns a timer that will call callback after durationMs has passed. */
    abstract getTimer(name: string, durationMs: number, callback: TimerCallback): Timer;
    static readonly getTimer: (name: string, durationMs: number, callback: TimerCallback) => Timer;
    /** Returns a timer that will periodically call callback at intervalMs intervals. */
    abstract getPeriodicTimer(name: string, intervalMs: number, callback: TimerCallback): Timer;
    static readonly getPeriodicTimer: (name: string, intervalMs: number, callback: TimerCallback) => Timer;
    static readonly sleep: (name: string, durationMs: number) => Promise<void>;
    static register(timer: Timer): void;
    static unregister(timer: Timer): void;
}
export interface Timer {
    /** Name (diagnostics) */
    name: string;
    /** Set to true to indicate the timer should not prevent program exit */
    utility: boolean;
    /** System ID (diagnostics) */
    systemId: unknown;
    /** Interval (diagnostics) */
    intervalMs: number;
    /** Is the timer periodic? (diagnostics) */
    isPeriodic: boolean;
    /** Amount of time interval has been active (diagnostics) */
    elapsed?: Diagnostic.Elapsed;
    /** Is true if this timer is running. */
    isRunning: boolean;
    /** Starts this timer, chainable. */
    start(): Timer;
    /** Stops this timer, chainable. */
    stop(): Timer;
}
//# sourceMappingURL=Time.d.ts.map