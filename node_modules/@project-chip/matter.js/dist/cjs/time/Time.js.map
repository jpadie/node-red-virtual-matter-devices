{
  "version": 3,
  "sources": ["../../../src/time/Time.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NoProviderError } from \"../common/MatterError.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { DiagnosticSource } from \"../log/DiagnosticSource.js\";\n\nexport type TimerCallback = () => any;\n\nconst registry = new Set<Timer>();\n\nexport abstract class Time {\n    static get: () => Time = () => DefaultTime;\n\n    abstract now(): Date;\n    static readonly now = (): Date => Time.get().now();\n\n    abstract nowMs(): number;\n    static readonly nowMs = (): number => Time.get().nowMs();\n\n    /** Returns a timer that will call callback after durationMs has passed. */\n    abstract getTimer(name: string, durationMs: number, callback: TimerCallback): Timer;\n    static readonly getTimer = (name: string, durationMs: number, callback: TimerCallback): Timer =>\n        Time.get().getTimer(name, durationMs, callback);\n\n    /** Returns a timer that will periodically call callback at intervalMs intervals. */\n    abstract getPeriodicTimer(name: string, intervalMs: number, callback: TimerCallback): Timer;\n    static readonly getPeriodicTimer = (name: string, intervalMs: number, callback: TimerCallback): Timer =>\n        Time.get().getPeriodicTimer(name, intervalMs, callback);\n\n    static readonly sleep = async (name: string, durationMs: number): Promise<void> =>\n        new Promise(resolve => Time.get().getTimer(name, durationMs, resolve).start());\n\n    static register(timer: Timer) {\n        timer.elapsed = Diagnostic.elapsed();\n        registry.add(timer);\n    }\n\n    static unregister(timer: Timer) {\n        registry.delete(timer);\n    }\n}\n\nconst DefaultTime = new (class extends Time {\n    now() {\n        return new Date();\n    }\n\n    nowMs() {\n        return this.now().getTime();\n    }\n\n    getTimer(): Timer {\n        throw new NoProviderError(\"Default time provider does not implement timers\");\n    }\n\n    getPeriodicTimer() {\n        return this.getTimer();\n    }\n})();\n\nexport interface Timer {\n    /** Name (diagnostics) */\n    name: string;\n\n    /** Set to true to indicate the timer should not prevent program exit */\n    utility: boolean;\n\n    /** System ID (diagnostics) */\n    systemId: unknown;\n\n    /** Interval (diagnostics) */\n    intervalMs: number;\n\n    /** Is the timer periodic? (diagnostics) */\n    isPeriodic: boolean;\n\n    /** Amount of time interval has been active (diagnostics) */\n    elapsed?: Diagnostic.Elapsed;\n\n    /** Is true if this timer is running. */\n    isRunning: boolean;\n\n    /** Starts this timer, chainable. */\n    start(): Timer;\n\n    /** Stops this timer, chainable. */\n    stop(): Timer;\n}\n\n// Hook for testing frameworks\nif (typeof MatterHooks !== \"undefined\") {\n    MatterHooks.timeSetup?.(Time);\n}\n\nDiagnosticSource.add({\n    get [Diagnostic.value]() {\n        return Diagnostic.node(\"\u23F1\", \"Timers\", {\n            children: [...registry].map(timer => [\n                timer.name,\n                Diagnostic.dict({\n                    periodic: timer.isPeriodic,\n                    interval: Diagnostic.interval(timer.intervalMs),\n                    system: timer.systemId,\n                    elapsed: timer.elapsed,\n                }),\n            ]),\n        });\n    },\n});\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,yBAAgC;AAChC,wBAA2B;AAC3B,8BAAiC;AARjC;AAAA;AAAA;AAAA;AAAA;AAYA,MAAM,WAAW,oBAAI,IAAW;AAEzB,MAAe,KAAK;AAAA,EACvB,OAAO,MAAkB,MAAM;AAAA,EAG/B,OAAgB,MAAM,MAAY,KAAK,IAAI,EAAE,IAAI;AAAA,EAGjD,OAAgB,QAAQ,MAAc,KAAK,IAAI,EAAE,MAAM;AAAA,EAIvD,OAAgB,WAAW,CAAC,MAAc,YAAoB,aAC1D,KAAK,IAAI,EAAE,SAAS,MAAM,YAAY,QAAQ;AAAA,EAIlD,OAAgB,mBAAmB,CAAC,MAAc,YAAoB,aAClE,KAAK,IAAI,EAAE,iBAAiB,MAAM,YAAY,QAAQ;AAAA,EAE1D,OAAgB,QAAQ,OAAO,MAAc,eACzC,IAAI,QAAQ,aAAW,KAAK,IAAI,EAAE,SAAS,MAAM,YAAY,OAAO,EAAE,MAAM,CAAC;AAAA,EAEjF,OAAO,SAAS,OAAc;AAC1B,UAAM,UAAU,6BAAW,QAAQ;AACnC,aAAS,IAAI,KAAK;AAAA,EACtB;AAAA,EAEA,OAAO,WAAW,OAAc;AAC5B,aAAS,OAAO,KAAK;AAAA,EACzB;AACJ;AAEA,MAAM,cAAc,IAAK,cAAc,KAAK;AAAA,EACxC,MAAM;AACF,WAAO,oBAAI,KAAK;AAAA,EACpB;AAAA,EAEA,QAAQ;AACJ,WAAO,KAAK,IAAI,EAAE,QAAQ;AAAA,EAC9B;AAAA,EAEA,WAAkB;AACd,UAAM,IAAI,mCAAgB,iDAAiD;AAAA,EAC/E;AAAA,EAEA,mBAAmB;AACf,WAAO,KAAK,SAAS;AAAA,EACzB;AACJ,EAAG;AAgCH,IAAI,OAAO,gBAAgB,aAAa;AACpC,cAAY,YAAY,IAAI;AAChC;AAEA,yCAAiB,IAAI;AAAA,EACjB,KAAK,6BAAW,KAAK,IAAI;AACrB,WAAO,6BAAW,KAAK,UAAK,UAAU;AAAA,MAClC,UAAU,CAAC,GAAG,QAAQ,EAAE,IAAI,WAAS;AAAA,QACjC,MAAM;AAAA,QACN,6BAAW,KAAK;AAAA,UACZ,UAAU,MAAM;AAAA,UAChB,UAAU,6BAAW,SAAS,MAAM,UAAU;AAAA,UAC9C,QAAQ,MAAM;AAAA,UACd,SAAS,MAAM;AAAA,QACnB,CAAC;AAAA,MACL,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AACJ,CAAC;",
  "names": []
}
