"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var RootCertificateManager_exports = {};
__export(RootCertificateManager_exports, {
  RootCertificateManager: () => RootCertificateManager
});
module.exports = __toCommonJS(RootCertificateManager_exports);
var import_Crypto = require("../crypto/Crypto.js");
var import_Key = require("../crypto/Key.js");
var import_Logger = require("../log/Logger.js");
var import_StorageContext = require("../storage/StorageContext.js");
var import_Time = require("../time/Time.js");
var import_ByteArray = require("../util/ByteArray.js");
var import_Construction = require("../util/Construction.js");
var import_Number = require("../util/Number.js");
var import_CertificateManager = require("./CertificateManager.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("RootCertificateManager");
class RootCertificateManager {
  rootCertId = BigInt(0);
  rootKeyPair = import_Crypto.Crypto.createKeyPair();
  rootKeyIdentifier = import_Crypto.Crypto.hash(this.rootKeyPair.publicKey).slice(0, 20);
  rootCertBytes = this.generateRootCert();
  nextCertificateId = BigInt(1);
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(options) {
    return (0, import_Construction.asyncNew)(RootCertificateManager, options);
  }
  constructor(options) {
    this.#construction = (0, import_Construction.Construction)(this, async () => {
      const certValues = options instanceof import_StorageContext.StorageContext ? await options.values() : options;
      if (typeof certValues.rootCertId === "bigint" && (ArrayBuffer.isView(certValues.rootKeyPair) || typeof certValues.rootKeyPair === "object") && ArrayBuffer.isView(certValues.rootKeyIdentifier) && ArrayBuffer.isView(certValues.rootCertBytes) && (typeof certValues.nextCertificateId === "number" || typeof certValues.nextCertificateId === "bigint")) {
        this.rootCertId = BigInt(certValues.rootCertId);
        this.rootKeyPair = (0, import_Key.PrivateKey)(certValues.rootKeyPair);
        this.rootKeyIdentifier = certValues.rootKeyIdentifier;
        this.rootCertBytes = certValues.rootCertBytes;
        this.nextCertificateId = BigInt(certValues.nextCertificateId);
        logger.debug(`Loaded root certificate with ID ${this.rootCertId} from storage`);
        return;
      }
      logger.debug(`Created new root certificate with ID ${this.rootCertId}`);
      if (options instanceof import_StorageContext.StorageContext) {
        await options.set({
          rootCertId: this.rootCertId,
          rootKeyPair: this.rootKeyPair.keyPair,
          rootKeyIdentifier: this.rootKeyIdentifier,
          rootCertBytes: this.rootCertBytes,
          nextCertificateId: this.nextCertificateId
        });
      }
    });
  }
  get rootCert() {
    return this.rootCertBytes;
  }
  get data() {
    return {
      rootCertId: this.rootCertId,
      rootKeyPair: this.rootKeyPair.keyPair,
      rootKeyIdentifier: this.rootKeyIdentifier,
      rootCertBytes: this.rootCertBytes,
      nextCertificateId: this.nextCertificateId
    };
  }
  generateRootCert() {
    const now = import_Time.Time.get().now();
    const unsignedCertificate = {
      serialNumber: import_ByteArray.ByteArray.fromHex((0, import_Number.toHex)(this.rootCertId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: { rcacId: this.rootCertId },
      notBefore: (0, import_CertificateManager.jsToMatterDate)(now, -1),
      notAfter: (0, import_CertificateManager.jsToMatterDate)(now, 10),
      subject: { rcacId: this.rootCertId },
      ellipticCurvePublicKey: this.rootKeyPair.publicKey,
      extensions: {
        basicConstraints: { isCa: true },
        keyUsage: {
          keyCertSign: true,
          cRLSign: true
        },
        subjectKeyIdentifier: this.rootKeyIdentifier,
        authorityKeyIdentifier: this.rootKeyIdentifier
      }
    };
    const signature = import_Crypto.Crypto.sign(this.rootKeyPair, import_CertificateManager.CertificateManager.rootCertToAsn1(unsignedCertificate));
    return import_CertificateManager.TlvRootCertificate.encode({ ...unsignedCertificate, signature });
  }
  generateNoc(publicKey, fabricId, nodeId, caseAuthenticatedTags) {
    const now = import_Time.Time.get().now();
    const certId = this.nextCertificateId++;
    const unsignedCertificate = {
      serialNumber: import_ByteArray.ByteArray.fromHex((0, import_Number.toHex)(certId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: { rcacId: this.rootCertId },
      notBefore: (0, import_CertificateManager.jsToMatterDate)(now, -1),
      notAfter: (0, import_CertificateManager.jsToMatterDate)(now, 10),
      subject: { fabricId, nodeId, caseAuthenticatedTags },
      ellipticCurvePublicKey: publicKey,
      extensions: {
        basicConstraints: { isCa: false },
        keyUsage: {
          digitalSignature: true
        },
        extendedKeyUsage: [2, 1],
        subjectKeyIdentifier: import_Crypto.Crypto.hash(publicKey).slice(0, 20),
        authorityKeyIdentifier: this.rootKeyIdentifier
      }
    };
    const signature = import_Crypto.Crypto.sign(
      this.rootKeyPair,
      import_CertificateManager.CertificateManager.nodeOperationalCertToAsn1(unsignedCertificate)
    );
    return import_CertificateManager.TlvOperationalCertificate.encode({ ...unsignedCertificate, signature });
  }
}
//# sourceMappingURL=RootCertificateManager.js.map
