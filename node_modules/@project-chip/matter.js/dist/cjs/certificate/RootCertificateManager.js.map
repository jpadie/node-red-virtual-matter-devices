{
  "version": 3,
  "sources": ["../../../src/certificate/RootCertificateManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { BinaryKeyPair, PrivateKey } from \"../crypto/Key.js\";\nimport { CaseAuthenticatedTag } from \"../datatype/CaseAuthenticatedTag.js\";\nimport { FabricId } from \"../datatype/FabricId.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { StorageContext } from \"../storage/StorageContext.js\";\nimport { Time } from \"../time/Time.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { Construction, asyncNew } from \"../util/Construction.js\";\nimport { toHex } from \"../util/Number.js\";\nimport {\n    CertificateManager,\n    OperationalCertificate,\n    RootCertificate,\n    TlvOperationalCertificate,\n    TlvRootCertificate,\n    Unsigned,\n    jsToMatterDate,\n} from \"./CertificateManager.js\";\n\nconst logger = Logger.get(\"RootCertificateManager\");\n\nexport class RootCertificateManager {\n    private rootCertId = BigInt(0);\n    private rootKeyPair = Crypto.createKeyPair();\n    private rootKeyIdentifier = Crypto.hash(this.rootKeyPair.publicKey).slice(0, 20);\n    private rootCertBytes = this.generateRootCert();\n    private nextCertificateId = BigInt(1);\n    #construction: Construction<RootCertificateManager>;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    static async create(options: StorageContext | RootCertificateManager.Data) {\n        return asyncNew(RootCertificateManager, options);\n    }\n\n    constructor(options: StorageContext | RootCertificateManager.Data) {\n        this.#construction = Construction(this, async () => {\n            // Use provided root certificate data or read from storage if we have them stored, else store the just generated data\n            const certValues = options instanceof StorageContext ? await options.values() : options;\n\n            if (\n                typeof certValues.rootCertId === \"bigint\" &&\n                (ArrayBuffer.isView(certValues.rootKeyPair) || typeof certValues.rootKeyPair === \"object\") &&\n                ArrayBuffer.isView(certValues.rootKeyIdentifier) &&\n                ArrayBuffer.isView(certValues.rootCertBytes) &&\n                (typeof certValues.nextCertificateId === \"number\" || typeof certValues.nextCertificateId === \"bigint\")\n            ) {\n                this.rootCertId = BigInt(certValues.rootCertId);\n                this.rootKeyPair = PrivateKey(certValues.rootKeyPair as BinaryKeyPair);\n                this.rootKeyIdentifier = certValues.rootKeyIdentifier;\n                this.rootCertBytes = certValues.rootCertBytes;\n                this.nextCertificateId = BigInt(certValues.nextCertificateId);\n                logger.debug(`Loaded root certificate with ID ${this.rootCertId} from storage`);\n                return;\n            }\n\n            logger.debug(`Created new root certificate with ID ${this.rootCertId}`);\n\n            if (options instanceof StorageContext) {\n                await options.set({\n                    rootCertId: this.rootCertId,\n                    rootKeyPair: this.rootKeyPair.keyPair,\n                    rootKeyIdentifier: this.rootKeyIdentifier,\n                    rootCertBytes: this.rootCertBytes,\n                    nextCertificateId: this.nextCertificateId,\n                });\n            }\n        });\n    }\n\n    get rootCert() {\n        return this.rootCertBytes;\n    }\n\n    get data(): RootCertificateManager.Data {\n        return {\n            rootCertId: this.rootCertId,\n            rootKeyPair: this.rootKeyPair.keyPair,\n            rootKeyIdentifier: this.rootKeyIdentifier,\n            rootCertBytes: this.rootCertBytes,\n            nextCertificateId: this.nextCertificateId,\n        };\n    }\n\n    private generateRootCert() {\n        const now = Time.get().now();\n        const unsignedCertificate: Unsigned<RootCertificate> = {\n            serialNumber: ByteArray.fromHex(toHex(this.rootCertId)),\n            signatureAlgorithm: 1 /* EcdsaWithSHA256 */,\n            publicKeyAlgorithm: 1 /* EC */,\n            ellipticCurveIdentifier: 1 /* P256v1 */,\n            issuer: { rcacId: this.rootCertId },\n            notBefore: jsToMatterDate(now, -1),\n            notAfter: jsToMatterDate(now, 10),\n            subject: { rcacId: this.rootCertId },\n            ellipticCurvePublicKey: this.rootKeyPair.publicKey,\n            extensions: {\n                basicConstraints: { isCa: true },\n                keyUsage: {\n                    keyCertSign: true,\n                    cRLSign: true,\n                },\n                subjectKeyIdentifier: this.rootKeyIdentifier,\n                authorityKeyIdentifier: this.rootKeyIdentifier,\n            },\n        };\n        const signature = Crypto.sign(this.rootKeyPair, CertificateManager.rootCertToAsn1(unsignedCertificate));\n        return TlvRootCertificate.encode({ ...unsignedCertificate, signature });\n    }\n\n    generateNoc(\n        publicKey: ByteArray,\n        fabricId: FabricId,\n        nodeId: NodeId,\n        caseAuthenticatedTags?: CaseAuthenticatedTag[],\n    ) {\n        const now = Time.get().now();\n        const certId = this.nextCertificateId++;\n        const unsignedCertificate: Unsigned<OperationalCertificate> = {\n            serialNumber: ByteArray.fromHex(toHex(certId)),\n            signatureAlgorithm: 1 /* EcdsaWithSHA256 */,\n            publicKeyAlgorithm: 1 /* EC */,\n            ellipticCurveIdentifier: 1 /* P256v1 */,\n            issuer: { rcacId: this.rootCertId },\n            notBefore: jsToMatterDate(now, -1),\n            notAfter: jsToMatterDate(now, 10),\n            subject: { fabricId, nodeId, caseAuthenticatedTags },\n            ellipticCurvePublicKey: publicKey,\n            extensions: {\n                basicConstraints: { isCa: false },\n                keyUsage: {\n                    digitalSignature: true,\n                },\n                extendedKeyUsage: [2, 1],\n                subjectKeyIdentifier: Crypto.hash(publicKey).slice(0, 20),\n                authorityKeyIdentifier: this.rootKeyIdentifier,\n            },\n        };\n\n        const signature = Crypto.sign(\n            this.rootKeyPair,\n            CertificateManager.nodeOperationalCertToAsn1(unsignedCertificate),\n        );\n\n        return TlvOperationalCertificate.encode({ ...unsignedCertificate, signature });\n    }\n}\n\nexport namespace RootCertificateManager {\n    export type Data = {\n        rootCertId: bigint;\n        rootKeyPair: BinaryKeyPair;\n        rootKeyIdentifier: ByteArray;\n        rootCertBytes: ByteArray;\n        nextCertificateId: bigint;\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
