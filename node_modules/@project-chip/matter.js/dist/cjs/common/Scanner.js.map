{
  "version": 3,
  "sources": ["../../../src/common/Scanner.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { VendorId } from \"../datatype/VendorId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { ServerAddress, ServerAddressIp } from \"./ServerAddress.js\";\n\n/**\n * All information exposed by a commissionable device via announcements.\n * The properties are named identical as in the Matter specification.\n */\nexport type DiscoveryData = {\n    /** VendorId + ProductId */\n    VP?: string;\n\n    /** Device type */\n    DT?: number;\n\n    /** Device advertising name */\n    DN?: string;\n\n    /** Rotating device identifier */\n    RI?: string;\n\n    /** Pairing hint */\n    PH?: number;\n\n    /** Pairing instructions */\n    PI?: string;\n\n    /** Sleep Idle Interval */\n    SII?: number;\n\n    /** Sleep Active Interval */\n    SAI?: number;\n\n    /** Session active threshold */\n    SAT?: number;\n\n    /** TCP supported */\n    T?: number;\n\n    /** ICD Long Idle Time operating mode supported */\n    ICD?: number;\n};\n\nexport type DiscoverableDevice<SA extends ServerAddress> = DiscoveryData & {\n    /** The device's addresses IP/port pairs */\n    addresses: SA[];\n};\n\nexport type AddressTypeFromDevice<D extends DiscoverableDevice<any>> =\n    D extends DiscoverableDevice<infer SA> ? SA : never;\n\nexport type OperationalDevice = DiscoverableDevice<ServerAddressIp> & {\n    deviceIdentifier: string;\n};\n\nexport type CommissionableDevice = DiscoverableDevice<ServerAddress> & {\n    deviceIdentifier: string;\n\n    /** Discriminator */\n    D: number;\n\n    /** Commissioning Mode */\n    CM: number;\n};\n\n/**\n * Identifier to use to discover a commissionable device.\n * Please decide for the best matching identifier that you have.\n */\nexport type CommissionableDeviceIdentifiers =\n    | {\n          /** Instance ID of the commissionable device. This is mainly used by UDC. */\n          instanceId: string;\n      }\n    | {\n          /** The Long Discriminator of the commissionable device that can be obtained from the QR code. */\n          longDiscriminator: number;\n      }\n    | {\n          /** The Short Discriminator of the commissionable device that can be obtained from the Pairing code. */\n          shortDiscriminator: number;\n      }\n    | {\n          /** The vendor ID of the commissionable device, if devices from a special vendor should be discovered. */\n          vendorId: VendorId;\n      }\n    | {\n          /** The device type of the commissionable device, if devices of a special type should be discovered. */\n          deviceType: number;\n      }\n    | {\n          /** The product ID of the commissionable device, if devices with a special product should be discovered. */\n          productId: number;\n      }\n    | {\n          /** Pass empty object to discover any commissionable device. */\n          [K in any]: never; // aka \"empty object\" for just discovering any commisionable device\n      };\n\nexport interface Scanner {\n    /**\n     * Send DNS-SD queries to discover the current addresses of an operational paired device by its operational ID\n     * and return them.\n     */\n    findOperationalDevice(\n        fabric: Fabric,\n        nodeId: NodeId,\n        timeoutSeconds?: number,\n        ignoreExistingRecords?: boolean,\n    ): Promise<OperationalDevice | undefined>;\n\n    /**\n     * Return already discovered addresses of an operational paired device and return them. Does not send out new\n     * DNS-SD queries.\n     */\n    getDiscoveredOperationalDevice(fabric: Fabric, nodeId: NodeId): OperationalDevice | undefined;\n\n    /**\n     * Send DNS-SD queries to discover commissionable devices by a provided identifier (e.g. discriminator,\n     * vendorId, etc.) and returns as soon as minimum one was found or the timeout is over.\n     */\n    findCommissionableDevices(\n        identifier: CommissionableDeviceIdentifiers,\n        timeoutSeconds?: number,\n        ignoreExistingRecords?: boolean,\n    ): Promise<CommissionableDevice[]>;\n\n    /**\n     * Send DNS-SD queries to discover commissionable devices by a provided identifier (e.g. discriminator,\n     * vendorId, etc.) and returns after the timeout is over. For each new discovered device the provided callback is\n     * called when it is discovered.\n     */\n    findCommissionableDevicesContinuously(\n        identifier: CommissionableDeviceIdentifiers,\n        callback: (device: CommissionableDevice) => void,\n        timeoutSeconds?: number,\n    ): Promise<CommissionableDevice[]>;\n\n    /** Return already discovered commissionable devices and return them. Does not send out new DNS-SD queries. */\n    getDiscoveredCommissionableDevices(identifier: CommissionableDeviceIdentifiers): CommissionableDevice[];\n\n    /**\n     * Cancel a running discovery of commissionable devices. The waiter promises are resolved as if the timeout would\n     * be over.\n     */\n    cancelCommissionableDeviceDiscovery(identifier: CommissionableDeviceIdentifiers): void;\n\n    /** Close the scanner server and free resources. */\n    close(): void;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
