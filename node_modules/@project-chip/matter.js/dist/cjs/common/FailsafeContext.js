"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FailsafeContext_exports = {};
__export(FailsafeContext_exports, {
  FailsafeContext: () => FailsafeContext,
  MatterFabricInvalidAdminSubjectError: () => MatterFabricInvalidAdminSubjectError
});
module.exports = __toCommonJS(FailsafeContext_exports);
var import_CaseAuthenticatedTag = require("../datatype/CaseAuthenticatedTag.js");
var import_NodeId = require("../datatype/NodeId.js");
var import_Fabric = require("../fabric/Fabric.js");
var import_Logger = require("../log/Logger.js");
var import_Construction = require("../util/Construction.js");
var import_Observable = require("../util/Observable.js");
var import_FailsafeTimer = require("./FailsafeTimer.js");
var import_MatterError = require("./MatterError.js");
var import_ValidationError = require("./ValidationError.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("FailsafeContext");
class MatterFabricInvalidAdminSubjectError extends import_MatterError.MatterFlowError {
}
class FailsafeContext {
  #sessions;
  #fabrics;
  #failsafe;
  #construction;
  #associatedFabric;
  #csrSessionId;
  #forUpdateNoc;
  #fabricBuilder = new import_Fabric.FabricBuilder();
  #commissioned = (0, import_Observable.AsyncObservable)();
  constructor(options) {
    const { expiryLengthSeconds, associatedFabric, maxCumulativeFailsafeSeconds } = options;
    this.#sessions = options.sessions;
    this.#fabrics = options.fabrics;
    this.#associatedFabric = options.associatedFabric;
    this.#construction = (0, import_Construction.Construction)(this, async () => {
      await Promise.resolve();
      await this.storeEndpointState();
      this.#failsafe = new import_FailsafeTimer.FailsafeTimer(
        associatedFabric,
        expiryLengthSeconds,
        maxCumulativeFailsafeSeconds,
        () => this.#failSafeExpired()
      );
      logger.debug(`Arm failSafe timer for ${expiryLengthSeconds}s.`);
    });
  }
  async extend(fabric, expiryLengthSeconds) {
    await this.#construction;
    await this.#failsafe?.reArm(fabric, expiryLengthSeconds);
    if (expiryLengthSeconds > 0) {
      logger.debug(`Extend failSafe timer for ${expiryLengthSeconds}s.`);
    }
  }
  get fabricIndex() {
    return this.#fabricBuilder.fabricIndex;
  }
  get construction() {
    return this.#construction;
  }
  get commissioned() {
    return this.#commissioned;
  }
  get associatedFabric() {
    return this.#associatedFabric;
  }
  get csrSessionId() {
    return this.#csrSessionId;
  }
  get forUpdateNoc() {
    return this.#forUpdateNoc;
  }
  get hasRootCert() {
    return this.#fabricBuilder.hasRootCert();
  }
  get rootCert() {
    return this.#fabricBuilder.rootCert;
  }
  async completeCommission() {
    if (this.#failsafe === void 0) {
      throw new import_MatterError.MatterFlowError("armFailSafe should be called first!");
    }
    this.#failsafe.complete();
    if (this.fabricIndex !== void 0) {
      await this.#fabrics.persistFabrics();
    }
    this.#failsafe = void 0;
    await this.commissioned.emit();
    await this.removePaseSession();
    await this.close();
  }
  getFailSafeContext() {
    if (this.#failsafe === void 0) throw new import_MatterError.MatterFlowError("armFailSafe should be called first!");
    return this.#failsafe;
  }
  getNextFabricIndex() {
    return this.#fabrics.getNextFabricIndex();
  }
  async addFabric(fabric) {
    this.#fabrics.addFabric(fabric);
    if (this.#failsafe !== void 0) {
      this.#associatedFabric = this.#failsafe.associatedFabric = fabric;
    }
    return fabric.fabricIndex;
  }
  async updateFabric(fabric) {
    await this.#fabrics.updateFabric(fabric);
    await this.#sessions.updateFabricForResumptionRecords(fabric);
  }
  /**
   * Handles a CSR from OperationalCredentials cluster and stores additional internal information for further
   * validity checks.
   */
  createCertificateSigningRequest(isForUpdateNoc, sessionId) {
    if (this.#fabrics.findByKeypair(this.#fabricBuilder.keyPair)) {
      throw new import_MatterError.MatterFlowError("Key pair already exists.");
    }
    const result = this.#fabricBuilder.createCertificateSigningRequest();
    this.#csrSessionId = sessionId;
    this.#forUpdateNoc = isForUpdateNoc;
    return result;
  }
  async removePaseSession() {
    const session = this.#sessions.getPaseSession();
    if (session) {
      await session.close(true);
    }
  }
  async close() {
    await this.#construction;
    await this.#construction.close(async () => {
      if (this.#failsafe) {
        await this.#failsafe.close();
        this.#failsafe = void 0;
        await this.rollback();
      }
    });
  }
  /** Handles adding a trusted root certificate from Operational Credentials cluster. */
  setRootCert(rootCert) {
    this.#fabricBuilder.setRootCert(rootCert);
  }
  /**
   * Build a new Fabric object based on an existing fabric for the "UpdateNoc" case of the Operational Credentials
   * cluster.
   */
  async buildUpdatedFabric(nocValue, icacValue) {
    if (this.associatedFabric === void 0) {
      throw new import_MatterError.MatterFlowError("No fabric associated with failsafe context, but we prepare an Fabric update.");
    }
    this.#fabricBuilder.initializeFromFabricForUpdate(this.associatedFabric);
    this.#fabricBuilder.setOperationalCert(nocValue, icacValue);
    return await this.#fabricBuilder.build(this.associatedFabric.fabricIndex);
  }
  /** Build a new Fabric object for a new fabric for the "AddNoc" case of the Operational Credentials cluster. */
  async buildFabric(nocData) {
    const builder = this.#fabricBuilder;
    const { nocValue, icacValue, adminVendorId, ipkValue, caseAdminSubject } = nocData;
    if (!import_NodeId.NodeId.isOperationalNodeId(caseAdminSubject) && !import_NodeId.NodeId.isCaseAuthenticatedTag(caseAdminSubject)) {
      try {
        if (import_CaseAuthenticatedTag.CaseAuthenticatedTag.getVersion(import_NodeId.NodeId.extractAsCaseAuthenticatedTag(caseAdminSubject)) === 0) {
          throw new MatterFabricInvalidAdminSubjectError();
        }
      } catch (error) {
        if (error instanceof import_ValidationError.ValidationError || error instanceof import_MatterError.UnexpectedDataError) {
          throw new MatterFabricInvalidAdminSubjectError();
        } else {
          throw error;
        }
      }
    }
    builder.setOperationalCert(nocValue, icacValue);
    const fabricAlreadyExisting = this.#fabrics.getFabrics().find((fabric) => builder.matchesToFabric(fabric));
    if (fabricAlreadyExisting) {
      throw new import_FailsafeTimer.MatterFabricConflictError(
        `Fabric with Id ${builder.fabricId} and Node Id ${builder.nodeId} already exists.`
      );
    }
    return builder.setRootVendorId(adminVendorId).setIdentityProtectionKey(ipkValue).setRootNodeId(caseAdminSubject).build(this.#fabrics.getNextFabricIndex());
  }
  async #failSafeExpired() {
    logger.info("Failsafe timer expired, Reset fabric builder.");
    await this.close();
  }
  async rollback() {
    if (this.fabricIndex !== void 0 && !this.#forUpdateNoc) {
      logger.debug(`Revoking fabric with index ${this.fabricIndex}`);
      await this.#fabrics.revokeFabric(this.fabricIndex);
    }
    await this.removePaseSession();
    let fabric = void 0;
    if (this.fabricIndex !== void 0) {
      const fabricIndex = this.fabricIndex;
      fabric = this.#fabrics.getFabrics().find((fabric2) => fabric2.fabricIndex === fabricIndex);
      if (fabric !== void 0) {
        const session = this.#sessions.getSessionForNode(fabric, fabric.rootNodeId);
        if (session !== void 0 && session.isSecure) {
          await session.close(false);
        }
      }
    }
    await this.restoreNetworkState();
    if (this.#forUpdateNoc && this.associatedFabric !== void 0) {
      await this.restoreFabric(this.associatedFabric);
    }
    if (!this.#forUpdateNoc && fabric !== void 0) {
      const fabricIndex = this.fabricIndex;
      if (fabricIndex !== void 0) {
        const fabric2 = this.#fabrics.getFabrics().find((fabric3) => fabric3.fabricIndex === fabricIndex);
        if (fabric2 !== void 0) {
          await this.revokeFabric(fabric2);
        }
      }
    }
    await this.restoreBreadcrumb();
  }
  async restoreFabric(fabric) {
    await this.updateFabric(fabric);
  }
}
//# sourceMappingURL=FailsafeContext.js.map
