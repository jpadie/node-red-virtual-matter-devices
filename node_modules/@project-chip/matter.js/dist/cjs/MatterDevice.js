"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MatterDevice_exports = {};
__export(MatterDevice_exports, {
  MatterDevice: () => MatterDevice
});
module.exports = __toCommonJS(MatterDevice_exports);
var import_AdministratorCommissioningConstants = require("./behavior/definitions/administrator-commissioning/AdministratorCommissioningConstants.js");
var import_AdministratorCommissioningCluster = require("./cluster/definitions/AdministratorCommissioningCluster.js");
var import_Lifecycle = require("./common/Lifecycle.js");
var import_MatterError = require("./common/MatterError.js");
var import_Crypto = require("./crypto/Crypto.js");
var import_FabricManager = require("./fabric/FabricManager.js");
var import_Diagnostic = require("./log/Diagnostic.js");
var import_Logger = require("./log/Logger.js");
var import_model = require("./model/index.js");
var import_NetInterface = require("./net/NetInterface.js");
var import_Network = require("./net/Network.js");
var import_ChannelManager = require("./protocol/ChannelManager.js");
var import_ExchangeManager = require("./protocol/ExchangeManager.js");
var import_InteractionServer = require("./protocol/interaction/InteractionServer.js");
var import_StatusCode = require("./protocol/interaction/StatusCode.js");
var import_SecureChannelProtocol = require("./protocol/securechannel/SecureChannelProtocol.js");
var import_Session = require("./session/Session.js");
var import_SessionManager = require("./session/SessionManager.js");
var import_PaseServer = require("./session/pase/PaseServer.js");
var import_Time = require("./time/Time.js");
var import_Construction = require("./util/Construction.js");
var import_Mutex = require("./util/Mutex.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("MatterDevice");
class MatterDevice {
  constructor(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode, commissioningChangedCallback, sessionChangedCallback, sessionParameters = {}) {
    this.sessionStorage = sessionStorage;
    this.fabricStorage = fabricStorage;
    this.getCommissioningConfig = getCommissioningConfig;
    this.commissioningChangedCallback = commissioningChangedCallback;
    this.sessionChangedCallback = sessionChangedCallback;
    this.sessionParameters = {
      idleIntervalMs: import_Session.SESSION_IDLE_INTERVAL_MS,
      activeIntervalMs: import_Session.SESSION_ACTIVE_INTERVAL_MS,
      activeThresholdMs: import_Session.SESSION_ACTIVE_THRESHOLD_MS,
      dataModelRevision: import_model.Specification.DATA_MODEL_REVISION,
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
      specificationVersion: import_model.Specification.SPECIFICATION_VERSION,
      maxPathsPerInvoke: import_InteractionServer.DEFAULT_MAX_PATHS_PER_INVOKE,
      ...sessionParameters
    };
    this.channelManager = new import_ChannelManager.ChannelManager(minimumCaseSessionsPerFabricAndNode);
    this.#fabricManager = new import_FabricManager.FabricManager(fabricStorage);
    this.#fabricManager.events.deleted.on(async (fabric) => {
      const { fabricIndex, rootNodeId } = fabric;
      await this.#sessionManager.removeResumptionRecord(rootNodeId);
      this.commissioningChangedCallback(fabricIndex, import_FabricManager.FabricAction.Removed);
      if (this.#fabricManager.getFabrics().length === 0) {
        await this.expireAllFabricAnnouncements();
      }
      this.reAnnounceAsCommissionable();
    });
    this.#fabricManager.events.updated.on(
      ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, import_FabricManager.FabricAction.Updated)
    );
    this.#sessionManager = new import_SessionManager.SessionManager(this, sessionStorage);
    this.#exchangeManager = new import_ExchangeManager.ExchangeManager(this.#sessionManager, this.channelManager);
    this.addProtocolHandler(this.secureChannelProtocol);
    this.announceInterval = import_Time.Time.getPeriodicTimer(
      "Server node announcement",
      import_AdministratorCommissioningConstants.DEVICE_ANNOUNCEMENT_INTERVAL_MS,
      () => (
        // Announcement needs to await a previous announcement because otherwise in testing at least announcement
        // may crash if started simultaneously
        this.#announcementMutex.run(() => this.announce())
      )
    );
    this.#sessionManager.sessionOpened.on((session) => {
      if (session.fabric) {
        this.sessionChangedCallback(session.fabric.fabricIndex);
      }
    });
    this.#sessionManager.sessionClosed.on(async (session) => {
      if (!session.closingAfterExchangeFinished) {
        await this.exchangeManager.closeSession(session);
      }
      const currentFabricIndex = session.fabric?.fabricIndex;
      if (currentFabricIndex !== void 0) {
        this.sessionChangedCallback(currentFabricIndex);
      }
      if (this.isClosing) {
        return;
      }
      const existingSessionFabric = currentFabricIndex === void 0 ? void 0 : this.getFabricByIndex(currentFabricIndex)?.fabricIndex;
      if (this.#fabricManager.getFabrics().length > 0 || session.isPase || !existingSessionFabric) {
        this.startAnnouncement().catch((error) => logger.warn(`Error while announcing`, error));
      }
    });
    this.#sessionManager.subscriptionsChanged.on((session) => {
      const currentFabric = session.fabric;
      if (currentFabric !== void 0) {
        this.sessionChangedCallback(currentFabric.fabricIndex);
      }
    });
    this.#construction = (0, import_Construction.Construction)(this, async () => {
      await this.#fabricManager.initFromStorage();
      this.#fabricManager.events.added.on(
        ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, import_FabricManager.FabricAction.Added)
      );
      await this.#sessionManager.initFromStorage(this.#fabricManager.getFabrics());
    });
  }
  scanners = new Array();
  broadcasters = new Array();
  transportInterfaces = new Array();
  channelManager;
  secureChannelProtocol = new import_SecureChannelProtocol.SecureChannelProtocol(() => this.endCommissioning());
  activeCommissioningMode = import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
  activeCommissioningDiscriminator;
  activeCommissioningEndCallback;
  announceInterval;
  announcementStartedTime = null;
  #isClosing = false;
  #exchangeManager;
  #fabricManager;
  #sessionManager;
  #failsafeContext;
  sessionParameters;
  // Currently we do not put much effort into synchronizing announcements as it probably isn't really necessary.  But
  // this mutex prevents automated announcements from piling up and allows us to ensure announcements are complete
  // on close
  #announcementMutex = new import_Mutex.Mutex(this);
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode = 3, commissioningChangedCallback, sessionChangedCallback, sessionParameters) {
    return (0, import_Construction.asyncNew)(
      MatterDevice,
      sessionStorage,
      fabricStorage,
      getCommissioningConfig,
      minimumCaseSessionsPerFabricAndNode,
      commissioningChangedCallback,
      sessionChangedCallback,
      sessionParameters
    );
  }
  get fabricManager() {
    return this.#fabricManager;
  }
  get sessionManager() {
    return this.#sessionManager;
  }
  get exchangeManager() {
    return this.#exchangeManager;
  }
  get failsafeContext() {
    this.assertFailSafeArmed();
    return this.#failsafeContext;
  }
  get isClosing() {
    return this.#isClosing;
  }
  async beginTimed(failsafeContext) {
    await failsafeContext.construction;
    this.#failsafeContext = failsafeContext;
    this.#fabricManager.events.added.on((fabric) => {
      const fabrics = this.#fabricManager.getFabrics();
      this.sendFabricAnnouncements(fabrics, true).catch(
        (error) => logger.warn(`Error sending Fabric announcement for Index ${fabric.fabricIndex}`, error)
      );
      logger.info("Announce done", import_Diagnostic.Diagnostic.dict({ fabric: fabric.fabricId, fabricIndex: fabric.fabricIndex }));
    });
    failsafeContext.commissioned.on(async () => await this.endCommissioning());
    failsafeContext.construction.change.on((status) => {
      if (status === import_Lifecycle.Lifecycle.Status.Destroyed) {
        this.#failsafeContext = void 0;
      }
    });
  }
  assertFailSafeArmed(message) {
    if (this.isFailsafeArmed()) return;
    throw new import_StatusCode.StatusResponseError(
      message ?? "Failsafe timer needs to be armed to execute this action.",
      import_StatusCode.StatusCode.FailsafeRequired
    );
  }
  isFailsafeArmed() {
    return this.#failsafeContext !== void 0;
  }
  addScanner(scanner) {
    this.scanners.push(scanner);
    return this;
  }
  hasBroadcaster(broadcaster) {
    return this.broadcasters.includes(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.broadcasters.push(broadcaster);
    return this;
  }
  async deleteBroadcaster(broadcaster) {
    const pos = this.broadcasters.findIndex((b) => b === broadcaster);
    if (pos !== -1) {
      this.broadcasters.splice(pos, 1);
      await broadcaster.expireAllAnnouncements();
    }
  }
  addTransportInterface(transport) {
    this.exchangeManager.addTransportInterface(transport);
    this.transportInterfaces.push(transport);
    return this;
  }
  async deleteTransportInterface(transport) {
    const pos = this.transportInterfaces.findIndex((t) => t === transport);
    if (pos !== -1) {
      this.transportInterfaces.splice(pos, 1);
      await transport.close();
    }
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  addProtocolHandler(protocol) {
    this.exchangeManager.addProtocolHandler(protocol);
    return this;
  }
  async start() {
    await this.startAnnouncement();
  }
  async startAnnouncement() {
    if (this.isClosing) return;
    if (this.announceInterval.isRunning) {
      this.announceInterval.stop();
    }
    this.announcementStartedTime = import_Time.Time.nowMs();
    this.announceInterval.start();
    await this.announce();
  }
  async expireAllFabricAnnouncements() {
    for (const broadcaster of this.broadcasters) {
      await broadcaster.expireFabricAnnouncement();
    }
  }
  async announce(announceOnce = false) {
    if (!announceOnce) {
      if (this.announcementStartedTime !== null && import_Time.Time.nowMs() - this.announcementStartedTime > import_AdministratorCommissioningConstants.DEVICE_ANNOUNCEMENT_DURATION_MS) {
        await this.endCommissioning();
        logger.debug("Announcement duration reached, stop announcing");
        return;
      }
      if (this.activeCommissioningMode !== import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
        for (const broadcaster of this.broadcasters) {
          await broadcaster.announce();
        }
        return;
      }
    }
    const fabrics = this.#fabricManager.getFabrics();
    if (fabrics.length) {
      let fabricsWithoutSessions = 0;
      for (const fabric of fabrics) {
        const session = this.#sessionManager.getSessionForNode(fabric, fabric.rootNodeId);
        if (session === void 0 || !session.isSecure || session.numberOfActiveSubscriptions === 0) {
          fabricsWithoutSessions++;
          logger.debug("Announcing", import_Diagnostic.Diagnostic.dict({ fabric: fabric.fabricId }));
        }
      }
      for (const broadcaster of this.broadcasters) {
        await broadcaster.setFabrics(fabrics);
        if (fabricsWithoutSessions > 0 || this.activeCommissioningMode !== import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
          await broadcaster.announce();
        }
      }
    } else {
      await this.expireAllFabricAnnouncements();
      await this.allowBasicCommissioning();
    }
  }
  async announceAsCommissionable(mode, activeCommissioningEndCallback, discriminator) {
    if (this.activeCommissioningMode === mode && (discriminator === void 0 || discriminator === this.activeCommissioningDiscriminator)) {
      return this.reAnnounceAsCommissionable();
    }
    if (this.activeCommissioningMode !== import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      throw new import_MatterError.InternalError(
        `Commissioning window already open with different mode (${this.activeCommissioningMode})!`
      );
    }
    if (this.activeCommissioningEndCallback !== void 0) {
      throw new import_MatterError.InternalError("Commissioning window already open with different callback!");
    }
    this.activeCommissioningMode = mode;
    this.activeCommissioningDiscriminator = discriminator;
    if (activeCommissioningEndCallback !== void 0) {
      this.activeCommissioningEndCallback = activeCommissioningEndCallback;
    }
    this.sendCommissionableAnnouncement(mode, discriminator).catch(
      (error) => logger.warn("Error sending announcement:", error)
    );
  }
  reAnnounceAsCommissionable() {
    if (this.activeCommissioningMode === import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      return;
    }
    this.sendCommissionableAnnouncement(this.activeCommissioningMode, this.activeCommissioningDiscriminator).catch(
      (error) => logger.warn("Error sending announcement:", error)
    );
  }
  async sendCommissionableAnnouncement(mode, discriminator) {
    const commissioningConfig = this.getCommissioningConfig();
    for (const broadcaster of this.broadcasters) {
      await broadcaster.setCommissionMode(
        mode === import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen ? 2 : 1,
        {
          ...commissioningConfig.productDescription,
          discriminator: discriminator ?? commissioningConfig.discriminator
        }
      );
    }
    await this.startAnnouncement();
  }
  async getNextAvailableSessionId() {
    return this.#sessionManager.getNextAvailableSessionId();
  }
  findFabricFromDestinationId(destinationId, peerRandom) {
    return this.#fabricManager.findFabricFromDestinationId(destinationId, peerRandom);
  }
  async sendFabricAnnouncements(fabrics, expireCommissioningAnnouncement = false) {
    for (const broadcaster of this.broadcasters) {
      await broadcaster.setFabrics(fabrics, expireCommissioningAnnouncement);
      await broadcaster.announce();
    }
  }
  getFabricByIndex(fabricIndex) {
    return this.#fabricManager.getFabrics().find((fabric) => fabric.fabricIndex === fabricIndex);
  }
  initiateExchange(fabric, nodeId, protocolId) {
    return this.exchangeManager.initiateExchange(fabric, nodeId, protocolId);
  }
  findResumptionRecordById(resumptionId) {
    return this.#sessionManager.findResumptionRecordById(resumptionId);
  }
  async saveResumptionRecord(resumptionRecord) {
    return this.#sessionManager.saveResumptionRecord(resumptionRecord);
  }
  getFabrics() {
    return this.#fabricManager.getFabrics();
  }
  isCommissioned() {
    return !!this.#fabricManager.getFabrics().length;
  }
  async allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback) {
    if (this.activeCommissioningMode === import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen) {
      throw new import_MatterError.MatterFlowError(
        "Basic commissioning window is already open! Cannot set Enhanced commissioning mode."
      );
    }
    this.secureChannelProtocol.setPaseCommissioner(paseServer);
    await this.announceAsCommissionable(
      import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen,
      commissioningEndCallback,
      discriminator
    );
  }
  async allowBasicCommissioning(commissioningEndCallback) {
    if (this.activeCommissioningMode === import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen) {
      throw new import_MatterError.MatterFlowError(
        "Enhanced commissioning window is already open! Cannot set Basic commissioning mode."
      );
    }
    this.secureChannelProtocol.setPaseCommissioner(
      await import_PaseServer.PaseServer.fromPin(this.getCommissioningConfig().passcode, {
        iterations: 1e3,
        salt: import_Crypto.Crypto.get().getRandomData(32)
      })
    );
    await this.announceAsCommissionable(
      import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen,
      commissioningEndCallback
    );
  }
  async endCommissioning() {
    logger.debug("Commissioning mode ended, stop announcements.");
    if (this.activeCommissioningMode === import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen || this.isCommissioned()) {
      this.secureChannelProtocol.removePaseCommissioner();
    }
    this.activeCommissioningMode = import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
    this.announceInterval.stop();
    this.announcementStartedTime = null;
    if (this.activeCommissioningEndCallback !== void 0) {
      const activeCommissioningEndCallback = this.activeCommissioningEndCallback;
      this.activeCommissioningEndCallback = void 0;
      activeCommissioningEndCallback();
    }
    for (const broadcaster of this.broadcasters) {
      await broadcaster.expireCommissioningAnnouncement();
    }
    logger.info("All announcements expired");
  }
  existsOpenPaseSession() {
    return !!this.#sessionManager.getPaseSession();
  }
  async findDevice(fabric, nodeId, timeOutSeconds = 5) {
    const device = await this.scanners[0].findOperationalDevice(fabric, nodeId, timeOutSeconds);
    if (device === void 0) return void 0;
    const session = this.#sessionManager.getSessionForNode(fabric, nodeId);
    if (session === void 0) return void 0;
    const networkInterface = this.transportInterfaces.find((netInterface) => (0, import_NetInterface.isNetworkInterface)(netInterface));
    if (networkInterface === void 0 || !(0, import_NetInterface.isNetworkInterface)(networkInterface)) {
      throw new import_Network.NetworkError("No network interface found");
    }
    return { session, channel: await networkInterface.openChannel(device.addresses[0]) };
  }
  async clearSubscriptionsForNode(fabricIndex, peerNodeId, flushSubscriptions) {
    await this.#sessionManager.clearSubscriptionsForNode(fabricIndex, peerNodeId, flushSubscriptions);
  }
  async close() {
    this.#isClosing = true;
    await this.endCommissioning();
    await this.#announcementMutex;
    for (const broadcaster of this.broadcasters) {
      await broadcaster.close();
    }
    if (this.#failsafeContext) {
      await this.#failsafeContext.close();
      this.#failsafeContext = void 0;
    }
    await this.exchangeManager.close();
    await this.#sessionManager.close();
    await this.channelManager.close();
    for (const transportInterface of this.transportInterfaces) {
      await transportInterface.close();
    }
  }
  getActiveSessionInformation() {
    return this.#sessionManager.getActiveSessionInformation();
  }
}
//# sourceMappingURL=MatterDevice.js.map
