{
  "version": 3,
  "sources": ["../../../../src/net/fake/NetworkFake.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { isIPv4 } from \"../../util/Ip.js\";\nimport { Network, NetworkInterface, NetworkInterfaceDetails } from \"../Network.js\";\nimport { UdpChannel, UdpChannelOptions } from \"../UdpChannel.js\";\nimport { FAKE_INTERFACE_NAME } from \"./SimulatedNetwork.js\";\nimport { UdpChannelFake } from \"./UdpChannelFake.js\";\n\nexport class NetworkFake extends Network {\n    private readonly ipV4: string[];\n    private readonly ipV6: string[];\n\n    constructor(\n        private readonly mac: string,\n        ips: string[],\n    ) {\n        super();\n        this.ipV4 = ips.filter(ip => isIPv4(ip));\n        this.ipV6 = ips.filter(ip => !isIPv4(ip));\n    }\n\n    getNetInterfaces(): NetworkInterface[] {\n        return [{ name: FAKE_INTERFACE_NAME }];\n    }\n\n    getIpMac(_netInterface: string): NetworkInterfaceDetails {\n        return { mac: this.mac, ipV4: this.ipV4, ipV6: this.ipV6 };\n    }\n\n    override createUdpChannel(options: UdpChannelOptions): Promise<UdpChannel> {\n        return UdpChannelFake.create(this, options);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,gBAAuB;AACvB,qBAAmE;AAEnE,8BAAoC;AACpC,4BAA+B;AAV/B;AAAA;AAAA;AAAA;AAAA;AAYO,MAAM,oBAAoB,uBAAQ;AAAA,EAIrC,YACqB,KACjB,KACF;AACE,UAAM;AAHW;AAIjB,SAAK,OAAO,IAAI,OAAO,YAAM,kBAAO,EAAE,CAAC;AACvC,SAAK,OAAO,IAAI,OAAO,QAAM,KAAC,kBAAO,EAAE,CAAC;AAAA,EAC5C;AAAA,EAViB;AAAA,EACA;AAAA,EAWjB,mBAAuC;AACnC,WAAO,CAAC,EAAE,MAAM,4CAAoB,CAAC;AAAA,EACzC;AAAA,EAEA,SAAS,eAAgD;AACrD,WAAO,EAAE,KAAK,KAAK,KAAK,MAAM,KAAK,MAAM,MAAM,KAAK,KAAK;AAAA,EAC7D;AAAA,EAES,iBAAiB,SAAiD;AACvE,WAAO,qCAAe,OAAO,MAAM,OAAO;AAAA,EAC9C;AACJ;",
  "names": []
}
