{
  "version": 3,
  "sources": ["../../../../src/net/fake/SimulatedNetwork.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Listener } from \"../../common/TransportInterface.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport { singleton } from \"../../util/Singleton.js\";\n\nexport type ListenerFunc = (netInterface: string, peerAddress: string, peerPort: number, data: ByteArray) => void;\n\nconst logger = Logger.get(\"SimulatedNetwork\");\n\nexport const FAKE_INTERFACE_NAME = \"fakeInterface\";\n\nexport class SimulatedNetwork {\n    static get = singleton(() => new SimulatedNetwork());\n\n    private readonly listenersMap = new Map<string, Array<ListenerFunc>>();\n\n    onUdpData(host: string | undefined, port: number, listener: ListenerFunc): Listener {\n        const ipPort = `${host ?? \"*\"}:${port}`;\n        let listeners = this.listenersMap.get(ipPort);\n        if (listeners === undefined) {\n            listeners = new Array<ListenerFunc>();\n            this.listenersMap.set(ipPort, listeners);\n        }\n        listeners.push(listener);\n        return {\n            close: async () => this.offUdpData(host, port, listener),\n        };\n    }\n\n    private offUdpData(host: string | undefined, port: number, listenerToRemove: ListenerFunc) {\n        const ipPort = `${host ?? \"*\"}:${port}`;\n        const listeners = this.listenersMap.get(ipPort);\n        if (listeners === undefined) return;\n        const newListeners = listeners.filter(listener => listener !== listenerToRemove);\n        if (newListeners.length === 0) {\n            this.listenersMap.delete(ipPort);\n            return;\n        }\n        this.listenersMap.set(ipPort, newListeners);\n    }\n\n    sendUdp(localAddress: string, localPort: number, remoteAddress: string, remotePort: number, data: ByteArray) {\n        [`${remoteAddress}:${remotePort}`, `*:${remotePort}`].forEach(ipPort =>\n            this.listenersMap.get(ipPort)?.forEach(listener => {\n                try {\n                    listener(FAKE_INTERFACE_NAME, localAddress, localPort, data);\n                } catch (error) {\n                    logger.error(error);\n                }\n            }),\n        );\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,oBAAuB;AAEvB,uBAA0B;AAT1B;AAAA;AAAA;AAAA;AAAA;AAaA,MAAM,SAAS,qBAAO,IAAI,kBAAkB;AAErC,MAAM,sBAAsB;AAE5B,MAAM,iBAAiB;AAAA,EAC1B,OAAO,UAAM,4BAAU,MAAM,IAAI,iBAAiB,CAAC;AAAA,EAElC,eAAe,oBAAI,IAAiC;AAAA,EAErE,UAAU,MAA0B,MAAc,UAAkC;AAChF,UAAM,SAAS,GAAG,QAAQ,GAAG,IAAI,IAAI;AACrC,QAAI,YAAY,KAAK,aAAa,IAAI,MAAM;AAC5C,QAAI,cAAc,QAAW;AACzB,kBAAY,IAAI,MAAoB;AACpC,WAAK,aAAa,IAAI,QAAQ,SAAS;AAAA,IAC3C;AACA,cAAU,KAAK,QAAQ;AACvB,WAAO;AAAA,MACH,OAAO,YAAY,KAAK,WAAW,MAAM,MAAM,QAAQ;AAAA,IAC3D;AAAA,EACJ;AAAA,EAEQ,WAAW,MAA0B,MAAc,kBAAgC;AACvF,UAAM,SAAS,GAAG,QAAQ,GAAG,IAAI,IAAI;AACrC,UAAM,YAAY,KAAK,aAAa,IAAI,MAAM;AAC9C,QAAI,cAAc,OAAW;AAC7B,UAAM,eAAe,UAAU,OAAO,cAAY,aAAa,gBAAgB;AAC/E,QAAI,aAAa,WAAW,GAAG;AAC3B,WAAK,aAAa,OAAO,MAAM;AAC/B;AAAA,IACJ;AACA,SAAK,aAAa,IAAI,QAAQ,YAAY;AAAA,EAC9C;AAAA,EAEA,QAAQ,cAAsB,WAAmB,eAAuB,YAAoB,MAAiB;AACzG,KAAC,GAAG,aAAa,IAAI,UAAU,IAAI,KAAK,UAAU,EAAE,EAAE;AAAA,MAAQ,YAC1D,KAAK,aAAa,IAAI,MAAM,GAAG,QAAQ,cAAY;AAC/C,YAAI;AACA,mBAAS,qBAAqB,cAAc,WAAW,IAAI;AAAA,QAC/D,SAAS,OAAO;AACZ,iBAAO,MAAM,KAAK;AAAA,QACtB;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;",
  "names": []
}
