{
  "version": 3,
  "sources": ["../../../src/parser/Lexer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FieldValue } from \"../model/definitions/index.js\";\nimport { BasicToken, Token } from \"./Token.js\";\n\nfunction isNameChar(c: string) {\n    return (c >= \"A\" && c <= \"Z\") || (c >= \"a\" && c <= \"z\") || (c >= \"0\" && c <= \"9\") || c === \"_\";\n}\n\n/**\n * DSL lexer.\n *\n * Tokenizes simple text dialects.  Currently sufficient for Matter conformance and constraint tokenization.\n */\nexport class Lexer<T extends BasicToken> {\n    #keywords: Set<string>;\n\n    constructor(keywords: Iterable<string> = []) {\n        if (keywords instanceof Set) {\n            this.#keywords = keywords;\n        } else {\n            this.#keywords = new Set(keywords);\n        }\n    }\n\n    lex(text: string, error: (code: string, message: string) => void) {\n        return lex(text, error, this.#keywords) as Iterator<T>;\n    }\n}\n\nexport namespace Lexer {\n    export const Basic = new Lexer();\n}\n\nfunction* lex(\n    text: string,\n    error: (code: string, message: string) => void,\n    keywords: Set<string>,\n): Generator<Token, undefined> {\n    const i = text[Symbol.iterator]();\n\n    let current = i.next();\n    if (current.done) {\n        return;\n    }\n    let peeked = i.next();\n\n    let line = 1;\n    let char = 1;\n\n    let startLine = -1;\n    let startChar = -1;\n\n    function markStart() {\n        startLine = line;\n        startChar = char;\n    }\n\n    function next() {\n        current = peeked;\n        if (!current.done) {\n            char++;\n            peeked = i.next();\n        }\n    }\n\n    function tokenizeName(): Token | BasicToken.Word {\n        const chars = [current.value];\n        while (isNameChar(peeked.value)) {\n            next();\n            chars.push(current.value);\n        }\n        const name = chars.join(\"\");\n\n        if (keywords.has(name)) {\n            return { type: name, startLine, startChar };\n        }\n\n        return { type: \"word\", value: name, startLine, startChar };\n    }\n\n    function binaryValueOf(digit: string) {\n        if (digit === \"0\") {\n            return 0;\n        }\n        if (digit === \"1\") {\n            return 1;\n        }\n    }\n\n    function decimalValueOf(digit: string) {\n        if (digit >= \"0\" && digit <= \"9\") {\n            return digit.charCodeAt(0) - \"0\".charCodeAt(0);\n        }\n    }\n\n    function hexadecimalValueOf(digit: string) {\n        if (digit >= \"0\" && digit <= \"9\") {\n            return digit.charCodeAt(0) - \"0\".charCodeAt(0);\n        }\n        if (digit >= \"a\" && digit <= \"f\") {\n            return 10 + digit.charCodeAt(0) - \"a\".charCodeAt(0);\n        }\n        if (digit >= \"A\" && digit <= \"F\") {\n            return 10 + digit.charCodeAt(0) - \"A\".charCodeAt(0);\n        }\n        return;\n    }\n\n    function tokenizeNumber(sign: number) {\n        markStart();\n        if (sign === -1) {\n            // Skip \"-\" prefix\n            next();\n        }\n\n        if (current.value === \"0\") {\n            if (peeked.value === \"x\") {\n                next();\n                next();\n                return tokenizeDigits(16, sign, hexadecimalValueOf);\n            } else if (peeked.value === \"b\") {\n                next();\n                next();\n                return tokenizeDigits(2, sign, binaryValueOf);\n            }\n        }\n\n        return tokenizeDigits(10, sign, decimalValueOf);\n    }\n\n    function tokenizeDigits(base: number, sign: number, valueOf: (digit: string[1]) => number | undefined): BasicToken {\n        // The first digit may not actually be a digit if number is hexadecimal or binary\n        let num = valueOf(current.value);\n        if (num === undefined) {\n            error(\"INVALID_NUMBER\", `Expected digit following numeric suffix`);\n            return { type: \"value\", value: 0, startLine, startChar };\n        }\n\n        // Add subsequent digits\n        while (true) {\n            const digitValue = valueOf(peeked.value);\n            if (digitValue === undefined) {\n                break;\n            }\n            next();\n            num = num * base + digitValue;\n        }\n\n        num *= sign;\n\n        // Handle specialized suffices for percents and temperatures\n        if (peeked.value === \"%\") {\n            next();\n            return { type: \"value\", value: FieldValue.Percent(num), startLine, startChar };\n        } else if (peeked.value === \"\u00B0\") {\n            next();\n            if (peeked.value?.toLowerCase() === \"C\") {\n                next();\n            }\n            return { type: \"value\", value: FieldValue.Celsius(num), startLine, startChar };\n        }\n\n        // No special suffix; return raw value\n        return { type: \"value\", value: num, startLine, startChar };\n    }\n\n    while (!current.done) {\n        switch (current.value) {\n            case \"|\":\n            case \"^\":\n            case \"&\":\n            case \".\":\n            case \",\":\n            case \"[\":\n            case \"]\":\n            case \"(\":\n            case \")\":\n            case \"+\":\n            case \"/\":\n            case \"*\":\n                yield { type: current.value, startLine: line, startChar: char };\n                break;\n\n            case \"-\":\n                if (peeked.value >= \"0\" || peeked.value <= \"0\") {\n                    yield tokenizeNumber(-1);\n                } else {\n                    yield { type: current.value, startLine: line, startChar: char };\n                }\n                break;\n\n            case \"0\":\n                yield tokenizeNumber(1);\n                break;\n\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                yield tokenizeDigits(10, 1, decimalValueOf);\n                break;\n\n            case \"!\":\n            case \">\":\n            case \"<\":\n                {\n                    const base = current.value;\n                    if (peeked.value === \"=\") {\n                        const type = `${base}${peeked.value}` as BasicToken.Operator;\n                        next();\n                        yield {\n                            type,\n                            startLine: line,\n                            startChar: char,\n                        };\n                    } else {\n                        yield { type: base, startLine: line, startChar: char };\n                    }\n                }\n                break;\n\n            case \"=\":\n                markStart();\n                if (peeked.value === \"=\") {\n                    next();\n                } else {\n                    error(\"BAD_EQUAL\", `\"=\" must be followed by another \"=\"`);\n                }\n                yield { type: \"==\", startLine, startChar };\n                break;\n\n            case \"\\n\":\n                line++;\n                char = 0;\n                break;\n\n            case \" \":\n            case \"\\t\":\n            case \"\\r\":\n            case \"\\v\":\n            case \"\\f\":\n                break;\n\n            default:\n                if (isNameChar(current.value)) {\n                    markStart();\n                    yield tokenizeName();\n                } else {\n                    error(\"GARBAGE_CHARACTER\", `Unexpected character \"${current.value}\"`);\n                }\n                break;\n        }\n        next();\n    }\n}\n"],
  "mappings": "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",
  "names": ["Lexer"]
}
