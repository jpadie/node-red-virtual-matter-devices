{
  "version": 3,
  "sources": ["../../../../src/cluster/server/CommissioningServerFailsafeContext.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FailsafeContext } from \"../../common/FailsafeContext.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { Endpoint } from \"../../device/Endpoint.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { Fabric } from \"../../fabric/Fabric.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { asyncNew } from \"../../util/Construction.js\";\nimport { BasicInformation } from \"../definitions/BasicInformationCluster.js\";\nimport { GeneralCommissioning } from \"../definitions/GeneralCommissioningCluster.js\";\nimport { NetworkCommissioning } from \"../definitions/NetworkCommissioningCluster.js\";\nimport { OperationalCredentials } from \"../definitions/OperationalCredentialsCluster.js\";\n\n/**\n * {@link FailsafeContext} implementation for {@link EndpointInterface} API.\n */\nexport class CommissioningServerFailsafeContext extends FailsafeContext {\n    #rootEndpoint: Endpoint;\n    #storedNetworkClusterState = new Map<\n        EndpointNumber,\n        TypeFromSchema<typeof NetworkCommissioning.TlvNetworkInfo>[]\n    >();\n\n    constructor(rootEndpoint: Endpoint, options: FailsafeContext.Options) {\n        super(options);\n        this.#rootEndpoint = rootEndpoint;\n    }\n\n    static async create(rootEndpoint: Endpoint, options: FailsafeContext.Options) {\n        return asyncNew(this, rootEndpoint, options);\n    }\n\n    override async storeEndpointState() {\n        await this.#storeEndpointState(this.#rootEndpoint);\n    }\n\n    override async restoreFabric(fabric: Fabric) {\n        await super.restoreFabric(fabric);\n        const operationalCredentialsCluster = this.#rootEndpoint.getClusterServer(OperationalCredentials.Cluster);\n        operationalCredentialsCluster?.attributes.nocs.updatedLocalForFabric(fabric);\n        operationalCredentialsCluster?.attributes.fabrics.updatedLocalForFabric(fabric);\n    }\n\n    override async restoreNetworkState() {\n        await this.#restoreEndpointState(this.#rootEndpoint);\n    }\n\n    override async revokeFabric(fabric: Fabric) {\n        const basicInformationCluster = this.#rootEndpoint.getClusterServer(BasicInformation.Cluster);\n        basicInformationCluster?.triggerLeaveEvent?.({ fabricIndex: fabric.fabricIndex });\n\n        await fabric.remove();\n\n        const operationalCredentialsCluster = this.#rootEndpoint.getClusterServer(OperationalCredentials.Cluster);\n        operationalCredentialsCluster?.attributes.nocs.updatedLocalForFabric(fabric);\n        operationalCredentialsCluster?.attributes.commissionedFabrics.updatedLocal();\n        operationalCredentialsCluster?.attributes.fabrics.updatedLocalForFabric(fabric);\n        operationalCredentialsCluster?.attributes.trustedRootCertificates.updatedLocal();\n    }\n\n    override async restoreBreadcrumb() {\n        const generalCommissioningCluster = this.#rootEndpoint.getClusterServer(GeneralCommissioning.Cluster);\n        generalCommissioningCluster?.setBreadcrumbAttribute(0);\n    }\n\n    async #storeEndpointState(endpoint: Endpoint) {\n        // TODO: When implementing Network clusters we somehow need to make sure that a \"temporary\" network\n        //  configuration is not persisted to disk. The NetworkClusterHandlers need to make sure it is only persisted\n        //  when the commissioning is completed.\n        const networkCluster = endpoint.getClusterServer(NetworkCommissioning.Complete);\n        if (networkCluster !== undefined) {\n            this.#storedNetworkClusterState.set(endpoint.getNumber(), networkCluster.getNetworksAttribute());\n        }\n        for (const childEndpoint of endpoint.getChildEndpoints()) {\n            await this.#storeEndpointState(childEndpoint);\n        }\n    }\n\n    async #restoreEndpointState(endpoint: Endpoint) {\n        const endpointId = endpoint.getNumber();\n        const networkState = this.#storedNetworkClusterState.get(endpointId);\n        if (networkState !== undefined) {\n            const networkCluster = endpoint.getClusterServer(NetworkCommissioning.Complete);\n            if (networkCluster !== undefined) {\n                networkCluster.setNetworksAttribute(networkState);\n            }\n            this.#storedNetworkClusterState.delete(endpointId);\n        }\n        for (const childEndpoint of endpoint.getChildEndpoints()) {\n            await this.#restoreEndpointState(childEndpoint);\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,6BAAgC;AAMhC,0BAAyB;AACzB,qCAAiC;AACjC,yCAAqC;AACrC,yCAAqC;AACrC,2CAAuC;AAhBvC;AAAA;AAAA;AAAA;AAAA;AAqBO,MAAM,2CAA2C,uCAAgB;AAAA,EACpE;AAAA,EACA,6BAA6B,oBAAI,IAG/B;AAAA,EAEF,YAAY,cAAwB,SAAkC;AAClE,UAAM,OAAO;AACb,SAAK,gBAAgB;AAAA,EACzB;AAAA,EAEA,aAAa,OAAO,cAAwB,SAAkC;AAC1E,eAAO,8BAAS,MAAM,cAAc,OAAO;AAAA,EAC/C;AAAA,EAEA,MAAe,qBAAqB;AAChC,UAAM,KAAK,oBAAoB,KAAK,aAAa;AAAA,EACrD;AAAA,EAEA,MAAe,cAAc,QAAgB;AACzC,UAAM,MAAM,cAAc,MAAM;AAChC,UAAM,gCAAgC,KAAK,cAAc,iBAAiB,4DAAuB,OAAO;AACxG,mCAA+B,WAAW,KAAK,sBAAsB,MAAM;AAC3E,mCAA+B,WAAW,QAAQ,sBAAsB,MAAM;AAAA,EAClF;AAAA,EAEA,MAAe,sBAAsB;AACjC,UAAM,KAAK,sBAAsB,KAAK,aAAa;AAAA,EACvD;AAAA,EAEA,MAAe,aAAa,QAAgB;AACxC,UAAM,0BAA0B,KAAK,cAAc,iBAAiB,gDAAiB,OAAO;AAC5F,6BAAyB,oBAAoB,EAAE,aAAa,OAAO,YAAY,CAAC;AAEhF,UAAM,OAAO,OAAO;AAEpB,UAAM,gCAAgC,KAAK,cAAc,iBAAiB,4DAAuB,OAAO;AACxG,mCAA+B,WAAW,KAAK,sBAAsB,MAAM;AAC3E,mCAA+B,WAAW,oBAAoB,aAAa;AAC3E,mCAA+B,WAAW,QAAQ,sBAAsB,MAAM;AAC9E,mCAA+B,WAAW,wBAAwB,aAAa;AAAA,EACnF;AAAA,EAEA,MAAe,oBAAoB;AAC/B,UAAM,8BAA8B,KAAK,cAAc,iBAAiB,wDAAqB,OAAO;AACpG,iCAA6B,uBAAuB,CAAC;AAAA,EACzD;AAAA,EAEA,MAAM,oBAAoB,UAAoB;AAI1C,UAAM,iBAAiB,SAAS,iBAAiB,wDAAqB,QAAQ;AAC9E,QAAI,mBAAmB,QAAW;AAC9B,WAAK,2BAA2B,IAAI,SAAS,UAAU,GAAG,eAAe,qBAAqB,CAAC;AAAA,IACnG;AACA,eAAW,iBAAiB,SAAS,kBAAkB,GAAG;AACtD,YAAM,KAAK,oBAAoB,aAAa;AAAA,IAChD;AAAA,EACJ;AAAA,EAEA,MAAM,sBAAsB,UAAoB;AAC5C,UAAM,aAAa,SAAS,UAAU;AACtC,UAAM,eAAe,KAAK,2BAA2B,IAAI,UAAU;AACnE,QAAI,iBAAiB,QAAW;AAC5B,YAAM,iBAAiB,SAAS,iBAAiB,wDAAqB,QAAQ;AAC9E,UAAI,mBAAmB,QAAW;AAC9B,uBAAe,qBAAqB,YAAY;AAAA,MACpD;AACA,WAAK,2BAA2B,OAAO,UAAU;AAAA,IACrD;AACA,eAAW,iBAAiB,SAAS,kBAAkB,GAAG;AACtD,YAAM,KAAK,sBAAsB,aAAa;AAAA,IAClD;AAAA,EACJ;AACJ;",
  "names": []
}
