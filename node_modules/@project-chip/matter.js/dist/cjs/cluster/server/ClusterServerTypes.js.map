{
  "version": 3,
  "sources": ["../../../../src/cluster/server/ClusterServerTypes.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Message } from \"../../codec/MessageCodec.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { Endpoint } from \"../../device/Endpoint.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { Fabric } from \"../../fabric/Fabric.js\";\nimport { MatterDevice } from \"../../MatterDevice.js\";\nimport { EventHandler } from \"../../protocol/interaction/EventHandler.js\";\nimport { Session } from \"../../session/Session.js\";\nimport { Storage } from \"../../storage/Storage.js\";\nimport { SupportedStorageTypes } from \"../../storage/StringifyTools.js\";\nimport { Merge } from \"../../util/Type.js\";\nimport { ClusterClientObj } from \"../client/ClusterClientTypes.js\";\nimport {\n    Attribute,\n    AttributeJsType,\n    Attributes,\n    Cluster,\n    Command,\n    Commands,\n    Events,\n    EventType,\n    FabricScopedAttribute,\n    FixedAttribute,\n    GlobalAttributes,\n    MandatoryAttributeNames,\n    MandatoryEventNames,\n    OptionalAttribute,\n    OptionalAttributeNames,\n    OptionalCommand,\n    OptionalEventNames,\n    OptionalFixedAttribute,\n    OptionalWritableAttribute,\n    OptionalWritableFabricScopedAttribute,\n    RequestType,\n    ResponseType,\n    WritableAttribute,\n    WritableFabricScopedAttribute,\n} from \"../Cluster.js\";\nimport { ClusterType } from \"../ClusterType.js\";\nimport { AttributeServer, FabricScopedAttributeServer, FixedAttributeServer } from \"./AttributeServer.js\";\nimport { type ClusterServer } from \"./ClusterServer.js\";\nimport { CommandServer } from \"./CommandServer.js\";\nimport { AnyEventServer } from \"./EventServer.js\";\n\n/** Cluster attributes accessible on the cluster server */\ntype MandatoryAttributeServers<A extends Attributes> = Omit<\n    {\n        [P in MandatoryAttributeNames<A>]: A[P] extends FabricScopedAttribute<any, any>\n            ? FabricScopedAttributeServer<AttributeJsType<A[P]>>\n            : A[P] extends WritableFabricScopedAttribute<any, any>\n              ? FabricScopedAttributeServer<AttributeJsType<A[P]>>\n              : A[P] extends FixedAttribute<any, any>\n                ? FixedAttributeServer<AttributeJsType<A[P]>>\n                : AttributeServer<AttributeJsType<A[P]>>;\n    },\n    keyof GlobalAttributes<any>\n>;\ntype OptionalAttributeServers<A extends Attributes> = {\n    [P in OptionalAttributeNames<A>]?: A[P] extends OptionalWritableFabricScopedAttribute<any, any>\n        ? FabricScopedAttributeServer<AttributeJsType<A[P]>>\n        : A[P] extends OptionalFixedAttribute<any, any>\n          ? FixedAttributeServer<AttributeJsType<A[P]>>\n          : AttributeServer<AttributeJsType<A[P]>>;\n};\nexport type AttributeServers<A extends Attributes = Attributes> = Merge<\n    MandatoryAttributeServers<A>,\n    OptionalAttributeServers<A>\n>;\n\n/** Initial values for the cluster attribute */\nexport type AttributeInitialValues<A extends Attributes> = Merge<\n    Omit<{ [P in MandatoryAttributeNames<A>]: AttributeJsType<A[P]> }, keyof GlobalAttributes<any>>,\n    { [P in OptionalAttributeNames<A>]?: AttributeJsType<A[P]> }\n>;\nexport type AttributeServerValues<A extends Attributes> = Merge<\n    { [P in MandatoryAttributeNames<A>]: AttributeJsType<A[P]> },\n    { [P in OptionalAttributeNames<A>]?: AttributeJsType<A[P]> }\n>;\n\ntype MandatoryCommandNames<C extends Commands> = {\n    [K in keyof C]: C[K] extends OptionalCommand<any, any, any> ? never : K;\n}[keyof C];\ntype OptionalCommandNames<C extends Commands> = {\n    [K in keyof C]: C[K] extends OptionalCommand<any, any, any> ? K : never;\n}[keyof C];\ntype AttributeGetters<A extends Attributes> = {\n    [P in keyof A as `${string & P}AttributeGetter`]?: (args: {\n        attributes: AttributeServers<A>;\n        endpoint?: Endpoint;\n        session?: Session<MatterDevice>;\n        isFabricFiltered?: boolean;\n    }) => AttributeJsType<A[P]>;\n};\ntype AttributeSetters<A extends Attributes> = {\n    [P in keyof A as `${string & P}AttributeSetter`]?: (\n        value: AttributeJsType<A[P]>,\n        args: { attributes: AttributeServers<A>; endpoint?: Endpoint; session?: Session<MatterDevice> },\n    ) => boolean;\n};\ntype AttributeValidators<A extends Attributes> = {\n    [P in keyof A as `${string & P}AttributeValidator`]?: (\n        value: AttributeJsType<A[P]>,\n        args: { attributes: AttributeServers<A>; endpoint?: Endpoint; session?: Session<MatterDevice> },\n    ) => void;\n};\nexport type CommandHandler<\n    C extends Command<any, any, any>,\n    AS extends AttributeServers<any>,\n    ES extends EventServers<any>,\n> =\n    C extends Command<infer RequestT, infer ResponseT, any>\n        ? (args: {\n              request: RequestT;\n              attributes: AS;\n              events: ES;\n              session: Session<MatterDevice>;\n              message: Message;\n              endpoint: Endpoint;\n          }) => Promise<ResponseT> | ResponseT\n        : never;\ntype CommandHandlers<T extends Commands, AS extends AttributeServers<any>, ES extends EventServers<any>> = Merge<\n    { [P in MandatoryCommandNames<T>]: CommandHandler<T[P], AS, ES> },\n    { [P in OptionalCommandNames<T>]?: CommandHandler<T[P], AS, ES> }\n>;\n\n/** Handlers to process cluster commands */\ntype AttributeHandlers<A extends Attributes> = Merge<\n    AttributeGetters<A>,\n    Merge<AttributeSetters<A>, AttributeValidators<A>>\n>;\nexport type ClusterServerHandlers<C extends ClusterType> = Merge<\n    CommandHandlers<C[\"commands\"], AttributeServers<C[\"attributes\"]>, EventServers<C[\"events\"]>>,\n    Merge<\n        AttributeHandlers<C[\"attributes\"]>,\n        {\n            initializeClusterServer?: (args: {\n                attributes: AttributeServers<C[\"attributes\"]>;\n                events: EventServers<C[\"events\"]>;\n                endpoint: Endpoint;\n            }) => void;\n            destroyClusterServer?: () => void;\n        }\n    >\n>;\n\nexport type CommandServers<C extends Commands = Commands> = Merge<\n    { [P in MandatoryCommandNames<C>]: CommandServer<RequestType<C[P]>, ResponseType<C[P]>> },\n    { [P in OptionalCommandNames<C>]?: CommandServer<RequestType<C[P]>, ResponseType<C[P]>> }\n>;\n\ntype OptionalAttributeConf<T extends Attributes> = { [K in OptionalAttributeNames<T>]?: true };\ntype MakeAttributeMandatory<A extends Attribute<any, any>> =\n    A extends OptionalWritableFabricScopedAttribute<infer T, any>\n        ? WritableFabricScopedAttribute<T, any>\n        : A extends OptionalWritableAttribute<infer T, any>\n          ? WritableAttribute<T, any>\n          : A extends OptionalAttribute<infer T, any>\n            ? Attribute<T, any>\n            : A;\ntype MakeAttributesMandatory<T extends Attributes, C extends OptionalAttributeConf<T>> = {\n    [K in keyof T]: K extends keyof C ? MakeAttributeMandatory<T[K]> : T[K];\n};\n\nconst MakeAttributesMandatory = <T extends Attributes, C extends OptionalAttributeConf<T>>(\n    attributes: T,\n    conf: C,\n): MakeAttributesMandatory<T, C> => {\n    const result = <Attributes>{ ...attributes };\n    for (const key in conf) {\n        (result as any)[key] = { ...result[key], optional: false };\n    }\n    return result as MakeAttributesMandatory<T, C>;\n};\ntype UseOptionalAttributes<\n    C extends Cluster<any, any, any, any, any>,\n    A extends OptionalAttributeConf<C[\"attributes\"]>,\n> = Cluster<\n    C[\"features\"],\n    C[\"supportedFeatures\"],\n    MakeAttributesMandatory<C[\"attributes\"], A>,\n    C[\"commands\"],\n    C[\"events\"]\n>;\n\n/** Forces the presence of the specified optional attributes, so they can be used in the command handlers */\nexport const UseOptionalAttributes = <\n    C extends Cluster<any, any, any, any, any>,\n    A extends OptionalAttributeConf<C[\"attributes\"]>,\n>(\n    cluster: C,\n    conf: A,\n): UseOptionalAttributes<C, A> => ({ ...cluster, attributes: MakeAttributesMandatory(cluster.attributes, conf) });\n\nexport type FabricScopedAttributeNames<A extends Attributes> = {\n    [K in keyof A]: A[K] extends FabricScopedAttribute<any, any>\n        ? K\n        : A[K] extends WritableFabricScopedAttribute<any, any>\n          ? K\n          : A[K] extends OptionalWritableFabricScopedAttribute<any, any>\n            ? K\n            : never;\n}[keyof A];\nexport type NonFixedAttributeNames<A extends Attributes> = {\n    [K in keyof A]: A[K] extends FixedAttribute<any, any>\n        ? never\n        : A[K] extends OptionalFixedAttribute<any, any>\n          ? never\n          : K;\n}[keyof A];\n\ntype GetterTypeFromSpec<A extends Attribute<any, any>> =\n    A extends OptionalAttribute<infer T, any> ? T | undefined : AttributeJsType<A>;\ntype ServerAttributeGetters<A extends Attributes> = {\n    [P in MandatoryAttributeNames<A> as `get${Capitalize<string & P>}Attribute`]: () => GetterTypeFromSpec<A[P]>;\n} & { [P in OptionalAttributeNames<A> as `get${Capitalize<string & P>}Attribute`]?: () => GetterTypeFromSpec<A[P]> } & {\n    [P in FabricScopedAttributeNames<A> as `get${Capitalize<string & P>}Attribute`]: (\n        fabric: Fabric,\n    ) => GetterTypeFromSpec<A[P]>;\n};\ntype ServerAttributeSetters<A extends Attributes> = {\n    [P in NonFixedAttributeNames<A> as `set${Capitalize<string & P>}Attribute`]: (value: AttributeJsType<A[P]>) => void;\n} & {\n    [P in FabricScopedAttributeNames<A> as `set${Capitalize<string & P>}Attribute`]: (\n        value: AttributeJsType<A[P]>,\n        fabric: Fabric,\n    ) => void;\n};\ntype ServerAttributeSubscribers<A extends Attributes> = {\n    [P in NonFixedAttributeNames<A> as `subscribe${Capitalize<string & P>}Attribute`]: (\n        listener: (newValue: AttributeJsType<A[P]>, oldValue: AttributeJsType<A[P]>) => void,\n    ) => void;\n} & {\n    [P in FabricScopedAttributeNames<A> as `subscribe${Capitalize<string & P>}Attribute`]: (\n        listener: (newValue: AttributeJsType<A[P]>, oldValue: AttributeJsType<A[P]>) => void,\n        fabric: Fabric,\n    ) => void;\n};\n\nexport type EventServers<E extends Events = Events> = Merge<\n    { [P in MandatoryEventNames<E>]: AnyEventServer<EventType<E[P]>, any> },\n    { [P in OptionalEventNames<E>]?: AnyEventServer<EventType<E[P]>, any> }\n>;\ntype ServerEventTriggers<E extends Events> = {\n    [P in MandatoryEventNames<E> as `trigger${Capitalize<string & P>}Event`]: (event: EventType<E[P]>) => void;\n} & { [P in OptionalEventNames<E> as `trigger${Capitalize<string & P>}Event`]?: (event: EventType<E[P]>) => void };\nexport type SupportedEventsList<E extends Events> = Merge<\n    { [P in MandatoryEventNames<E>]: true },\n    { [P in OptionalEventNames<E>]?: boolean }\n>;\n\nexport interface ClusterDatasource<S extends Storage = any> {\n    readonly version: number;\n    readonly eventHandler?: EventHandler<S>;\n    increaseVersion(): number;\n    changed(key: string, value: SupportedStorageTypes): void;\n}\n\nexport namespace ClusterDatasource {\n    export type Factory = (endpoint: EndpointInterface, cluster: ClusterServerObj) => ClusterDatasource;\n}\n\nexport type ClusterServerObj<T extends ClusterType = ClusterType> = ClusterServer<T> & {\n    /**\n     * Cluster ID\n     * @readonly\n     */\n    id: ClusterId;\n\n    /**\n     * Cluster name\n     * @readonly\n     */\n    readonly name: string;\n\n    /**\n     * Cluster type\n     * @private\n     * @readonly\n     */\n    _type: \"ClusterServer\";\n\n    /** Returns if a given Attribute Id is defined and supported by this cluster server. */\n    isAttributeSupported: (attributeId: AttributeId) => boolean;\n\n    /** Returns if a given Attribute for provided name is defined and supported by this cluster server. */\n    isAttributeSupportedByName: (attributeName: string) => boolean;\n\n    /** Returns if a given Event is defined and supported by this cluster server. */\n    isEventSupported: (eventId: EventId) => boolean;\n\n    /** Returns if a given Event for provided name is defined and supported by this cluster server. */\n    isEventSupportedByName: (eventName: string) => boolean;\n\n    /** Returns if a given Command is defined and supported by this cluster server. */\n    isCommandSupported: (commandId: CommandId) => boolean;\n\n    /** Returns if a given Command for provided name is defined and supported by this cluster server. */\n    isCommandSupportedByName: (commandName: string) => boolean;\n} & ServerAttributeGetters<T[\"attributes\"]> &\n    ServerAttributeSetters<T[\"attributes\"]> &\n    ServerAttributeSubscribers<T[\"attributes\"]> &\n    ServerEventTriggers<T[\"events\"]>;\n\n/** Strongly typed interface of a cluster server */\nexport type ClusterServerObjInternal<T extends ClusterType = ClusterType> = ClusterServerObj<T> & {\n    /**\n     * Assign this cluster to a specific endpoint. This method also initializes the internal Cluster logics\n     * @private\n     *\n     * @param endpoint Endpoint to assign to\n     */\n    readonly _assignToEndpoint: (endpoint: Endpoint) => void;\n\n    /**\n     * Destroy internal cluster logics, timers and such\n     * @private\n     */\n    readonly _close: () => void;\n};\n\nexport function isClusterServer<T extends ClusterType>(\n    obj: ClusterClientObj<T> | ClusterServerObj<T>,\n): obj is ClusterServerObj<T> {\n    return obj._type === \"ClusterServer\";\n}\n\nexport function isClusterServerInternal<T extends ClusterType>(\n    obj: ClusterClientObj<T> | ClusterServerObj<T>,\n): obj is ClusterServerObjInternal<T> {\n    return obj._type === \"ClusterServer\";\n}\n\nexport function asClusterServerInternal<T extends ClusterType>(obj: ClusterServerObj<T>): ClusterServerObjInternal<T> {\n    if (!isClusterServerInternal(obj)) {\n        throw new Error(\"Object is not a ClusterServerObj instance.\");\n    }\n    return obj;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4KA,MAAM,0BAA0B,CAC5B,YACA,SACgC;AAChC,QAAM,SAAqB,EAAE,GAAG,WAAW;AAC3C,aAAW,OAAO,MAAM;AACpB,IAAC,OAAe,GAAG,IAAI,EAAE,GAAG,OAAO,GAAG,GAAG,UAAU,MAAM;AAAA,EAC7D;AACA,SAAO;AACX;AAaO,MAAM,wBAAwB,CAIjC,SACA,UAC+B,EAAE,GAAG,SAAS,YAAY,wBAAwB,QAAQ,YAAY,IAAI,EAAE;AAiIxG,SAAS,gBACZ,KAC0B;AAC1B,SAAO,IAAI,UAAU;AACzB;AAEO,SAAS,wBACZ,KACkC;AAClC,SAAO,IAAI,UAAU;AACzB;AAEO,SAAS,wBAA+C,KAAuD;AAClH,MAAI,CAAC,wBAAwB,GAAG,GAAG;AAC/B,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AACA,SAAO;AACX;",
  "names": []
}
