"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AdministratorCommissioningServer_exports = {};
__export(AdministratorCommissioningServer_exports, {
  AdministratorCommissioningHandler: () => AdministratorCommissioningHandler,
  BasicAdminCommissioningHandler: () => BasicAdminCommissioningHandler
});
module.exports = __toCommonJS(AdministratorCommissioningServer_exports);
var import_AdministratorCommissioningConstants = require("../../behavior/definitions/administrator-commissioning/AdministratorCommissioningConstants.js");
var import_MatterError = require("../../common/MatterError.js");
var import_Logger = require("../../log/Logger.js");
var import_StatusCode = require("../../protocol/interaction/StatusCode.js");
var import_PaseServer = require("../../session/pase/PaseServer.js");
var import_Time = require("../../time/Time.js");
var import_TlvNumber = require("../../tlv/TlvNumber.js");
var import_TlvObject = require("../../tlv/TlvObject.js");
var import_TlvString = require("../../tlv/TlvString.js");
var import_Cluster = require("../Cluster.js");
var import_AdministratorCommissioningCluster = require("../definitions/AdministratorCommissioningCluster.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("AdministratorCommissioningServer");
import_AdministratorCommissioningCluster.AdministratorCommissioning.Cluster.commands = {
  ...import_AdministratorCommissioningCluster.AdministratorCommissioning.Cluster.commands,
  openCommissioningWindow: (0, import_Cluster.Command)(
    0,
    (0, import_TlvObject.TlvObject)({
      commissioningTimeout: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
      pakePasscodeVerifier: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvByteString),
      discriminator: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16.bound({ max: 4095 })),
      iterations: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt32),
      salt: (0, import_TlvObject.TlvField)(4, import_TlvString.TlvByteString)
    }),
    0,
    import_Cluster.TlvNoResponse,
    {
      invokeAcl: import_Cluster.AccessLevel.Administer,
      timed: true
    }
  )
};
class AdministratorCommissioningManager {
  constructor(windowStatusAttribute, adminFabricIndexAttribute, adminVendorIdAttribute) {
    this.windowStatusAttribute = windowStatusAttribute;
    this.adminFabricIndexAttribute = adminFabricIndexAttribute;
    this.adminVendorIdAttribute = adminVendorIdAttribute;
    windowStatusAttribute.setLocal(import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen);
  }
  commissioningWindowTimeout;
  fabricRemoveHandler = async () => this.adminFabricIndexAttribute.setLocal(null);
  /**
   * Called whenever a Commissioning/Announcement Window is opened by this cluster. This method starts the timer and
   * adjusts the needed attributes.
   */
  initializeCommissioningWindow(commissioningTimeout, session) {
    if (this.commissioningWindowTimeout !== void 0) {
      throw new import_MatterError.InternalError("Commissioning window already initialized.");
    }
    logger.debug(`Commissioning window timer started for ${commissioningTimeout} seconds for ${session.name}.`);
    this.commissioningWindowTimeout = import_Time.Time.getTimer(
      "Commissioning timeout",
      commissioningTimeout * 1e3,
      async () => await this.closeCommissioningWindow(session)
    ).start();
    this.adminFabricIndexAttribute.setLocal(session.associatedFabric.fabricIndex);
    this.adminVendorIdAttribute.setLocal(session.associatedFabric.rootVendorId);
    session.associatedFabric.addRemoveCallback(async () => this.fabricRemoveHandler());
  }
  /**
   * This method validates if a commissioning window can be opened and throws various exceptions in case of failures.
   */
  assertCommissioningWindowRequirements(commissioningTimeout, device) {
    if (this.commissioningWindowTimeout !== void 0) {
      throw new import_StatusCode.StatusResponseError(
        "A commissioning window is already opened.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.Busy
      );
    }
    if (commissioningTimeout > import_AdministratorCommissioningConstants.MAXIMUM_COMMISSIONING_TIMEOUT_S) {
      throw new import_StatusCode.StatusResponseError(
        `Commissioning timeout must not exceed ${import_AdministratorCommissioningConstants.MAXIMUM_COMMISSIONING_TIMEOUT_S} seconds.`,
        import_StatusCode.StatusCode.InvalidCommand
      );
    }
    if (commissioningTimeout < import_AdministratorCommissioningConstants.MINIMUM_COMMISSIONING_TIMEOUT_S) {
      throw new import_StatusCode.StatusResponseError(
        `Commissioning timeout must not be lower then ${import_AdministratorCommissioningConstants.MINIMUM_COMMISSIONING_TIMEOUT_S} seconds.`,
        import_StatusCode.StatusCode.InvalidCommand
      );
    }
    if (device.isFailsafeArmed()) {
      throw new import_StatusCode.StatusResponseError(
        "Failsafe timer armed, assume commissioning in progress.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.Busy
      );
    }
  }
  /**
   * This method opens an Enhanced Commissioning Window (A dynamic passcode is used which was provided by the caller).
   */
  async openEnhancedCommissioningWindow(pakeVerifier, discriminator, iterations, salt, commissioningTimeout, session) {
    if (pakeVerifier.length !== import_AdministratorCommissioningConstants.PAKE_PASSCODE_VERIFIER_LENGTH) {
      throw new import_StatusCode.StatusResponseError(
        "PAKE Passcode verifier length is invalid.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.PakeParameterError
      );
    }
    if (iterations < 1e3 || iterations > 1e5) {
      throw new import_StatusCode.StatusResponseError(
        "PAKE iterations invalid.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.PakeParameterError
      );
    }
    if (salt.length < 16 || salt.length > 32) {
      throw new import_StatusCode.StatusResponseError(
        "PAKE salt has invalid length.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.PakeParameterError
      );
    }
    const device = session.context;
    this.assertCommissioningWindowRequirements(commissioningTimeout, device);
    this.windowStatusAttribute.setLocal(import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen);
    this.initializeCommissioningWindow(commissioningTimeout, session);
    await device.allowEnhancedCommissioning(
      discriminator,
      import_PaseServer.PaseServer.fromVerificationValue(pakeVerifier, { iterations, salt }),
      () => {
        session.associatedFabric.deleteRemoveCallback(this.fabricRemoveHandler);
        this.endCommissioning();
      }
    );
  }
  /** This method opens a Basic Commissioning Window. The default passcode is used. */
  async openBasicCommissioningWindow(commissioningTimeout, session) {
    const device = session.context;
    this.assertCommissioningWindowRequirements(commissioningTimeout, device);
    this.windowStatusAttribute.setLocal(import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen);
    this.initializeCommissioningWindow(commissioningTimeout, session);
    await device.allowBasicCommissioning(() => {
      session.associatedFabric.deleteRemoveCallback(this.fabricRemoveHandler);
      this.endCommissioning();
    });
  }
  /**
   * This method is used internally when the commissioning window timer expires or the commissioning was completed.
   */
  endCommissioning() {
    if (this.commissioningWindowTimeout === void 0) {
      return;
    }
    this.commissioningWindowTimeout.stop();
    this.commissioningWindowTimeout = void 0;
    logger.debug("End commissioning window.");
    this.windowStatusAttribute.setLocal(import_AdministratorCommissioningCluster.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen);
    this.adminFabricIndexAttribute.setLocal(null);
    this.adminVendorIdAttribute.setLocal(null);
  }
  /** This method is used to close a commissioning window. */
  async closeCommissioningWindow(session) {
    this.endCommissioning();
    await session.context.endCommissioning();
  }
  /** This method is used to revoke a commissioning window. */
  async revokeCommissioning(session) {
    if (this.commissioningWindowTimeout === void 0) {
      throw new import_StatusCode.StatusResponseError(
        "No commissioning window is opened that could be revoked.",
        import_StatusCode.StatusCode.Failure,
        import_AdministratorCommissioningCluster.AdministratorCommissioning.StatusCode.WindowNotOpen
      );
    }
    logger.debug("Revoking commissioning window.");
    await this.closeCommissioningWindow(session);
    const device = session.context;
    if (device.isFailsafeArmed()) {
      await device.failsafeContext.close();
    }
  }
  /** Cleanup resources and stop the timer when the ClusterServer is destroyed. */
  close() {
    if (this.commissioningWindowTimeout !== void 0) {
      this.commissioningWindowTimeout.stop();
      this.commissioningWindowTimeout = void 0;
    }
  }
}
const AdministratorCommissioningHandler = () => {
  let manager;
  return {
    initializeClusterServer: ({ attributes: { windowStatus, adminVendorId, adminFabricIndex } }) => {
      manager = new AdministratorCommissioningManager(windowStatus, adminFabricIndex, adminVendorId);
    },
    openCommissioningWindow: async ({
      request: { pakePasscodeVerifier: pakeVerifier, discriminator, iterations, salt, commissioningTimeout },
      session
    }) => manager.openEnhancedCommissioningWindow(
      pakeVerifier,
      discriminator,
      iterations,
      salt,
      commissioningTimeout,
      session
    ),
    revokeCommissioning: async ({ session }) => await manager.revokeCommissioning(session),
    destroyClusterServer: () => manager?.close()
  };
};
const AdministratorCommissioningBasicCluster = import_AdministratorCommissioningCluster.AdministratorCommissioning.Cluster.with("Basic");
const BasicAdminCommissioningHandler = () => {
  let manager;
  return {
    initializeClusterServer: ({ attributes: { windowStatus, adminVendorId, adminFabricIndex } }) => {
      manager = new AdministratorCommissioningManager(windowStatus, adminFabricIndex, adminVendorId);
    },
    openCommissioningWindow: async ({
      request: { pakePasscodeVerifier: pakeVerifier, discriminator, iterations, salt, commissioningTimeout },
      session
    }) => manager.openEnhancedCommissioningWindow(
      pakeVerifier,
      discriminator,
      iterations,
      salt,
      commissioningTimeout,
      session
    ),
    openBasicCommissioningWindow: async ({ request: { commissioningTimeout }, session }) => manager.openBasicCommissioningWindow(commissioningTimeout, session),
    revokeCommissioning: async ({ session }) => await manager.revokeCommissioning(session),
    destroyClusterServer: () => manager?.close()
  };
};
//# sourceMappingURL=AdministratorCommissioningServer.js.map
