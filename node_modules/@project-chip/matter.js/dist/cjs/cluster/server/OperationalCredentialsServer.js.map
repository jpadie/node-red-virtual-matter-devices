{
  "version": 3,
  "sources": ["../../../../src/cluster/server/OperationalCredentialsServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// TODO: Rename to NodeOperationalCredentialsServer to match with specs\n\nimport { DeviceCertification } from \"../../behavior/definitions/operational-credentials/DeviceCertification.js\";\nimport {\n    TlvAttestation,\n    TlvCertSigningRequest,\n} from \"../../behavior/definitions/operational-credentials/OperationalCredentialsTypes.js\";\nimport { ProductDescription } from \"../../behavior/system/product-description/ProductDescription.js\";\nimport { CertificateError } from \"../../certificate/CertificateManager.js\";\nimport { MatterFabricInvalidAdminSubjectError } from \"../../common/FailsafeContext.js\";\nimport { MatterFabricConflictError } from \"../../common/FailsafeTimer.js\";\nimport { MatterFlowError, UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { ValidationError } from \"../../common/ValidationError.js\";\nimport { CryptoVerifyError } from \"../../crypto/Crypto.js\";\nimport { FabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { PublicKeyError } from \"../../fabric/Fabric.js\";\nimport { FabricTableFullError } from \"../../fabric/FabricManager.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { StatusCode, StatusResponseError } from \"../../protocol/interaction/StatusCode.js\";\nimport { assertSecureSession } from \"../../session/SecureSession.js\";\nimport { TlvBoolean } from \"../../tlv/TlvBoolean.js\";\nimport { TlvField, TlvObject, TlvOptionalField } from \"../../tlv/TlvObject.js\";\nimport { TlvByteString } from \"../../tlv/TlvString.js\";\nimport { AccessLevel, Command } from \"../Cluster.js\";\nimport { BasicInformation } from \"../definitions/BasicInformationCluster.js\";\nimport { OperationalCredentials } from \"../definitions/OperationalCredentialsCluster.js\";\nimport { AccessControl } from \"../definitions/index.js\";\nimport { ClusterServerHandlers } from \"./ClusterServerTypes.js\";\n\nconst logger = Logger.get(\"OperationalCredentialsServer\");\n\n/**\n * Monkey patching Tlv Structure of attestationRequest and csrRequest commands to prevent data validation of the nonce\n * fields to be handled as ConstraintError because we need to return a special error.\n * We do this to leave the model in fact for other validations and only apply the change for our Schema-aware Tlv parsing.\n */\nOperationalCredentials.Cluster.commands = {\n    ...OperationalCredentials.Cluster.commands,\n    attestationRequest: Command(\n        0x0,\n        TlvObject({ attestationNonce: TlvField(0, TlvByteString) }),\n        0x1,\n        OperationalCredentials.TlvAttestationResponse,\n        { invokeAcl: AccessLevel.Administer },\n    ),\n    csrRequest: Command(\n        0x4,\n        TlvObject({\n            csrNonce: TlvField(0, TlvByteString),\n            isForUpdateNoc: TlvOptionalField(1, TlvBoolean),\n        }),\n        0x5,\n        OperationalCredentials.TlvCsrResponse,\n        { invokeAcl: AccessLevel.Administer },\n    ),\n};\n\nexport const OperationalCredentialsClusterHandler: (\n    certificates: DeviceCertification.Definition,\n    productDescription?: ProductDescription,\n) => ClusterServerHandlers<typeof OperationalCredentials.Cluster> = (certificates, productDescription) => {\n    let certification: DeviceCertification | undefined = undefined;\n    const cert = () => {\n        if (certification !== undefined) {\n            return certification;\n        }\n        return (certification = new DeviceCertification(certificates, productDescription));\n    };\n\n    const assureCertification = async () => {\n        await cert().construction;\n    };\n\n    return {\n        attestationRequest: async ({ request: { attestationNonce }, session }) => {\n            if (attestationNonce.length !== 32) {\n                throw new StatusResponseError(\"Invalid attestation nonce length\", StatusCode.InvalidCommand);\n            }\n            assertSecureSession(session);\n            await assureCertification();\n            const elements = TlvAttestation.encode({\n                declaration: cert().declaration,\n                attestationNonce,\n                timestamp: 0,\n            });\n            return { attestationElements: elements, attestationSignature: cert().sign(session, elements) };\n        },\n\n        csrRequest: async ({ request: { csrNonce, isForUpdateNoc }, session }) => {\n            if (csrNonce.length !== 32) {\n                throw new StatusResponseError(\"Invalid CSR nonce length\", StatusCode.InvalidCommand);\n            }\n            assertSecureSession(session);\n            if (isForUpdateNoc && session.isPase) {\n                throw new StatusResponseError(\n                    \"csrRequest for UpdateNoc received on a PASE session.\",\n                    StatusCode.InvalidCommand,\n                );\n            }\n            const device = session.context;\n            device.assertFailSafeArmed(\"csrRequest received while failsafe is not armed.\");\n\n            const timedOp = device.failsafeContext;\n            if (timedOp.fabricIndex !== undefined) {\n                throw new StatusResponseError(\n                    `csrRequest received after ${timedOp.forUpdateNoc ? \"UpdateNOC\" : \"AddNOC\"} already invoked.`,\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            await assureCertification();\n\n            const certSigningRequest = timedOp.createCertificateSigningRequest(isForUpdateNoc ?? false, session.id);\n            const nocsrElements = TlvCertSigningRequest.encode({ certSigningRequest, csrNonce });\n            return { nocsrElements, attestationSignature: cert().sign(session, nocsrElements) };\n        },\n\n        certificateChainRequest: async ({ request: { certificateType } }) => {\n            await assureCertification();\n            switch (certificateType) {\n                case OperationalCredentials.CertificateChainType.DacCertificate:\n                    return { certificate: cert().certificate };\n                case OperationalCredentials.CertificateChainType.PaiCertificate:\n                    return { certificate: cert().intermediateCertificate };\n                default:\n                    throw new StatusResponseError(\n                        `Unsupported certificate type: ${certificateType}`,\n                        StatusCode.InvalidCommand,\n                    );\n            }\n        },\n\n        addNoc: async ({\n            request: { nocValue, icacValue, ipkValue, caseAdminSubject, adminVendorId },\n            attributes: { nocs, commissionedFabrics, fabrics, trustedRootCertificates, supportedFabrics },\n            session,\n            endpoint,\n            message,\n        }) => {\n            if (!session.isSecure)\n                throw new MatterFlowError(\"addOperationalCert should be called on a secure session.\");\n\n            const device = session.context;\n\n            const failsafeContext = device.failsafeContext;\n\n            if (failsafeContext.fabricIndex !== undefined) {\n                throw new StatusResponseError(\n                    `addNoc received after ${failsafeContext.forUpdateNoc ? \"UpdateNOC\" : \"AddNOC\"} already invoked.`,\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            if (!failsafeContext.hasRootCert) {\n                return {\n                    statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidNoc,\n                    debugText: \"Root certificate not found.\",\n                };\n            }\n\n            if (failsafeContext.csrSessionId !== session.id) {\n                return {\n                    statusCode: OperationalCredentials.NodeOperationalCertStatus.MissingCsr,\n                    debugText: \"CSR not found in failsafe context.\",\n                };\n            }\n\n            if (failsafeContext.forUpdateNoc) {\n                throw new StatusResponseError(\n                    `addNoc received after csr request was invoked for UpdateNOC.`,\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            if (device.getFabrics().length === supportedFabrics.getLocal()) {\n                return {\n                    statusCode: OperationalCredentials.NodeOperationalCertStatus.TableFull,\n                    debugText: `No more fabrics can be added because limit ${supportedFabrics.getLocal()} reached.`,\n                };\n            }\n\n            let fabric;\n            try {\n                fabric = await failsafeContext.buildFabric({\n                    nocValue,\n                    icacValue,\n                    adminVendorId,\n                    ipkValue,\n                    caseAdminSubject,\n                });\n            } catch (error) {\n                logger.info(\"building fabric failed\", error);\n                if (error instanceof MatterFabricConflictError) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.FabricConflict,\n                        debugText: error.message,\n                    };\n                } else if (error instanceof FabricTableFullError) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.TableFull,\n                        debugText: error.message,\n                    };\n                } else if (\n                    error instanceof CryptoVerifyError ||\n                    error instanceof CertificateError ||\n                    error instanceof ValidationError ||\n                    error instanceof UnexpectedDataError\n                ) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidNoc,\n                        debugText: error.message,\n                    };\n                } else if (error instanceof PublicKeyError) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidPublicKey,\n                        debugText: error.message,\n                    };\n                } else if (error instanceof MatterFabricInvalidAdminSubjectError) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidAdminSubject,\n                        debugText: error.message,\n                    };\n                }\n                throw error;\n            }\n            await failsafeContext.addFabric(fabric);\n\n            assertSecureSession(session);\n            if (session.isPase) {\n                logger.debug(`Add Fabric with index ${fabric.fabricIndex} to PASE session ${session.name}.`);\n                session.addAssociatedFabric(fabric);\n            }\n\n            // Update connected attributes\n            nocs.updated(session);\n            commissionedFabrics.updated(session);\n            fabrics.updated(session);\n            trustedRootCertificates.updated(session);\n\n            // The receiver SHALL create and add a new Access Control Entry using the CaseAdminSubject field to grant\n            // subsequent Administer access to an Administrator member of the new Fabric.\n            const aclServer = endpoint.getClusterServer(AccessControl.Cluster);\n            if (aclServer !== undefined) {\n                // Set is fabric filtered automatically, so we can set because this is a new fabric\n                aclServer.attributes.acl.set(\n                    [\n                        {\n                            fabricIndex: fabric.fabricIndex,\n                            privilege: AccessControl.AccessControlEntryPrivilege.Administer,\n                            authMode: AccessControl.AccessControlEntryAuthMode.Case,\n                            subjects: [caseAdminSubject],\n                            targets: null, // entire node\n                        },\n                    ],\n                    session,\n                    message,\n                    false,\n                    true,\n                );\n            }\n\n            // TODO The incoming IPKValue SHALL be stored in the Fabric-scoped slot within the Group Key Management cluster\n            //  (see KeySetWrite), for subsequent use during CASE.\n\n            // TODO If the current secure session was established with PASE, the receiver SHALL:\n            //  a. Augment the secure session context with the FabricIndex generated above, such that subsequent interactions\n            //     have the proper accessing fabric.\n\n            logger.info(`addNoc success, adminVendorId ${adminVendorId}, caseAdminSubject ${caseAdminSubject}`);\n\n            return { statusCode: OperationalCredentials.NodeOperationalCertStatus.Ok, fabricIndex: fabric.fabricIndex };\n        },\n\n        fabricsAttributeGetter: ({ session, isFabricFiltered }) => {\n            if (session === undefined || !session.isSecure) return []; // ???\n            const fabrics = isFabricFiltered ? [session.associatedFabric] : session.context.getFabrics();\n\n            return fabrics.map(fabric => ({\n                fabricId: fabric.fabricId,\n                label: fabric.label,\n                nodeId: fabric.nodeId,\n                rootPublicKey: fabric.rootPublicKey,\n                vendorId: fabric.rootVendorId,\n                fabricIndex: fabric.fabricIndex,\n            }));\n        },\n\n        // Needed because FabricScopedAttributeServer clas requires both getter and setter if custom\n        fabricsAttributeSetter: () => {\n            throw new MatterFlowError(\"fabrics attribute is read-only.\");\n        },\n\n        nocsAttributeGetter: ({ session, isFabricFiltered }) => {\n            if (session === undefined || !session.isSecure) return []; // ???\n            const fabrics = isFabricFiltered ? [session.associatedFabric] : session.context.getFabrics();\n            return fabrics.map(fabric => ({\n                noc: fabric.operationalCert,\n                icac: fabric.intermediateCACert ?? null,\n                fabricIndex: fabric.fabricIndex,\n            }));\n        },\n\n        // Needed because FabricScopedAttributeServer clas requires both getter and setter if custom\n        nocsAttributeSetter: () => {\n            throw new MatterFlowError(\"fabrics attribute is read-only.\");\n        },\n\n        commissionedFabricsAttributeGetter: ({ session }) => {\n            if (session === undefined || !session.isSecure) return 0; // ???\n            return session.context.getFabrics().length;\n        },\n\n        trustedRootCertificatesAttributeGetter: ({ session }) => {\n            if (session === undefined || !session.isSecure) {\n                logger.debug(`trustedRootCertificatesAttributeGetter: session not set or not secure ${!!session}`);\n                return [];\n            } // ???\n            if (!session.isSecure)\n                throw new MatterFlowError(\"addOperationalCert should be called on a secure session.\");\n\n            const rootCerts = session.context.getFabrics().map(fabric => fabric.rootCert);\n\n            const device = session.context;\n            if (device.isFailsafeArmed()) {\n                const failsafeContext = device.failsafeContext;\n                const temporaryRootCert = failsafeContext.rootCert;\n                if (temporaryRootCert !== undefined) {\n                    logger.debug(`Add temporary trusted root certificate to the list.`);\n                    rootCerts.push(temporaryRootCert);\n                } else {\n                    logger.debug(`No temporary trusted root certificate to be added.`);\n                }\n            }\n            return rootCerts;\n        },\n\n        currentFabricIndexAttributeGetter: ({ session }) => {\n            if (session === undefined || !session.isSecure) return FabricIndex.NO_FABRIC;\n            assertSecureSession(session);\n            return session.fabric?.fabricIndex ?? FabricIndex.NO_FABRIC;\n        },\n\n        updateNoc: async ({ request: { nocValue, icacValue }, attributes: { nocs, fabrics }, session }) => {\n            assertSecureSession(session);\n\n            // Assert associated fabric is present\n            session.associatedFabric;\n\n            const device = session.context;\n\n            const failsafeContext = device.failsafeContext;\n\n            if (failsafeContext.fabricIndex !== undefined) {\n                throw new StatusResponseError(\n                    `updateNoc received after ${failsafeContext.forUpdateNoc ? \"UpdateNOC\" : \"AddNOC\"} already invoked.`,\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            if (failsafeContext.forUpdateNoc) {\n                throw new StatusResponseError(\n                    `addNoc received after csr request was invoked for UpdateNOC.`,\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            if (failsafeContext.hasRootCert) {\n                throw new StatusResponseError(\n                    \"Trusted root certificate added in this session which is now allowed for UpdateNOC.\",\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            if (!failsafeContext.forUpdateNoc) {\n                throw new StatusResponseError(\"csrRequest not invoked for UpdateNOC.\", StatusCode.ConstraintError);\n            }\n\n            if (session.associatedFabric.fabricIndex !== failsafeContext.associatedFabric?.fabricIndex) {\n                throw new StatusResponseError(\n                    \"Fabric of this session and the failsafe context do not match.\",\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            try {\n                // Build a new Fabric with the updated NOC and ICAC\n                const updateFabric = await failsafeContext.buildUpdatedFabric(nocValue, icacValue);\n\n                // update FabricManager and Resumption records but leave current session intact\n                await failsafeContext.updateFabric(updateFabric);\n\n                // Update connected attributes\n                nocs.updated(session);\n                fabrics.updated(session);\n\n                return {\n                    statusCode: OperationalCredentials.NodeOperationalCertStatus.Ok,\n                    fabricIndex: updateFabric.fabricIndex,\n                };\n            } catch (error) {\n                logger.info(\"building fabric for update failed\", error);\n                if (\n                    error instanceof CryptoVerifyError ||\n                    error instanceof CertificateError ||\n                    error instanceof ValidationError ||\n                    error instanceof UnexpectedDataError\n                ) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidNoc,\n                        debugText: error.message,\n                    };\n                } else if (error instanceof PublicKeyError) {\n                    return {\n                        statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidPublicKey,\n                        debugText: error.message,\n                    };\n                }\n                throw error;\n            }\n        },\n\n        updateFabricLabel: async ({ request: { label }, attributes: { fabrics }, session }) => {\n            assertSecureSession(session, \"updateOperationalCert should be called on a secure session.\");\n\n            const fabric = session.associatedFabric;\n            const currentFabricIndex = fabric.fabricIndex;\n            const device = session.context;\n            const conflictingLabelFabric = device\n                .getFabrics()\n                .find(f => f.label === label && f.fabricIndex !== currentFabricIndex);\n            if (conflictingLabelFabric !== undefined) {\n                return {\n                    statusCode: OperationalCredentials.NodeOperationalCertStatus.LabelConflict,\n                    debugText: `Label ${label} already used by fabric ${conflictingLabelFabric.fabricIndex}`,\n                };\n            }\n\n            await fabric.setLabel(label);\n\n            fabrics.updated(session);\n\n            return { statusCode: OperationalCredentials.NodeOperationalCertStatus.Ok, fabricIndex: fabric.fabricIndex };\n        },\n\n        removeFabric: async ({\n            request: { fabricIndex },\n            attributes: { nocs, commissionedFabrics, fabrics, trustedRootCertificates },\n            session,\n            endpoint,\n        }) => {\n            const device = session.context;\n\n            const fabric = device.getFabricByIndex(fabricIndex);\n\n            if (fabric === undefined) {\n                return {\n                    statusCode: OperationalCredentials.NodeOperationalCertStatus.InvalidFabricIndex,\n                    debugText: `Fabric ${fabricIndex} not found`,\n                };\n            }\n\n            const basicInformationCluster = endpoint.getClusterServer(BasicInformation.Cluster);\n            basicInformationCluster?.triggerLeaveEvent?.({ fabricIndex });\n\n            assertSecureSession(session);\n\n            await fabric.remove(session.id);\n            nocs.updated(session);\n            commissionedFabrics.updated(session);\n            fabrics.updated(session);\n            trustedRootCertificates.updated(session);\n\n            return {\n                statusCode: OperationalCredentials.NodeOperationalCertStatus.Ok,\n                fabricIndex,\n            };\n        },\n\n        addTrustedRootCertificate: async ({\n            request: { rootCaCertificate },\n            attributes: { trustedRootCertificates },\n            session,\n        }) => {\n            assertSecureSession(session);\n\n            const failsafeContext = session.context.failsafeContext;\n\n            if (failsafeContext.hasRootCert) {\n                throw new StatusResponseError(\n                    \"Trusted root certificate already added in this FailSafe context.\",\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            if (failsafeContext.fabricIndex !== undefined) {\n                throw new StatusResponseError(\n                    `Cannot add trusted root certificates after ${failsafeContext.forUpdateNoc ? \"UpdateNOC\" : \"AddNOC\"}.`,\n                    StatusCode.ConstraintError,\n                );\n            }\n\n            try {\n                failsafeContext.setRootCert(rootCaCertificate);\n            } catch (error) {\n                logger.info(\"setting root certificate failed\", error);\n                if (\n                    error instanceof CryptoVerifyError ||\n                    error instanceof CertificateError ||\n                    error instanceof ValidationError ||\n                    error instanceof UnexpectedDataError\n                ) {\n                    throw new StatusResponseError(error.message, StatusCode.InvalidCommand);\n                }\n                throw error;\n            }\n\n            trustedRootCertificates.updated(session);\n        },\n    };\n};\n"],
  "mappings": "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",
  "names": []
}
