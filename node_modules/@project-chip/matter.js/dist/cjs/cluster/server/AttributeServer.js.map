{
  "version": 3,
  "sources": ["../../../../src/cluster/server/AttributeServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterDevice } from \"../../MatterDevice.js\";\nimport { Message } from \"../../codec/MessageCodec.js\";\nimport { ImplementationError, InternalError, MatterError } from \"../../common/MatterError.js\";\nimport { ValidationError } from \"../../common/ValidationError.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { Fabric } from \"../../fabric/Fabric.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { AttributeModel, ClusterModel, DatatypeModel, MatterModel } from \"../../model/index.js\";\nimport { FabricIndex } from \"../../model/standard/elements/FabricIndex.js\";\nimport { StatusCode, StatusResponseError } from \"../../protocol/interaction/StatusCode.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport { NoAssociatedFabricError, SecureSession, assertSecureSession } from \"../../session/SecureSession.js\";\nimport { Session } from \"../../session/Session.js\";\nimport { TlvSchema } from \"../../tlv/TlvSchema.js\";\nimport { isDeepEqual } from \"../../util/DeepEqual.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { camelize } from \"../../util/String.js\";\nimport { AccessLevel, Attribute, Attributes, Cluster, Commands, Events } from \"../Cluster.js\";\nimport { ClusterDatasource } from \"./ClusterServerTypes.js\";\n\nconst logger = Logger.get(\"AttributeServer\");\n\nconst FabricIndexName = camelize(FabricIndex.name);\n\n/**\n * Thrown when an operation cannot complete because fabric information is\n * unavailable.\n */\nexport class FabricScopeError extends MatterError {}\n\nexport type AnyAttributeServer<T> = AttributeServer<T> | FabricScopedAttributeServer<T> | FixedAttributeServer<T>;\n\ntype DelayedChangeData = {\n    oldValue: any;\n    newValue: any;\n    changed: boolean;\n};\n\n/**\n * Factory function to create an attribute server.\n */\nexport function createAttributeServer<\n    T,\n    F extends BitSchema,\n    SF extends TypeFromPartialBitSchema<F>,\n    A extends Attributes,\n    C extends Commands,\n    E extends Events,\n>(\n    clusterDef: Cluster<F, SF, A, C, E>,\n    attributeDef: Attribute<T, F>,\n    attributeName: string,\n    initValue: T,\n    datasource: ClusterDatasource,\n    getter?: (\n        session?: Session<MatterDevice>,\n        endpoint?: EndpointInterface,\n        isFabricFiltered?: boolean,\n        message?: Message,\n    ) => T,\n    setter?: (value: T, session?: Session<MatterDevice>, endpoint?: EndpointInterface, message?: Message) => boolean,\n    validator?: (value: T, session?: Session<MatterDevice>, endpoint?: EndpointInterface) => void,\n) {\n    const {\n        id,\n        schema,\n        writable,\n        fabricScoped,\n        fixed,\n        omitChanges,\n        timed,\n        default: defaultValue,\n        readAcl,\n        writeAcl,\n    } = attributeDef;\n\n    if (fixed) {\n        return new FixedAttributeServer(\n            id,\n            attributeName,\n            readAcl,\n            writeAcl,\n            schema,\n            writable,\n            false,\n            timed,\n            initValue,\n            defaultValue,\n            datasource,\n            getter,\n        );\n    }\n\n    if (fabricScoped) {\n        return new FabricScopedAttributeServer(\n            id,\n            attributeName,\n            readAcl,\n            writeAcl,\n            schema,\n            writable,\n            !omitChanges,\n            timed,\n            initValue,\n            defaultValue,\n            clusterDef,\n            datasource,\n            getter,\n            setter,\n            validator,\n        );\n    }\n\n    return new AttributeServer(\n        id,\n        attributeName,\n        readAcl,\n        writeAcl,\n        schema,\n        writable,\n        !omitChanges,\n        timed,\n        initValue,\n        defaultValue,\n        datasource,\n        getter,\n        setter,\n        validator,\n    );\n}\n\n/**\n * Base class for all attribute servers.\n */\nexport abstract class BaseAttributeServer<T> {\n    /**\n     * The value is undefined when getter/setter are used. But we still handle the version number here.\n     */\n    protected value: T | undefined = undefined;\n    protected endpoint?: EndpointInterface;\n    readonly defaultValue: T;\n    #readAcl: AccessLevel | undefined;\n    #writeAcl: AccessLevel | undefined;\n\n    constructor(\n        readonly id: AttributeId,\n        readonly name: string,\n        readAcl: AccessLevel | undefined,\n        writeAcl: AccessLevel | undefined,\n        readonly schema: TlvSchema<T>,\n        readonly isWritable: boolean,\n        readonly isSubscribable: boolean,\n        readonly requiresTimedInteraction: boolean,\n        initValue: T,\n        defaultValue: T | undefined,\n    ) {\n        this.#readAcl = readAcl;\n        this.#writeAcl = writeAcl;\n        try {\n            this.validateWithSchema(initValue);\n            this.value = initValue;\n        } catch (error) {\n            logger.warn(\n                `Attribute value to initialize for ${name} has an invalid value ${Logger.toJSON(\n                    initValue,\n                )}. Restore to default ${Logger.toJSON(defaultValue)}`,\n            );\n            if (defaultValue === undefined) {\n                throw new ImplementationError(`Attribute value to initialize for ${name} cannot be undefined.`);\n            }\n            this.validateWithSchema(defaultValue);\n            this.value = defaultValue;\n        }\n        this.defaultValue = this.value;\n    }\n\n    get hasFabricSensitiveData() {\n        return false;\n    }\n\n    validateWithSchema(value: T) {\n        try {\n            this.schema.validate(value);\n        } catch (e) {\n            ValidationError.accept(e);\n\n            // Handle potential error cases where a custom validator is used.\n            e.message = `Validation error for attribute \"${this.name}\"${e.fieldName !== undefined ? ` in field ${e.fieldName}` : \"\"}: ${e.message}`;\n            throw e;\n        }\n    }\n\n    assignToEndpoint(endpoint: EndpointInterface) {\n        this.endpoint = endpoint;\n    }\n\n    /**\n     * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be\n     * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!\n     */\n    abstract init(value: T | undefined): void;\n\n    get writeAcl() {\n        return this.#writeAcl ?? AccessLevel.Operate; // ???\n    }\n\n    get readAcl() {\n        return this.#readAcl ?? AccessLevel.View; // ???\n    }\n}\n\n/**\n * Attribute server class that handled fixed attribute values that never change and is the base class for other\n * Attribute server types.\n */\nexport class FixedAttributeServer<T> extends BaseAttributeServer<T> {\n    readonly isFixed: boolean = true;\n    protected readonly getter: (\n        session?: Session<MatterDevice>,\n        endpoint?: EndpointInterface,\n        isFabricFiltered?: boolean,\n        message?: Message,\n    ) => T;\n\n    constructor(\n        id: AttributeId,\n        name: string,\n        readAcl: AccessLevel | undefined,\n        writeAcl: AccessLevel | undefined,\n        schema: TlvSchema<T>,\n        isWritable: boolean,\n        isSubscribable: boolean,\n        requiresTimedInteraction: boolean,\n        initValue: T,\n        defaultValue: T | undefined,\n        protected readonly datasource: ClusterDatasource,\n\n        /**\n         * Optional getter function to handle special requirements or the data are stored in different places.\n         *\n         * @param session the session that is requesting the value (if any)\n         * @param endpoint the endpoint the cluster server of this attribute is assigned to\n         * @param isFabricFiltered whether the read request is fabric scoped or not\n         * @param message the wire message that initiated the request (if any)\n         */\n        getter?: (\n            session?: Session<MatterDevice>,\n            endpoint?: EndpointInterface,\n            isFabricFiltered?: boolean,\n            message?: Message,\n        ) => T,\n    ) {\n        super(\n            id,\n            name,\n            readAcl,\n            writeAcl,\n            schema,\n            isWritable,\n            isSubscribable,\n            requiresTimedInteraction,\n            initValue,\n            defaultValue,\n        ); // Fixed attributes do not change, so are not subscribable\n\n        if (getter === undefined) {\n            this.getter = () => {\n                if (this.value === undefined) {\n                    // Should not happen\n                    throw new InternalError(`Attribute value for attribute \"${name}\" is not initialized.`);\n                }\n                return this.value;\n            };\n        } else {\n            this.getter = getter;\n        }\n    }\n\n    /**\n     * Get the value of the attribute. This method is used by the Interaction model to read the value of the attribute\n     * and includes the ACL check. It should not be used locally in the code!\n     *\n     * If a getter is defined the value is determined by that getter method.\n     */\n    get(session: Session<MatterDevice>, isFabricFiltered: boolean, message?: Message): T {\n        // TODO: check ACL\n\n        return this.getter(session, this.endpoint, isFabricFiltered, message);\n    }\n\n    /**\n     * Get the value of the attribute including the version number. This method is used by the Interaction model to read\n     * the value of the attribute and includes the ACL check. It should not be used locally in the code!\n     *\n     * If a getter is defined the value is determined by that getter method. The version number is always 0 for fixed\n     * attributes.\n     */\n    getWithVersion(session: Session<MatterDevice>, isFabricFiltered: boolean, message?: Message) {\n        return { version: this.datasource.version, value: this.get(session, isFabricFiltered, message) };\n    }\n\n    /**\n     * Get the value of the attribute locally. This method should be used locally in the code and does not include the\n     * ACL check.\n     * If a getter is defined the value is determined by that getter method.\n     */\n    getLocal(): T {\n        return this.getter(undefined, this.endpoint);\n    }\n\n    /**\n     * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be\n     * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!\n     * If a getter or setter is defined the value must be undefined The version number must also be undefined.\n     */\n    init(value: T | undefined) {\n        if (value === undefined) {\n            throw new InternalError(`Cannot initialize fixed attribute \"${this.name}\" with undefined value.`);\n        }\n        this.validateWithSchema(value);\n        this.value = value;\n    }\n\n    /**\n     * Add an internal listener that is called when the value of the attribute changes. The listener is called with the\n     * new value and the version number.\n     */\n    addValueChangeListener(_listener: (value: T, version: number) => void) {\n        /** Fixed attributes do not change. */\n    }\n\n    /**\n     * Remove an internal listener.\n     */\n    removeValueChangeListener(_listener: (value: T, version: number) => void) {\n        /** Fixed attributes do not change. */\n    }\n\n    /**\n     * Add an external listener that is called when the value of the attribute changes. The listener is called with the\n     * new value and the old value.\n     */\n    addValueSetListener(_listener: (newValue: T, oldValue: T) => void) {\n        /** Fixed attributes do not change. */\n    }\n\n    /**\n     * Add an external listener that is called when the value of the attribute changes. The listener is called with the\n     * new value and the old value. This method is a convenient alias for addValueSetListener.\n     */\n    subscribe(_listener: (newValue: T, oldValue: T) => void) {\n        /** Fixed attributes do not change. */\n    }\n\n    /**\n     * Remove an external listener.\n     */\n    removeValueSetListener(_listener: (newValue: T, oldValue: T) => void) {\n        /** Fixed attributes do not change. */\n    }\n}\n\n/**\n * Attribute server for normal attributes that can be read and written.\n */\nexport class AttributeServer<T> extends FixedAttributeServer<T> {\n    override readonly isFixed = false;\n    protected readonly valueChangeListeners = new Array<(value: T, version: number) => void>();\n    protected readonly valueSetListeners = new Array<(newValue: T, oldValue: T) => void>();\n    protected readonly setter: (\n        value: T,\n        session?: Session<MatterDevice>,\n        endpoint?: EndpointInterface,\n        message?: Message,\n    ) => boolean;\n    protected readonly validator: (value: T, session?: Session<MatterDevice>, endpoint?: EndpointInterface) => void;\n    protected delayedChangeData?: DelayedChangeData = undefined;\n\n    constructor(\n        id: AttributeId,\n        name: string,\n        readAcl: AccessLevel | undefined,\n        writeAcl: AccessLevel | undefined,\n        schema: TlvSchema<T>,\n        isWritable: boolean,\n        isSubscribable: boolean,\n        requiresTimedInteraction: boolean,\n        initValue: T,\n        defaultValue: T | undefined,\n        datasource: ClusterDatasource,\n        getter?: (\n            session?: Session<MatterDevice>,\n            endpoint?: EndpointInterface,\n            isFabricFiltered?: boolean,\n            message?: Message,\n        ) => T,\n\n        /**\n         * Optional setter function to handle special requirements or the data are stored in different places. If a\n         * setter method is used for a writable attribute, the getter method must be implemented as well. The method\n         * needs to return if the stored value has changed or not.\n         *\n         * @param value the value to be set.\n         * @param session the session that is requesting the value (if any).\n         * @param endpoint the endpoint the cluster server of this attribute is assigned to.\n         * @returns true if the value has changed, false otherwise.\n         */\n        setter?: (\n            value: T,\n            session?: Session<MatterDevice>,\n            endpoint?: EndpointInterface,\n            message?: Message,\n        ) => boolean,\n\n        /**\n         * Optional Validator function to handle special requirements for verification of stored data. The method should\n         * throw an error if the value is not valid. If a StatusResponseError is thrown this one is also returned to the\n         * client.\n         *\n         * If a setter is used then no validator should be used as the setter should handle the validation itself!\n         *\n         * @param value the value to be set.\n         * @param session the session that is requesting the value (if any).\n         * @param endpoint the endpoint the cluster server of this attribute is assigned to.\n         */\n        validator?: (value: T, session?: Session<MatterDevice>, endpoint?: EndpointInterface) => void,\n    ) {\n        if (\n            isWritable &&\n            (getter === undefined || setter === undefined) &&\n            !(getter === undefined && setter === undefined)\n        ) {\n            throw new ImplementationError(\n                `Getter and setter must be implemented together for writeable attribute \"${name}\".`,\n            );\n        }\n\n        super(\n            id,\n            name,\n            readAcl,\n            writeAcl,\n            schema,\n            isWritable,\n            isSubscribable,\n            requiresTimedInteraction,\n            initValue,\n            defaultValue,\n            datasource,\n            getter,\n        );\n\n        if (setter === undefined) {\n            this.setter = value => {\n                const oldValue = this.value;\n                this.value = value;\n                return !isDeepEqual(value, oldValue);\n            };\n        } else {\n            this.setter = setter;\n        }\n\n        this.validator = (value, session, endpoint) => {\n            this.validateWithSchema(value);\n            if (validator !== undefined) {\n                validator(value, session, endpoint);\n            }\n        };\n    }\n\n    /**\n     * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be\n     * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!\n     */\n    override init(value: T | undefined) {\n        if (value === undefined) {\n            value = this.getter(undefined, this.endpoint);\n        }\n        if (value === undefined) {\n            throw new InternalError(`Cannot initialize attribute \"${this.name}\" with undefined value.`);\n        }\n        this.validator(value, undefined, this.endpoint);\n        this.value = value;\n    }\n\n    /**\n     * Set the value of the attribute. This method is used by the Interaction model to write the value of the attribute\n     * and includes the ACL check. It should not be used locally in the code!\n     *\n     * If a setter is defined this setter method is called to store the value.\n     *\n     * Listeners are called when the value changes (internal listeners) or in any case (external listeners).\n     */\n    set(value: T, session: Session<MatterDevice>, message?: Message, delayChangeEvents = false) {\n        if (!this.isWritable) {\n            throw new StatusResponseError(`Attribute \"${this.name}\" is not writable.`, StatusCode.UnsupportedWrite);\n        }\n\n        this.setRemote(value, session, message, delayChangeEvents);\n    }\n\n    /**\n     * Method that contains the logic to set a value \"from remote\" (e.g. from a client).\n     */\n    protected setRemote(value: T, session: Session<MatterDevice>, message?: Message, delayChangeEvents = false) {\n        this.processSet(value, session, message, delayChangeEvents);\n        this.value = value;\n    }\n\n    /**\n     * Set the value of the attribute locally. This method should be used locally in the code and does not include the\n     * ACL check.\n     *\n     * If a setter is defined this setter method is called to validate and store the value.\n     *\n     * Else if a validator is defined the value is validated before it is stored.\n     *\n     * Listeners are called when the value changes (internal listeners) or in any case (external listeners).\n     */\n    setLocal(value: T) {\n        this.processSet(value, undefined);\n        this.value = value;\n    }\n\n    /**\n     * Helper Method to process the set of a value in a generic way. This method is used internally.\n     */\n    protected processSet(value: T, session?: Session<MatterDevice>, message?: Message, delayChangeEvents = false) {\n        this.validator(value, session, this.endpoint);\n        const oldValue = this.getter(session, this.endpoint, undefined, message);\n        const valueChanged = this.setter(value, session, this.endpoint, message);\n        if (delayChangeEvents) {\n            this.delayedChangeData = {\n                oldValue: this.delayedChangeData?.oldValue ?? oldValue, // We keep the oldest value\n                newValue: value,\n                changed: !!this.delayedChangeData?.changed || valueChanged, // We combine the changed flag\n            };\n            logger.info(`Delay change for attribute \"${this.name}\" with value ${Logger.toJSON(value)}`);\n        } else {\n            this.handleVersionAndTriggerListeners(value, oldValue, valueChanged);\n        }\n    }\n\n    triggerDelayedChangeEvents() {\n        if (this.delayedChangeData !== undefined) {\n            const { oldValue, newValue, changed } = this.delayedChangeData;\n            this.delayedChangeData = undefined;\n            logger.info(`Trigger delayed change for attribute \"${this.name}\" with value ${Logger.toJSON(newValue)}`);\n            this.handleVersionAndTriggerListeners(newValue, oldValue, changed);\n        }\n    }\n\n    /**\n     * Helper Method to handle needed version increases and trigger the relevant listeners. This method is used\n     * internally.\n     */\n    protected handleVersionAndTriggerListeners(value: T, oldValue: T | undefined, considerVersionChanged: boolean) {\n        if (considerVersionChanged) {\n            const version = this.datasource.increaseVersion();\n            this.valueChangeListeners.forEach(listener => listener(value, version));\n        }\n        if (oldValue !== undefined) {\n            this.valueSetListeners.forEach(listener => listener(value, oldValue));\n        }\n    }\n\n    /**\n     * When the value is handled by getter or setter methods and is changed by other processes this method can be used\n     * to notify the attribute server that the value has changed. This will increase the version number and trigger the\n     * listeners.\n     *\n     * ACL checks needs to be performed before calling this method.\n     */\n    updated(session: SecureSession<MatterDevice>) {\n        const oldValue = this.value ?? this.defaultValue;\n        try {\n            this.value = this.get(session, false);\n        } catch (e) {\n            NoAssociatedFabricError.accept(e);\n\n            // Handle potential error cases where the session does not have a fabric assigned.\n            if (this.value === undefined) {\n                this.value = this.defaultValue;\n            }\n        }\n        this.handleVersionAndTriggerListeners(this.value, oldValue, true);\n    }\n\n    /**\n     * When the value is handled by getter or setter methods and is changed by other processes and no session from the\n     * originating process is known this method can be used to notify the attribute server that the value has changed.\n     * This will increase the version number and trigger the listeners.\n     *\n     * ACL checks needs to be performed before calling this method.\n     */\n    updatedLocal() {\n        const oldValue = this.value ?? this.defaultValue;\n        this.value = this.getLocal();\n        this.handleVersionAndTriggerListeners(this.value, oldValue, true);\n    }\n\n    /**\n     * Add an internal listener that is called when the value of the attribute changes. The listener is called with the\n     * new value and the version number.\n     */\n    override addValueChangeListener(listener: (value: T, version: number) => void) {\n        this.valueChangeListeners.push(listener);\n    }\n\n    /**\n     * Remove an internal listener.\n     */\n    override removeValueChangeListener(listener: (value: T, version: number) => void) {\n        const entryIndex = this.valueChangeListeners.indexOf(listener);\n        if (entryIndex !== -1) {\n            this.valueChangeListeners.splice(entryIndex, 1);\n        }\n    }\n\n    /**\n     * Add an external listener that is called when the value of the attribute changes. The listener is called with the\n     * new value and the old value.\n     */\n    override addValueSetListener(listener: (newValue: T, oldValue: T) => void) {\n        this.valueSetListeners.push(listener);\n    }\n\n    /**\n     * Add an external listener that is called when the value of the attribute changes. The listener is called with the\n     * new value and the old value. This method is a convenient alias for addValueSetListener.\n     */\n    override subscribe(listener: (newValue: T, oldValue: T) => void) {\n        this.addValueSetListener(listener);\n    }\n\n    /**\n     * Remove an external listener.\n     */\n    override removeValueSetListener(listener: (newValue: T, oldValue: T) => void) {\n        const entryIndex = this.valueSetListeners.indexOf(listener);\n        if (entryIndex !== -1) {\n            this.valueSetListeners.splice(entryIndex, 1);\n        }\n    }\n}\n\nexport function genericFabricScopedAttributeGetterFromFabric<T>(\n    fabric: Fabric,\n    cluster: Cluster<any, any, any, any, any>,\n    attributeName: string,\n    defaultValue: T,\n) {\n    const data = fabric.getScopedClusterDataValue<{ value: T }>(cluster, attributeName);\n    return data?.value ?? defaultValue;\n}\n\nexport function genericFabricScopedAttributeGetter<T>(\n    session: Session<MatterDevice> | undefined,\n    isFabricFiltered: boolean,\n    cluster: Cluster<any, any, any, any, any>,\n    attributeName: string,\n    defaultValue: T,\n) {\n    if (session === undefined) {\n        throw new FabricScopeError(`Session is required for fabric scoped attribute ${attributeName}`);\n    }\n\n    if (isFabricFiltered) {\n        assertSecureSession(session);\n        return genericFabricScopedAttributeGetterFromFabric(\n            session.associatedFabric,\n            cluster,\n            attributeName,\n            defaultValue,\n        );\n    } else {\n        const fabrics = session.context.getFabrics();\n        const values = new Array<any>();\n        for (const fabric of fabrics) {\n            const value = genericFabricScopedAttributeGetterFromFabric(fabric, cluster, attributeName, defaultValue);\n            if (!Array.isArray(value)) {\n                throw new FabricScopeError(\n                    `Fabric scoped attribute \"${attributeName}\" can only be read for all fabrics if they are arrays.`,\n                );\n            }\n            values.push(...value);\n        }\n        return values as T;\n    }\n}\n\nexport function genericFabricScopedAttributeSetterForFabric<T>(\n    fabric: Fabric,\n    cluster: Cluster<any, any, any, any, any>,\n    attributeName: string,\n    value: T,\n    defaultValue?: T,\n) {\n    const oldValue = genericFabricScopedAttributeGetterFromFabric(fabric, cluster, attributeName, defaultValue);\n    if (!isDeepEqual(value, oldValue)) {\n        const setResult = fabric.setScopedClusterDataValue(cluster, attributeName, { value });\n        if (MaybePromise.is(setResult)) {\n            throw new ImplementationError(\n                \"Seems like an Asynchronous Storage is used with Legacy code paths which is forbidden!\",\n            );\n        }\n        return true;\n    }\n    return false;\n}\n\nexport function genericFabricScopedAttributeSetter<T>(\n    value: T,\n    session: Session<MatterDevice> | undefined,\n    cluster: Cluster<any, any, any, any, any>,\n    attributeName: string,\n    defaultValue?: T,\n) {\n    if (session === undefined) {\n        throw new FabricScopeError(`Session is required for fabric scoped attribute \"${attributeName}\".`);\n    }\n\n    assertSecureSession(session);\n    const fabric = session.associatedFabric;\n\n    return genericFabricScopedAttributeSetterForFabric(fabric, cluster, attributeName, value, defaultValue);\n}\n\n/**\n * Attribute server which is getting and setting the value for a defined fabric. The values are automatically persisted\n * on fabric level if no custom getter or setter is defined.\n */\nexport class FabricScopedAttributeServer<T> extends AttributeServer<T> {\n    private readonly isCustomGetter: boolean;\n    private readonly isCustomSetter: boolean;\n    private readonly fabricSensitiveElementsToRemove = new Array<string>();\n\n    constructor(\n        id: AttributeId,\n        name: string,\n        readAcl: AccessLevel | undefined,\n        writeAcl: AccessLevel | undefined,\n        schema: TlvSchema<T>,\n        isWritable: boolean,\n        isSubscribable: boolean,\n        requiresTimedInteraction: boolean,\n        initValue: T,\n        defaultValue: T | undefined,\n        readonly cluster: Cluster<any, any, any, any, any>,\n        datasource: ClusterDatasource,\n        getter?: (session?: Session<MatterDevice>, endpoint?: EndpointInterface, isFabricFiltered?: boolean) => T,\n        setter?: (\n            value: T,\n            session?: Session<MatterDevice>,\n            endpoint?: EndpointInterface,\n            message?: Message,\n        ) => boolean,\n        validator?: (value: T, session?: Session<MatterDevice>, endpoint?: EndpointInterface) => void,\n    ) {\n        if (\n            isWritable &&\n            (getter === undefined || setter === undefined) &&\n            !(getter === undefined && setter === undefined)\n        ) {\n            throw new ImplementationError(\n                `Getter and setter must be implemented together for writeable fabric scoped attribute \"${name}\".`,\n            );\n        }\n\n        let isCustomGetter = false;\n        if (getter === undefined) {\n            getter = (session, _endpoint, isFabricFiltered) => {\n                if (session === undefined)\n                    throw new FabricScopeError(`Session is required for fabric scoped attribute ${name}`);\n\n                if (isFabricFiltered === true) {\n                    assertSecureSession(session);\n                    return this.getLocalForFabric(session.associatedFabric);\n                } else {\n                    const fabrics = session.context.getFabrics();\n                    const values = new Array<any>();\n                    for (const fabric of fabrics) {\n                        const value = this.getLocalForFabric(fabric);\n                        if (!Array.isArray(value)) {\n                            throw new FabricScopeError(\n                                `Fabric scoped attribute \"${name}\" can only be read for all fabrics if they are arrays.`,\n                            );\n                        }\n                        values.push(...value);\n                    }\n                    return values as T;\n                }\n            };\n        } else {\n            isCustomGetter = true;\n        }\n\n        let isCustomSetter = false;\n        if (setter === undefined) {\n            setter = (value, session) =>\n                genericFabricScopedAttributeSetter(value, session, this.cluster, this.name, this.defaultValue);\n        } else {\n            isCustomSetter = true;\n        }\n\n        super(\n            id,\n            name,\n            readAcl,\n            writeAcl,\n            schema,\n            isWritable,\n            isSubscribable,\n            requiresTimedInteraction,\n            initValue,\n            defaultValue,\n            datasource,\n            getter,\n            setter,\n            validator,\n        );\n        this.isCustomGetter = isCustomGetter;\n        this.isCustomSetter = isCustomSetter;\n\n        this.#determineSensitiveFieldsToRemove();\n    }\n\n    #determineSensitiveFieldsToRemove() {\n        const clusterFromModel = MatterModel.standard.get(ClusterModel, this.cluster.id);\n        if (clusterFromModel === undefined) {\n            logger.debug(`${this.cluster.name}: Cluster for Fabric scoped element not found in Model, ignore`);\n            return;\n        }\n        const attributeFromModel = clusterFromModel.get(AttributeModel, this.id);\n        if (attributeFromModel === undefined) {\n            logger.debug(\n                `${this.cluster.name}.${this.id}: Attribute for Fabric scoped element not found in Model, ignore`,\n            );\n            return;\n        }\n        if (!attributeFromModel.fabricScoped) {\n            logger.debug(`${this.cluster.name}.${this.id}: Attribute is not Fabric scoped in model, ignore`);\n            return;\n        }\n        if (attributeFromModel.children.length !== 1) {\n            logger.debug(`${this.cluster.name}.${this.id}: Attribute has not exactly one child, ignore`);\n            return;\n        }\n        const type = attributeFromModel.children[0].type;\n        if (type === undefined) {\n            logger.debug(`${this.cluster.name}.${this.id}: Attribute field has no type, ignore`);\n            return;\n        }\n        const dataType = clusterFromModel.get(DatatypeModel, type);\n        if (dataType === undefined) {\n            logger.debug(`${this.cluster.name}.${this.id}: DataType ${type} not found in model, ignore`);\n            return;\n        }\n        dataType.children\n            .filter(field => field.fabricSensitive)\n            .forEach(field => this.fabricSensitiveElementsToRemove.push(camelize(field.name)));\n    }\n\n    override get hasFabricSensitiveData() {\n        return this.fabricSensitiveElementsToRemove.length > 0;\n    }\n\n    /**\n     * Sanitize the value of the attribute by removing fabric sensitive fields that do not belong to the\n     * associated fabric\n     */\n    sanitizeFabricSensitiveFields(value: T, associatedFabric?: Fabric) {\n        if (this.fabricSensitiveElementsToRemove.length && Array.isArray(value)) {\n            // Get the associated Fabric Index or uses -1 when no Fabric is associated because this value will\n            // never be in the struct\n            const associatedFabricIndex = associatedFabric?.fabricIndex ?? -1;\n            return value.map(data => {\n                if (data[FabricIndexName] !== associatedFabricIndex) {\n                    const result = { ...data };\n                    this.fabricSensitiveElementsToRemove.forEach(fieldName => delete result[fieldName]);\n                    return result;\n                }\n                return data;\n            });\n        }\n        return value;\n    }\n\n    /**\n     * Initialize the attribute with a value. Because the value is stored on fabric level this method only initializes\n     * the version number.\n     */\n    override init(value: T | undefined) {\n        if (value !== undefined) {\n            throw new InternalError(`Cannot initialize fabric scoped attribute \"${this.name}\" with a value.`);\n        }\n    }\n\n    /**\n     * Fabric scoped enhancement of set to allow setting special fabricindex locally.\n     */\n    override set(\n        value: T,\n        session: Session<MatterDevice>,\n        message: Message,\n        delayChangeEvents = false,\n        preserveFabricIndex = false,\n    ) {\n        if (!this.isWritable) {\n            throw new StatusResponseError(`Attribute \"${this.name}\" is not writable.`, StatusCode.UnsupportedWrite);\n        }\n\n        this.setRemote(value, session, message, delayChangeEvents, preserveFabricIndex);\n    }\n\n    /**\n     * Method that contains the logic to set a value \"from remote\" (e.g. from a client). For Fabric scoped attributes\n     * we need to inject the fabric index into the value.\n     */\n    protected override setRemote(\n        value: T,\n        session: Session<MatterDevice>,\n        message: Message,\n        delayChangeEvents = false,\n        preserveFabricIndex = false,\n    ) {\n        // Inject fabric index into structures in general if undefined, if set it will be used\n        value = this.schema.injectField(\n            value,\n            <number>FabricIndex.id,\n            session.associatedFabric.fabricIndex,\n            () => !preserveFabricIndex, // Noone should send any index and if we simply SHALL ignore it,  biuut internally we might need it\n        );\n        logger.info(`Set remote value for fabric scoped attribute \"${this.name}\" to ${Logger.toJSON(value)}`);\n\n        super.setRemote(value, session, message, delayChangeEvents);\n    }\n\n    /**\n     * Set Local is not allowed for fabric scoped attributes. Use setLocalForFabric instead.\n     */\n    override setLocal(_value: T) {\n        throw new FabricScopeError(\n            `Fabric scoped attribute \"${this.name}\" can only be set locally by providing a Fabric. Use setLocalForFabric instead.`,\n        );\n    }\n\n    /**\n     * Set the value of the attribute locally for a fabric. This method should be used locally in the code and does not\n     * include the ACL check.\n     * If a setter is defined this method cannot be used!\n     * If a validator is defined the value is validated before it is stored.\n     * Listeners are called when the value changes (internal listeners) or in any case (external listeners).\n     */\n    setLocalForFabric(value: T, fabric: Fabric) {\n        if (this.isCustomSetter) {\n            throw new FabricScopeError(\n                `Fabric scoped attribute \"${this.name}\" cannot be set locally when a custom setter is defined.`,\n            );\n        }\n        this.validator(value, undefined, this.endpoint);\n\n        const oldValue = this.getLocalForFabric(fabric);\n        const valueChanged = !isDeepEqual(value, oldValue);\n        if (valueChanged) {\n            const setResult = fabric.setScopedClusterDataValue(this.cluster, this.name, { value });\n            if (MaybePromise.is(setResult)) {\n                throw new ImplementationError(\n                    \"Seems like an Asynchronous Storage is used with Legacy code paths which is forbidden!\",\n                );\n            }\n        }\n        this.handleVersionAndTriggerListeners(value, oldValue, valueChanged); // TODO Make callbacks sense without fabric, but then they would have other signature?\n    }\n\n    /**\n     * When the value is handled by getter or setter methods and is changed by other processes and no session from the\n     * originating process is known this method can be used to notify the attribute server that the value has changed.\n     * This will increase the version number and trigger the listeners.\n     * ACL checks needs to be performed before calling this method.\n     */\n    updatedLocalForFabric(fabric: Fabric) {\n        const oldValue = this.value ?? this.defaultValue;\n        try {\n            this.value = this.getLocalForFabric(fabric);\n        } catch (e) {\n            FabricScopeError.accept(e);\n\n            if (this.value === undefined) {\n                this.value = this.defaultValue;\n            }\n        }\n        this.handleVersionAndTriggerListeners(this.value, oldValue, true);\n    }\n\n    /**\n     * Get the value of the attribute locally for a special Fabric. This method should be used locally in the code and\n     * does not include the ACL check.\n     * If a getter is defined this method returns an error and the value should be retrieved directly internally.\n     */\n    getLocalForFabric(fabric: Fabric): T {\n        if (this.isCustomGetter) {\n            throw new FabricScopeError(\n                `Fabric scoped attribute \"${this.name}\" cannot be read locally when a custom getter is defined.`,\n            );\n        }\n        return genericFabricScopedAttributeGetterFromFabric(fabric, this.cluster, this.name, this.defaultValue);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,yBAAgE;AAChE,6BAAgC;AAIhC,oBAAuB;AACvB,mBAAyE;AACzE,yBAA4B;AAC5B,wBAAgD;AAEhD,2BAA4E;AAG5E,uBAA4B;AAC5B,sBAA6B;AAC7B,oBAAyB;AACzB,qBAA8E;AAxB9E;AAAA;AAAA;AAAA;AAAA;AA2BA,MAAM,SAAS,qBAAO,IAAI,iBAAiB;AAE3C,MAAM,sBAAkB,wBAAS,+BAAY,IAAI;AAM1C,MAAM,yBAAyB,+BAAY;AAAC;AAa5C,SAAS,sBAQZ,YACA,cACA,eACA,WACA,YACA,QAMA,QACA,WACF;AACE,QAAM;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT;AAAA,IACA;AAAA,EACJ,IAAI;AAEJ,MAAI,OAAO;AACP,WAAO,IAAI;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAEA,MAAI,cAAc;AACd,WAAO,IAAI;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC;AAAA,MACD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,IAAI;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,CAAC;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAKO,MAAe,oBAAuB;AAAA,EAUzC,YACa,IACA,MACT,SACA,UACS,QACA,YACA,gBACA,0BACT,WACA,cACF;AAVW;AACA;AAGA;AACA;AACA;AACA;AAIT,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,QAAI;AACA,WAAK,mBAAmB,SAAS;AACjC,WAAK,QAAQ;AAAA,IACjB,SAAS,OAAO;AACZ,aAAO;AAAA,QACH,qCAAqC,IAAI,yBAAyB,qBAAO;AAAA,UACrE;AAAA,QACJ,CAAC,wBAAwB,qBAAO,OAAO,YAAY,CAAC;AAAA,MACxD;AACA,UAAI,iBAAiB,QAAW;AAC5B,cAAM,IAAI,uCAAoB,qCAAqC,IAAI,uBAAuB;AAAA,MAClG;AACA,WAAK,mBAAmB,YAAY;AACpC,WAAK,QAAQ;AAAA,IACjB;AACA,SAAK,eAAe,KAAK;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EApCU,QAAuB;AAAA,EACvB;AAAA,EACD;AAAA,EACT;AAAA,EACA;AAAA,EAkCA,IAAI,yBAAyB;AACzB,WAAO;AAAA,EACX;AAAA,EAEA,mBAAmB,OAAU;AACzB,QAAI;AACA,WAAK,OAAO,SAAS,KAAK;AAAA,IAC9B,SAAS,GAAG;AACR,6CAAgB,OAAO,CAAC;AAGxB,QAAE,UAAU,mCAAmC,KAAK,IAAI,IAAI,EAAE,cAAc,SAAY,aAAa,EAAE,SAAS,KAAK,EAAE,KAAK,EAAE,OAAO;AACrI,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,iBAAiB,UAA6B;AAC1C,SAAK,WAAW;AAAA,EACpB;AAAA,EAQA,IAAI,WAAW;AACX,WAAO,KAAK,aAAa,2BAAY;AAAA,EACzC;AAAA,EAEA,IAAI,UAAU;AACV,WAAO,KAAK,YAAY,2BAAY;AAAA,EACxC;AACJ;AAMO,MAAM,6BAAgC,oBAAuB;AAAA,EAShE,YACI,IACA,MACA,SACA,UACA,QACA,YACA,gBACA,0BACA,WACA,cACmB,YAUnB,QAMF;AACE;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AA5BmB;AA8BnB,QAAI,WAAW,QAAW;AACtB,WAAK,SAAS,MAAM;AAChB,YAAI,KAAK,UAAU,QAAW;AAE1B,gBAAM,IAAI,iCAAc,kCAAkC,IAAI,uBAAuB;AAAA,QACzF;AACA,eAAO,KAAK;AAAA,MAChB;AAAA,IACJ,OAAO;AACH,WAAK,SAAS;AAAA,IAClB;AAAA,EACJ;AAAA,EA5DS,UAAmB;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmEnB,IAAI,SAAgC,kBAA2B,SAAsB;AAGjF,WAAO,KAAK,OAAO,SAAS,KAAK,UAAU,kBAAkB,OAAO;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,SAAgC,kBAA2B,SAAmB;AACzF,WAAO,EAAE,SAAS,KAAK,WAAW,SAAS,OAAO,KAAK,IAAI,SAAS,kBAAkB,OAAO,EAAE;AAAA,EACnG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAc;AACV,WAAO,KAAK,OAAO,QAAW,KAAK,QAAQ;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAK,OAAsB;AACvB,QAAI,UAAU,QAAW;AACrB,YAAM,IAAI,iCAAc,sCAAsC,KAAK,IAAI,yBAAyB;AAAA,IACpG;AACA,SAAK,mBAAmB,KAAK;AAC7B,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,uBAAuB,WAAgD;AAAA,EAEvE;AAAA;AAAA;AAAA;AAAA,EAKA,0BAA0B,WAAgD;AAAA,EAE1E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oBAAoB,WAA+C;AAAA,EAEnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,WAA+C;AAAA,EAEzD;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAuB,WAA+C;AAAA,EAEtE;AACJ;AAKO,MAAM,wBAA2B,qBAAwB;AAAA,EAC1C,UAAU;AAAA,EACT,uBAAuB,IAAI,MAA2C;AAAA,EACtE,oBAAoB,IAAI,MAA0C;AAAA,EAClE;AAAA,EAMA;AAAA,EACT,oBAAwC;AAAA,EAElD,YACI,IACA,MACA,SACA,UACA,QACA,YACA,gBACA,0BACA,WACA,cACA,YACA,QAiBA,QAkBA,WACF;AACE,QACI,eACC,WAAW,UAAa,WAAW,WACpC,EAAE,WAAW,UAAa,WAAW,SACvC;AACE,YAAM,IAAI;AAAA,QACN,2EAA2E,IAAI;AAAA,MACnF;AAAA,IACJ;AAEA;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAEA,QAAI,WAAW,QAAW;AACtB,WAAK,SAAS,WAAS;AACnB,cAAM,WAAW,KAAK;AACtB,aAAK,QAAQ;AACb,eAAO,KAAC,8BAAY,OAAO,QAAQ;AAAA,MACvC;AAAA,IACJ,OAAO;AACH,WAAK,SAAS;AAAA,IAClB;AAEA,SAAK,YAAY,CAAC,OAAO,SAAS,aAAa;AAC3C,WAAK,mBAAmB,KAAK;AAC7B,UAAI,cAAc,QAAW;AACzB,kBAAU,OAAO,SAAS,QAAQ;AAAA,MACtC;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMS,KAAK,OAAsB;AAChC,QAAI,UAAU,QAAW;AACrB,cAAQ,KAAK,OAAO,QAAW,KAAK,QAAQ;AAAA,IAChD;AACA,QAAI,UAAU,QAAW;AACrB,YAAM,IAAI,iCAAc,gCAAgC,KAAK,IAAI,yBAAyB;AAAA,IAC9F;AACA,SAAK,UAAU,OAAO,QAAW,KAAK,QAAQ;AAC9C,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,OAAU,SAAgC,SAAmB,oBAAoB,OAAO;AACxF,QAAI,CAAC,KAAK,YAAY;AAClB,YAAM,IAAI,sCAAoB,cAAc,KAAK,IAAI,sBAAsB,6BAAW,gBAAgB;AAAA,IAC1G;AAEA,SAAK,UAAU,OAAO,SAAS,SAAS,iBAAiB;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKU,UAAU,OAAU,SAAgC,SAAmB,oBAAoB,OAAO;AACxG,SAAK,WAAW,OAAO,SAAS,SAAS,iBAAiB;AAC1D,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,SAAS,OAAU;AACf,SAAK,WAAW,OAAO,MAAS;AAChC,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKU,WAAW,OAAU,SAAiC,SAAmB,oBAAoB,OAAO;AAC1G,SAAK,UAAU,OAAO,SAAS,KAAK,QAAQ;AAC5C,UAAM,WAAW,KAAK,OAAO,SAAS,KAAK,UAAU,QAAW,OAAO;AACvE,UAAM,eAAe,KAAK,OAAO,OAAO,SAAS,KAAK,UAAU,OAAO;AACvE,QAAI,mBAAmB;AACnB,WAAK,oBAAoB;AAAA,QACrB,UAAU,KAAK,mBAAmB,YAAY;AAAA;AAAA,QAC9C,UAAU;AAAA,QACV,SAAS,CAAC,CAAC,KAAK,mBAAmB,WAAW;AAAA;AAAA,MAClD;AACA,aAAO,KAAK,+BAA+B,KAAK,IAAI,gBAAgB,qBAAO,OAAO,KAAK,CAAC,EAAE;AAAA,IAC9F,OAAO;AACH,WAAK,iCAAiC,OAAO,UAAU,YAAY;AAAA,IACvE;AAAA,EACJ;AAAA,EAEA,6BAA6B;AACzB,QAAI,KAAK,sBAAsB,QAAW;AACtC,YAAM,EAAE,UAAU,UAAU,QAAQ,IAAI,KAAK;AAC7C,WAAK,oBAAoB;AACzB,aAAO,KAAK,yCAAyC,KAAK,IAAI,gBAAgB,qBAAO,OAAO,QAAQ,CAAC,EAAE;AACvG,WAAK,iCAAiC,UAAU,UAAU,OAAO;AAAA,IACrE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMU,iCAAiC,OAAU,UAAyB,wBAAiC;AAC3G,QAAI,wBAAwB;AACxB,YAAM,UAAU,KAAK,WAAW,gBAAgB;AAChD,WAAK,qBAAqB,QAAQ,cAAY,SAAS,OAAO,OAAO,CAAC;AAAA,IAC1E;AACA,QAAI,aAAa,QAAW;AACxB,WAAK,kBAAkB,QAAQ,cAAY,SAAS,OAAO,QAAQ,CAAC;AAAA,IACxE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,QAAQ,SAAsC;AAC1C,UAAM,WAAW,KAAK,SAAS,KAAK;AACpC,QAAI;AACA,WAAK,QAAQ,KAAK,IAAI,SAAS,KAAK;AAAA,IACxC,SAAS,GAAG;AACR,mDAAwB,OAAO,CAAC;AAGhC,UAAI,KAAK,UAAU,QAAW;AAC1B,aAAK,QAAQ,KAAK;AAAA,MACtB;AAAA,IACJ;AACA,SAAK,iCAAiC,KAAK,OAAO,UAAU,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe;AACX,UAAM,WAAW,KAAK,SAAS,KAAK;AACpC,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,iCAAiC,KAAK,OAAO,UAAU,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMS,uBAAuB,UAA+C;AAC3E,SAAK,qBAAqB,KAAK,QAAQ;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKS,0BAA0B,UAA+C;AAC9E,UAAM,aAAa,KAAK,qBAAqB,QAAQ,QAAQ;AAC7D,QAAI,eAAe,IAAI;AACnB,WAAK,qBAAqB,OAAO,YAAY,CAAC;AAAA,IAClD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMS,oBAAoB,UAA8C;AACvE,SAAK,kBAAkB,KAAK,QAAQ;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMS,UAAU,UAA8C;AAC7D,SAAK,oBAAoB,QAAQ;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKS,uBAAuB,UAA8C;AAC1E,UAAM,aAAa,KAAK,kBAAkB,QAAQ,QAAQ;AAC1D,QAAI,eAAe,IAAI;AACnB,WAAK,kBAAkB,OAAO,YAAY,CAAC;AAAA,IAC/C;AAAA,EACJ;AACJ;AAEO,SAAS,6CACZ,QACA,SACA,eACA,cACF;AACE,QAAM,OAAO,OAAO,0BAAwC,SAAS,aAAa;AAClF,SAAO,MAAM,SAAS;AAC1B;AAEO,SAAS,mCACZ,SACA,kBACA,SACA,eACA,cACF;AACE,MAAI,YAAY,QAAW;AACvB,UAAM,IAAI,iBAAiB,mDAAmD,aAAa,EAAE;AAAA,EACjG;AAEA,MAAI,kBAAkB;AAClB,kDAAoB,OAAO;AAC3B,WAAO;AAAA,MACH,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ,OAAO;AACH,UAAM,UAAU,QAAQ,QAAQ,WAAW;AAC3C,UAAM,SAAS,IAAI,MAAW;AAC9B,eAAW,UAAU,SAAS;AAC1B,YAAM,QAAQ,6CAA6C,QAAQ,SAAS,eAAe,YAAY;AACvG,UAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,cAAM,IAAI;AAAA,UACN,4BAA4B,aAAa;AAAA,QAC7C;AAAA,MACJ;AACA,aAAO,KAAK,GAAG,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;AAEO,SAAS,4CACZ,QACA,SACA,eACA,OACA,cACF;AACE,QAAM,WAAW,6CAA6C,QAAQ,SAAS,eAAe,YAAY;AAC1G,MAAI,KAAC,8BAAY,OAAO,QAAQ,GAAG;AAC/B,UAAM,YAAY,OAAO,0BAA0B,SAAS,eAAe,EAAE,MAAM,CAAC;AACpF,QAAI,6BAAa,GAAG,SAAS,GAAG;AAC5B,YAAM,IAAI;AAAA,QACN;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEO,SAAS,mCACZ,OACA,SACA,SACA,eACA,cACF;AACE,MAAI,YAAY,QAAW;AACvB,UAAM,IAAI,iBAAiB,oDAAoD,aAAa,IAAI;AAAA,EACpG;AAEA,gDAAoB,OAAO;AAC3B,QAAM,SAAS,QAAQ;AAEvB,SAAO,4CAA4C,QAAQ,SAAS,eAAe,OAAO,YAAY;AAC1G;AAMO,MAAM,oCAAuC,gBAAmB;AAAA,EAKnE,YACI,IACA,MACA,SACA,UACA,QACA,YACA,gBACA,0BACA,WACA,cACS,SACT,YACA,QACA,QAMA,WACF;AACE,QACI,eACC,WAAW,UAAa,WAAW,WACpC,EAAE,WAAW,UAAa,WAAW,SACvC;AACE,YAAM,IAAI;AAAA,QACN,yFAAyF,IAAI;AAAA,MACjG;AAAA,IACJ;AAEA,QAAI,iBAAiB;AACrB,QAAI,WAAW,QAAW;AACtB,eAAS,CAAC,SAAS,WAAW,qBAAqB;AAC/C,YAAI,YAAY;AACZ,gBAAM,IAAI,iBAAiB,mDAAmD,IAAI,EAAE;AAExF,YAAI,qBAAqB,MAAM;AAC3B,wDAAoB,OAAO;AAC3B,iBAAO,KAAK,kBAAkB,QAAQ,gBAAgB;AAAA,QAC1D,OAAO;AACH,gBAAM,UAAU,QAAQ,QAAQ,WAAW;AAC3C,gBAAM,SAAS,IAAI,MAAW;AAC9B,qBAAW,UAAU,SAAS;AAC1B,kBAAM,QAAQ,KAAK,kBAAkB,MAAM;AAC3C,gBAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,oBAAM,IAAI;AAAA,gBACN,4BAA4B,IAAI;AAAA,cACpC;AAAA,YACJ;AACA,mBAAO,KAAK,GAAG,KAAK;AAAA,UACxB;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ,OAAO;AACH,uBAAiB;AAAA,IACrB;AAEA,QAAI,iBAAiB;AACrB,QAAI,WAAW,QAAW;AACtB,eAAS,CAAC,OAAO,YACb,mCAAmC,OAAO,SAAS,KAAK,SAAS,KAAK,MAAM,KAAK,YAAY;AAAA,IACrG,OAAO;AACH,uBAAiB;AAAA,IACrB;AAEA;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAxES;AAyET,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;AAEtB,SAAK,kCAAkC;AAAA,EAC3C;AAAA,EA5FiB;AAAA,EACA;AAAA,EACA,kCAAkC,IAAI,MAAc;AAAA,EA4FrE,oCAAoC;AAChC,UAAM,mBAAmB,yBAAY,SAAS,IAAI,2BAAc,KAAK,QAAQ,EAAE;AAC/E,QAAI,qBAAqB,QAAW;AAChC,aAAO,MAAM,GAAG,KAAK,QAAQ,IAAI,gEAAgE;AACjG;AAAA,IACJ;AACA,UAAM,qBAAqB,iBAAiB,IAAI,6BAAgB,KAAK,EAAE;AACvE,QAAI,uBAAuB,QAAW;AAClC,aAAO;AAAA,QACH,GAAG,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE;AAAA,MACnC;AACA;AAAA,IACJ;AACA,QAAI,CAAC,mBAAmB,cAAc;AAClC,aAAO,MAAM,GAAG,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE,mDAAmD;AAC/F;AAAA,IACJ;AACA,QAAI,mBAAmB,SAAS,WAAW,GAAG;AAC1C,aAAO,MAAM,GAAG,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE,+CAA+C;AAC3F;AAAA,IACJ;AACA,UAAM,OAAO,mBAAmB,SAAS,CAAC,EAAE;AAC5C,QAAI,SAAS,QAAW;AACpB,aAAO,MAAM,GAAG,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE,uCAAuC;AACnF;AAAA,IACJ;AACA,UAAM,WAAW,iBAAiB,IAAI,4BAAe,IAAI;AACzD,QAAI,aAAa,QAAW;AACxB,aAAO,MAAM,GAAG,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE,cAAc,IAAI,6BAA6B;AAC3F;AAAA,IACJ;AACA,aAAS,SACJ,OAAO,WAAS,MAAM,eAAe,EACrC,QAAQ,WAAS,KAAK,gCAAgC,SAAK,wBAAS,MAAM,IAAI,CAAC,CAAC;AAAA,EACzF;AAAA,EAEA,IAAa,yBAAyB;AAClC,WAAO,KAAK,gCAAgC,SAAS;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,8BAA8B,OAAU,kBAA2B;AAC/D,QAAI,KAAK,gCAAgC,UAAU,MAAM,QAAQ,KAAK,GAAG;AAGrE,YAAM,wBAAwB,kBAAkB,eAAe;AAC/D,aAAO,MAAM,IAAI,UAAQ;AACrB,YAAI,KAAK,eAAe,MAAM,uBAAuB;AACjD,gBAAM,SAAS,EAAE,GAAG,KAAK;AACzB,eAAK,gCAAgC,QAAQ,eAAa,OAAO,OAAO,SAAS,CAAC;AAClF,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMS,KAAK,OAAsB;AAChC,QAAI,UAAU,QAAW;AACrB,YAAM,IAAI,iCAAc,8CAA8C,KAAK,IAAI,iBAAiB;AAAA,IACpG;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKS,IACL,OACA,SACA,SACA,oBAAoB,OACpB,sBAAsB,OACxB;AACE,QAAI,CAAC,KAAK,YAAY;AAClB,YAAM,IAAI,sCAAoB,cAAc,KAAK,IAAI,sBAAsB,6BAAW,gBAAgB;AAAA,IAC1G;AAEA,SAAK,UAAU,OAAO,SAAS,SAAS,mBAAmB,mBAAmB;AAAA,EAClF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMmB,UACf,OACA,SACA,SACA,oBAAoB,OACpB,sBAAsB,OACxB;AAEE,YAAQ,KAAK,OAAO;AAAA,MAChB;AAAA,MACQ,+BAAY;AAAA,MACpB,QAAQ,iBAAiB;AAAA,MACzB,MAAM,CAAC;AAAA;AAAA,IACX;AACA,WAAO,KAAK,iDAAiD,KAAK,IAAI,QAAQ,qBAAO,OAAO,KAAK,CAAC,EAAE;AAEpG,UAAM,UAAU,OAAO,SAAS,SAAS,iBAAiB;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKS,SAAS,QAAW;AACzB,UAAM,IAAI;AAAA,MACN,4BAA4B,KAAK,IAAI;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,kBAAkB,OAAU,QAAgB;AACxC,QAAI,KAAK,gBAAgB;AACrB,YAAM,IAAI;AAAA,QACN,4BAA4B,KAAK,IAAI;AAAA,MACzC;AAAA,IACJ;AACA,SAAK,UAAU,OAAO,QAAW,KAAK,QAAQ;AAE9C,UAAM,WAAW,KAAK,kBAAkB,MAAM;AAC9C,UAAM,eAAe,KAAC,8BAAY,OAAO,QAAQ;AACjD,QAAI,cAAc;AACd,YAAM,YAAY,OAAO,0BAA0B,KAAK,SAAS,KAAK,MAAM,EAAE,MAAM,CAAC;AACrF,UAAI,6BAAa,GAAG,SAAS,GAAG;AAC5B,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,iCAAiC,OAAO,UAAU,YAAY;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,sBAAsB,QAAgB;AAClC,UAAM,WAAW,KAAK,SAAS,KAAK;AACpC,QAAI;AACA,WAAK,QAAQ,KAAK,kBAAkB,MAAM;AAAA,IAC9C,SAAS,GAAG;AACR,uBAAiB,OAAO,CAAC;AAEzB,UAAI,KAAK,UAAU,QAAW;AAC1B,aAAK,QAAQ,KAAK;AAAA,MACtB;AAAA,IACJ;AACA,SAAK,iCAAiC,KAAK,OAAO,UAAU,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,kBAAkB,QAAmB;AACjC,QAAI,KAAK,gBAAgB;AACrB,YAAM,IAAI;AAAA,QACN,4BAA4B,KAAK,IAAI;AAAA,MACzC;AAAA,IACJ;AACA,WAAO,6CAA6C,QAAQ,KAAK,SAAS,KAAK,MAAM,KAAK,YAAY;AAAA,EAC1G;AACJ;",
  "names": []
}
