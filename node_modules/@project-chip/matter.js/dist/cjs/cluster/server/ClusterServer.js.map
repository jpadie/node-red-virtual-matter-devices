{
  "version": 3,
  "sources": ["../../../../src/cluster/server/ClusterServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError, InternalError } from \"../../common/MatterError.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { Endpoint } from \"../../device/Endpoint.js\";\nimport { Fabric } from \"../../fabric/Fabric.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { capitalize } from \"../../util/String.js\";\nimport { AccessLevel, ConditionalFeatureList, TlvNoResponse } from \"../Cluster.js\";\nimport { ClusterType } from \"../ClusterType.js\";\nimport { createAttributeServer } from \"./AttributeServer.js\";\nimport {\n    AttributeInitialValues,\n    AttributeServers,\n    ClusterDatasource,\n    ClusterServerHandlers,\n    ClusterServerObj,\n    CommandServers,\n    EventServers,\n    SupportedEventsList,\n} from \"./ClusterServerTypes.js\";\nimport { CommandServer } from \"./CommandServer.js\";\nimport { createEventServer } from \"./EventServer.js\";\n\nconst logger = Logger.get(\"ClusterServer\");\n\nfunction isConditionMatching<F extends BitSchema, SF extends TypeFromPartialBitSchema<F>>(\n    featureSets: ConditionalFeatureList<F>,\n    supportedFeatures: SF,\n): boolean {\n    for (const features of featureSets) {\n        if (Object.keys(features).every(feature => !!features[feature] === !!supportedFeatures[feature])) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * A collection of servers for a cluster's attributes, commands and events.\n */\nexport interface ClusterServer<T extends ClusterType = ClusterType> {\n    /**\n     * Cluster ID\n     */\n    id: ClusterId;\n\n    /**\n     * Cluster name\n     */\n    readonly name: string;\n\n    /**\n     * Cluster datasource\n     */\n    datasource?: ClusterDatasource;\n\n    /**\n     * Cluster attributes as named object that can be used to programmatically work with available attributes\n     */\n    readonly attributes: AttributeServers<T[\"attributes\"]>;\n\n    /**\n     * Cluster commands as array\n     */\n    readonly commands: CommandServers<T[\"commands\"]>;\n\n    /**\n     * Cluster events as named object\n     */\n    readonly events: EventServers<T[\"events\"]>;\n}\n\n// Note - template parameter H should not be necessary but works around TS (as of 5.4) bug\nexport function ClusterServer<const T extends ClusterType, const H extends ClusterServerHandlers<T>>(\n    clusterDef: T,\n    attributesInitialValues: AttributeInitialValues<T[\"attributes\"]>,\n    handlers: H,\n    supportedEvents: SupportedEventsList<T[\"events\"]> = <SupportedEventsList<T[\"events\"]>>{},\n    ignoreMissingElements = false,\n): ClusterServerObj<T> {\n    const {\n        id: clusterId,\n        name,\n        commands: commandDef,\n        attributes: attributeDef,\n        events: eventDef,\n        supportedFeatures,\n    } = clusterDef;\n    let datasource: ClusterDatasource | undefined;\n    const sceneAttributeList = new Array<string>();\n    const attributes = <AttributeServers<T[\"attributes\"]>>{};\n    const commands = <CommandServers<T[\"commands\"]>>{};\n    const events = <EventServers<T[\"events\"]>>{};\n    let assignedEndpoint: Endpoint | undefined = undefined;\n\n    // We pass a proxy into attribute servers so we can swap out our datasource without updating all servers\n    //\n    // There should always be a datasource when the server is online, so if there is no datasource we just report\n    // version as 0 rather than assigning a random version that will be overwritten when we receive a datasource\n    const datasourceProxy: ClusterDatasource = {\n        get version() {\n            return datasource?.version ?? 0;\n        },\n\n        get eventHandler() {\n            return datasource?.eventHandler;\n        },\n\n        increaseVersion() {\n            return datasource?.increaseVersion() ?? 0;\n        },\n\n        changed(key, value) {\n            datasource?.changed(key, value);\n        },\n    };\n\n    const result: any = {\n        id: clusterId,\n        name,\n        _type: \"ClusterServer\",\n        attributes,\n        commands: commands,\n        events: events,\n\n        get datasource() {\n            return datasource;\n        },\n\n        set datasource(newDatasource: ClusterDatasource<any> | undefined) {\n            // This is not legal but TS requires setters to accept getter type\n            if (newDatasource === undefined) {\n                throw new InternalError(\"Cluster datasource cannot be unset\");\n            }\n\n            datasource = newDatasource;\n\n            if (assignedEndpoint === undefined) {\n                throw new InternalError(\n                    \"The Endpoint always needs to be existing before storage is initialized for an Endpoint.\",\n                );\n            }\n\n            if (typeof handlers.initializeClusterServer === \"function\") {\n                handlers.initializeClusterServer({\n                    attributes,\n                    events,\n                    endpoint: assignedEndpoint,\n                });\n            }\n\n            if (datasource.eventHandler) {\n                for (const eventName in events) {\n                    const bindResult = (events as any)[eventName].bindToEventHandler(datasource.eventHandler);\n                    if (bindResult !== undefined && MaybePromise.is(bindResult)) {\n                        throw new InternalError(\"Binding events to event handler should never return a promise\");\n                    }\n                }\n            }\n        },\n\n        _assignToEndpoint: (endpoint: Endpoint) => {\n            for (const name in attributes) {\n                (attributes as any)[name].assignToEndpoint(endpoint);\n            }\n            for (const name in events) {\n                (events as any)[name].assignToEndpoint(endpoint);\n            }\n            assignedEndpoint = endpoint;\n        },\n\n        _close: () => {\n            if (typeof handlers.destroyClusterServer === \"function\") {\n                handlers.destroyClusterServer();\n            }\n        },\n\n        isAttributeSupported: (attributeId: AttributeId) => {\n            return (attributes as any).attributeList.getLocal().includes(attributeId);\n        },\n\n        isAttributeSupportedByName: (attributeName: string) => {\n            return (attributesInitialValues as any)[attributeName] !== undefined;\n        },\n\n        isEventSupported: (eventId: EventId) => {\n            return (attributes as any).eventList.getLocal().includes(eventId);\n        },\n\n        isEventSupportedByName: (eventName: string) => {\n            return (supportedEvents as any)[eventName] === true;\n        },\n\n        isCommandSupported: (commandId: CommandId) => {\n            return (attributes as any).acceptedCommandList.getLocal().includes(commandId);\n        },\n\n        isCommandSupportedByName: (commandName: string) => {\n            return (commands as any)[commandName] !== undefined;\n        },\n    };\n\n    // Create attributes\n    attributesInitialValues = {\n        ...attributesInitialValues,\n        clusterRevision: clusterDef.revision,\n        featureMap: supportedFeatures,\n        attributeList: new Array<AttributeId>(),\n        acceptedCommandList: new Array<CommandId>(),\n        generatedCommandList: new Array<CommandId>(),\n        eventList: new Array<EventId>(),\n    };\n\n    const attributeList = new Array<AttributeId>();\n    for (const attributeName in attributeDef) {\n        const capitalizedAttributeName = capitalize(attributeName);\n\n        // logger.info(`check this for REQUIRED Attributes ${Logger.toJSON(attributeName)}`)\n        if (attributeDef[attributeName].isConditional) {\n            const { mandatoryIf, optionalIf } = attributeDef[attributeName];\n            let conditionHasMatched = false;\n            if (mandatoryIf !== undefined && mandatoryIf.length > 0) {\n                // Check if mandatoryIf is relevant for current feature combination and the attribute initial value is set\n                const conditionMatched = isConditionMatching(mandatoryIf, supportedFeatures);\n                if (conditionMatched && (attributesInitialValues as any)[attributeName] === undefined) {\n                    logger.warn(\n                        `InitialAttributeValue for \"${\n                            clusterDef.name\n                        }/${attributeName}\" is REQUIRED by supportedFeatures: ${Logger.toJSON(\n                            supportedFeatures,\n                        )} but is not set!`,\n                    );\n                }\n                conditionHasMatched = conditionHasMatched || conditionMatched;\n            }\n            // TODO Remove optional info/checks\n            if (!conditionHasMatched && optionalIf !== undefined && optionalIf.length > 0) {\n                const conditionMatched = isConditionMatching(optionalIf, supportedFeatures);\n                if (conditionMatched && (attributesInitialValues as any)[attributeName] === undefined) {\n                    logger.debug(\n                        `InitialAttributeValue for \"${\n                            clusterDef.name\n                        }/${attributeName}\" is optional by supportedFeatures: ${Logger.toJSON(\n                            supportedFeatures,\n                        )} and is not set!`,\n                    );\n                }\n                conditionHasMatched = conditionHasMatched || conditionMatched;\n            }\n\n            if (!conditionHasMatched && (attributesInitialValues as any)[attributeName] !== undefined) {\n                logger.warn(\n                    `InitialAttributeValue for \"${\n                        clusterDef.name\n                    }/${attributeName}\" is provided but it's neither optional or mandatory for supportedFeatures: ${Logger.toJSON(\n                        supportedFeatures,\n                    )} but is set!`,\n                );\n            }\n        }\n\n        const { id, persistent, fabricScoped, scene, fixed } = attributeDef[attributeName];\n        if ((attributesInitialValues as any)[attributeName] !== undefined) {\n            // Get the handlers for this attribute if present\n            const getter = (handlers as any)[`${attributeName}AttributeGetter`];\n            const setter = (handlers as any)[`${attributeName}AttributeSetter`];\n            const validator = (handlers as any)[`${attributeName}AttributeValidator`];\n\n            (attributes as any)[attributeName] = createAttributeServer(\n                clusterDef,\n                attributeDef[attributeName],\n                attributeName,\n                (attributesInitialValues as any)[attributeName],\n                datasourceProxy,\n                getter\n                    ? (session, endpoint, isFabricFiltered, message) =>\n                          getter({\n                              attributes,\n                              endpoint,\n                              session,\n                              isFabricFiltered,\n                              message,\n                          })\n                    : undefined,\n                setter\n                    ? (value, session, endpoint, message) =>\n                          setter(value, {\n                              attributes,\n                              endpoint,\n                              session,\n                              message,\n                          })\n                    : undefined,\n                validator\n                    ? (value, session, endpoint) =>\n                          validator(value, {\n                              attributes,\n                              endpoint,\n                              session,\n                          })\n                    : undefined,\n            );\n\n            // Add the relevant convenient methods to the ClusterServerObj\n            if (fixed) {\n                result[`get${capitalizedAttributeName}Attribute`] = () => (attributes as any)[attributeName].getLocal();\n            } else if (fabricScoped) {\n                result[`get${capitalizedAttributeName}Attribute`] = (fabric: Fabric) =>\n                    (attributes as any)[attributeName].getLocalForFabric(fabric);\n                result[`set${capitalizedAttributeName}Attribute`] = <T>(value: T, fabric: Fabric) =>\n                    (attributes as any)[attributeName].setLocalForFabric(value, fabric);\n                result[`subscribe${capitalizedAttributeName}Attribute`] = <T>(\n                    listener: (newValue: T, oldValue: T) => void,\n                ) => (attributes as any)[attributeName].addValueSetListener(listener);\n            } else {\n                if (scene) {\n                    sceneAttributeList.push(attributeName);\n                }\n                result[`get${capitalizedAttributeName}Attribute`] = () => (attributes as any)[attributeName].getLocal();\n                result[`set${capitalizedAttributeName}Attribute`] = <T>(value: T) =>\n                    (attributes as any)[attributeName].setLocal(value);\n                result[`subscribe${capitalizedAttributeName}Attribute`] = <T>(\n                    listener: (newValue: T, oldValue: T) => void,\n                ) => (attributes as any)[attributeName].addValueSetListener(listener);\n            }\n            if (persistent || getter || setter) {\n                const listener = (value: any) =>\n                    datasource?.changed(attributeName, fabricScoped || getter || setter ? undefined : value);\n                (attributes as any)[attributeName].addValueChangeListener(listener);\n            }\n            attributeList.push(AttributeId(id));\n        } else {\n            // TODO: Find maybe a better way to do this including strong typing according to attribute initial values set?\n            result[`get${capitalizedAttributeName}Attribute`] = () => undefined;\n            if (!fixed) {\n                result[`set${capitalizedAttributeName}Attribute`] = () => {\n                    throw new ImplementationError(\n                        `Attribute ${attributeName} is optional and not initialized. To use it please initialize it first.`,\n                    );\n                };\n                result[`subscribe${capitalizedAttributeName}Attribute`] = () => {\n                    throw new ImplementationError(\n                        `Attribute ${attributeName} is optional and not initialized. To use it please initialize it first.`,\n                    );\n                };\n            }\n        }\n    }\n    (attributes as any).attributeList.setLocal(attributeList.sort((a, b) => a - b));\n\n    // Create commands\n    const acceptedCommandList = new Array<CommandId>();\n    const generatedCommandList = new Array<CommandId>();\n    for (const name in commandDef) {\n        const handler = (handlers as any)[name];\n\n        if (commandDef[name].isConditional) {\n            const { mandatoryIf, optionalIf } = commandDef[name];\n            let conditionHasMatched = false;\n            if (mandatoryIf !== undefined && mandatoryIf.length > 0) {\n                const conditionMatched = isConditionMatching(mandatoryIf, supportedFeatures);\n                if (conditionMatched && handler === undefined) {\n                    logger.warn(\n                        `Command \"${clusterDef.name}/${name}\" is REQUIRED by supportedFeatures: ${Logger.toJSON(\n                            supportedFeatures,\n                        )} but is not set!`,\n                    );\n                }\n                conditionHasMatched = conditionHasMatched || conditionMatched;\n            }\n            // TODO Remove optional info/checks\n            if (!conditionHasMatched && optionalIf !== undefined && optionalIf.length > 0) {\n                const conditionMatched = isConditionMatching(optionalIf, supportedFeatures);\n                if (conditionMatched && handler === undefined) {\n                    logger.debug(\n                        `Command \"${clusterDef.name}/${name}\" is optional by supportedFeatures: ${Logger.toJSON(\n                            supportedFeatures,\n                        )} and is not set!`,\n                    );\n                }\n                conditionHasMatched = conditionHasMatched || conditionMatched;\n            }\n\n            if (!conditionHasMatched && handler !== undefined) {\n                logger.warn(\n                    `Command \"${\n                        clusterDef.name\n                    }/${name}\" is provided but it's neither optional nor mandatory for supportedFeatures: ${Logger.toJSON(\n                        supportedFeatures,\n                    )} but is set!`,\n                );\n            }\n        }\n\n        if (handler === undefined) continue;\n        const { requestId, requestSchema, responseId, responseSchema, timed, invokeAcl } = commandDef[name];\n        (commands as any)[name] = new CommandServer(\n            requestId,\n            responseId,\n            name,\n            requestSchema,\n            responseSchema,\n            timed,\n            invokeAcl ?? AccessLevel.Operate, //????\n            (request, session, message, endpoint) =>\n                handler({\n                    request,\n                    attributes,\n                    events,\n                    session,\n                    message,\n                    endpoint,\n                }),\n        );\n        if (!acceptedCommandList.includes(requestId)) {\n            acceptedCommandList.push(requestId);\n        }\n        if (responseSchema !== TlvNoResponse) {\n            if (!generatedCommandList.includes(responseId)) {\n                generatedCommandList.push(responseId);\n            }\n        }\n    }\n    (attributes as any).acceptedCommandList.setLocal(acceptedCommandList.sort((a, b) => a - b));\n    (attributes as any).generatedCommandList.setLocal(generatedCommandList.sort((a, b) => a - b));\n\n    const eventList = new Array<EventId>();\n    for (const eventName in eventDef) {\n        const { id, schema, priority, optional, readAcl } = eventDef[eventName];\n        if (!optional && (supportedEvents as any)[eventName] !== true) {\n            if (!ignoreMissingElements) {\n                throw new ImplementationError(\n                    `Event ${eventName} needs be supported by cluster ${name} (${clusterId})`,\n                );\n            }\n            logger.warn(\n                `Event ${eventName} should be supported by cluster ${name} (${clusterId}) but not present and ignored.`,\n            );\n            continue;\n        }\n\n        if (eventDef[eventName].isConditional) {\n            const { mandatoryIf, optionalIf } = eventDef[eventName];\n            let conditionHasMatched = false;\n            if (mandatoryIf !== undefined) {\n                const conditionMatched = isConditionMatching(mandatoryIf, supportedFeatures);\n                if (conditionMatched && (supportedEvents as any)[eventName] === undefined) {\n                    logger.warn(\n                        `Event \"${clusterDef.name}/${eventName}\" is REQUIRED by supportedFeatures: ${Logger.toJSON(\n                            supportedFeatures,\n                        )} but is not set!`,\n                    );\n                }\n                conditionHasMatched = conditionHasMatched || conditionMatched;\n            }\n            // TODO Remove optional info/checks\n            if (!conditionHasMatched && optionalIf !== undefined && optionalIf.length > 0) {\n                const conditionMatched = isConditionMatching(optionalIf, supportedFeatures);\n                if (conditionMatched && (supportedEvents as any)[eventName] === undefined) {\n                    logger.debug(\n                        `Event \"${clusterDef.name}/${eventName}\" is optional by supportedFeatures: ${Logger.toJSON(\n                            supportedFeatures,\n                        )} and is not set!`,\n                    );\n                }\n                conditionHasMatched = conditionHasMatched || conditionMatched;\n            }\n\n            if (!conditionHasMatched && (supportedEvents as any)[eventName] !== undefined) {\n                logger.warn(\n                    `Event \"${\n                        clusterDef.name\n                    }/${eventName}\" is provided but it's neither optional or mandatory for supportedFeatures: ${Logger.toJSON(\n                        supportedFeatures,\n                    )} but is set!`,\n                );\n            }\n        }\n\n        if ((supportedEvents as any)[eventName] === true) {\n            (events as any)[eventName] = createEventServer(\n                clusterDef,\n                eventDef[eventName],\n                eventName,\n                schema,\n                priority,\n                readAcl,\n            );\n            const capitalizedEventName = capitalize(eventName);\n            result[`trigger${capitalizedEventName}Event`] = <T>(event: T) =>\n                (events as any)[eventName].triggerEvent(event);\n            eventList.push(id);\n        }\n    }\n    (attributes as any).eventList.setLocal(eventList.sort((a, b) => a - b));\n\n    return result as ClusterServerObj<T>;\n}\n"],
  "mappings": "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",
  "names": ["name"]
}
