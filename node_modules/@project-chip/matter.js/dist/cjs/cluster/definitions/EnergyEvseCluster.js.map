{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/EnergyEvseCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport {\n    Attribute,\n    Command,\n    TlvNoResponse,\n    OptionalWritableAttribute,\n    AccessLevel,\n    OptionalEvent,\n    EventPriority,\n    OptionalCommand,\n    Event\n} from \"../Cluster.js\";\nimport {\n    TlvEpochS,\n    TlvInt64,\n    TlvPercent,\n    TlvUInt16,\n    TlvUInt8,\n    TlvBitmap,\n    TlvEnum,\n    TlvUInt32\n} from \"../../tlv/TlvNumber.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { TlvField, TlvObject, TlvOptionalField } from \"../../tlv/TlvObject.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { BitFlag } from \"../../schema/BitmapSchema.js\";\nimport { TlvNoArguments } from \"../../tlv/TlvNoArguments.js\";\nimport { TlvString, TlvByteString } from \"../../tlv/TlvString.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace EnergyEvse {\n    /**\n     * These are optional features supported by EnergyEvseCluster.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4\n     */\n    export enum Feature {\n        /**\n         * ChargingPreferences (PREF)\n         *\n         * Since some EVSEs cannot obtain the SoC from the vehicle, some EV charging solutions allow the consumer to\n         * specify a daily charging target (for adding energy to the EV\u2019s battery). This feature allows the consumer to\n         * specify how many miles or km of additional range they need for their typical daily commute. This range\n         * requirement can be converted into a daily energy demand with a target charging completion time.\n         *\n         * The EVSE itself may use this information (or may allow a controller such as an EMS) to compute an\n         *\n         * optimized charging schedule.\n         *\n         * An EVSE device may implement the Device Energy Management cluster PFR (Power Forecast Reporting) and FA\n         * (Forecast Adjustment) features. This can help a controller (such as an EMS) to optimize the EVSE against\n         * other ESAs. For example, a solar PV ESA may share its Forecast and allow the EVSE to know the best time to\n         * charge so that any excess solar generation is used to charge the EV.\n         *\n         * EVSE devices that support the Device Energy Management cluster\u2019s FA feature can have their charging profiles\n         * set by a controller device such as an EMS. For example, if the EVSE advertises a simple power forecast which\n         * allows the EMS to adjust over a wide range of power and time durations, then the EVSE may allow the EMS to\n         * propose a revised optimized forecast (which is the charging profile).\n         *\n         * See the Device Energy Management Cluster for more details.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.1\n         */\n        ChargingPreferences = \"ChargingPreferences\",\n\n        /**\n         * SoCReporting (SOC)\n         *\n         * Vehicles and EVSEs which support ISO 15118 may allow the vehicle to report its battery size and state of\n         * charge. If the EVSE supports PLC it may have a vehicle connected which optionally supports reporting of its\n         * battery size and current State of Charge (SoC).\n         *\n         * If the EVSE supports reporting of State of Charge this feature will only work if a compatible EV is\n         * connected.\n         *\n         * Note some EVSEs may use other undefined mechanisms to obtain vehicle State of Charge outside the scope of\n         * this cluster.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.2\n         */\n        SoCReporting = \"SoCReporting\",\n\n        /**\n         * PlugAndCharge (PNC)\n         *\n         * If the EVSE supports PLC, it may be able to support the Plug and Charge feature. e.g. this may allow the\n         * vehicle ID to be obtained which may allow an energy management system to track energy usage per vehicle\n         * (e.g. to give the owner an indicative cost of charging, or for work place charging).\n         *\n         * If the EVSE supports the Plug and Charge feature, it will only work if a compatible EV is connected.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.3\n         */\n        PlugAndCharge = \"PlugAndCharge\",\n\n        /**\n         * Rfid (RFID)\n         *\n         * If the EVSE is fitted with an RFID reader, it may be possible to obtain the User or Vehicle ID from an RFID\n         * card. This may be used to record a charging session against a specific charging account, and may optionally\n         * be used to authorize a charging session.\n         *\n         * An RFID event can be generated when a user taps an RFID card onto the RFID reader. The event must be\n         * subscribed to by the EVSE Management cluster client. This client may use this to enable the EV to charge or\n         * discharge. The lookup and authorization of RIFD UID is outside the scope of this cluster.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.4\n         */\n        Rfid = \"Rfid\",\n\n        /**\n         * V2X (V2X)\n         *\n         * If the EVSE can support bi-directional charging, it may be possible to request that the vehicle can\n         * discharge to the home or grid.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.5\n         */\n        V2X = \"V2X\"\n    }\n\n    /**\n     * Input to the EnergyEvse enableDischarging command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.3\n     */\n    export const TlvEnableDischargingRequest = TlvObject({\n        /**\n         * This field shall indicate the expiry time, in UTC, when discharging will be automatically disabled.\n         *\n         * A value in the past in this field shall disable the EVSE whereas a null value shall enable it permanently.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.3.1\n         */\n        dischargingEnabledUntil: TlvField(0, TlvNullable(TlvEpochS)),\n\n        /**\n         * This field shall indicate the maximum current that can be received by the EVSE from the EV. The EVSE current\n         * limit can be advertised to an EV in 0.6A steps. The value of the MaximumDischargeCurrent attribute shall be\n         * stored and persisted across reboots by the EVSE to the value of this\n         *\n         * field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.3.2\n         */\n        maximumDischargeCurrent: TlvField(1, TlvInt64.bound({ min: 0 }))\n    });\n\n    /**\n     * Input to the EnergyEvse enableDischarging command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.3\n     */\n    export interface EnableDischargingRequest extends TypeFromSchema<typeof TlvEnableDischargingRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.5\n     */\n    export const TargetDayOfWeek = {\n        /**\n         * Sunday\n         */\n        sunday: BitFlag(0),\n\n        /**\n         * Monday\n         */\n        monday: BitFlag(1),\n\n        /**\n         * Tuesday\n         */\n        tuesday: BitFlag(2),\n\n        /**\n         * Wednesday\n         */\n        wednesday: BitFlag(3),\n\n        /**\n         * Thursday\n         */\n        thursday: BitFlag(4),\n\n        /**\n         * Friday\n         */\n        friday: BitFlag(5),\n\n        /**\n         * Saturday\n         */\n        saturday: BitFlag(6)\n    };\n\n    /**\n     * This represents a single user specified charging target for an EV.\n     *\n     * An EVSE or EMS system optimizer may use this information to take the Time of Use Tariff, grid carbon intensity,\n     * local generation (solar PV) into account to provide the cheapest and cleanest energy to the EV.\n     *\n     * The optimization strategy is not defined here, however in simple terms, the AddedEnergy requirement can be\n     * fulfilled by knowing the charging Power (W) and the time needed to charge.\n     *\n     * To compute the Charging Time: Required Energy (Wh) = Power (W) x ChargingTime (s) / 3600 Therefore: ChargingTime\n     * (s) = (3600 x RequiredEnergy (wH)) / Power (W)\n     *\n     * To compute the charging time: Charging StartTime = TargetTimeMinutesPastMidnight - ChargingTime\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.6\n     */\n    export const TlvChargingTarget = TlvObject({\n        /**\n         * This field shall indicate the desired charging completion time of the associated day. The time will be\n         * represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am will be\n         * represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since midnight.\n         *\n         * This field is based on local wall clock time. In case of Daylight Savings Time transition which may result\n         * in an extra hour or one hour less in the day, the charging algorithm should take into account the shift\n         * appropriately.\n         *\n         * Note that if the TargetTimeMinutesPastMidnight values are too close together (e.g. 2 per day) these may\n         * overlap. The EVSE may have to coalesce the charging targets into a single target. e.g. if the 1st charging\n         * target cannot be met in the time available, the EVSE may be forced to begin working towards the 2nd charging\n         * target and immediately continue until both targets have been satisfied (or the vehicle becomes full).\n         *\n         * The EVSE itself cannot predict the behavior of the vehicle (i.e. if it cannot obtain the SoC from the\n         * vehicle), so should attempt to perform a sensible operation based on these targets. It is recommended that\n         * the charging schedule is pessimistic (i.e. starts earlier) since the vehicle may charge more slowly than the\n         * electrical supply may provide power (especially if it is cold).\n         *\n         * If the user configures large charging targets (e.g. high values of AddedEnergy or SoC) then it is expected\n         * that the EVSE may need to begin charging immediately, and may not be able to guarantee that the vehicle will\n         * be able to reach the target.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.6.1\n         */\n        targetTimeMinutesPastMidnight: TlvField(0, TlvUInt16.bound({ max: 1439 })),\n\n        /**\n         * This field represents the target SoC that the vehicle should be charged to before the\n         * TargetTimeMinutesPastMidnight.\n         *\n         * If the EVSE can obtain the SoC of the vehicle:\n         *\n         *   \u2022 the TargetSoC field shall take precedence over the AddedEnergy field.\n         *\n         *   \u2022 the EVSE SHOULD charge to the TargetSoC and then stop the charging automatically when it reaches that\n         *     point.\n         *\n         *   \u2022 if the TargetSoC value is set to 100% then the EVSE SHOULD continue to charge the vehicle until the\n         *     vehicle decides to stop charging.\n         *\n         * If the EVSE cannot obtain the SoC of the vehicle:\n         *\n         *   \u2022 in this case, the AddedEnergy field shall take precedence over the TargetSoC field, and the TargetSoC\n         *     field may only take the values null or 100%.\n         *\n         *   \u2022 if the AddedEnergy field has not been provided, the EVSE SHOULD assume the vehicle is empty and charge\n         *     until the vehicle stops demanding a charge.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.6.2\n         */\n        targetSoC: TlvOptionalField(1, TlvPercent),\n\n        /**\n         * This field represents the amount of energy that the user would like to have added to the vehicle before the\n         * TargetTimeMinutesPastMidnight.\n         *\n         * This represents a positive value in mWh that SHOULD be added during the session (i.e. if the vehicle\n         * charging is stopped and started several times, this equates to the total energy since the vehicle has been\n         * plugged in).\n         *\n         * The maximum value (500kWh) is much larger than most EV batteries on the market today. If the client tries to\n         * set this value too high then the EVSE will need to start charging immediately and continue charging until\n         * the vehicle stops demanding charge (i.e. it is full). Therefore the maximum value should be set based on\n         * typical battery size of the vehicles on the market (e.g. 70000Wh), however this is up to the client to\n         * carefully choose a value.\n         *\n         * NOTE\n         *\n         * If the EVSE can obtain the Battery Capacity of the vehicle, it SHOULD not limit this AddedEnergy value to\n         * the Battery Capacity of the vehicle, since the EV may also require energy for heating and cooling of the\n         * battery during charging, or for heating or cooling the cabin.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.6.3\n         */\n        addedEnergy: TlvOptionalField(2, TlvInt64.bound({ min: 0 }))\n    });\n\n    /**\n     * This represents a single user specified charging target for an EV.\n     *\n     * An EVSE or EMS system optimizer may use this information to take the Time of Use Tariff, grid carbon intensity,\n     * local generation (solar PV) into account to provide the cheapest and cleanest energy to the EV.\n     *\n     * The optimization strategy is not defined here, however in simple terms, the AddedEnergy requirement can be\n     * fulfilled by knowing the charging Power (W) and the time needed to charge.\n     *\n     * To compute the Charging Time: Required Energy (Wh) = Power (W) x ChargingTime (s) / 3600 Therefore: ChargingTime\n     * (s) = (3600 x RequiredEnergy (wH)) / Power (W)\n     *\n     * To compute the charging time: Charging StartTime = TargetTimeMinutesPastMidnight - ChargingTime\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.6\n     */\n    export interface ChargingTarget extends TypeFromSchema<typeof TlvChargingTarget> {}\n\n    /**\n     * This represents a set of user specified charging targets for an EV for a set of specified days.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.7\n     */\n    export const TlvChargingTargetSchedule = TlvObject({\n        dayOfWeekForSequence: TlvOptionalField(0, TlvBitmap(TlvUInt8, TargetDayOfWeek)),\n        chargingTargets: TlvOptionalField(1, TlvArray(TlvChargingTarget, { maxLength: 10 }))\n    });\n\n    /**\n     * This represents a set of user specified charging targets for an EV for a set of specified days.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.7\n     */\n    export interface ChargingTargetSchedule extends TypeFromSchema<typeof TlvChargingTargetSchedule> {}\n\n    /**\n     * Input to the EnergyEvse setTargets command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.5\n     */\n    export const TlvSetTargetsRequest = TlvObject({\n        /**\n         * This field shall indicate a list of up to 7 sets of daily charging targets together with their associated\n         * days of the week. Each of the days of the week may only be included in a single ChargingTargetSchedule\n         * within this list field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.5.1\n         */\n        chargingTargetSchedules: TlvField(0, TlvArray(TlvChargingTargetSchedule, { maxLength: 7 }))\n    });\n\n    /**\n     * Input to the EnergyEvse setTargets command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.5\n     */\n    export interface SetTargetsRequest extends TypeFromSchema<typeof TlvSetTargetsRequest> {}\n\n    /**\n     * The GetTargetsResponse is sent in response to the GetTargets Command.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.7\n     */\n    export const TlvGetTargetsResponse = TlvObject({\n        /**\n         * This field shall indicate a list of up to 7 sets of daily charging targets together with their associated\n         * days of the week.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.7.1\n         */\n        chargingTargetSchedules: TlvField(0, TlvArray(TlvChargingTargetSchedule, { maxLength: 7 }))\n    });\n\n    /**\n     * The GetTargetsResponse is sent in response to the GetTargets Command.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.7\n     */\n    export interface GetTargetsResponse extends TypeFromSchema<typeof TlvGetTargetsResponse> {}\n\n    /**\n     * Body of the EnergyEvse rfid event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.6\n     */\n    export const TlvRfidEvent = TlvObject({\n        /**\n         * The UID field (ISO 14443A UID) is either 4, 7 or 10 bytes.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.6.1\n         */\n        uid: TlvField(0, TlvByteString.bound({ maxLength: 10 }))\n    });\n\n    /**\n     * Body of the EnergyEvse rfid event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.6\n     */\n    export interface RfidEvent extends TypeFromSchema<typeof TlvRfidEvent> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.1\n     */\n    export enum State {\n        /**\n         * The EV is not plugged in.\n         */\n        NotPluggedIn = 0,\n\n        /**\n         * The EV is plugged in, but not demanding current.\n         */\n        PluggedInNoDemand = 1,\n\n        /**\n         * The EV is plugged in and is demanding current, but EVSE is not allowing current to flow.\n         */\n        PluggedInDemand = 2,\n\n        /**\n         * The EV is plugged in, charging is in progress, and current is flowing\n         */\n        PluggedInCharging = 3,\n\n        /**\n         * The EV is plugged in, discharging is in progress, and current is flowing\n         */\n        PluggedInDischarging = 4,\n\n        /**\n         * The EVSE is transitioning from any plugged- in state to NotPluggedIn\n         */\n        SessionEnding = 5,\n\n        /**\n         * There is a fault (see FaultState attribute)\n         */\n        Fault = 6\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.2\n     */\n    export enum SupplyState {\n        /**\n         * The EV is not currently allowed to charge or discharge\n         */\n        Disabled = 0,\n\n        /**\n         * The EV is currently allowed to charge\n         */\n        ChargingEnabled = 1,\n\n        /**\n         * The EV is currently allowed to discharge\n         */\n        DischargingEnabled = 2,\n\n        /**\n         * The EV is not currently allowed to charge or discharge due to an error. The error must be cleared before\n         * operation can continue.\n         */\n        DisabledError = 3,\n\n        /**\n         * The EV is not currently allowed to charge or discharge due to Diagnostics Mode.\n         */\n        DisabledDiagnostics = 4\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.3\n     */\n    export enum FaultState {\n        /**\n         * The EVSE is not in an error state.\n         */\n        NoError = 0,\n\n        /**\n         * The EVSE is unable to obtain electrical measurements.\n         */\n        MeterFailure = 1,\n\n        /**\n         * The EVSE input voltage level is too high.\n         */\n        OverVoltage = 2,\n\n        /**\n         * The EVSE input voltage level is too low.\n         */\n        UnderVoltage = 3,\n\n        /**\n         * The EVSE detected charging current higher than allowed by charger.\n         */\n        OverCurrent = 4,\n\n        /**\n         * The EVSE detected voltage on charging pins when the contactor is open.\n         */\n        ContactWetFailure = 5,\n\n        /**\n         * The EVSE detected absence of voltage after enabling contactor.\n         */\n        ContactDryFailure = 6,\n\n        /**\n         * The EVSE has an unbalanced current supply.\n         */\n        GroundFault = 7,\n\n        /**\n         * The EVSE has detected a loss in power.\n         */\n        PowerLoss = 8,\n\n        /**\n         * The EVSE has detected another power quality issue (e.g. phase imbalance).\n         */\n        PowerQuality = 9,\n\n        /**\n         * The EVSE pilot signal amplitude short circuited to ground.\n         */\n        PilotShortCircuit = 10,\n\n        /**\n         * The emergency stop button was pressed.\n         */\n        EmergencyStop = 11,\n\n        /**\n         * The EVSE detected that the cable has been disconnected.\n         */\n        EvDisconnected = 12,\n\n        /**\n         * The EVSE could not determine proper power supply level.\n         */\n        WrongPowerSupply = 13,\n\n        /**\n         * The EVSE detected Live and Neutral are swapped.\n         */\n        LiveNeutralSwap = 14,\n\n        /**\n         * The EVSE internal temperature is too high.\n         */\n        OverTemperature = 15,\n\n        /**\n         * Any other reason.\n         */\n        Other = 255\n    }\n\n    /**\n     * Input to the EnergyEvse enableCharging command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.2\n     */\n    export const TlvEnableChargingRequest = TlvObject({\n        /**\n         * This field shall indicate the expiry time, in UTC, when charging will be automatically disabled.\n         *\n         * A value in the past in this field shall disable the EVSE charging whereas a null value shall enable it\n         * permanently.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.2.1\n         */\n        chargingEnabledUntil: TlvField(0, TlvNullable(TlvEpochS)),\n\n        /**\n         * This field shall indicate the minimum current that can be delivered by the EVSE to the EV in trickle mode.\n         * The EVSE current limit can be advertised to an EV in 0.6A steps.\n         *\n         * The value of the MinimumChargeCurrent attribute shall be set to the value of this field (see\n         * MinimumChargeCurrent attribute for further details).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.2.2\n         */\n        minimumChargeCurrent: TlvField(1, TlvInt64.bound({ min: 0 })),\n\n        /**\n         * This field shall indicate the maximum current that can be delivered by the EVSE to the EV. The EVSE current\n         * limit can be advertised to an EV in 0.6A steps.\n         *\n         * The value of the this field shall be stored by the EVSE to determine the value of MaximumChargeCurrent\n         * attribute. For example, if the UserMaximumChargeCurrent attribute is adjusted below then\n         *\n         * this value, and then later adjusted above this value, the resulting MaximumChargeCurrent attribute will be\n         * limited to this value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.2.3\n         */\n        maximumChargeCurrent: TlvField(2, TlvInt64.bound({ min: 0 }))\n    });\n\n    /**\n     * Input to the EnergyEvse enableCharging command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.2\n     */\n    export interface EnableChargingRequest extends TypeFromSchema<typeof TlvEnableChargingRequest> {}\n\n    /**\n     * Body of the EnergyEvse evConnected event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.1\n     */\n    export const TlvEvConnectedEvent = TlvObject({\n        /**\n         * This is the new session ID created after the vehicle is plugged in.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.1.1\n         */\n        sessionId: TlvField(0, TlvUInt32)\n    });\n\n    /**\n     * Body of the EnergyEvse evConnected event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.1\n     */\n    export interface EvConnectedEvent extends TypeFromSchema<typeof TlvEvConnectedEvent> {}\n\n    /**\n     * Body of the EnergyEvse evNotDetected event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2\n     */\n    export const TlvEvNotDetectedEvent = TlvObject({\n        /**\n         * This field shall indicate the current value of the SessionID attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2.1\n         */\n        sessionId: TlvField(0, TlvUInt32),\n\n        /**\n         * This field shall indicate the value of the State attribute prior to the EV not being detected.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2.2\n         */\n        state: TlvField(1, TlvEnum<State>()),\n\n        /**\n         * This field shall indicate the total duration of the session, from the start of the session when the EV was\n         * plugged in, until it was unplugged.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2.3\n         */\n        sessionDuration: TlvField(2, TlvUInt32),\n\n        /**\n         * This field shall indicate the total amount of energy transferred from the EVSE to the EV during the session.\n         * This value shall always be positive.\n         *\n         * Note that if bi-directional charging occurs during the session, then this value shall only include the sum\n         * of energy transferred from the EVSE to the EV, and shall NOT be a net value of charging and discharging\n         * energy.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2.4\n         */\n        sessionEnergyCharged: TlvField(3, TlvInt64.bound({ min: 0 })),\n\n        /**\n         * This field shall indicate the total amount of energy transferred from the EV to the EVSE during the session.\n         * This value shall always be positive.\n         *\n         * Note that if bi-directional discharging occurs during the session, then this value shall only include the\n         * sum of energy transferred from the EV to the EVSE, and shall NOT be a net value of charging and discharging\n         * energy.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2.5\n         */\n        sessionEnergyDischarged: TlvOptionalField(4, TlvInt64.bound({ min: 0 }))\n    });\n\n    /**\n     * Body of the EnergyEvse evNotDetected event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2\n     */\n    export interface EvNotDetectedEvent extends TypeFromSchema<typeof TlvEvNotDetectedEvent> {}\n\n    /**\n     * Body of the EnergyEvse energyTransferStarted event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.3\n     */\n    export const TlvEnergyTransferStartedEvent = TlvObject({\n        /**\n         * This field shall indicate the value of the SessionID attribute at the time the event was generated.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.3.1\n         */\n        sessionId: TlvField(0, TlvUInt32),\n\n        /**\n         * This field shall indicate the value of the State attribute at the time the event was generated.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.3.2\n         */\n        state: TlvField(1, TlvEnum<State>()),\n\n        /**\n         * This field shall indicate the value of the maximum charging or discharging current at the time the event was\n         * generated.\n         *\n         * This field is signed. A positive value indicates the EV has been enabled for charging and the value is taken\n         * directly from the MaximumChargeCurrent attribute.\n         *\n         * A negative value indicates that the EV has been enabled for discharging and the value can be taken from the\n         * MaximumDischargeCurrent attribute with its sign inverted. i.e. if the MaximumDischargeCurrent was 32000mA,\n         * this would be represented here as -32000mA.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.3.3\n         */\n        maximumCurrent: TlvField(2, TlvInt64.bound({ min: 0 }))\n    });\n\n    /**\n     * Body of the EnergyEvse energyTransferStarted event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.3\n     */\n    export interface EnergyTransferStartedEvent extends TypeFromSchema<typeof TlvEnergyTransferStartedEvent> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.7.4\n     */\n    export enum EnergyTransferStoppedReason {\n        /**\n         * The EV decided to stop\n         */\n        EvStopped = 0,\n\n        /**\n         * The EVSE decided to stop\n         */\n        EvseStopped = 1,\n\n        /**\n         * An other unknown reason\n         */\n        Other = 2\n    }\n\n    /**\n     * Body of the EnergyEvse energyTransferStopped event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.4\n     */\n    export const TlvEnergyTransferStoppedEvent = TlvObject({\n        /**\n         * This field shall indicate the value of the SessionID attribute prior to the energy transfer stopping.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.4.1\n         */\n        sessionId: TlvField(0, TlvUInt32),\n\n        /**\n         * This field shall indicate the value of the State attribute prior to the energy transfer stopping.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.4.2\n         */\n        state: TlvField(1, TlvEnum<State>()),\n\n        /**\n         * This field shall indicate the reason why the energy transferred stopped.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.4.3\n         */\n        reason: TlvField(2, TlvEnum<EnergyTransferStoppedReason>()),\n\n        energyTransferred: TlvField(4, TlvInt64.bound({ min: 0 }))\n    });\n\n    /**\n     * Body of the EnergyEvse energyTransferStopped event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.4\n     */\n    export interface EnergyTransferStoppedEvent extends TypeFromSchema<typeof TlvEnergyTransferStoppedEvent> {}\n\n    /**\n     * Body of the EnergyEvse fault event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5\n     */\n    export const TlvFaultEvent = TlvObject({\n        /**\n         * This field shall indicate the value of the SessionID attribute prior to the Fault State being changed. A\n         * value of null indicates no sessions have occurred before the fault occurred.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5.1\n         */\n        sessionId: TlvField(0, TlvNullable(TlvUInt32)),\n\n        /**\n         * This field shall indicate the value of the State attribute prior to the Fault State being changed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5.2\n         */\n        state: TlvField(1, TlvEnum<State>()),\n\n        /**\n         * This field shall indicate the value of the FaultState attribute prior to the Fault State being changed.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5.3\n         */\n        faultStatePreviousState: TlvField(2, TlvEnum<FaultState>()),\n\n        /**\n         * This field shall indicate the current value of the FaultState attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5.4\n         */\n        faultStateCurrentState: TlvField(4, TlvEnum<FaultState>())\n    });\n\n    /**\n     * Body of the EnergyEvse fault event\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5\n     */\n    export interface FaultEvent extends TypeFromSchema<typeof TlvFaultEvent> {}\n\n    /**\n     * A EnergyEvseCluster supports these elements if it supports feature V2X.\n     */\n    export const V2XComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the time, in UTC, that the EVSE will automatically stop current flow from the EV.\n             *\n             * A null value indicates the EVSE is always enabled for discharging.\n             *\n             * A value in the past or 0x0 indicates that EVSE discharging shall be disabled. The attribute is only set\n             * via the payload of the EnableDischarging command.\n             *\n             * This attribute shall be persisted, for example a temporary power failure should not stop the vehicle\n             * from being discharged.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.5\n             */\n            dischargingEnabledUntil: Attribute(0x4, TlvNullable(TlvEpochS), { persistent: true, default: 0 }),\n\n            /**\n             * Indicates the maximum current that can be received by the EVSE from the EV. This attribute can be set\n             * using the EnableDischarging command.\n             *\n             * This attribute value shall be the minimum of:\n             *\n             *   \u2022 CircuitCapacity - Electrician\u2019s installation setting\n             *\n             *   \u2022 CableAssemblyCurrentLimit (detected by the EVSE when the cable is plugged in)\n             *\n             *   \u2022 MaximumDischargeCurrent field in the EnableDischarging command\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.9\n             */\n            maximumDischargeCurrent: Attribute(0x8, TlvInt64.bound({ min: 0 }), { persistent: true, default: 0 }),\n\n            /**\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8\n             */\n            sessionEnergyDischarged: Attribute(\n                0x43,\n                TlvNullable(TlvInt64.bound({ min: 0 })),\n                { persistent: true, default: null }\n            )\n        },\n\n        commands: {\n            /**\n             * Allows a client to enable the EVSE to discharge an EV.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.3\n             */\n            enableDischarging: Command(0x3, TlvEnableDischargingRequest, 0x3, TlvNoResponse, { timed: true })\n        }\n    });\n\n    /**\n     * A EnergyEvseCluster supports these elements if it supports feature ChargingPreferences.\n     */\n    export const ChargingPreferencesComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the time, in UTC, when the EVSE plans to start the next scheduled charge based on the charging\n             * preferences.\n             *\n             * If this is null it indicates that there is no scheduled charging, or that the vehicle is not plugged in.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.12\n             */\n            nextChargeStartTime: Attribute(0x23, TlvNullable(TlvEpochS), { default: null }),\n\n            /**\n             * Indicates the time, in UTC, when the EVSE SHOULD complete the next scheduled charge based on the\n             * charging preferences.\n             *\n             * If this is null it indicates that there is no scheduled charging, or that the vehicle is not plugged in.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.13\n             */\n            nextChargeTargetTime: Attribute(0x24, TlvNullable(TlvEpochS), { default: null }),\n\n            /**\n             * Indicates the amount of energy that the EVSE is going to attempt to add to the vehicle in the next\n             * charging target.\n             *\n             * If this is null it indicates that there is no scheduled charging, or that the EVSE is using the\n             * TargetSoC method to charge the vehicle.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.14\n             */\n            nextChargeRequiredEnergy: Attribute(0x25, TlvNullable(TlvInt64.bound({ min: 0 })), { default: null }),\n\n            /**\n             * Indicates the target SoC the EVSE is going to attempt to reach when the vehicle is next charged.\n             *\n             * If this is null it indicates that there is no scheduled charging, or that the EVSE cannot obtain the\n             * current State of Charge from the vehicle.\n             *\n             * If the SOC feature is not supported, only the values null and 100% are supported.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.15\n             */\n            nextChargeTargetSoC: Attribute(0x26, TlvNullable(TlvPercent), { default: null }),\n\n            /**\n             * Indicates the vehicle efficiency rating for a connected vehicle.\n             *\n             * This can be used to help indicate to the user approximately how many miles or km of range will be added.\n             * It allows user interfaces to display to the user simpler terms that they can relate to compared to kWh.\n             *\n             * This is value is stored in km per kWh multiplied by a scaling factor of 1000.\n             *\n             * A null value indicates that the EV efficiency is unknown and the NextChargeRequiredEnergy attribute\n             * cannot be converted from Wh to miles or km.\n             *\n             * To convert from Wh into Range:\n             *\n             * AddedRange (km) = AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) AddedRange (Miles) = AddedEnergy\n             * (Wh) x ApproxEVEfficiency (km/kWh x 1000) x 0.6213\n             *\n             * Example:\n             *\n             * ApproxEVEfficiency (km/kWh x 1000): 4800 (i.e. 4.8km/kWh x 1000)\n             *\n             * AddedEnergy (Wh): 10,000\n             *\n             * AddedRange (km) = 10,000 x 4800 / 1,000,000 = 48 km\n             *\n             * AddedRange (Miles) = AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) x 0.6213\n             *\n             * = 29.82 Miles\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.16\n             */\n            approximateEvEfficiency: OptionalWritableAttribute(\n                0x27,\n                TlvNullable(TlvUInt16),\n                { persistent: true, default: null, writeAcl: AccessLevel.Manage }\n            )\n        },\n\n        commands: {\n            /**\n             * Allows a client to set the user specified charging targets.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.5\n             */\n            setTargets: Command(0x5, TlvSetTargetsRequest, 0x5, TlvNoResponse, { timed: true }),\n\n            /**\n             * Allows a client to retrieve the current set of charging targets.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.6\n             */\n            getTargets: Command(0x6, TlvNoArguments, 0x0, TlvGetTargetsResponse, { timed: true }),\n\n            /**\n             * Allows a client to clear all stored charging targets.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.8\n             */\n            clearTargets: Command(0x7, TlvNoArguments, 0x7, TlvNoResponse, { timed: true })\n        }\n    });\n\n    /**\n     * A EnergyEvseCluster supports these elements if it supports feature SoCReporting.\n     */\n    export const SoCReportingComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the state of charge of the EV battery in steps of 1%. The values are in the 0-100%. This\n             * attribute is only available on EVSEs which can read the state of charge from the vehicle and that\n             * support the SOC feature. If the StateOfCharge cannot be read from the vehicle it shall be returned with\n             * a NULL value.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.17\n             */\n            stateOfCharge: Attribute(0x30, TlvNullable(TlvPercent), { default: null }),\n\n            /**\n             * Indicates the capacity of the EV battery in mWh. This value is always positive.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.18\n             */\n            batteryCapacity: Attribute(0x31, TlvNullable(TlvInt64.bound({ min: 0 })), { default: null })\n        }\n    });\n\n    /**\n     * A EnergyEvseCluster supports these elements if it supports feature PlugAndCharge.\n     */\n    export const PlugAndChargeComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the vehicle ID read by the EVSE via ISO-15118 using the PNC feature, if the EVSE supports this\n             * capability.\n             *\n             * The field may be based on the e-Mobility Account Identifier (EMAID). A null value shall indicate that\n             * this is unknown.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.19\n             */\n            vehicleId: Attribute(0x32, TlvNullable(TlvString.bound({ maxLength: 32 })), { default: null })\n        }\n    });\n\n    /**\n     * A EnergyEvseCluster supports these elements if it supports feature Rfid.\n     */\n    export const RfidComponent = MutableCluster.Component({\n        events: {\n            /**\n             * This event shall be generated when a RFID card has been read. This allows a controller to register the\n             * card ID and use this to authenticate and start the charging session.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.6\n             */\n            rfid: OptionalEvent(0x5, EventPriority.Info, TlvRfidEvent)\n        }\n    });\n\n    /**\n     * These elements and properties are present in all EnergyEvse clusters.\n     */\n    export const Base = MutableCluster.Component({\n        id: 0x99,\n        name: \"EnergyEvse\",\n        revision: 2,\n\n        features: {\n            /**\n             * ChargingPreferences\n             *\n             * Since some EVSEs cannot obtain the SoC from the vehicle, some EV charging solutions allow the consumer\n             * to specify a daily charging target (for adding energy to the EV\u2019s battery). This feature allows the\n             * consumer to specify how many miles or km of additional range they need for their typical daily commute.\n             * This range requirement can be converted into a daily energy demand with a target charging completion\n             * time.\n             *\n             * The EVSE itself may use this information (or may allow a controller such as an EMS) to compute an\n             *\n             * optimized charging schedule.\n             *\n             * An EVSE device may implement the Device Energy Management cluster PFR (Power Forecast Reporting) and FA\n             * (Forecast Adjustment) features. This can help a controller (such as an EMS) to optimize the EVSE against\n             * other ESAs. For example, a solar PV ESA may share its Forecast and allow the EVSE to know the best time\n             * to charge so that any excess solar generation is used to charge the EV.\n             *\n             * EVSE devices that support the Device Energy Management cluster\u2019s FA feature can have their charging\n             * profiles set by a controller device such as an EMS. For example, if the EVSE advertises a simple power\n             * forecast which allows the EMS to adjust over a wide range of power and time durations, then the EVSE may\n             * allow the EMS to propose a revised optimized forecast (which is the charging profile).\n             *\n             * See the Device Energy Management Cluster for more details.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.1\n             */\n            chargingPreferences: BitFlag(0),\n\n            /**\n             * SoCReporting\n             *\n             * Vehicles and EVSEs which support ISO 15118 may allow the vehicle to report its battery size and state of\n             * charge. If the EVSE supports PLC it may have a vehicle connected which optionally supports reporting of\n             * its battery size and current State of Charge (SoC).\n             *\n             * If the EVSE supports reporting of State of Charge this feature will only work if a compatible EV is\n             * connected.\n             *\n             * Note some EVSEs may use other undefined mechanisms to obtain vehicle State of Charge outside the scope\n             * of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.2\n             */\n            soCReporting: BitFlag(1),\n\n            /**\n             * PlugAndCharge\n             *\n             * If the EVSE supports PLC, it may be able to support the Plug and Charge feature. e.g. this may allow the\n             * vehicle ID to be obtained which may allow an energy management system to track energy usage per vehicle\n             * (e.g. to give the owner an indicative cost of charging, or for work place charging).\n             *\n             * If the EVSE supports the Plug and Charge feature, it will only work if a compatible EV is connected.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.3\n             */\n            plugAndCharge: BitFlag(2),\n\n            /**\n             * Rfid\n             *\n             * If the EVSE is fitted with an RFID reader, it may be possible to obtain the User or Vehicle ID from an\n             * RFID card. This may be used to record a charging session against a specific charging account, and may\n             * optionally be used to authorize a charging session.\n             *\n             * An RFID event can be generated when a user taps an RFID card onto the RFID reader. The event must be\n             * subscribed to by the EVSE Management cluster client. This client may use this to enable the EV to charge\n             * or discharge. The lookup and authorization of RIFD UID is outside the scope of this cluster.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.4\n             */\n            rfid: BitFlag(3),\n\n            /**\n             * V2X\n             *\n             * If the EVSE can support bi-directional charging, it may be possible to request that the vehicle can\n             * discharge to the home or grid.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.4.5\n             */\n            v2X: BitFlag(4)\n        },\n\n        attributes: {\n            /**\n             * Indicates the current status of the EVSE. This higher-level status is partly derived from the signaling\n             * protocol as communicated between the EVSE and the vehicle through the pilot signal.\n             *\n             * The State attribute shall change when the EVSE detects change of condition of the EV (plugged in or\n             * unplugged, whether the vehicle is asking for demand or not, and if it is charging or discharging).\n             *\n             * NOTE\n             *\n             * SessionEnding is not really a state but a transition. However, the transition period\n             *\n             * may take a few seconds and is useful for some clean up purposes. The Fault state is used to indicate\n             * that the FaultState attribute is not NoError.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.1\n             */\n            state: Attribute(0x0, TlvNullable(TlvEnum<State>())),\n\n            /**\n             * Indicates whether the EV is currently allowed to charge from or discharge to the EVSE.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.2\n             */\n            supplyState: Attribute(0x1, TlvEnum<SupplyState>()),\n\n            /**\n             * Indicates the type of fault detected by the EVSE (internally or as detected in the pilot signal).\n             *\n             * When the SupplyState attribute is DisabledError, the FaultState attribute will be one of the values\n             * listed in FaultStateEnum, except NoError. For all values of SupplyState other than DisabledError, the\n             * FaultState attribute shall be NoError.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.3\n             */\n            faultState: Attribute(0x2, TlvEnum<FaultState>()),\n\n            /**\n             * Indicates the time, in UTC, that the EVSE will automatically stop current flow to the EV.\n             *\n             * A null value indicates the EVSE is always enabled for charging.\n             *\n             * A value in the past or 0x0 indicates that EVSE charging shall be disabled. The attribute is only set via\n             * the payload of the EnableCharging command.\n             *\n             * This attribute shall be persisted, for example a temporary power failure should not stop the vehicle\n             * from being charged.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.4\n             */\n            chargingEnabledUntil: Attribute(0x3, TlvNullable(TlvEpochS), { persistent: true, default: 0 }),\n\n            /**\n             * Indicates the capacity that the circuit that the EVSE is connected to can provide. It is intended to\n             * allow implementation of a self-managed network of EVSEs. It is assumed that the device will allow the\n             * setting of such values by an installer.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.6\n             */\n            circuitCapacity: Attribute(0x5, TlvInt64.bound({ min: 0 }), { persistent: true, default: 0 }),\n\n            /**\n             * Indicates the minimum current that can be delivered by the EVSE to the EV. The attribute can be set\n             * using the EnableCharging command.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.7\n             */\n            minimumChargeCurrent: Attribute(0x6, TlvInt64.bound({ min: 0 }), { persistent: true, default: 6000 }),\n\n            /**\n             * Indicates the maximum current that can be delivered by the EVSE to the EV.\n             *\n             * This shall represent the actual maximum current offered to the EV at any time. Note that the EV can draw\n             * less current than this value. For example, the EV may be limiting its power draw based on the operating\n             * conditions of the battery, such as temperature and state of charge.\n             *\n             * The attribute can be initially set using the EnableCharging command or by adjusting the\n             * UserMaximumChargeCurrent attribute.\n             *\n             * This attribute value shall be the minimum of:\n             *\n             *   \u2022 CircuitCapacity - Electrician\u2019s installation setting\n             *\n             *   \u2022 CableAssemblyCurrentLimit (detected by the EVSE when the cable is plugged in)\n             *\n             *   \u2022 MaximumChargeCurrent field in the EnableCharging command\n             *\n             *   \u2022 UserMaximumChargeCurrent attribute\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.8\n             */\n            maximumChargeCurrent: Attribute(0x7, TlvInt64.bound({ min: 0 }), { persistent: true, default: 0 }),\n\n            /**\n             * Indicates a maximum current that can set by the consumer (e.g. via an app) as a preference to further\n             * reduce the charging rate. This may be desirable if the home owner has a solar PV or battery storage\n             * system which may only be able to deliver a limited amount of power. The consumer can manually control\n             * how much they allow the EV to take.\n             *\n             * This attribute value shall be limited by the EVSE to be in the range of:\n             *\n             * MinimumChargeCurrent <= UserMaximumChargeCurrent <= MaximumChargeCurrent\n             *\n             * where MinimumChargeCurrent and MaximumChargeCurrent are the values received in the EnableCharging\n             * command.\n             *\n             * Its default value SHOULD be initialized to the same as the CircuitCapacity attribute. This value shall\n             * be persisted across reboots to ensure it does not cause charging issues during temporary power failures.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.10\n             */\n            userMaximumChargeCurrent: OptionalWritableAttribute(\n                0x9,\n                TlvInt64,\n                { persistent: true, default: 0, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * Indicates the size of a random window over which the EVSE will randomize the start of a charging\n             * session. This value is in seconds.\n             *\n             * This is a feature that is mandated in some markets (such as UK) where the EVSE should by default\n             * randomize its start time within the randomization window. By default in the UK this should be 600s.\n             *\n             * For example, if the RandomizationDelayWindow is 600s (i.e. 10 minutes) and if there was a cheap rate\n             * energy starting at 00:30, then the EVSE must compute a random delay between 0-599s and add this to its\n             * initial planned start time.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8.11\n             */\n            randomizationDelayWindow: OptionalWritableAttribute(\n                0xa,\n                TlvUInt32.bound({ min: 0, max: 86400 }),\n                { persistent: true, default: 600, writeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8\n             */\n            sessionId: Attribute(0x40, TlvNullable(TlvUInt32), { persistent: true, default: null }),\n\n            /**\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8\n             */\n            sessionDuration: Attribute(0x41, TlvNullable(TlvUInt32), { persistent: true, default: null }),\n\n            /**\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.8\n             */\n            sessionEnergyCharged: Attribute(\n                0x42,\n                TlvNullable(TlvInt64.bound({ min: 0 })),\n                { persistent: true, default: null }\n            )\n        },\n\n        commands: {\n            /**\n             * Allows a client to disable the EVSE from charging and discharging.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.1\n             */\n            disable: Command(0x1, TlvNoArguments, 0x1, TlvNoResponse, { timed: true }),\n\n            /**\n             * Allows a client to enable the EVSE to charge an EV.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.2\n             */\n            enableCharging: Command(0x2, TlvEnableChargingRequest, 0x2, TlvNoResponse, { timed: true }),\n\n            /**\n             * Allows a client to put the EVSE into a self-diagnostics mode.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.9.4\n             */\n            startDiagnostics: OptionalCommand(0x4, TlvNoArguments, 0x4, TlvNoResponse, { timed: true })\n        },\n\n        events: {\n            /**\n             * This event shall be generated when the EV is plugged in.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.1\n             */\n            evConnected: Event(0x0, EventPriority.Info, TlvEvConnectedEvent),\n\n            /**\n             * This event shall be generated when the EV is unplugged or not detected (having been previously plugged\n             * in). When the vehicle is unplugged then the session is ended.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.2\n             */\n            evNotDetected: Event(0x1, EventPriority.Info, TlvEvNotDetectedEvent),\n\n            /**\n             * This event shall be generated when the EV starts charging or discharging.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.3\n             */\n            energyTransferStarted: Event(0x2, EventPriority.Info, TlvEnergyTransferStartedEvent),\n\n            /**\n             * This event shall be generated when the EV stops charging or discharging.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.4\n             */\n            energyTransferStopped: Event(0x3, EventPriority.Info, TlvEnergyTransferStoppedEvent),\n\n            /**\n             * If the EVSE detects a fault it shall generate a Fault Event. The SupplyState attribute shall be set to\n             * DisabledError and the type of fault detected by the EVSE shall be stored in the FaultState attribute.\n             *\n             * This event shall be generated when the FaultState changes from any error state. i.e. if it changes from\n             * NoError to any other state and if the error then clears, this would generate 2 events.\n             *\n             * It is assumed that the fault will be cleared locally on the EVSE device. When all faults have been\n             * cleared, the EVSE device shall set the FaultState attribute to NoError and the SupplyState attribute\n             * shall be set back to its previous state.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3.10.5\n             */\n            fault: Event(0x4, EventPriority.Critical, TlvFaultEvent)\n        },\n\n        /**\n         * This metadata controls which EnergyEvseCluster elements matter.js activates for specific feature\n         * combinations.\n         */\n        extensions: MutableCluster.Extensions(\n            { flags: { v2X: true }, component: V2XComponent },\n            { flags: { chargingPreferences: true }, component: ChargingPreferencesComponent },\n            { flags: { soCReporting: true }, component: SoCReportingComponent },\n            { flags: { plugAndCharge: true }, component: PlugAndChargeComponent },\n            { flags: { rfid: true }, component: RfidComponent }\n        )\n    });\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster(Base);\n\n    /**\n     * Electric Vehicle Supply Equipment (EVSE) is equipment used to charge an Electric Vehicle (EV) or Plug-In Hybrid\n     * Electric Vehicle. This cluster provides an interface to the functionality of Electric Vehicle Supply Equipment\n     * (EVSE) management.\n     *\n     * Devices targeted by this cluster include Electric Vehicle Supply Equipment (EVSE). The cluster generically\n     * assumes a signaling protocol (J1772 in NA and IEC61851 in Europe and Asia) between the EVSE and Electric Vehicle\n     * (EV) that utilizes a pilot signal to manage the states of the charging process. [SAE J2847/3_202311] version and\n     * IEC61841 define Pilot signal as a modulated DC voltage on a single wire.\n     *\n     * Power Line Communication (PLC) is supported by some EVSEs (e.g. for support of ISO 15118 in Europe and SAE\n     * J2931/4 in NA) and may enable features such as Vehicle to Grid (V2G) or Vehicle to Home (V2H) that allows for\n     * bi-directional charging/discharging of electric vehicles.\n     *\n     * More modern EVSE devices may optionally support ISO 15118-20 in Europe and SAE J2836/3 for NA to support\n     * bi-directional charging (Vehicle to Grid - V2G) and Plug and Charge capabilities.\n     *\n     * This cluster definition assumes AC charging only. DC charging options may be added in future revisions of this\n     * cluster.\n     *\n     * This cluster supports a safety mechanism that may lockout remote operation until the initial latching conditions\n     * have been met. Some of the fault conditions defined in SAE J1772, such as Ground- Fault Circuit Interrupter\n     * (GFCI) or Charging Circuit Interrupting Device (CCID), may require clearing by an operator by, for example,\n     * pressing a button on the equipment or breaker panel.\n     *\n     * This EVSE cluster is written around support of a single EVSE. Having multiple EVSEs at home or a business is\n     * managed by backend system and outside scope of this cluster.\n     *\n     * Note that in many deployments the EVSE may be outside the home and may suffer from intermittent network\n     * connections (e.g. a weak WiFi signal). It also allows for a charging profile to be pre- configured, in case\n     * there is a temporary communications loss during a charging session.\n     *\n     * EnergyEvseCluster supports optional features that you can enable with the EnergyEvseCluster.with() factory\n     * method.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 9.3\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    const V2X = { v2X: true };\n    const PREF = { chargingPreferences: true };\n    const SOC = { soCReporting: true };\n    const PNC = { plugAndCharge: true };\n    const RFID = { rfid: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster({\n        id: Cluster.id,\n        name: Cluster.name,\n        revision: Cluster.revision,\n        features: Cluster.features,\n\n        attributes: {\n            ...Cluster.attributes,\n            dischargingEnabledUntil: MutableCluster.AsConditional(\n                V2XComponent.attributes.dischargingEnabledUntil,\n                { mandatoryIf: [V2X] }\n            ),\n            maximumDischargeCurrent: MutableCluster.AsConditional(\n                V2XComponent.attributes.maximumDischargeCurrent,\n                { mandatoryIf: [V2X] }\n            ),\n            nextChargeStartTime: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.attributes.nextChargeStartTime,\n                { mandatoryIf: [PREF] }\n            ),\n            nextChargeTargetTime: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.attributes.nextChargeTargetTime,\n                { mandatoryIf: [PREF] }\n            ),\n            nextChargeRequiredEnergy: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.attributes.nextChargeRequiredEnergy,\n                { mandatoryIf: [PREF] }\n            ),\n            nextChargeTargetSoC: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.attributes.nextChargeTargetSoC,\n                { mandatoryIf: [PREF] }\n            ),\n            approximateEvEfficiency: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.attributes.approximateEvEfficiency,\n                { optionalIf: [PREF] }\n            ),\n            stateOfCharge: MutableCluster.AsConditional(\n                SoCReportingComponent.attributes.stateOfCharge,\n                { mandatoryIf: [SOC] }\n            ),\n            batteryCapacity: MutableCluster.AsConditional(\n                SoCReportingComponent.attributes.batteryCapacity,\n                { mandatoryIf: [SOC] }\n            ),\n            vehicleId: MutableCluster.AsConditional(\n                PlugAndChargeComponent.attributes.vehicleId,\n                { mandatoryIf: [PNC] }\n            ),\n            sessionEnergyDischarged: MutableCluster.AsConditional(\n                V2XComponent.attributes.sessionEnergyDischarged,\n                { mandatoryIf: [V2X] }\n            )\n        },\n\n        commands: {\n            ...Cluster.commands,\n            enableDischarging: MutableCluster.AsConditional(\n                V2XComponent.commands.enableDischarging,\n                { mandatoryIf: [V2X] }\n            ),\n            setTargets: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.commands.setTargets,\n                { mandatoryIf: [PREF] }\n            ),\n            getTargets: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.commands.getTargets,\n                { mandatoryIf: [PREF] }\n            ),\n            clearTargets: MutableCluster.AsConditional(\n                ChargingPreferencesComponent.commands.clearTargets,\n                { mandatoryIf: [PREF] }\n            )\n        },\n\n        events: {\n            ...Cluster.events,\n            rfid: MutableCluster.AsConditional(RfidComponent.events.rfid, { optionalIf: [RFID] })\n        }\n    });\n\n    /**\n     * This cluster supports all EnergyEvse features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n\nexport type EnergyEvseCluster = EnergyEvse.Cluster;\nexport const EnergyEvseCluster = EnergyEvse.Cluster;\nClusterRegistry.register(EnergyEvse.Complete);\n"],
  "mappings": "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",
  "names": ["EnergyEvse", "Feature", "State", "SupplyState", "FaultState", "EnergyTransferStoppedReason"]
}
