{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/ContentControlCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport { Attribute, Command, TlvNoResponse, AccessLevel, Event, EventPriority } from \"../Cluster.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvField, TlvOptionalField, TlvObject } from \"../../tlv/TlvObject.js\";\nimport { TlvString } from \"../../tlv/TlvString.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvUInt32, TlvUInt16, TlvEnum, TlvUInt8 } from \"../../tlv/TlvNumber.js\";\nimport { TlvNoArguments } from \"../../tlv/TlvNoArguments.js\";\nimport { TlvBoolean } from \"../../tlv/TlvBoolean.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { BitFlag } from \"../../schema/BitmapSchema.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace ContentControl {\n    /**\n     * These are optional features supported by ContentControlCluster.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.4\n     */\n    export enum Feature {\n        /**\n         * ScreenTime (ST)\n         *\n         * Supports managing screen time limits.\n         */\n        ScreenTime = \"ScreenTime\",\n\n        /**\n         * PinManagement (PM)\n         *\n         * Supports managing a PIN code which is used for restricting access to configuration of this feature.\n         */\n        PinManagement = \"PinManagement\",\n\n        /**\n         * BlockUnrated (BU)\n         *\n         * Supports managing content controls for unrated content.\n         */\n        BlockUnrated = \"BlockUnrated\",\n\n        /**\n         * OnDemandContentRating (OCR)\n         *\n         * Supports managing content controls based upon rating threshold for on demand content.\n         */\n        OnDemandContentRating = \"OnDemandContentRating\",\n\n        /**\n         * ScheduledContentRating (SCR)\n         *\n         * Supports managing content controls based upon rating threshold for scheduled content.\n         */\n        ScheduledContentRating = \"ScheduledContentRating\",\n\n        /**\n         * BlockChannels (BC)\n         *\n         * Supports managing a set of channels that are prohibited.\n         */\n        BlockChannels = \"BlockChannels\",\n\n        /**\n         * BlockApplications (BA)\n         *\n         * Supports managing a set of applications that are prohibited.\n         */\n        BlockApplications = \"BlockApplications\",\n\n        /**\n         * BlockContentTimeWindow (BTW)\n         *\n         * Supports managing content controls based upon setting time window in which all contents and applications\n         * SHALL be blocked.\n         */\n        BlockContentTimeWindow = \"BlockContentTimeWindow\"\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.1\n     */\n    export const TlvRatingName = TlvObject({\n        /**\n         * This field shall indicate the name of the rating level of the applied rating system. The applied rating\n         * system is dependent upon the region or country where the Node has been provisioned, and may vary from one\n         * country to another.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.1.1\n         */\n        ratingName: TlvField(0, TlvString.bound({ maxLength: 8 })),\n\n        /**\n         * This field shall specify a human readable (displayable) description for RatingName.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.1.2\n         */\n        ratingNameDesc: TlvOptionalField(1, TlvString.bound({ maxLength: 64 }))\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.1\n     */\n    export interface RatingName extends TypeFromSchema<typeof TlvRatingName> {}\n\n    /**\n     * Input to the ContentControl setOnDemandRatingThreshold command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.10\n     */\n    export const TlvSetOnDemandRatingThresholdRequest = TlvObject({\n        /**\n         * This field indicates a threshold rating for filtering on-demand content. This field shall be set to one of\n         * the values present in the OnDemandRatings attribute\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.10.1\n         */\n        rating: TlvField(0, TlvString.bound({ maxLength: 8 }))\n    });\n\n    /**\n     * Input to the ContentControl setOnDemandRatingThreshold command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.10\n     */\n    export interface SetOnDemandRatingThresholdRequest extends TypeFromSchema<typeof TlvSetOnDemandRatingThresholdRequest> {}\n\n    /**\n     * Input to the ContentControl setScheduledContentRatingThreshold command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.11\n     */\n    export const TlvSetScheduledContentRatingThresholdRequest = TlvObject({\n        /**\n         * This field indicates a threshold rating for filtering scheduled content. This field shall be set to one\n         *\n         * of the values present in the ScheduledContentRatings attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.11.1\n         */\n        rating: TlvField(0, TlvString.bound({ maxLength: 8 }))\n    });\n\n    /**\n     * Input to the ContentControl setScheduledContentRatingThreshold command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.11\n     */\n    export interface SetScheduledContentRatingThresholdRequest extends TypeFromSchema<typeof TlvSetScheduledContentRatingThresholdRequest> {}\n\n    /**\n     * Input to the ContentControl addBonusTime command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.6\n     */\n    export const TlvAddBonusTimeRequest = TlvObject({\n        /**\n         * This field shall indicate the PIN.\n         *\n         * This field shall be optional for clients with Manage or greater privilege but shall be mandatory for clients\n         * with Operate privilege. The PIN provided in this field shall be used to guarantee that a client with Operate\n         * permission is allowed to invoke this command only if the PIN passed in this command is equal to the current\n         * PIN value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.6.1\n         */\n        pinCode: TlvOptionalField(0, TlvString.bound({ maxLength: 6 })),\n\n        /**\n         * This field shall indicate the amount of extra time (in seconds) to increase RemainingScreenTime. This field\n         * shall not exceed the remaining time of this day.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.6.2\n         */\n        bonusTime: TlvField(1, TlvUInt32)\n    });\n\n    /**\n     * Input to the ContentControl addBonusTime command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.6\n     */\n    export interface AddBonusTimeRequest extends TypeFromSchema<typeof TlvAddBonusTimeRequest> {}\n\n    /**\n     * Input to the ContentControl setScreenDailyTime command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.7\n     */\n    export const TlvSetScreenDailyTimeRequest = TlvObject({\n        /**\n         * This field shall indicate the time (in seconds) which the User is allowed to spend watching TV on\n         *\n         * this media device within one day.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.7.1\n         */\n        screenTime: TlvField(0, TlvUInt32.bound({ max: 86400 }))\n    });\n\n    /**\n     * Input to the ContentControl setScreenDailyTime command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.7\n     */\n    export interface SetScreenDailyTimeRequest extends TypeFromSchema<typeof TlvSetScreenDailyTimeRequest> {}\n\n    /**\n     * [options=\"header\",valign=\"middle\"]b\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.2\n     */\n    export const TlvBlockChannel = TlvObject({\n        /**\n         * This field shall indicate a unique index value for a blocked channel. This value may be used to indicate one\n         * selected channel which will be removed from BlockChannelList attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.2.1\n         */\n        blockChannelIndex: TlvField(0, TlvNullable(TlvUInt16)),\n\n        /**\n         * This field shall indicate the channel major number value (for example, using ATSC format). When the channel\n         * number is expressed as a string, such as \"13.1\" or \"256\", the major number would be 13 or 256, respectively.\n         * This field is required but shall be set to 0 for channels such as over-the-top channels that are not\n         * represented by a major or minor number.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.2.2\n         */\n        majorNumber: TlvField(1, TlvUInt16),\n\n        /**\n         * This field shall indicate the channel minor number value (for example, using ATSC format). When the channel\n         * number is expressed as a string, such as \"13.1\" or \"256\", the minor number would be 1 or 0, respectively.\n         * This field is required but shall be set to 0 for channels such as over-the-top channels that are not\n         * represented by a major or minor number.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.2.3\n         */\n        minorNumber: TlvField(2, TlvUInt16),\n\n        /**\n         * This field shall indicate the unique identifier for a specific channel. This field is optional, but SHOULD\n         * be provided when MajorNumber and MinorNumber are not available.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.2.4\n         */\n        identifier: TlvOptionalField(3, TlvString)\n    });\n\n    /**\n     * [options=\"header\",valign=\"middle\"]b\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.2\n     */\n    export interface BlockChannel extends TypeFromSchema<typeof TlvBlockChannel> {}\n\n    /**\n     * Input to the ContentControl addBlockChannels command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.12\n     */\n    export const TlvAddBlockChannelsRequest = TlvObject({\n        /**\n         * This field indicates a set of channels that shall be blocked when the Content Control feature is activated.\n         * This field shall be set to values present in ChannelList attribute in the Channel cluster. The\n         * BlockChannelIndex field passed in this command shall be NULL.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.12.1\n         */\n        channels: TlvField(0, TlvArray(TlvBlockChannel))\n    });\n\n    /**\n     * Input to the ContentControl addBlockChannels command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.12\n     */\n    export interface AddBlockChannelsRequest extends TypeFromSchema<typeof TlvAddBlockChannelsRequest> {}\n\n    /**\n     * Input to the ContentControl removeBlockChannels command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.13\n     */\n    export const TlvRemoveBlockChannelsRequest = TlvObject({\n        /**\n         * This field shall specify a set of indexes indicating Which channels shall be removed from the\n         * BlockChannelList attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.13.1\n         */\n        channelIndexes: TlvField(0, TlvArray(TlvUInt16))\n    });\n\n    /**\n     * Input to the ContentControl removeBlockChannels command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.13\n     */\n    export interface RemoveBlockChannelsRequest extends TypeFromSchema<typeof TlvRemoveBlockChannelsRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.3\n     */\n    export const TlvAppInfo = TlvObject({\n        /**\n         * This field shall indicate the CSA-issued vendor ID for the catalog. The DIAL registry shall use value 0x0000.\n         *\n         * Content App Platform providers will have their own catalog vendor ID (set to their own Vendor ID) and will\n         * assign an ApplicationID to each Content App.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.3.1\n         */\n        catalogVendorId: TlvField(0, TlvUInt16),\n\n        /**\n         * This field shall indicate the application identifier, expressed as a string, such as \"PruneVideo\" or\n         * \"Company X\". This field shall be unique within a catalog.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.3.2\n         */\n        applicationId: TlvField(1, TlvString)\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.3\n     */\n    export interface AppInfo extends TypeFromSchema<typeof TlvAppInfo> {}\n\n    /**\n     * Input to the ContentControl addBlockApplications command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.14\n     */\n    export const TlvAddBlockApplicationsRequest = TlvObject({\n        /**\n         * This field indicates a set of applications that shall be blocked when the Content Control feature is\n         * activated.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.14.1\n         */\n        applications: TlvField(0, TlvArray(TlvAppInfo))\n    });\n\n    /**\n     * Input to the ContentControl addBlockApplications command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.14\n     */\n    export interface AddBlockApplicationsRequest extends TypeFromSchema<typeof TlvAddBlockApplicationsRequest> {}\n\n    /**\n     * Input to the ContentControl removeBlockApplications command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.15\n     */\n    export const TlvRemoveBlockApplicationsRequest = TlvObject({\n        /**\n         * This field indicates a set of applications which shall be removed from BlockApplicationList attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.15.1\n         */\n        applications: TlvField(0, TlvArray(TlvAppInfo))\n    });\n\n    /**\n     * Input to the ContentControl removeBlockApplications command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.15\n     */\n    export interface RemoveBlockApplicationsRequest extends TypeFromSchema<typeof TlvRemoveBlockApplicationsRequest> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.5\n     */\n    export enum DayOfWeek {\n        /**\n         * Sunday\n         */\n        Sunday = 0,\n\n        /**\n         * Monday\n         */\n        Monday = 1,\n\n        /**\n         * Tuesday\n         */\n        Tuesday = 2,\n\n        /**\n         * Wednesday\n         */\n        Wednesday = 3,\n\n        /**\n         * Thursday\n         */\n        Thursday = 4,\n\n        /**\n         * Friday\n         */\n        Friday = 5,\n\n        /**\n         * Saturday\n         */\n        Saturday = 6\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.6\n     */\n    export const TlvTimePeriod = TlvObject({\n        /**\n         * This field shall indicate the starting hour.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.6.1\n         */\n        startHour: TlvField(0, TlvUInt8.bound({ max: 23 })),\n\n        /**\n         * This field shall indicate the starting minute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.6.2\n         */\n        startMinute: TlvField(1, TlvUInt8.bound({ max: 59 })),\n\n        /**\n         * This field shall indicate the ending hour. EndHour shall be equal to or greater than StartHour\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.6.3\n         */\n        endHour: TlvField(2, TlvUInt8.bound({ max: 23 })),\n\n        /**\n         * This field shall indicate the ending minute. If EndHour is equal to StartHour then EndMinute shall be\n         * greater than StartMinute. If the EndHour is equal to 23 and the EndMinute is equal to 59, all contents shall\n         * be blocked until 23:59:59.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.6.4\n         */\n        endMinute: TlvField(3, TlvUInt8.bound({ max: 59 }))\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.6\n     */\n    export interface TimePeriod extends TypeFromSchema<typeof TlvTimePeriod> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.4\n     */\n    export const TlvTimeWindow = TlvObject({\n        /**\n         * This field shall indicate a unique index of a specific time window. This value may be used to indicate a\n         * selected time window which will be removed from the BlockContentTimeWindow attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.4.1\n         */\n        timeWindowIndex: TlvField(0, TlvNullable(TlvUInt16)),\n\n        /**\n         * This field shall indicate a day of week.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.4.2\n         */\n        dayOfWeek: TlvField(1, TlvEnum<DayOfWeek>()),\n\n        /**\n         * This field shall indicate one or more discrete time periods.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.4.3\n         */\n        timePeriod: TlvField(2, TlvArray(TlvTimePeriod))\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.5.4\n     */\n    export interface TimeWindow extends TypeFromSchema<typeof TlvTimeWindow> {}\n\n    /**\n     * Input to the ContentControl setBlockContentTimeWindow command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.16\n     */\n    export const TlvSetBlockContentTimeWindowRequest = TlvObject({\n        /**\n         * This field shall indicate a time window requested to set to the BlockContentTimeWindow attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.16.1\n         */\n        timeWindow: TlvField(0, TlvTimeWindow)\n    });\n\n    /**\n     * Input to the ContentControl setBlockContentTimeWindow command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.16\n     */\n    export interface SetBlockContentTimeWindowRequest extends TypeFromSchema<typeof TlvSetBlockContentTimeWindowRequest> {}\n\n    /**\n     * Input to the ContentControl removeBlockContentTimeWindow command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.17\n     */\n    export const TlvRemoveBlockContentTimeWindowRequest = TlvObject({\n        /**\n         * This field shall specify a set of time window indexes indicating which time windows will be removed from the\n         * BlockContentTimeWindow attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.17.1\n         */\n        timeWindowIndexes: TlvField(0, TlvArray(TlvUInt16))\n    });\n\n    /**\n     * Input to the ContentControl removeBlockContentTimeWindow command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.17\n     */\n    export interface RemoveBlockContentTimeWindowRequest extends TypeFromSchema<typeof TlvRemoveBlockContentTimeWindowRequest> {}\n\n    /**\n     * Input to the ContentControl updatePin command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.1\n     */\n    export const TlvUpdatePinRequest = TlvObject({\n        /**\n         * This field shall specify the original PIN. Once the UpdatePIN command is performed successfully, it shall be\n         * invalid.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.1.1\n         */\n        oldPin: TlvField(0, TlvString.bound({ maxLength: 6 })),\n\n        /**\n         * This field shall indicate a new PIN for the Content Control feature.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.1.2\n         */\n        newPin: TlvField(1, TlvString.bound({ maxLength: 6 }))\n    });\n\n    /**\n     * Input to the ContentControl updatePin command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.1\n     */\n    export interface UpdatePinRequest extends TypeFromSchema<typeof TlvUpdatePinRequest> {}\n\n    /**\n     * This command shall be generated in response to a ResetPIN command.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.3\n     */\n    export const TlvResetPinResponse = TlvObject({\n        /**\n         * This field shall indicate a new PIN of the Content Control feature.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.3.1\n         */\n        pinCode: TlvField(0, TlvString.bound({ maxLength: 6 }))\n    });\n\n    /**\n     * This command shall be generated in response to a ResetPIN command.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.3\n     */\n    export interface ResetPinResponse extends TypeFromSchema<typeof TlvResetPinResponse> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.6.1\n     */\n    export enum StatusCode {\n        /**\n         * Provided PIN Code does not match the current PIN code.\n         */\n        InvalidPinCode = 2,\n\n        /**\n         * Provided Rating is out of scope of the corresponding Rating list.\n         */\n        InvalidRating = 3,\n\n        /**\n         * Provided Channel(s) is invalid.\n         */\n        InvalidChannel = 4,\n\n        /**\n         * Provided Channel(s) already exists.\n         */\n        ChannelAlreadyExist = 5,\n\n        /**\n         * Provided Channel(s) doesn\u2019t exist in BlockChannelList attribute.\n         */\n        ChannelNotExist = 6,\n\n        /**\n         * Provided Application(s) is not identified.\n         */\n        UnidentifiableApplication = 7,\n\n        /**\n         * Provided Application(s) already exists.\n         */\n        ApplicationAlreadyExist = 8,\n\n        /**\n         * Provided Application(s) doesn\u2019t exist in BlockApplicationList attribute.\n         */\n        ApplicationNotExist = 9,\n\n        /**\n         * Provided time Window already exists in BlockContentTimeWindow attribute.\n         */\n        TimeWindowAlreadyExist = 10,\n\n        /**\n         * Provided time window doesn\u2019t exist in BlockContentTimeWindow attribute.\n         */\n        TimeWindowNotExist = 11\n    }\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature OnDemandContentRating.\n     */\n    export const OnDemandContentRatingComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * This attribute shall provide the collection of ratings that are currently valid for this media device.\n             * The items should honor the metadata of the on-demand content (e.g. Movie) rating system for one country\n             * or region where the media device has been provisioned. For example, for the MPAA system, RatingName may\n             * be one value out of \"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\".\n             *\n             * The media device shall have a way to determine which rating system applies for the on-demand content and\n             * then populate this attribute. For example, it can do it through examining the Location attribute in the\n             * Basic Information cluster, and then determining which rating system applies.\n             *\n             * The ratings in this collection shall be in order from a rating for the youngest viewers to the one for\n             * the oldest viewers. Each rating in the list shall be unique.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.2\n             */\n            onDemandRatings: Attribute(0x1, TlvArray(TlvRatingName), { default: [] }),\n\n            /**\n             * Indicates a threshold rating as a content filter which is compared with the rating for on-demand\n             * content. For example, if the on-demand content rating is greater than or equal to\n             * OnDemandRatingThreshold, for a rating system that is ordered from lower viewer age to higher viewer age,\n             * then on-demand content is not appropriate for the User and the Node shall prevent the playback of\n             * content.\n             *\n             * This attribute shall be set to one of the values present in the OnDemandRatings attribute.\n             *\n             * When this attribute changes, the device SHOULD make the user aware of any limits of this feature. For\n             * example, if the feature does not control content within apps, then the device should make this clear to\n             * the user when the attribute changes.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.3\n             */\n            onDemandRatingThreshold: Attribute(0x2, TlvString.bound({ maxLength: 8 }))\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to set the OnDemandRatingThreshold attribute.\n             *\n             * Upon receipt of the SetOnDemandRatingThreshold command, the media device shall check if the Rating field\n             * is one of values present in the OnDemandRatings attribute. If not, then a response with InvalidRating\n             * error status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.10\n             */\n            setOnDemandRatingThreshold: Command(\n                0x9,\n                TlvSetOnDemandRatingThresholdRequest,\n                0x9,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature ScheduledContentRating.\n     */\n    export const ScheduledContentRatingComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates a collection of ratings which ScheduledContentRatingThreshold can be set to. The items should\n             * honor metadata of the scheduled content rating system for the country or region where the media device\n             * has been provisioned.\n             *\n             * The media device shall have a way to determine which scheduled content rating system applies and then\n             * populate this attribute. For example, this can be done by examining the Location attribute in Basic\n             * Information cluster, and then determining which rating system applies.\n             *\n             * The ratings in this collection shall be in order from a rating for the youngest viewers to the one for\n             * the oldest viewers. Each rating in the list shall be unique.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.4\n             */\n            scheduledContentRatings: Attribute(0x3, TlvArray(TlvRatingName), { default: [] }),\n\n            /**\n             * Indicates a threshold rating as a content filter which is used to compare with the rating for scheduled\n             * content. For example, if the scheduled content rating is greater than or equal to\n             * ScheduledContentRatingThreshold for a rating system that is ordered from lower viewer age to higher\n             * viewer age, then the scheduled content is not appropriate for the User and shall be blocked.\n             *\n             * This attribute shall be set to one of the values present in the ScheduledContentRatings attribute.\n             *\n             * When this attribute changes, the device SHOULD make the user aware of any limits of this feature. For\n             * example, if the feature does not control content within apps, then the device should make this clear to\n             * the user when the attribute changes.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.5\n             */\n            scheduledContentRatingThreshold: Attribute(0x4, TlvString.bound({ maxLength: 8 }))\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to set ScheduledContentRatingThreshold attribute.\n             *\n             * Upon receipt of the SetScheduledContentRatingThreshold command, the media device shall check if the\n             * Rating field is one of values present in the ScheduledContentRatings attribute. If not, then a response\n             * with InvalidRating error status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.11\n             */\n            setScheduledContentRatingThreshold: Command(\n                0xa,\n                TlvSetScheduledContentRatingThresholdRequest,\n                0xa,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature ScreenTime.\n     */\n    export const ScreenTimeComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates the amount of time (in seconds) which the User is allowed to spend watching TV within one day\n             * when the Content Control feature is activated.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.6\n             */\n            screenDailyTime: Attribute(0x5, TlvUInt32.bound({ max: 86400 })),\n\n            /**\n             * Indicates the remaining screen time (in seconds) which the User is allowed to spend watching TV for the\n             * current day when the Content Control feature is activated. When this value equals 0, the media device\n             * shall terminate the playback of content.\n             *\n             * This attribute shall be updated when the AddBonusTime command is received and processed successfully\n             * (with the correct PIN).\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.7\n             */\n            remainingScreenTime: Attribute(0x6, TlvUInt32.bound({ max: 86400 }))\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to add the extra screen time for the user.\n             *\n             * If a client with Operate privilege invokes this command, the media device shall check whether\n             *\n             * the PINCode passed in the command matches the current PINCode value. If these match, then the\n             * RemainingScreenTime attribute shall be increased by the specified BonusTime value.\n             *\n             * If the PINs do not match, then a response with InvalidPINCode error status shall be returned, and no\n             * changes shall be made to RemainingScreenTime.\n             *\n             * If a client with Manage privilege or greater invokes this command, the media device shall ignore the\n             * PINCode field and directly increase the RemainingScreenTime attribute by the specified BonusTime value.\n             *\n             * A server that does not support the PM feature shall respond with InvalidPINCode to clients that only\n             * have Operate privilege unless:\n             *\n             *   \u2022 It has been provided with the PIN value to expect via an out of band mechanism, and\n             *\n             *   \u2022 The client has provided a PINCode that matches the expected PIN value.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.6\n             */\n            addBonusTime: Command(0x5, TlvAddBonusTimeRequest, 0x5, TlvNoResponse),\n\n            /**\n             * The purpose of this command is to set the ScreenDailyTime attribute.\n             *\n             * Upon receipt of the SetScreenDailyTime command, the media device shall set the ScreenDailyTime attribute\n             * to the ScreenTime value.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.7\n             */\n            setScreenDailyTime: Command(\n                0x6,\n                TlvSetScreenDailyTimeRequest,\n                0x6,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        },\n\n        events: {\n            /**\n             * This event shall be generated when the RemainingScreenTime equals 0.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.9.1\n             */\n            remainingScreenTimeExpired: Event(0x0, EventPriority.Info, TlvNoArguments)\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature BlockUnrated.\n     */\n    export const BlockUnratedComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates whether the playback of unrated content is allowed when the Content Control feature is\n             * activated. If this attribute equals FALSE, then playback of unrated content\n             *\n             * shall be permitted. Otherwise, the media device shall prevent the playback of unrated content.\n             *\n             * When this attribute changes, the device SHOULD make the user aware of any limits of this feature. For\n             * example, if the feature does not control content within apps, then the device should make this clear to\n             * the user when the attribute changes.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.8\n             */\n            blockUnrated: Attribute(0x7, TlvBoolean)\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to specify whether programs with no Content rating must be blocked by\n             * this media device.\n             *\n             * Upon receipt of the BlockUnratedContent command, the media device shall set the BlockUnrated attribute\n             * to TRUE.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.8\n             */\n            blockUnratedContent: Command(0x7, TlvNoArguments, 0x7, TlvNoResponse, { invokeAcl: AccessLevel.Manage }),\n\n            /**\n             * The purpose of this command is to specify whether programs with no Content rating must be blocked by\n             * this media device.\n             *\n             * Upon receipt of the UnblockUnratedContent command, the media device shall set the BlockUnrated attribute\n             * to FALSE.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.9\n             */\n            unblockUnratedContent: Command(0x8, TlvNoArguments, 0x8, TlvNoResponse, { invokeAcl: AccessLevel.Manage })\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature BlockChannels.\n     */\n    export const BlockChannelsComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates a set of channels that shall be blocked when the Content Control feature is activated.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.9\n             */\n            blockChannelList: Attribute(0x8, TlvArray(TlvBlockChannel), { default: [] })\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to set BlockChannelList attribute.\n             *\n             * Upon receipt of the AddBlockChannels command, the media device shall check if the channels passed in\n             * this command are valid. If the channel is invalid, then a response with InvalidChannel error Status\n             * shall be returned.\n             *\n             * If there is at least one channel in Channels field which is not in the BlockChannelList attribute, the\n             * media device shall process the request by adding these new channels into the BlockChannelList attribute\n             * and return a successful Status Response. During this process, the media device shall assign one unique\n             * index to BlockChannelIndex field for every channel passed in this command.\n             *\n             * If all channels in Channel field already exist in the BlockChannelList attribute, then a response with\n             * ChannelAlreadyExist error Status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.12\n             */\n            addBlockChannels: Command(\n                0xb,\n                TlvAddBlockChannelsRequest,\n                0xb,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * The purpose of this command is to remove channels from the BlockChannelList attribute.\n             *\n             * Upon receipt of the RemoveBlockChannels command, the media device shall check if the channels indicated\n             * by ChannelIndexes passed in this command are present in BlockChannelList attribute. If one or more\n             * channels indicated by ChannelIndexes passed in this command field are not present in the\n             * BlockChannelList attribute, then a response with ChannelNotExist error Status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.13\n             */\n            removeBlockChannels: Command(\n                0xc,\n                TlvRemoveBlockChannelsRequest,\n                0xc,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature BlockApplications.\n     */\n    export const BlockApplicationsComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates a set of applications that shall be blocked when the Content Control feature is activated.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.10\n             */\n            blockApplicationList: Attribute(0x9, TlvArray(TlvAppInfo), { default: [] })\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to set applications to the BlockApplicationList attribute.\n             *\n             * Upon receipt of the AddBlockApplications command, the media device shall check if the Applications\n             * passed in this command are installed. If there is an application in Applications field which is not\n             * identified by media device, then a response with UnidentifiableApplication error Status may be returned.\n             *\n             * If there is one or more applications which are not present in BlockApplicationList attribute, the media\n             * device shall process the request by adding the new application to the BlockApplicationList attribute and\n             * return a successful Status Response.\n             *\n             * If all applications in Applications field are already present in BlockApplicationList attribute, then a\n             * response with ApplicationAlreadyExist error Status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.14\n             */\n            addBlockApplications: Command(\n                0xd,\n                TlvAddBlockApplicationsRequest,\n                0xd,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * The purpose of this command is to remove applications from the BlockApplicationList attribute.\n             *\n             * Upon receipt of the RemoveBlockApplications command, the media device shall check if the applications\n             * passed in this command present in the BlockApplicationList attribute. If one or more applications in\n             * Applications field which are not present in the BlockApplicationList attribute, then a response with\n             * ApplicationNotExist error Status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.15\n             */\n            removeBlockApplications: Command(\n                0xe,\n                TlvRemoveBlockApplicationsRequest,\n                0xe,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature BlockContentTimeWindow.\n     */\n    export const BlockContentTimeWindowComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates a set of periods during which the playback of content on media device shall be blocked when\n             * the Content Control feature is activated. The media device shall reject any request to play content\n             * during one period of this attribute. If it is entering any one period of this attribute, the media\n             * device shall block content which is playing and generate an event EnteringBlockContentTimeWindow. There\n             * shall not be multiple entries in this attribute list for the same day of week.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.11\n             */\n            blockContentTimeWindow: Attribute(0xa, TlvArray(TlvTimeWindow, { maxLength: 7 }), { default: [] })\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to set the BlockContentTimeWindow attribute.\n             *\n             * Upon receipt of the SetBlockContentTimeWindow command, the media device shall check if the\n             *\n             * TimeWindowIndex field passed in this command is NULL. If the TimeWindowIndex field is NULL, the media\n             * device shall check if there is an entry in the BlockContentTimeWindow attribute which matches with the\n             * TimePeriod and DayOfWeek fields passed in this command. * If Yes, then a response with\n             * TimeWindowAlreadyExist error status shall be returned. * If No, then the media device shall assign one\n             * unique index for this time window and add it into the BlockContentTimeWindow list attribute.\n             *\n             * If the TimeWindowIndex field is not NULL and presents in the BlockContentTimeWindow attribute, the media\n             * device shall replace the original time window with the new time window passed in this command.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.16\n             */\n            setBlockContentTimeWindow: Command(\n                0xf,\n                TlvSetBlockContentTimeWindowRequest,\n                0xf,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            ),\n\n            /**\n             * The purpose of this command is to remove the selected time windows from the BlockContentTimeWindow\n             * attribute.\n             *\n             * Upon receipt of the RemoveBlockContentTimeWindow command, the media device shall check if the time\n             * window index passed in this command presents in the BlockContentTimeWindow attribute.\n             *\n             * If one or more time window indexes passed in this command are not present in BlockContentTimeWindow\n             * attribute, then a response with TimeWindowNotExist error status shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.17\n             */\n            removeBlockContentTimeWindow: Command(\n                0x10,\n                TlvRemoveBlockContentTimeWindowRequest,\n                0x10,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage }\n            )\n        },\n\n        events: {\n            /**\n             * This event shall be generated when entering a period of blocked content as configured in the\n             * BlockContentTimeWindow attribute.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.9.2\n             */\n            enteringBlockContentTimeWindow: Event(0x1, EventPriority.Info, TlvNoArguments)\n        }\n    });\n\n    /**\n     * A ContentControlCluster supports these elements if it supports feature PinManagement.\n     */\n    export const PinManagementComponent = MutableCluster.Component({\n        commands: {\n            /**\n             * The purpose of this command is to update the PIN used for protecting configuration of the content\n             * control settings. Upon success, the old PIN shall no longer work.\n             *\n             * The PIN is used to ensure that only the Node (or User) with the PIN code can make changes to the Content\n             * Control settings, for example, turn off Content Controls or modify the ScreenDailyTime. The PIN is\n             * composed of a numeric string of up to 6 human readable characters (displayable) .\n             *\n             * Upon receipt of this command, the media device shall check if the OldPIN field of this command is the\n             * same as the current PIN. If the PINs are the same, then the PIN code shall be set to NewPIN. Otherwise a\n             * response with InvalidPINCode error status shall be returned.\n             *\n             * The media device may provide a default PIN to the User via an out of band mechanism. For security\n             * reasons, it is recommended that a client encourage the user to update the PIN from its default value\n             * when performing configuration of the Content Control settings exposed by this cluster. The ResetPIN\n             * command can also be used to obtain the default PIN.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.1\n             */\n            updatePin: Command(\n                0x0,\n                TlvUpdatePinRequest,\n                0x0,\n                TlvNoResponse,\n                { invokeAcl: AccessLevel.Manage, timed: true }\n            ),\n\n            /**\n             * The purpose of this command is to reset the PIN.\n             *\n             * If this command is executed successfully, a ResetPINResponse command with a new PIN shall be returned.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.2\n             */\n            resetPin: Command(\n                0x1,\n                TlvNoArguments,\n                0x2,\n                TlvResetPinResponse,\n                { invokeAcl: AccessLevel.Administer, timed: true }\n            )\n        }\n    });\n\n    /**\n     * These elements and properties are present in all ContentControl clusters.\n     */\n    export const Base = MutableCluster.Component({\n        id: 0x50f,\n        name: \"ContentControl\",\n        revision: 1,\n\n        features: {\n            /**\n             * ScreenTime\n             *\n             * Supports managing screen time limits.\n             */\n            screenTime: BitFlag(0),\n\n            /**\n             * PinManagement\n             *\n             * Supports managing a PIN code which is used for restricting access to configuration of this feature.\n             */\n            pinManagement: BitFlag(1),\n\n            /**\n             * BlockUnrated\n             *\n             * Supports managing content controls for unrated content.\n             */\n            blockUnrated: BitFlag(2),\n\n            /**\n             * OnDemandContentRating\n             *\n             * Supports managing content controls based upon rating threshold for on demand content.\n             */\n            onDemandContentRating: BitFlag(3),\n\n            /**\n             * ScheduledContentRating\n             *\n             * Supports managing content controls based upon rating threshold for scheduled content.\n             */\n            scheduledContentRating: BitFlag(4),\n\n            /**\n             * BlockChannels\n             *\n             * Supports managing a set of channels that are prohibited.\n             */\n            blockChannels: BitFlag(5),\n\n            /**\n             * BlockApplications\n             *\n             * Supports managing a set of applications that are prohibited.\n             */\n            blockApplications: BitFlag(6),\n\n            /**\n             * BlockContentTimeWindow\n             *\n             * Supports managing content controls based upon setting time window in which all contents and applications\n             * SHALL be blocked.\n             */\n            blockContentTimeWindow: BitFlag(7)\n        },\n\n        attributes: {\n            /**\n             * Indicates whether the Content Control feature implemented on a media device is turned off (FALSE) or\n             * turned on (TRUE).\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.7.1\n             */\n            enabled: Attribute(0x0, TlvBoolean)\n        },\n\n        commands: {\n            /**\n             * The purpose of this command is to turn on the Content Control feature on a media device.\n             *\n             * Upon receipt of the Enable command, the media device shall set the Enabled attribute to TRUE.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.4\n             */\n            enable: Command(0x3, TlvNoArguments, 0x3, TlvNoResponse, { invokeAcl: AccessLevel.Manage, timed: true }),\n\n            /**\n             * The purpose of this command is to turn off the Content Control feature on a media device.\n             *\n             * On receipt of the Disable command, the media device shall set the Enabled attribute to FALSE.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13.8.5\n             */\n            disable: Command(0x4, TlvNoArguments, 0x4, TlvNoResponse, { invokeAcl: AccessLevel.Manage, timed: true })\n        },\n\n        /**\n         * This metadata controls which ContentControlCluster elements matter.js activates for specific feature\n         * combinations.\n         */\n        extensions: MutableCluster.Extensions(\n            { flags: { onDemandContentRating: true }, component: OnDemandContentRatingComponent },\n            { flags: { scheduledContentRating: true }, component: ScheduledContentRatingComponent },\n            { flags: { screenTime: true }, component: ScreenTimeComponent },\n            { flags: { blockUnrated: true }, component: BlockUnratedComponent },\n            { flags: { blockChannels: true }, component: BlockChannelsComponent },\n            { flags: { blockApplications: true }, component: BlockApplicationsComponent },\n            { flags: { blockContentTimeWindow: true }, component: BlockContentTimeWindowComponent },\n            { flags: { pinManagement: true }, component: PinManagementComponent }\n        )\n    });\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster(Base);\n\n    /**\n     * This cluster is used for managing the content control (including \"parental control\") settings on a\n     *\n     * media device such as a TV, or Set-top Box.\n     *\n     * This cluster allows to configure content control settings by clients with the Management privilege. It is\n     * responsibility of the end product to enforce appropriate right access (for example, to prevent a child from\n     * disabling this feature).\n     *\n     * NOTE Support for Content Control cluster is provisional.\n     *\n     * ContentControlCluster supports optional features that you can enable with the ContentControlCluster.with()\n     * factory method.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 6.13\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    const OCR = { onDemandContentRating: true };\n    const SCR = { scheduledContentRating: true };\n    const ST = { screenTime: true };\n    const BU = { blockUnrated: true };\n    const BC = { blockChannels: true };\n    const BA = { blockApplications: true };\n    const BTW = { blockContentTimeWindow: true };\n    const PM = { pinManagement: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster({\n        id: Cluster.id,\n        name: Cluster.name,\n        revision: Cluster.revision,\n        features: Cluster.features,\n\n        attributes: {\n            ...Cluster.attributes,\n            onDemandRatings: MutableCluster.AsConditional(\n                OnDemandContentRatingComponent.attributes.onDemandRatings,\n                { mandatoryIf: [OCR] }\n            ),\n            onDemandRatingThreshold: MutableCluster.AsConditional(\n                OnDemandContentRatingComponent.attributes.onDemandRatingThreshold,\n                { mandatoryIf: [OCR] }\n            ),\n            scheduledContentRatings: MutableCluster.AsConditional(\n                ScheduledContentRatingComponent.attributes.scheduledContentRatings,\n                { mandatoryIf: [SCR] }\n            ),\n            scheduledContentRatingThreshold: MutableCluster.AsConditional(\n                ScheduledContentRatingComponent.attributes.scheduledContentRatingThreshold,\n                { mandatoryIf: [SCR] }\n            ),\n            screenDailyTime: MutableCluster.AsConditional(\n                ScreenTimeComponent.attributes.screenDailyTime,\n                { mandatoryIf: [ST] }\n            ),\n            remainingScreenTime: MutableCluster.AsConditional(\n                ScreenTimeComponent.attributes.remainingScreenTime,\n                { mandatoryIf: [ST] }\n            ),\n            blockUnrated: MutableCluster.AsConditional(\n                BlockUnratedComponent.attributes.blockUnrated,\n                { mandatoryIf: [BU] }\n            ),\n            blockChannelList: MutableCluster.AsConditional(\n                BlockChannelsComponent.attributes.blockChannelList,\n                { mandatoryIf: [BC] }\n            ),\n            blockApplicationList: MutableCluster.AsConditional(\n                BlockApplicationsComponent.attributes.blockApplicationList,\n                { mandatoryIf: [BA] }\n            ),\n            blockContentTimeWindow: MutableCluster.AsConditional(\n                BlockContentTimeWindowComponent.attributes.blockContentTimeWindow,\n                { mandatoryIf: [BTW] }\n            )\n        },\n\n        commands: {\n            ...Cluster.commands,\n            updatePin: MutableCluster.AsConditional(PinManagementComponent.commands.updatePin, { mandatoryIf: [PM] }),\n            resetPin: MutableCluster.AsConditional(PinManagementComponent.commands.resetPin, { mandatoryIf: [PM] }),\n            addBonusTime: MutableCluster.AsConditional(\n                ScreenTimeComponent.commands.addBonusTime,\n                { mandatoryIf: [ST] }\n            ),\n            setScreenDailyTime: MutableCluster.AsConditional(\n                ScreenTimeComponent.commands.setScreenDailyTime,\n                { mandatoryIf: [ST] }\n            ),\n            blockUnratedContent: MutableCluster.AsConditional(\n                BlockUnratedComponent.commands.blockUnratedContent,\n                { mandatoryIf: [BU] }\n            ),\n            unblockUnratedContent: MutableCluster.AsConditional(\n                BlockUnratedComponent.commands.unblockUnratedContent,\n                { mandatoryIf: [BU] }\n            ),\n            setOnDemandRatingThreshold: MutableCluster.AsConditional(\n                OnDemandContentRatingComponent.commands.setOnDemandRatingThreshold,\n                { mandatoryIf: [OCR] }\n            ),\n            setScheduledContentRatingThreshold: MutableCluster.AsConditional(\n                ScheduledContentRatingComponent.commands.setScheduledContentRatingThreshold,\n                { mandatoryIf: [SCR] }\n            ),\n            addBlockChannels: MutableCluster.AsConditional(\n                BlockChannelsComponent.commands.addBlockChannels,\n                { mandatoryIf: [BC] }\n            ),\n            removeBlockChannels: MutableCluster.AsConditional(\n                BlockChannelsComponent.commands.removeBlockChannels,\n                { mandatoryIf: [BC] }\n            ),\n            addBlockApplications: MutableCluster.AsConditional(\n                BlockApplicationsComponent.commands.addBlockApplications,\n                { mandatoryIf: [BA] }\n            ),\n            removeBlockApplications: MutableCluster.AsConditional(\n                BlockApplicationsComponent.commands.removeBlockApplications,\n                { mandatoryIf: [BA] }\n            ),\n            setBlockContentTimeWindow: MutableCluster.AsConditional(\n                BlockContentTimeWindowComponent.commands.setBlockContentTimeWindow,\n                { mandatoryIf: [BTW] }\n            ),\n            removeBlockContentTimeWindow: MutableCluster.AsConditional(\n                BlockContentTimeWindowComponent.commands.removeBlockContentTimeWindow,\n                { mandatoryIf: [BTW] }\n            )\n        },\n\n        events: {\n            remainingScreenTimeExpired: MutableCluster.AsConditional(\n                ScreenTimeComponent.events.remainingScreenTimeExpired,\n                { mandatoryIf: [ST] }\n            ),\n            enteringBlockContentTimeWindow: MutableCluster.AsConditional(\n                BlockContentTimeWindowComponent.events.enteringBlockContentTimeWindow,\n                { mandatoryIf: [BTW] }\n            )\n        }\n    });\n\n    /**\n     * This cluster supports all ContentControl features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n\nexport type ContentControlCluster = ContentControl.Cluster;\nexport const ContentControlCluster = ContentControl.Cluster;\nClusterRegistry.register(ContentControl.Complete);\n"],
  "mappings": "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",
  "names": ["ContentControl", "Feature", "DayOfWeek", "StatusCode"]
}
