{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/AccessControlCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport {\n    WritableFabricScopedAttribute,\n    AccessLevel,\n    OptionalWritableFabricScopedAttribute,\n    FixedAttribute,\n    Event,\n    EventPriority\n} from \"../Cluster.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvField, TlvObject } from \"../../tlv/TlvObject.js\";\nimport { TlvEnum, TlvUInt16 } from \"../../tlv/TlvNumber.js\";\nimport { TlvSubjectId } from \"../../datatype/SubjectId.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { TlvClusterId } from \"../../datatype/ClusterId.js\";\nimport { TlvEndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { TlvDeviceTypeId } from \"../../datatype/DeviceTypeId.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvFabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { TlvByteString } from \"../../tlv/TlvString.js\";\nimport { TlvNodeId } from \"../../datatype/NodeId.js\";\nimport { Identity } from \"../../util/Type.js\";\nimport { ClusterRegistry } from \"../ClusterRegistry.js\";\n\nexport namespace AccessControl {\n    /**\n     * Proxy View Value\n     *\n     * This value implicitly grants View privileges\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.2\n     */\n    export enum AccessControlEntryPrivilege {\n        /**\n         * Can read and observe all (except Access Control Cluster and as seen by a non-Proxy)\n         */\n        View = 1,\n\n        /**\n         * Can read and observe all (as seen by a Proxy)\n         */\n        ProxyView = 2,\n\n        /**\n         * View privileges, and can perform the primary function of this Node (except Access Control Cluster)\n         *\n         * This value implicitly grants View privileges\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.2.1\n         */\n        Operate = 3,\n\n        /**\n         * Operate privileges, and can modify persistent configuration of this Node (except Access Control Cluster)\n         *\n         * This value implicitly grants Operate & View privileges\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.2.2\n         */\n        Manage = 4,\n\n        /**\n         * Manage privileges, and can observe and modify the Access Control Cluster\n         *\n         * This value implicitly grants Manage, Operate, Proxy View & View privileges\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.2.3\n         */\n        Administer = 5\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.3\n     */\n    export enum AccessControlEntryAuthMode {\n        /**\n         * Passcode authenticated session\n         */\n        Pase = 1,\n\n        /**\n         * Certificate authenticated session\n         */\n        Case = 2,\n\n        /**\n         * Group authenticated session\n         */\n        Group = 3\n    }\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.4\n     */\n    export const TlvAccessControlTarget = TlvObject({\n        cluster: TlvField(0, TlvNullable(TlvClusterId)),\n        endpoint: TlvField(1, TlvNullable(TlvEndpointNumber)),\n        deviceType: TlvField(2, TlvNullable(TlvDeviceTypeId))\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.4\n     */\n    export interface AccessControlTarget extends TypeFromSchema<typeof TlvAccessControlTarget> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.5\n     */\n    export const TlvAccessControlEntry = TlvObject({\n        /**\n         * The privilege field shall specify the level of privilege granted by this Access Control Entry.\n         *\n         * NOTE The Proxy View privilege is provisional.\n         *\n         * Each privilege builds upon its predecessor, expanding the set of actions that can be performed upon a Node.\n         * Administer is the highest privilege, and is special as it pertains to the administration of privileges\n         * itself, via the Access Control Cluster.\n         *\n         * When a Node is granted a particular privilege, it is also implicitly granted all logically lower privilege\n         * levels as well. The following diagram illustrates how the higher privilege levels subsume the lower\n         * privilege levels:\n         *\n         * Figure 43. Access Control Privilege Levels\n         *\n         * Individual clusters shall define whether attributes are readable, writable, or both readable and writable.\n         * Clusters also shall define which privilege is minimally required to be able to perform a particular read or\n         * write action on those attributes, or invoke particular commands. Device type specifications may further\n         * restrict the privilege required.\n         *\n         * The Access Control Cluster shall require the Administer privilege to observe and modify the Access Control\n         * Cluster itself. The Administer privilege shall NOT be used on Access Control Entries which use the Group\n         * auth mode.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.5.1\n         */\n        privilege: TlvField(1, TlvEnum<AccessControlEntryPrivilege>()),\n\n        /**\n         * The AuthMode field shall specify the authentication mode required by this Access Control Entry.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.5.2\n         */\n        authMode: TlvField(2, TlvEnum<AccessControlEntryAuthMode>()),\n\n        /**\n         * The subjects field shall specify a list of Subject IDs, to which this Access Control Entry grants access.\n         *\n         * Device types may impose additional constraints on the minimum number of subjects per Access Control Entry.\n         *\n         * An attempt to create an entry with more subjects than the node can support shall result in a\n         * RESOURCE_EXHAUSTED error and the entry shall NOT be created.\n         *\n         * ### Subject ID shall be of type uint64 with semantics depending on the entry\u2019s AuthMode as follows:\n         *\n         * Subject Semantics\n         *\n         * An empty subjects list indicates a wildcard; that is, this entry shall grant access to any Node that\n         * successfully authenticates via AuthMode. The subjects list shall NOT be empty if the entry\u2019s AuthMode is\n         * PASE.\n         *\n         * The PASE AuthMode is reserved for future use (see Section 6.6.2.8, \u201CBootstrapping of the Access Control\n         * Cluster\u201D). An attempt to write an entry with AuthMode set to PASE shall fail with a status code of\n         * CONSTRAINT_ERROR.\n         *\n         * For PASE authentication, the Passcode ID identifies the required passcode verifier, and shall be 0 for the\n         * default commissioning passcode.\n         *\n         * For CASE authentication, the Subject ID is a distinguished name within the Operational Certificate shared\n         * during CASE session establishment, the type of which is determined by its range to be one of:\n         *\n         *   \u2022 a Node ID, which identifies the required source node directly (by ID)\n         *\n         *   \u2022 a CASE Authenticated Tag, which identifies the required source node indirectly (by tag)\n         *\n         * For Group authentication, the Group ID identifies the required group, as defined in the Group Key Management\n         * Cluster.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.5.3\n         */\n        subjects: TlvField(3, TlvNullable(TlvArray(TlvSubjectId))),\n\n        /**\n         * The targets field shall specify a list of AccessControlTargetStruct, which define the clusters on this Node\n         * to which this Access Control Entry grants access.\n         *\n         * Device types may impose additional constraints on the minimum number of targets per Access Control Entry.\n         *\n         * An attempt to create an entry with more targets than the node can support shall result in a\n         * RESOURCE_EXHAUSTED error and the entry shall NOT be created.\n         *\n         * A single target shall contain at least one field (Cluster, Endpoint, or DeviceType), and shall NOT contain\n         * both an Endpoint field and a DeviceType field.\n         *\n         * A target grants access based on the presence of fields as follows:\n         *\n         * Target Semantics\n         *\n         * An empty targets list indicates a wildcard: that is, this entry shall grant access to all cluster instances\n         * on all endpoints on this Node.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.5.4\n         */\n        targets: TlvField(4, TlvNullable(TlvArray(TlvAccessControlTarget))),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.5\n     */\n    export interface AccessControlEntry extends TypeFromSchema<typeof TlvAccessControlEntry> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.6\n     */\n    export const TlvAccessControlExtension = TlvObject({\n        /**\n         * This field may be used by manufacturers to store arbitrary TLV-encoded data related to a fabric\u2019s Access\n         * Control Entries.\n         *\n         * The contents shall consist of a top-level anonymous list; each list element shall include a profile-specific\n         * tag encoded in fully-qualified form.\n         *\n         * Administrators may iterate over this list of elements, and interpret selected elements at their discretion.\n         * The content of each element is not specified, but may be coordinated among manufacturers at their discretion.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.6.1\n         */\n        data: TlvField(1, TlvByteString.bound({ maxLength: 128 })),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.6\n     */\n    export interface AccessControlExtension extends TypeFromSchema<typeof TlvAccessControlExtension> {}\n\n    /**\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.4.1\n     */\n    export enum ChangeType {\n        /**\n         * Entry or extension was changed\n         */\n        Changed = 0,\n\n        /**\n         * Entry or extension was added\n         */\n        Added = 1,\n\n        /**\n         * Entry or extension was removed\n         */\n        Removed = 2\n    }\n\n    /**\n     * Body of the AccessControl accessControlEntryChanged event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1\n     */\n    export const TlvAccessControlEntryChangedEvent = TlvObject({\n        /**\n         * The Node ID of the Administrator that made the change, if the change occurred via a CASE session.\n         *\n         * Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change occurred via a\n         * CASE or PASE session; the other shall be null.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1.1\n         */\n        adminNodeId: TlvField(1, TlvNullable(TlvNodeId)),\n\n        /**\n         * The Passcode ID of the Administrator that made the change, if the change occurred via a PASE session.\n         * Non-zero values are reserved for future use (see PasscodeId generation in PBKDFParamRequest).\n         *\n         * Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change occurred via a\n         * CASE or PASE session; the other shall be null.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1.2\n         */\n        adminPasscodeId: TlvField(2, TlvNullable(TlvUInt16)),\n\n        /**\n         * The type of change as appropriate.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1.3\n         */\n        changeType: TlvField(3, TlvEnum<ChangeType>()),\n\n        /**\n         * The latest value of the changed entry.\n         *\n         * This field SHOULD be set if resources are adequate for it; otherwise it shall be set to NULL if resources\n         * are scarce.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1.4\n         */\n        latestValue: TlvField(4, TlvNullable(TlvAccessControlEntry)),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * Body of the AccessControl accessControlEntryChanged event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1\n     */\n    export interface AccessControlEntryChangedEvent extends TypeFromSchema<typeof TlvAccessControlEntryChangedEvent> {}\n\n    /**\n     * Body of the AccessControl accessControlExtensionChanged event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2\n     */\n    export const TlvAccessControlExtensionChangedEvent = TlvObject({\n        /**\n         * The Node ID of the Administrator that made the change, if the change occurred via a CASE session.\n         *\n         * Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change occurred via a\n         * CASE or PASE session; the other shall be null.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2.1\n         */\n        adminNodeId: TlvField(1, TlvNullable(TlvNodeId)),\n\n        /**\n         * The Passcode ID of the Administrator that made the change, if the change occurred via a PASE session.\n         * Non-zero values are reserved for future use (see PasscodeId generation in PBKDFParamRequest).\n         *\n         * Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change occurred via a\n         * CASE or PASE session; the other shall be null.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2.2\n         */\n        adminPasscodeId: TlvField(2, TlvNullable(TlvUInt16)),\n\n        /**\n         * The type of change as appropriate.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2.3\n         */\n        changeType: TlvField(3, TlvEnum<ChangeType>()),\n\n        /**\n         * The latest value of the changed extension.\n         *\n         * This field SHOULD be set if resources are adequate for it; otherwise it shall be set to NULL if resources\n         * are scarce.\n         *\n         * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2.4\n         */\n        latestValue: TlvField(4, TlvNullable(TlvAccessControlExtension)),\n\n        fabricIndex: TlvField(254, TlvFabricIndex)\n    });\n\n    /**\n     * Body of the AccessControl accessControlExtensionChanged event\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2\n     */\n    export interface AccessControlExtensionChangedEvent extends TypeFromSchema<typeof TlvAccessControlExtensionChangedEvent> {}\n\n    /**\n     * @see {@link Cluster}\n     */\n    export const ClusterInstance = MutableCluster({\n        id: 0x1f,\n        name: \"AccessControl\",\n        revision: 1,\n\n        attributes: {\n            /**\n             * An attempt to add an Access Control Entry when no more entries are available shall result in a\n             * RESOURCE_EXHAUSTED error being reported and the ACL attribute shall NOT have the entry added to it. See\n             * access control limits.\n             *\n             * See the AccessControlEntriesPerFabric attribute for the actual value of the number of entries per fabric\n             * supported by the server.\n             *\n             * Each Access Control Entry codifies a single grant of privilege on this Node, and is used by the Access\n             * Control Privilege Granting algorithm to determine if a subject has privilege to interact with targets on\n             * the Node.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.5.3\n             */\n            acl: WritableFabricScopedAttribute(\n                0x0,\n                TlvArray(TlvAccessControlEntry),\n                { default: [], readAcl: AccessLevel.Administer, writeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * If present, the Access Control Extensions may be used by Administrators to store arbitrary data related\n             * to fabric\u2019s Access Control Entries.\n             *\n             * The Access Control Extension list shall support a single extension entry per supported fabric.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.5.4\n             */\n            extension: OptionalWritableFabricScopedAttribute(\n                0x1,\n                TlvArray(TlvAccessControlExtension),\n                { default: [], readAcl: AccessLevel.Administer, writeAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * This attribute shall provide the minimum number of Subjects per entry that are supported by this server.\n             *\n             * Since reducing this value over time may invalidate ACL entries already written, this value shall NOT\n             * decrease across time as software updates occur that could impact this value. If this is a concern for a\n             * given implementation, it is recommended to only use the minimum value required and avoid reporting a\n             * higher value than the required minimum.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.5.5\n             */\n            subjectsPerAccessControlEntry: FixedAttribute(0x2, TlvUInt16.bound({ min: 4 }), { default: 4 }),\n\n            /**\n             * This attribute shall provide the minimum number of Targets per entry that are supported by this server.\n             *\n             * Since reducing this value over time may invalidate ACL entries already written, this value shall NOT\n             * decrease across time as software updates occur that could impact this value. If this is a concern for a\n             * given implementation, it is recommended to only use the minimum value required and avoid reporting a\n             * higher value than the required minimum.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.5.6\n             */\n            targetsPerAccessControlEntry: FixedAttribute(0x3, TlvUInt16.bound({ min: 3 }), { default: 3 }),\n\n            /**\n             * This attribute shall provide the minimum number of ACL Entries per fabric that are supported by this\n             * server.\n             *\n             * Since reducing this value over time may invalidate ACL entries already written, this value shall NOT\n             * decrease across time as software updates occur that could impact this value. If this is a concern for a\n             * given implementation, it is recommended to only use the minimum value required and avoid reporting a\n             * higher value than the required minimum.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.5.7\n             */\n            accessControlEntriesPerFabric: FixedAttribute(0x4, TlvUInt16.bound({ min: 4 }), { default: 4 })\n        },\n\n        events: {\n            /**\n             * The cluster shall send AccessControlEntryChanged events whenever its ACL attribute data is changed by an\n             * Administrator.\n             *\n             *   \u2022 Each added entry shall generate an event with ChangeType Added.\n             *\n             *   \u2022 Each changed entry shall generate an event with ChangeType Changed.\n             *\n             *   \u2022 Each removed entry shall generate an event with ChangeType Removed.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.1\n             */\n            accessControlEntryChanged: Event(\n                0x0,\n                EventPriority.Info,\n                TlvAccessControlEntryChangedEvent,\n                { readAcl: AccessLevel.Administer }\n            ),\n\n            /**\n             * The cluster shall send AccessControlExtensionChanged events whenever its extension attribute data is\n             * changed by an Administrator.\n             *\n             *   \u2022 Each added extension shall generate an event with ChangeType Added.\n             *\n             *   \u2022 Each changed extension shall generate an event with ChangeType Changed.\n             *\n             *   \u2022 Each removed extension shall generate an event with ChangeType Removed.\n             *\n             * @see {@link MatterSpecification.v13.Core} \u00A7 9.10.7.2\n             */\n            accessControlExtensionChanged: Event(\n                0x1,\n                EventPriority.Info,\n                TlvAccessControlExtensionChangedEvent,\n                { readAcl: AccessLevel.Administer }\n            )\n        }\n    });\n\n    /**\n     * The Access Control Cluster exposes a data model view of a Node\u2019s Access Control List (ACL), which codifies the\n     * rules used to manage and enforce Access Control for the Node\u2019s endpoints and their associated cluster instances.\n     * Access to this Access Control Cluster itself requires a special Administer privilege level, such that only Nodes\n     * granted such privilege (hereafter termed \"Administrators\") can manage the Access Control Cluster.\n     *\n     * The Access Control Cluster shall be present on the root node endpoint of each Node, and shall NOT be present on\n     * any other Endpoint of any Node.\n     *\n     * @see {@link MatterSpecification.v13.Core} \u00A7 9.10\n     */\n    export interface Cluster extends Identity<typeof ClusterInstance> {}\n\n    export const Cluster: Cluster = ClusterInstance;\n    export const Complete = Cluster;\n}\n\nexport type AccessControlCluster = AccessControl.Cluster;\nexport const AccessControlCluster = AccessControl.Cluster;\nClusterRegistry.register(AccessControl.Complete);\n"],
  "mappings": "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",
  "names": ["AccessControl", "AccessControlEntryPrivilege", "AccessControlEntryAuthMode", "ChangeType"]
}
