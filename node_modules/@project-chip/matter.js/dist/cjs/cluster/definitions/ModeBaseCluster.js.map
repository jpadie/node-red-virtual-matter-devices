{
  "version": 3,
  "sources": ["../../../../src/cluster/definitions/ModeBaseCluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/*** THIS FILE IS GENERATED, DO NOT EDIT ***/\n\nimport { MutableCluster } from \"../mutation/MutableCluster.js\";\nimport { WritableAttribute, FixedAttribute, Attribute, OptionalWritableAttribute, Command } from \"../Cluster.js\";\nimport { TlvUInt8, TlvUInt16, TlvEnum } from \"../../tlv/TlvNumber.js\";\nimport { TlvNullable } from \"../../tlv/TlvNullable.js\";\nimport { BitFlag } from \"../../schema/BitmapSchema.js\";\nimport { TlvArray } from \"../../tlv/TlvArray.js\";\nimport { TlvField, TlvOptionalField, TlvObject } from \"../../tlv/TlvObject.js\";\nimport { TlvString } from \"../../tlv/TlvString.js\";\nimport { TlvVendorId } from \"../../datatype/VendorId.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { StatusCode } from \"../../protocol/interaction/StatusCode.js\";\nimport { Identity } from \"../../util/Type.js\";\n\nexport namespace ModeBase {\n    /**\n     * These are optional features supported by ModeBaseCluster.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.4\n     */\n    export enum Feature {\n        /**\n         * OnOff (DEPONOFF)\n         *\n         * This feature creates a dependency between an OnOff cluster instance and this cluster instance on the same\n         * endpoint. See OnMode for more information.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.4.1\n         */\n        OnOff = \"OnOff\"\n    }\n\n    /**\n     * A Mode Tag is meant to be interpreted by the client for the purpose the cluster serves.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.1\n     */\n    export const TlvModeTag = TlvObject({\n        /**\n         * If the MfgCode field exists, the Value field shall be in the manufacturer-specific value range (see Section\n         * 1.10.8, \u201CMode Namespace\u201D).\n         *\n         * This field shall indicate the manufacturer\u2019s VendorID and it shall determine the meaning of the Value field.\n         *\n         * The same manufacturer code and mode tag value in separate cluster instances are part of the same namespace\n         * and have the same meaning. For example: a manufacturer tag meaning \"pinch\" can be used both in a cluster\n         * whose purpose is to choose the amount of sugar, or in a cluster whose purpose is to choose the amount of\n         * salt.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.1.1\n         */\n        mfgCode: TlvOptionalField(0, TlvVendorId),\n\n        /**\n         * This field shall indicate the mode tag within a mode tag namespace which is either manufacturer specific or\n         * standard.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.1.2\n         */\n        value: TlvField(1, TlvUInt16)\n    });\n\n    /**\n     * A Mode Tag is meant to be interpreted by the client for the purpose the cluster serves.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.1\n     */\n    export interface ModeTag extends TypeFromSchema<typeof TlvModeTag> {}\n\n    /**\n     * This is a struct representing a possible mode of the server.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.2\n     */\n    export const TlvModeOption = TlvObject({\n        /**\n         * This field shall indicate readable text that describes the mode option, so that a client can provide it to\n         * the user to indicate what this option means. This field is meant to be readable and understandable by the\n         * user.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.2.1\n         */\n        label: TlvField(0, TlvString.bound({ maxLength: 64 })),\n\n        /**\n         * This field is used to identify the mode option.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.2.2\n         */\n        mode: TlvField(1, TlvUInt8),\n\n        /**\n         * This field shall contain a list of tags that are associated with the mode option. This may be used by\n         * clients to determine the full or the partial semantics of a certain mode, depending on which tags they\n         * understand, using standard definitions and/or manufacturer specific namespace definitions.\n         *\n         * The standard mode tags are defined in this cluster specification. For the derived cluster instances, if the\n         * specification of the derived cluster defines a namespace, the set of standard mode tags also includes the\n         * mode tag values from that namespace.\n         *\n         * Mode tags can help clients look for options that meet certain criteria, render the user interface, use\n         *\n         * the mode in an automation, or to craft help text their voice-driven interfaces. A mode tag shall be either a\n         * standard tag or a manufacturer specific tag, as defined in each ModeTagStruct list entry.\n         *\n         * A mode option may have more than one mode tag. A mode option may be associated with a mixture of standard\n         * and manufacturer specific mode tags. A mode option shall be associated with at least one standard mode tag.\n         *\n         * A few examples are provided below.\n         *\n         *   \u2022 A mode named \"100%\" can have both the High (manufacturer specific) and Max (standard) mode tag. Clients\n         *     seeking the mode for either High or Max will find the same mode in this case.\n         *\n         *   \u2022 A mode that includes a LowEnergy tag can be displayed by the client using a widget icon that shows a\n         *     green leaf.\n         *\n         *   \u2022 A mode that includes a LowNoise tag may be used by the client when the user wishes for a lower level of\n         *     audible sound, less likely to disturb the household\u2019s activities.\n         *\n         *   \u2022 A mode that includes a LowEnergy tag (standard, defined in this cluster specification) and also a\n         *     Delicate tag (standard, defined in the namespace of a Laundry Mode derived cluster).\n         *\n         *   \u2022 A mode that includes both a generic Quick tag (defined here), and Vacuum and Mop tags, (defined in the\n         *     RVC Clean cluster that is a derivation of this cluster).\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.2.3\n         */\n        modeTags: TlvField(2, TlvArray(TlvModeTag, { maxLength: 8 }))\n    });\n\n    /**\n     * This is a struct representing a possible mode of the server.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.5.2\n     */\n    export interface ModeOption extends TypeFromSchema<typeof TlvModeOption> {}\n\n    /**\n     * Input to the ModeBase changeToMode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.1\n     */\n    export const TlvChangeToModeRequest = TlvObject({\n        /**\n         * If the NewMode field doesn\u2019t match the Mode field of any entry of the SupportedModes list, the\n         * ChangeToModeResponse command\u2019s Status field shall indicate UnsupportedMode and the StatusText field shall be\n         * included and may be used to indicate the issue, with a human readable string, or include an empty string.\n         *\n         * If the NewMode field matches the Mode field of one entry of the SupportedModes list, but the device is not\n         * able to transition as requested, the ChangeToModeResponse command shall:\n         *\n         *   \u2022 Have the Status set to a product-specific Status value representing the error, or GenericFailure if a\n         *     more specific error cannot be provided. See Status Field for details.\n         *\n         *   \u2022 Provide a human readable string in the StatusText field.\n         *\n         * If the NewMode field matches the Mode field of one entry of the SupportedModes list and the device is able\n         * to transition as requested, the server shall transition into the mode associated with NewMode, the\n         * ChangeToModeResponse command shall have the Status field set to Success, the StatusText field may be\n         * supplied with a human readable string or include an empty string and the CurrentMode field shall be set to\n         * the value of the NewMode field.\n         *\n         * If the NewMode field is the same as the value of the CurrentMode attribute the ChangeToModeRe\n         *\n         * sponse command shall have the Status field set to Success and the StatusText field may be supplied with a\n         * human readable string or include an empty string.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.1.1\n         */\n        newMode: TlvField(0, TlvUInt8)\n    });\n\n    /**\n     * Input to the ModeBase changeToMode command\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.1\n     */\n    export interface ChangeToModeRequest extends TypeFromSchema<typeof TlvChangeToModeRequest> {}\n\n    /**\n     * This command is sent by the device on receipt of the ChangeToMode command.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2\n     */\n    export const TlvChangeToModeResponse = TlvObject({\n        /**\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2.1\n         */\n        status: TlvField(0, TlvEnum<StatusCode>()),\n\n        statusText: TlvField(1, TlvString.bound({ maxLength: 64 }))\n    });\n\n    /**\n     * This command is sent by the device on receipt of the ChangeToMode command.\n     *\n     * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2\n     */\n    export interface ChangeToModeResponse extends TypeFromSchema<typeof TlvChangeToModeResponse> {}\n\n    export enum ModeChangeStatus {\n        /**\n         * Switching to the mode indicated by the NewMode field is allowed and possible. The CurrentMode attribute is\n         * set to the value of the NewMode field.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2.1.2\n         */\n        Success = 0,\n\n        /**\n         * The value of the NewMode field doesn\u2019t match any entries in the SupportedMode attribute.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2.1.2\n         */\n        UnsupportedMode = 1,\n\n        /**\n         * Generic failure code, indicating that switching to the mode indicated by the NewMode field is not allowed or\n         * not possible.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2.1.2\n         */\n        GenericFailure = 2,\n\n        /**\n         * The received request cannot be handled due to the current mode of the device\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.2.1.2\n         */\n        InvalidInMode = 3\n    }\n\n    export enum ModeTagEnum {\n        /**\n         * The device decides which options, features and setting values to use.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Auto = 0,\n\n        /**\n         * The mode of the device is optimizing for faster completion.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Quick = 1,\n\n        /**\n         * The device is silent or barely audible while in this mode.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Quiet = 2,\n\n        /**\n         * Either the mode is inherently low noise or the device optimizes for that.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        LowNoise = 3,\n\n        /**\n         * The device is optimizing for lower energy usage in this mode. Sometimes called \"Eco mode\".\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        LowEnergy = 4,\n\n        /**\n         * A mode suitable for use during vacations or other extended absences.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Vacation = 5,\n\n        /**\n         * The mode uses the lowest available setting value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Min = 6,\n\n        /**\n         * The mode uses the highest available setting value.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Max = 7,\n\n        /**\n         * The mode is recommended or suitable for use during night time.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Night = 8,\n\n        /**\n         * The mode is recommended or suitable for use during day time.\n         *\n         * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.8\n         */\n        Day = 9\n    }\n\n    /**\n     * A ModeBaseCluster supports these elements if it supports feature OnOff.\n     */\n    export const OnOffComponent = MutableCluster.Component({\n        attributes: {\n            /**\n             * Indicates whether the value of CurrentMode depends on the state of the On/Off cluster on the same\n             * endpoint. If this attribute is not present or is set to null, there is no dependency, otherwise the\n             * CurrentMode attribute shall depend on the OnOff attribute in the On/Off cluster\n             *\n             * The value of this field shall match the Mode field of one of the entries in the SupportedModes attribute.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.6.5\n             */\n            onMode: WritableAttribute(0x3, TlvNullable(TlvUInt8), { persistent: true, default: null })\n        }\n    });\n\n    /**\n     * ModeBase is a derived cluster, not to be used directly. These elements are present in all clusters derived from\n     * ModeBase.\n     */\n    export const Base = MutableCluster.Component({\n        features: {\n            /**\n             * OnOff\n             *\n             * This feature creates a dependency between an OnOff cluster instance and this cluster instance on the\n             * same endpoint. See OnMode for more information.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.4.1\n             */\n            onOff: BitFlag(0)\n        },\n\n        name: \"ModeBase\",\n        revision: 2,\n\n        attributes: {\n            /**\n             * This attribute shall contain the list of supported modes that may be selected for the CurrentMode\n             * attribute. Each item in this list represents a unique mode as indicated by the Mode field of the\n             * ModeOptionStruct.\n             *\n             * Each entry in this list shall have a unique value for the Mode field. Each entry in this list shall have\n             * a unique value for the Label field.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.6.2\n             */\n            supportedModes: FixedAttribute(0x0, TlvArray(TlvModeOption, { minLength: 2, maxLength: 255 })),\n\n            /**\n             * Indicates the current mode of the server.\n             *\n             * The value of this field shall match the Mode field of one of the entries in the SupportedModes attribute.\n             *\n             * The value of this attribute may change at any time via an out-of-band interaction outside of the server,\n             * such as interactions with a user interface, via internal mode changes due to autonomously progressing\n             * through a sequence of operations, on system time-outs or idle delays, or via interactions coming from a\n             * fabric other than the one which last executed a ChangeToMode.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.6.3\n             */\n            currentMode: Attribute(0x1, TlvUInt8, { scene: true, persistent: true }),\n\n            /**\n             * Indicates the desired startup mode for the server when it is supplied with power.\n             *\n             * If this attribute is not null, the CurrentMode attribute shall be set to the StartUpMode value, when the\n             * server is powered up, except in the case when the OnMode attribute overrides the StartUpMode attribute\n             * (see OnModeWithPowerUp).\n             *\n             * This behavior does not apply to reboots associated with OTA. After an OTA restart, the CurrentMode\n             * attribute shall return to its value prior to the restart.\n             *\n             * The value of this field shall match the Mode field of one of the entries in the SupportedModes attribute.\n             *\n             * If this attribute is not implemented, or is set to the null value, it shall have no effect.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.6.4\n             */\n            startUpMode: OptionalWritableAttribute(0x2, TlvNullable(TlvUInt8), { persistent: true })\n        },\n\n        commands: {\n            /**\n             * This command is used to change device modes.\n             *\n             * On receipt of this command the device shall respond with a ChangeToModeResponse command.\n             *\n             * @see {@link MatterSpecification.v13.Cluster} \u00A7 1.10.7.1\n             */\n            changeToMode: Command(0x0, TlvChangeToModeRequest, 0x1, TlvChangeToModeResponse)\n        },\n\n        /**\n         * This metadata controls which ModeBaseCluster elements matter.js activates for specific feature combinations.\n         */\n        extensions: MutableCluster.Extensions({ flags: { onOff: true }, component: OnOffComponent })\n    });\n\n    const DEPONOFF = { onOff: true };\n\n    /**\n     * @see {@link Complete}\n     */\n    export const CompleteInstance = MutableCluster.Component({\n        name: Base.name,\n        revision: Base.revision,\n        features: Base.features,\n        attributes: {\n            ...Base.attributes,\n            onMode: MutableCluster.AsConditional(OnOffComponent.attributes.onMode, { mandatoryIf: [DEPONOFF] })\n        },\n        commands: Base.commands\n    });\n\n    /**\n     * This cluster supports all ModeBase features. It may support illegal feature combinations.\n     *\n     * If you use this cluster you must manually specify which features are active and ensure the set of active\n     * features is legal per the Matter specification.\n     */\n    export interface Complete extends Identity<typeof CompleteInstance> {}\n\n    export const Complete: Complete = CompleteInstance;\n}\n"],
  "mappings": "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",
  "names": ["ModeBase", "Feature", "ModeChangeStatus", "ModeTagEnum"]
}
