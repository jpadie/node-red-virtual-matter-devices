{
  "version": 3,
  "sources": ["../../../src/cluster/Cluster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterError } from \"../common/MatterError.js\";\nimport { AttributeId, TlvAttributeId } from \"../datatype/AttributeId.js\";\nimport { ClusterId } from \"../datatype/ClusterId.js\";\nimport { CommandId, TlvCommandId } from \"../datatype/CommandId.js\";\nimport { EventId, TlvEventId } from \"../datatype/EventId.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../schema/BitmapSchema.js\";\nimport { TlvAny } from \"../tlv/TlvAny.js\";\nimport { TlvArray } from \"../tlv/TlvArray.js\";\nimport { TlvBitmap, TlvUInt16, TlvUInt32 } from \"../tlv/TlvNumber.js\";\nimport { TlvSchema } from \"../tlv/TlvSchema.js\";\nimport { TlvVoid } from \"../tlv/TlvVoid.js\";\nimport { Merge } from \"../util/Type.js\";\n\nexport class AttributeError extends MatterError {}\n\nexport class EventError extends MatterError {}\n\n// This Enum needs to be in sync with the AccessControl.AccessControlEntryPrivilege enum!\nexport enum AccessLevel {\n    View = 1,\n    ProxyView = 2,\n    Operate = 3,\n    Manage = 4,\n    Administer = 5,\n}\n\nexport type ConditionalFeatureList<F extends BitSchema> = TypeFromPartialBitSchema<F>[];\n\n/* Interfaces and helper methods to define a cluster attribute */\nexport interface Attribute<T, F extends BitSchema> {\n    id: AttributeId;\n    schema: TlvSchema<T>;\n    optional: boolean;\n    readAcl: AccessLevel;\n    writable: boolean;\n    scene: boolean;\n    persistent: boolean;\n    timed: boolean;\n    fixed: boolean;\n    fabricScoped: boolean;\n    omitChanges: boolean;\n    writeAcl?: AccessLevel;\n    default?: T;\n    isConditional: boolean;\n    optionalIf: ConditionalFeatureList<F>;\n    mandatoryIf: ConditionalFeatureList<F>;\n    unknown: boolean;\n}\n\nexport interface OptionalAttribute<T, F extends BitSchema> extends Attribute<T, F> {\n    optional: true;\n}\n\nexport interface ConditionalAttribute<T, F extends BitSchema> extends OptionalAttribute<T, F> {\n    isConditional: true;\n}\n\nexport interface WritableAttribute<T, F extends BitSchema> extends Attribute<T, F> {\n    writable: true;\n}\n\nexport interface OptionalWritableAttribute<T, F extends BitSchema> extends OptionalAttribute<T, F> {\n    writable: true;\n}\n\nexport interface ConditionalWritableAttribute<T, F extends BitSchema> extends OptionalWritableAttribute<T, F> {\n    isConditional: true;\n}\n\nexport interface FabricScopedAttribute<T, F extends BitSchema> extends Attribute<T, F> {\n    fabricScoped: true;\n}\n\nexport interface WritableFabricScopedAttribute<T, F extends BitSchema> extends WritableAttribute<T, F> {\n    fabricScoped: true;\n}\n\nexport interface OptionalWritableFabricScopedAttribute<T, F extends BitSchema> extends OptionalWritableAttribute<T, F> {\n    fabricScoped: true;\n}\n\nexport interface ConditionalWritableFabricScopedAttribute<T, F extends BitSchema>\n    extends OptionalWritableFabricScopedAttribute<T, F> {\n    isConditional: true;\n}\n\nexport interface FixedAttribute<T, F extends BitSchema> extends Attribute<T, F> {\n    fixed: true;\n}\n\nexport interface WritableFixedAttribute<T, F extends BitSchema> extends WritableAttribute<T, F> {\n    fixed: true;\n}\n\nexport interface OptionalFixedAttribute<T, F extends BitSchema> extends OptionalAttribute<T, F> {\n    fixed: true;\n}\n\nexport interface ConditionalFixedAttribute<T, F extends BitSchema> extends OptionalFixedAttribute<T, F> {\n    isConditional: true;\n}\n\nexport type AttributeJsType<T extends Attribute<any, any>> = T extends Attribute<infer JsType, any> ? JsType : never;\n\ninterface AttributeOptions<T> {\n    scene?: boolean;\n    persistent?: boolean;\n    omitChanges?: boolean;\n    timed?: boolean;\n    default?: T;\n    readAcl?: AccessLevel;\n    writeAcl?: AccessLevel;\n}\n\ninterface ConditionalAttributeOptions<T, F extends BitSchema> extends AttributeOptions<T> {\n    optionalIf?: ConditionalFeatureList<F>;\n    mandatoryIf?: ConditionalFeatureList<F>;\n}\n\nexport const Attribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): Attribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: false,\n    writable: false,\n    fixed: false,\n    scene,\n    persistent,\n    timed,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const OptionalAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): OptionalAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: false,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const ConditionalAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        optionalIf = [],\n        mandatoryIf = [],\n        timed = false,\n    }: ConditionalAttributeOptions<V, F>,\n): ConditionalAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: false,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: true,\n    optionalIf,\n    mandatoryIf,\n    unknown: false,\n});\n\nexport const WritableAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        writeAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): WritableAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: false,\n    writable: true,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    writeAcl,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const OptionalWritableAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        writeAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): OptionalWritableAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: true,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    writeAcl,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const ConditionalWritableAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        writeAcl = AccessLevel.View,\n        optionalIf = [],\n        mandatoryIf = [],\n        timed = false,\n    }: ConditionalAttributeOptions<V, F>,\n): ConditionalWritableAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: true,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    writeAcl,\n    isConditional: true,\n    optionalIf,\n    mandatoryIf,\n    unknown: false,\n});\n\nexport const FabricScopedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): FabricScopedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: false,\n    writable: false,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: true,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const WritableFabricScopedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        writeAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): WritableFabricScopedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: false,\n    writable: true,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: true,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    writeAcl,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const OptionalWritableFabricScopedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        writeAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): OptionalWritableFabricScopedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: true,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: true,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    writeAcl,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const ConditionalWritableFabricScopedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = true,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        writeAcl = AccessLevel.View,\n        optionalIf = [],\n        mandatoryIf = [],\n        timed = false,\n    }: ConditionalAttributeOptions<V, F> = {},\n): ConditionalWritableFabricScopedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: true,\n    fixed: false,\n    scene,\n    persistent,\n    fabricScoped: true,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    writeAcl,\n    isConditional: true,\n    optionalIf,\n    mandatoryIf,\n    unknown: false,\n});\n\nexport const FixedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): FixedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: false,\n    writable: false,\n    fixed: true,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const WritableFixedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): FixedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: false,\n    writable: true,\n    fixed: true,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const OptionalFixedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n    }: AttributeOptions<V> = {},\n): OptionalFixedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: false,\n    fixed: true,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const ConditionalFixedAttribute = <T, V extends T, F extends BitSchema>(\n    id: number,\n    schema: TlvSchema<T>,\n    {\n        scene = false,\n        persistent = false,\n        omitChanges = false,\n        default: conformanceValue,\n        readAcl = AccessLevel.View,\n        timed = false,\n        optionalIf = [],\n        mandatoryIf = [],\n    }: ConditionalAttributeOptions<V, F>,\n): ConditionalFixedAttribute<T, F> => ({\n    id: AttributeId(id),\n    schema,\n    optional: true,\n    writable: false,\n    fixed: true,\n    scene,\n    persistent,\n    fabricScoped: false,\n    omitChanges,\n    default: conformanceValue,\n    readAcl,\n    timed,\n    isConditional: true,\n    optionalIf,\n    mandatoryIf,\n    unknown: false,\n});\n\nexport interface UnknownAttribute<T, F extends BitSchema> extends Attribute<T, F> {\n    unknown: true;\n}\nexport const UnknownAttribute = <F extends BitSchema>(id: number): UnknownAttribute<any, F> => ({\n    id: AttributeId(id),\n    schema: TlvAny,\n    optional: false,\n    writable: true,\n    fixed: false,\n    scene: false,\n    persistent: false,\n    fabricScoped: false,\n    omitChanges: true, // We assume custom clusters do mot report values via subscription because we do not know it\n    default: undefined,\n    readAcl: AccessLevel.View,\n    timed: false,\n    isConditional: true,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: true,\n});\n\nexport type MandatoryAttributeNames<A extends Attributes> = {\n    [K in keyof A]: A[K] extends OptionalAttribute<any, any> ? never : K;\n}[keyof A];\nexport type OptionalAttributeNames<A extends Attributes> = {\n    [K in keyof A]: A[K] extends OptionalAttribute<any, any> ? K : never;\n}[keyof A];\nexport type GlobalAttributeNames<F extends BitSchema> = keyof GlobalAttributes<F>;\n\n/* Interfaces and helper methods to define a cluster command */\nexport const TlvNoResponse = TlvVoid;\n\nexport interface Command<RequestT, ResponseT, F extends BitSchema> {\n    optional: boolean;\n    requestId: CommandId;\n    requestSchema: TlvSchema<RequestT>;\n    responseId: CommandId;\n    responseSchema: TlvSchema<ResponseT>;\n    invokeAcl: AccessLevel;\n    timed: boolean;\n    isConditional: boolean;\n    mandatoryIf: ConditionalFeatureList<F>;\n    optionalIf: ConditionalFeatureList<F>;\n}\n\nexport interface OptionalCommand<RequestT, ResponseT, F extends BitSchema> extends Command<RequestT, ResponseT, F> {\n    optional: true;\n}\n\nexport interface ConditionalCommand<RequestT, ResponseT, F extends BitSchema>\n    extends OptionalCommand<RequestT, ResponseT, F> {\n    isConditional: true;\n}\n\nexport type ResponseType<T extends Command<any, any, any>> =\n    T extends OptionalCommand<any, infer ResponseT, any>\n        ? ResponseT\n        : T extends Command<any, infer ResponseT, any>\n          ? ResponseT\n          : never;\nexport type RequestType<T extends Command<any, any, any>> =\n    T extends OptionalCommand<infer RequestT, any, any>\n        ? RequestT\n        : T extends Command<infer RequestT, any, any>\n          ? RequestT\n          : never;\n\ninterface CommandOptions {\n    invokeAcl?: AccessLevel;\n    timed?: boolean;\n}\n\ninterface ConditionalCommandOptions<F extends BitSchema> extends CommandOptions {\n    optionalIf?: ConditionalFeatureList<F>;\n    mandatoryIf?: ConditionalFeatureList<F>;\n}\n\nexport const Command = <RequestT, ResponseT, F extends BitSchema>(\n    requestId: number,\n    requestSchema: TlvSchema<RequestT>,\n    responseId: number,\n    responseSchema: TlvSchema<ResponseT>,\n    { invokeAcl = AccessLevel.Operate, timed = false }: CommandOptions = {},\n): Command<RequestT, ResponseT, F> => ({\n    optional: false,\n    requestId: CommandId(requestId),\n    requestSchema,\n    responseId: CommandId(responseId),\n    responseSchema,\n    invokeAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n});\n\nexport const OptionalCommand = <RequestT, ResponseT, F extends BitSchema>(\n    requestId: number,\n    requestSchema: TlvSchema<RequestT>,\n    responseId: number,\n    responseSchema: TlvSchema<ResponseT>,\n    { invokeAcl = AccessLevel.Operate, timed = false }: CommandOptions = {},\n): OptionalCommand<RequestT, ResponseT, F> => ({\n    optional: true,\n    requestId: CommandId(requestId),\n    requestSchema,\n    responseId: CommandId(responseId),\n    responseSchema,\n    invokeAcl,\n    timed,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n});\n\nexport const ConditionalCommand = <RequestT, ResponseT, F extends BitSchema>(\n    requestId: number,\n    requestSchema: TlvSchema<RequestT>,\n    responseId: number,\n    responseSchema: TlvSchema<ResponseT>,\n    {\n        invokeAcl = AccessLevel.Operate,\n        timed = false,\n        optionalIf = [],\n        mandatoryIf = [],\n    }: ConditionalCommandOptions<F> = {},\n): ConditionalCommand<RequestT, ResponseT, F> => ({\n    optional: true,\n    requestId: CommandId(requestId),\n    requestSchema,\n    responseId: CommandId(responseId),\n    responseSchema,\n    invokeAcl,\n    timed,\n    isConditional: true,\n    optionalIf,\n    mandatoryIf,\n});\n\n/**\n * Interfaces and helper methods to define a cluster event\n * @see {@link MatterSpecification.v11.Core} \u00A7 7.18.2.25\n */\nexport enum EventPriority {\n    Debug,\n    Info,\n    Critical,\n}\n\nexport interface Event<T, F extends BitSchema> {\n    id: EventId;\n    schema: TlvSchema<T>;\n    priority: EventPriority;\n    optional: boolean;\n    readAcl: AccessLevel;\n    isConditional: boolean;\n    optionalIf: ConditionalFeatureList<F>;\n    mandatoryIf: ConditionalFeatureList<F>;\n    unknown: boolean;\n}\n\nexport interface UnknownEvent<F extends BitSchema> extends Event<any, F> {\n    unknown: true;\n}\n\ninterface EventOptions {\n    readAcl?: AccessLevel;\n}\n\ninterface ConditionalEventOptions<F extends BitSchema> extends EventOptions {\n    optionalIf?: ConditionalFeatureList<F>;\n    mandatoryIf?: ConditionalFeatureList<F>;\n}\n\nexport interface OptionalEvent<T, F extends BitSchema> extends Event<T, F> {\n    optional: true;\n}\n\nexport interface ConditionalEvent<T, F extends BitSchema> extends OptionalEvent<T, F> {\n    isConditional: true;\n}\n\nexport const Event = <T, F extends BitSchema>(\n    id: number,\n    priority: EventPriority,\n    schema: TlvSchema<T>,\n    { readAcl = AccessLevel.View }: EventOptions = {},\n): Event<T, F> => ({\n    id: EventId(id),\n    schema,\n    priority,\n    optional: false,\n    isConditional: false,\n    readAcl,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const OptionalEvent = <T, F extends BitSchema>(\n    id: number,\n    priority: EventPriority,\n    schema: TlvSchema<T>,\n    { readAcl = AccessLevel.View }: EventOptions = {},\n): OptionalEvent<T, F> => ({\n    id: EventId(id),\n    schema,\n    priority,\n    optional: true,\n    readAcl,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: false,\n});\n\nexport const ConditionalEvent = <T, F extends BitSchema>(\n    id: EventId,\n    priority: EventPriority,\n    schema: TlvSchema<T>,\n    { readAcl = AccessLevel.View, optionalIf = [], mandatoryIf = [] }: ConditionalEventOptions<F>,\n): ConditionalEvent<T, F> => ({\n    id: EventId(id),\n    schema,\n    priority,\n    optional: true,\n    readAcl,\n    isConditional: true,\n    optionalIf,\n    mandatoryIf,\n    unknown: false,\n});\n\nexport const UnknownEvent = <F extends BitSchema>(id: number): Event<unknown, F> => ({\n    id: EventId(id),\n    schema: TlvVoid,\n    priority: EventPriority.Debug,\n    optional: false,\n    readAcl: AccessLevel.View,\n    isConditional: false,\n    optionalIf: [],\n    mandatoryIf: [],\n    unknown: true,\n});\n\nexport type EventType<T extends Event<any, any>> =\n    T extends OptionalEvent<infer EventT, any> ? EventT : T extends Event<infer EventT, any> ? EventT : never;\nexport type MandatoryEventNames<E extends Events> = {\n    [K in keyof E]: E[K] extends OptionalEvent<any, any> ? never : K;\n}[keyof E];\nexport type OptionalEventNames<E extends Events> = {\n    [K in keyof E]: E[K] extends OptionalEvent<any, any> ? K : never;\n}[keyof E];\n\n/* Interfaces and helper methods to define a cluster */\nexport interface Attributes {\n    [key: string]: Attribute<any, any>;\n}\n\nexport interface Commands {\n    [key: string]: Command<any, any, any>;\n}\n\nexport interface Events {\n    [key: string]: Event<any, any>;\n}\n\n// TODO Adjust typing to be derived from the schema below\n/** @see {@link MatterSpecification.v11.Core} \u00A7 7.13 */\nexport type GlobalAttributes<F extends BitSchema> = {\n    /** Indicates the revision of the server cluster specification supported by the cluster instance. */\n    clusterRevision: Attribute<number, never>;\n\n    /** Indicates whether the server supports zero or more optional cluster features. */\n    featureMap: Attribute<TypeFromPartialBitSchema<F>, never>;\n\n    /** List of the attribute IDs of the attributes supported by the cluster instance. */\n    attributeList: Attribute<AttributeId[], never>;\n\n    /** List of the event IDs of the events supported by the cluster instance. */\n    eventList: Attribute<EventId[], never>;\n\n    /** List of client generated commands which are supported by this cluster server instance. */\n    acceptedCommandList: Attribute<CommandId[], never>;\n\n    /** List of server generated commands (server to client commands). */\n    generatedCommandList: Attribute<CommandId[], never>;\n};\n\nexport const GlobalAttributes = <F extends BitSchema>(features: F) =>\n    ({\n        clusterRevision: Attribute(0xfffd, TlvUInt16),\n        featureMap: Attribute(0xfffc, TlvBitmap(TlvUInt32, features)),\n        attributeList: Attribute(0xfffb, TlvArray(TlvAttributeId)),\n        eventList: Attribute(0xfffa, TlvArray(TlvEventId)),\n        acceptedCommandList: Attribute(0xfff9, TlvArray(TlvCommandId)),\n        generatedCommandList: Attribute(0xfff8, TlvArray(TlvCommandId)),\n    }) as GlobalAttributes<F>;\n\nexport interface Cluster<\n    F extends BitSchema,\n    SF extends TypeFromPartialBitSchema<F>,\n    A extends Attributes,\n    C extends Commands,\n    E extends Events,\n> {\n    id: ClusterId;\n    name: string;\n    revision: number;\n    features: F;\n    supportedFeatures: SF;\n    attributes: A;\n    commands: C;\n    events: E;\n    unknown: boolean;\n}\n\nexport const Cluster = <\n    F extends BitSchema,\n    SF extends TypeFromPartialBitSchema<F>,\n    A extends Attributes = {},\n    C extends Commands = {},\n    E extends Events = {},\n>({\n    id,\n    name,\n    revision,\n    features = <F>{},\n    supportedFeatures = <SF>{},\n    attributes = <A>{},\n    commands = <C>{},\n    events = <E>{},\n    unknown = false,\n}: {\n    id: number;\n    name: string;\n    revision: number;\n    features?: F;\n    supportedFeatures?: SF;\n    attributes?: A;\n    commands?: C;\n    events?: E;\n    unknown?: boolean;\n}): Cluster<F, SF, Merge<A, GlobalAttributes<F>>, C, E> => ({\n    id: ClusterId(id),\n    name,\n    revision,\n    features,\n    supportedFeatures,\n    commands,\n    attributes: Merge(attributes, GlobalAttributes(features)),\n    events,\n    unknown,\n});\n\ntype ClusterExtend<\n    F extends BitSchema,\n    SF extends TypeFromPartialBitSchema<F>,\n    A extends Attributes,\n    C extends Commands,\n    E extends Events,\n> = {\n    supportedFeatures: SF;\n    attributes?: A;\n    commands?: C;\n    events?: E;\n};\n\nexport const ClusterExtend = <\n    F extends BitSchema,\n    SF_BASE extends TypeFromPartialBitSchema<F>,\n    SF_EXTEND extends TypeFromPartialBitSchema<F>,\n    A_BASE extends Attributes = {},\n    C_BASE extends Commands = {},\n    E_BASE extends Events = {},\n    A_EXTEND extends Attributes = {},\n    C_EXTEND extends Commands = {},\n    E_EXTEND extends Events = {},\n>(\n    {\n        id,\n        name,\n        revision,\n        features,\n        supportedFeatures,\n        attributes,\n        commands,\n        events,\n        unknown,\n    }: Cluster<F, SF_BASE, A_BASE, C_BASE, E_BASE>,\n    {\n        supportedFeatures: supportedFeaturesExtend,\n        attributes: attributesExtend = <A_EXTEND>{},\n        commands: commandsExtend = <C_EXTEND>{},\n        events: eventsExtend = <E_EXTEND>{},\n    }: ClusterExtend<F, SF_EXTEND, A_EXTEND, C_EXTEND, E_EXTEND>,\n): Cluster<\n    F,\n    Merge<SF_BASE, SF_EXTEND>,\n    Merge<A_BASE, A_EXTEND>,\n    Merge<C_BASE, C_EXTEND>,\n    Merge<E_BASE, E_EXTEND>\n> => ({\n    id,\n    name,\n    revision,\n    features,\n    supportedFeatures: Merge(supportedFeatures, supportedFeaturesExtend),\n    attributes: Merge(attributes, attributesExtend),\n    commands: Merge(commands, commandsExtend),\n    events: Merge(events, eventsExtend),\n    unknown,\n});\n"],
  "mappings": "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",
  "names": ["AccessLevel", "EventPriority"]
}
