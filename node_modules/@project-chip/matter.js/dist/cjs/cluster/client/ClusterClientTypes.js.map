{
  "version": 3,
  "sources": ["../../../../src/cluster/client/ClusterClientTypes.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { DecodedEventData } from \"../../protocol/interaction/EventDataDecoder.js\";\nimport { TlvEventFilter } from \"../../protocol/interaction/InteractionProtocol.js\";\nimport { BitSchema, TypeFromPartialBitSchema } from \"../../schema/BitmapSchema.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { Merge } from \"../../util/Type.js\";\nimport {\n    Attribute,\n    AttributeJsType,\n    Attributes,\n    Command,\n    Commands,\n    EventType,\n    Events,\n    GlobalAttributeNames,\n    GlobalAttributes,\n    MandatoryAttributeNames,\n    MandatoryEventNames,\n    OptionalAttribute,\n    OptionalAttributeNames,\n    OptionalEventNames,\n    OptionalWritableAttribute,\n    RequestType,\n    ResponseType,\n    WritableAttribute,\n} from \"../Cluster.js\";\nimport { ClusterType } from \"../ClusterType.js\";\nimport { ClusterServerObj } from \"../server/ClusterServerTypes.js\";\nimport { AttributeClient } from \"./AttributeClient.js\";\nimport { EventClient } from \"./EventClient.js\";\n\nexport type AttributeClients<F extends BitSchema, A extends Attributes> = Merge<\n    Merge<\n        { [P in MandatoryAttributeNames<A>]: AttributeClient<AttributeJsType<A[P]>> },\n        { [P in OptionalAttributeNames<A>]: AttributeClient<AttributeJsType<A[P]> | undefined> }\n    >,\n    { [P in GlobalAttributeNames<F>]: AttributeClient<AttributeJsType<GlobalAttributes<F>[P]>> }\n>;\n\nexport type EventClients<E extends Events> = Merge<\n    { [P in MandatoryEventNames<E>]: EventClient<EventType<E[P]>> },\n    { [P in OptionalEventNames<E>]: EventClient<EventType<E[P]> | undefined> }\n>;\n\nexport type SignatureFromCommandSpec<C extends Command<any, any, any>> = (\n    request: RequestType<C>,\n    options?: {\n        /** Send this command as a timed request also when not required. Default timeout are 10 seconds. */\n        asTimedRequest?: boolean;\n\n        /** Override the request timeout when the command is sent as times request. Default are 10s. */\n        timedRequestTimeoutMs?: number;\n\n        /**\n         * Use the extended fail-safe message response timeout of 30 seconds. Use this for all commands\n         * executed during an activated FailSafe context!\n         */\n        useExtendedFailSafeMessageResponseTimeout?: boolean;\n    },\n) => Promise<ResponseType<C>>;\ntype GetterTypeFromSpec<A extends Attribute<any, any>> =\n    A extends OptionalAttribute<infer T, any> ? T | undefined : AttributeJsType<A>;\ntype ClientAttributeGetters<A extends Attributes> = Omit<\n    {\n        [P in keyof A as `get${Capitalize<string & P>}Attribute`]: (\n            alwaysRequestFromRemote?: boolean,\n            isFabricFiltered?: boolean,\n        ) => Promise<GetterTypeFromSpec<A[P]>>;\n    },\n    keyof GlobalAttributes<any>\n>;\ntype ClientGlobalAttributeGetters<F extends BitSchema> = {\n    [P in GlobalAttributeNames<F> as `get${Capitalize<string & P>}Attribute`]: () => Promise<\n        GetterTypeFromSpec<GlobalAttributes<F>[P]>\n    >;\n};\ntype WritableAttributeNames<A extends Attributes> =\n    | { [K in keyof A]: A[K] extends WritableAttribute<any, any> ? K : never }[keyof A]\n    | { [K in keyof A]: A[K] extends OptionalWritableAttribute<any, any> ? K : never }[keyof A];\ntype ClientAttributeSetters<A extends Attributes> = {\n    [P in WritableAttributeNames<A> as `set${Capitalize<string & P>}Attribute`]: (\n        value: AttributeJsType<A[P]>,\n    ) => Promise<void>;\n};\ntype ClientAttributeSubscribers<A extends Attributes> = {\n    [P in keyof A as `subscribe${Capitalize<string & P>}Attribute`]: (\n        listener: (value: AttributeJsType<A[P]>) => void,\n        minIntervalS: number,\n        maxIntervalS: number,\n        knownDataVersion?: number,\n        isFabricFiltered?: boolean,\n    ) => Promise<void>;\n};\ntype ClientAttributeListeners<A extends Attributes> = {\n    [P in keyof A as `add${Capitalize<string & P>}AttributeListener`]: (\n        listener: (value: AttributeJsType<A[P]>) => void,\n    ) => void;\n};\n\ntype CommandServers<C extends Commands> = { [P in keyof C]: SignatureFromCommandSpec<C[P]> };\n\ntype ClientEventGetters<E extends Events> = {\n    [P in keyof E as `get${Capitalize<string & P>}Event`]: (\n        minimumEventNumber?: number | bigint,\n        isFabricFiltered?: boolean,\n    ) => Promise<DecodedEventData<EventType<E[P]>>>;\n};\ntype ClientEventSubscribers<E extends Events> = {\n    [P in keyof E as `subscribe${Capitalize<string & P>}Event`]: (\n        listener: (value: DecodedEventData<EventType<E[P]>>) => void,\n        minIntervalS: number,\n        maxIntervalS: number,\n        isUrgent?: boolean,\n        minimumEventNumber?: number | bigint,\n        isFabricFiltered?: boolean,\n    ) => Promise<void>;\n};\ntype ClientEventListeners<E extends Events> = {\n    [P in keyof E as `add${Capitalize<string & P>}EventListener`]: (\n        listener: (value: DecodedEventData<EventType<E[P]>>) => void,\n    ) => void;\n};\n\n/** Strongly typed interface of a cluster client */\nexport type ClusterClientObj<T extends ClusterType = ClusterType> = {\n    /**\n     * Cluster ID\n     * @readonly\n     */\n    id: ClusterId;\n\n    /**\n     * Cluster type\n     * @private\n     * @readonly\n     */\n    _type: \"ClusterClient\";\n\n    /**\n     * Cluster revision\n     * @readonly\n     */\n    readonly revision: number;\n\n    /**\n     * Cluster name\n     * @readonly\n     */\n    readonly name: string;\n\n    /**\n     * Whether the cluster is unknown, means that we do not have types and schema information for it. Most likely no\n     * official cluster.\n     * @readonly\n     */\n    readonly isUnknown: boolean;\n\n    /**\n     * Endpoint ID the cluster is on.\n     * @readonly\n     */\n    readonly endpointId: number;\n\n    /**\n     * Supported Features of the cluster\n     * @readonly\n     */\n    readonly supportedFeatures: TypeFromPartialBitSchema<T[\"features\"]>;\n\n    /**\n     * Attributes of the cluster as object with named keys. This can be used to discover the attributes of the cluster\n     * programmatically.\n     * @readonly\n     */\n    readonly attributes: AttributeClients<T[\"features\"], T[\"attributes\"]>;\n\n    /**\n     * Events of the cluster as object with named keys. This can be used to discover the events of the cluster\n     * programmatically.\n     * @readonly\n     */\n    readonly events: EventClients<T[\"events\"]>;\n\n    /**\n     * Commands of the cluster as object with named keys. This can be used to discover the commands of the cluster\n     * programmatically.\n     * @readonly\n     */\n    readonly commands: CommandServers<T[\"commands\"]>;\n\n    /**\n     * Subscribe to all attributes of the cluster. This will subscribe to all attributes of the cluster. Add listeners\n     * to the relevant attributes you want to get updates for.\n     */\n    readonly subscribeAllAttributes: (options: {\n        minIntervalFloorSeconds: number;\n        maxIntervalCeilingSeconds: number;\n        keepSubscriptions?: boolean;\n        isFabricFiltered?: boolean;\n        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];\n        dataVersionFilters?: { endpointId: EndpointNumber; clusterId: ClusterId; dataVersion: number }[];\n    }) => Promise<void>;\n\n    /** Returns if a given Attribute Id is present and supported at the connected cluster server. */\n    isAttributeSupported: (attributeId: AttributeId) => boolean;\n\n    /** Returns if a given Attribute with provided name is present and supported at the connected cluster server. */\n    isAttributeSupportedByName: (attributeName: string) => boolean;\n\n    /** Returns if a given Event Id is present and supported at the connected cluster server. */\n    isEventSupported: (eventId: EventId) => boolean;\n\n    /** Returns if a given Event with provided name is present and supported at the connected cluster server. */\n    isEventSupportedByName: (eventName: string) => boolean;\n\n    /** Returns if a given Command Id is present and supported at the connected cluster server. */\n    isCommandSupported: (commandId: CommandId) => boolean;\n\n    /** Returns if a given Command with provided name is present and supported at the connected cluster server. */\n    isCommandSupportedByName: (commandName: string) => boolean;\n} & ClientAttributeGetters<T[\"attributes\"]> &\n    ClientGlobalAttributeGetters<T[\"features\"]> &\n    ClientAttributeSetters<T[\"attributes\"]> &\n    ClientAttributeSubscribers<T[\"attributes\"]> &\n    ClientAttributeListeners<T[\"attributes\"]> &\n    CommandServers<T[\"commands\"]> &\n    ClientEventGetters<T[\"events\"]> &\n    ClientEventSubscribers<T[\"events\"]> &\n    ClientEventListeners<T[\"events\"]>;\n\nexport type ClusterClientObjInternal<T extends ClusterType = ClusterType> = ClusterClientObj<T> & {\n    /**\n     * Trigger an attribute update. This is mainly used internally and not needed to be called by the user.\n     * @private\n     */\n    readonly _triggerAttributeUpdate: (attributeId: AttributeId, value: any) => void;\n\n    /**\n     * Trigger an event update. This is mainly used internally and not needed to be called by the user.\n     * @private\n     */\n    readonly _triggerEventUpdate: (eventId: EventId, events: DecodedEventData<any>[]) => void;\n};\n\nexport function isClusterClient<const T extends ClusterType>(\n    obj: ClusterClientObj<T> | ClusterServerObj<T>,\n): obj is ClusterClientObj<T> {\n    return obj._type === \"ClusterClient\";\n}\n\nexport function isClusterClientInternal<const T extends ClusterType>(\n    obj: ClusterClientObj<T> | ClusterServerObj<T>,\n): obj is ClusterClientObjInternal<T> {\n    return obj._type === \"ClusterClient\";\n}\n\nexport function asClusterClientInternal<const T extends ClusterType>(\n    obj: ClusterClientObj<T>,\n): ClusterClientObjInternal<T> {\n    if (!isClusterClientInternal(obj)) {\n        throw new Error(\"Object is not a ClusterClientObj instance.\");\n    }\n    return obj;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6PO,SAAS,gBACZ,KAC0B;AAC1B,SAAO,IAAI,UAAU;AACzB;AAEO,SAAS,wBACZ,KACkC;AAClC,SAAO,IAAI,UAAU;AACzB;AAEO,SAAS,wBACZ,KAC2B;AAC3B,MAAI,CAAC,wBAAwB,GAAG,GAAG;AAC/B,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AACA,SAAO;AACX;",
  "names": []
}
