"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MatterController_exports = {};
__export(MatterController_exports, {
  MatterController: () => MatterController,
  PairRetransmissionLimitReachedError: () => PairRetransmissionLimitReachedError
});
module.exports = __toCommonJS(MatterController_exports);
var import_Ble = require("./ble/Ble.js");
var import_RootCertificateManager = require("./certificate/RootCertificateManager.js");
var import_ClusterClient = require("./cluster/client/ClusterClient.js");
var import_GeneralCommissioningCluster = require("./cluster/definitions/GeneralCommissioningCluster.js");
var import_MatterError = require("./common/MatterError.js");
var import_ServerAddress = require("./common/ServerAddress.js");
var import_Crypto = require("./crypto/Crypto.js");
var import_EndpointNumber = require("./datatype/EndpointNumber.js");
var import_FabricId = require("./datatype/FabricId.js");
var import_FabricIndex = require("./datatype/FabricIndex.js");
var import_NodeId = require("./datatype/NodeId.js");
var import_VendorId = require("./datatype/VendorId.js");
var import_Fabric = require("./fabric/Fabric.js");
var import_Logger = require("./log/Logger.js");
var import_MdnsScanner = require("./mdns/MdnsScanner.js");
var import_Specification = require("./model/definitions/Specification.js");
var import_ChannelManager = require("./protocol/ChannelManager.js");
var import_ControllerCommissioner = require("./protocol/ControllerCommissioner.js");
var import_ControllerDiscovery = require("./protocol/ControllerDiscovery.js");
var import_ExchangeManager = require("./protocol/ExchangeManager.js");
var import_MessageExchange = require("./protocol/MessageExchange.js");
var import_InteractionClient = require("./protocol/interaction/InteractionClient.js");
var import_SecureChannelMessages = require("./protocol/securechannel/SecureChannelMessages.js");
var import_SecureChannelProtocol = require("./protocol/securechannel/SecureChannelProtocol.js");
var import_Session = require("./session/Session.js");
var import_SessionManager = require("./session/SessionManager.js");
var import_CaseClient = require("./session/case/CaseClient.js");
var import_PaseClient = require("./session/pase/PaseClient.js");
var import_StorageBackendMemory = require("./storage/StorageBackendMemory.js");
var import_StorageManager = require("./storage/StorageManager.js");
var import_Time = require("./time/Time.js");
var import_TlvNumber = require("./tlv/TlvNumber.js");
var import_TlvObject = require("./tlv/TlvObject.js");
var import_TlvString = require("./tlv/TlvString.js");
var import_Construction = require("./util/Construction.js");
var import_Ip = require("./util/Ip.js");
var import_Promises = require("./util/Promises.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const TlvCommissioningSuccessFailureResponse = (0, import_TlvObject.TlvObject)({
  /** Contain the result of the operation. */
  errorCode: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
  /** Should help developers in troubleshooting errors. The value MAY go into logs or crash reports, not User UIs. */
  debugText: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 128 }))
});
const DEFAULT_FABRIC_INDEX = (0, import_FabricIndex.FabricIndex)(1);
const DEFAULT_FABRIC_ID = (0, import_FabricId.FabricId)(1);
const DEFAULT_ADMIN_VENDOR_ID = (0, import_VendorId.VendorId)(65521);
const RECONNECTION_POLLING_INTERVAL = 10 * 60 * 1e3;
const CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE = 3;
const CONTROLLER_MAX_PATHS_PER_INVOKE = 10;
const logger = import_Logger.Logger.get("MatterController");
class PairRetransmissionLimitReachedError extends import_MessageExchange.RetransmissionLimitReachedError {
}
class MatterController {
  static async create(options) {
    const {
      sessionStorage,
      rootCertificateStorage,
      fabricStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      sessionClosedCallback,
      adminVendorId = (0, import_VendorId.VendorId)(DEFAULT_ADMIN_VENDOR_ID),
      adminFabricId = (0, import_FabricId.FabricId)(DEFAULT_FABRIC_ID),
      adminFabricIndex = (0, import_FabricIndex.FabricIndex)(DEFAULT_FABRIC_INDEX),
      caseAuthenticatedTags
    } = options;
    const certificateManager = await import_RootCertificateManager.RootCertificateManager.create(rootCertificateStorage);
    let controller;
    if (await fabricStorage.has("fabric")) {
      const fabric = import_Fabric.Fabric.createFromStorageObject(await fabricStorage.get("fabric"));
      controller = new MatterController({
        sessionStorage,
        fabricStorage,
        nodesStorage,
        mdnsScanner,
        netInterfaceIpv4,
        netInterfaceIpv6,
        certificateManager,
        fabric,
        adminVendorId: fabric.rootVendorId,
        sessionClosedCallback
      });
    } else {
      const rootNodeId = import_NodeId.NodeId.randomOperationalNodeId();
      const ipkValue = import_Crypto.Crypto.getRandomData(import_Crypto.CRYPTO_SYMMETRIC_KEY_LENGTH);
      const fabricBuilder = new import_Fabric.FabricBuilder().setRootCert(certificateManager.rootCert).setRootNodeId(rootNodeId).setIdentityProtectionKey(ipkValue).setRootVendorId(adminVendorId);
      fabricBuilder.setOperationalCert(
        certificateManager.generateNoc(
          fabricBuilder.publicKey,
          adminFabricId,
          rootNodeId,
          caseAuthenticatedTags
        )
      );
      const fabric = await fabricBuilder.build(adminFabricIndex);
      controller = new MatterController({
        sessionStorage,
        fabricStorage,
        nodesStorage,
        mdnsScanner,
        netInterfaceIpv4,
        netInterfaceIpv6,
        certificateManager,
        fabric,
        adminVendorId,
        sessionClosedCallback
      });
    }
    await controller.construction;
    return controller;
  }
  static async createAsPaseCommissioner(options) {
    const {
      rootCertificateData,
      fabricData,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      sessionClosedCallback
    } = options;
    try {
      import_Ble.Ble.get();
    } catch (error) {
      import_MatterError.NoProviderError.accept(error);
      if (!mdnsScanner || !netInterfaceIpv6) {
        throw new import_MatterError.ImplementationError(
          "Ble must be initialized to create a Sub Commissioner without an IP network!"
        );
      }
      logger.info("BLE is not enabled. Using only IP network for commissioning.");
    }
    const certificateManager = await import_RootCertificateManager.RootCertificateManager.create(rootCertificateData);
    const storageManager = new import_StorageManager.StorageManager(new import_StorageBackendMemory.StorageBackendMemory());
    await storageManager.initialize();
    const sessionStorage = storageManager.createContext("sessions");
    const nodesStorage = storageManager.createContext("nodes");
    const fabric = import_Fabric.Fabric.createFromStorageObject(fabricData);
    const controller = new MatterController({
      sessionStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      certificateManager,
      fabric,
      adminVendorId: fabric.rootVendorId,
      sessionClosedCallback
    });
    await controller.construction;
    return controller;
  }
  sessionManager;
  channelManager = new import_ChannelManager.ChannelManager(CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE);
  exchangeManager;
  paseClient = new import_PaseClient.PaseClient();
  caseClient = new import_CaseClient.CaseClient();
  netInterfaceBle;
  bleScanner;
  commissionedNodes = /* @__PURE__ */ new Map();
  #construction;
  sessionStorage;
  fabricStorage;
  nodesStorage;
  mdnsScanner;
  netInterfaceIpv4;
  netInterfaceIpv6;
  certificateManager;
  fabric;
  adminVendorId;
  sessionClosedCallback;
  get construction() {
    return this.#construction;
  }
  constructor(options) {
    const {
      sessionStorage,
      fabricStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4,
      netInterfaceIpv6,
      certificateManager,
      fabric,
      sessionClosedCallback,
      adminVendorId
    } = options;
    this.sessionStorage = sessionStorage;
    this.fabricStorage = fabricStorage;
    this.nodesStorage = nodesStorage;
    this.mdnsScanner = mdnsScanner;
    this.netInterfaceIpv4 = netInterfaceIpv4;
    this.netInterfaceIpv6 = netInterfaceIpv6;
    this.certificateManager = certificateManager;
    this.fabric = fabric;
    this.sessionClosedCallback = sessionClosedCallback;
    this.adminVendorId = adminVendorId;
    this.sessionManager = new import_SessionManager.SessionManager(this, sessionStorage);
    this.sessionManager.sessionClosed.on(async (session) => {
      if (!session.closingAfterExchangeFinished) {
        await this.exchangeManager.closeSession(session);
      }
      this.sessionClosedCallback?.(session.peerNodeId);
    });
    this.exchangeManager = new import_ExchangeManager.ExchangeManager(this.sessionManager, this.channelManager);
    this.exchangeManager.addProtocolHandler(new import_SecureChannelProtocol.StatusReportOnlySecureChannelProtocol());
    if (netInterfaceIpv4 !== void 0) {
      this.addTransportInterface(netInterfaceIpv4);
    }
    if (netInterfaceIpv6 !== void 0) {
      this.addTransportInterface(netInterfaceIpv6);
    }
    this.#construction = (0, import_Construction.Construction)(this, async () => {
      if (await this.nodesStorage.has("commissionedNodes")) {
        const commissionedNodes = await this.nodesStorage.get("commissionedNodes");
        this.commissionedNodes.clear();
        for (const [nodeId, details] of commissionedNodes) {
          this.commissionedNodes.set(nodeId, details);
        }
      }
      await this.sessionManager.initFromStorage([this.fabric]);
    });
  }
  get nodeId() {
    return this.fabric.rootNodeId;
  }
  get rootCertificateData() {
    return this.certificateManager.data;
  }
  get fabricData() {
    return this.fabric.toStorageObject();
  }
  /** Returns our default session parameters for us as a controller. */
  get sessionParameters() {
    return {
      idleIntervalMs: import_Session.SESSION_IDLE_INTERVAL_MS,
      activeIntervalMs: import_Session.SESSION_ACTIVE_INTERVAL_MS,
      activeThresholdMs: import_Session.SESSION_ACTIVE_THRESHOLD_MS,
      dataModelRevision: import_Specification.Specification.DATA_MODEL_REVISION,
      interactionModelRevision: import_Specification.Specification.INTERACTION_MODEL_REVISION,
      specificationVersion: import_Specification.Specification.SPECIFICATION_VERSION,
      maxPathsPerInvoke: CONTROLLER_MAX_PATHS_PER_INVOKE
    };
  }
  addTransportInterface(netInterface) {
    this.exchangeManager.addTransportInterface(netInterface);
  }
  collectScanners(discoveryCapabilities = { onIpNetwork: true }) {
    const scannersToUse = new Array();
    if (this.mdnsScanner !== void 0) {
      scannersToUse.push(this.mdnsScanner);
    }
    if (discoveryCapabilities.ble) {
      if (this.bleScanner === void 0) {
        let ble;
        try {
          ble = import_Ble.Ble.get();
          this.netInterfaceBle = ble.getBleCentralInterface();
          this.addTransportInterface(this.netInterfaceBle);
          this.bleScanner = ble.getBleScanner();
        } catch (error) {
          import_MatterError.NoProviderError.accept(error);
          logger.warn("BLE is not supported on this platform. The device to commission might not be found!");
        }
      }
      if (this.bleScanner !== void 0) {
        scannersToUse.push(this.bleScanner);
      }
    }
    return scannersToUse;
  }
  /**
   * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first
   * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after
   * each other. It returns the NodeId of the commissioned device.
   * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing
   * request or the passode did not match to any discovered device/address.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commission(options, completeCommissioningCallback) {
    const {
      commissioning: commissioningOptions = {
        regulatoryLocation: import_GeneralCommissioningCluster.GeneralCommissioning.RegulatoryLocationType.Outdoor,
        // Set to the most restrictive if relevant
        regulatoryCountryCode: "XX"
      },
      discovery: { timeoutSeconds = 30 },
      passcode
    } = options;
    const commissionableDevice = "commissionableDevice" in options.discovery ? options.discovery.commissionableDevice : void 0;
    let {
      discovery: { discoveryCapabilities = {}, knownAddress }
    } = options;
    let identifierData = "identifierData" in options.discovery ? options.discovery.identifierData : {};
    if (this.mdnsScanner !== void 0 && this.netInterfaceIpv6 !== void 0) {
      discoveryCapabilities.onIpNetwork = true;
    }
    if (commissionableDevice !== void 0) {
      let { addresses } = commissionableDevice;
      if (discoveryCapabilities.ble === true) {
        discoveryCapabilities = { onIpNetwork: true, ble: addresses.some((address) => address.type === "ble") };
      } else if (discoveryCapabilities.onIpNetwork === true) {
        addresses = addresses.filter((address) => address.type !== "ble");
      }
      addresses.sort((a) => a.type === "udp" ? -1 : 1);
      knownAddress = addresses[0];
      if ("instanceId" in commissionableDevice && commissionableDevice.instanceId !== void 0) {
        identifierData = { instanceId: commissionableDevice.instanceId };
      } else {
        identifierData = { longDiscriminator: commissionableDevice.D };
      }
    }
    const scannersToUse = this.collectScanners(discoveryCapabilities);
    logger.info(
      `Commissioning device with identifier ${import_Logger.Logger.toJSON(identifierData)} and ${scannersToUse.length} scanners and knownAddress ${import_Logger.Logger.toJSON(knownAddress)}`
    );
    let paseSecureChannel;
    let discoveryData;
    if (knownAddress !== void 0) {
      try {
        paseSecureChannel = await this.initializePaseSecureChannel(knownAddress, passcode);
      } catch (error) {
        import_MessageExchange.RetransmissionLimitReachedError.accept(error);
      }
    }
    if (paseSecureChannel === void 0) {
      const discoveredDevices = await import_ControllerDiscovery.ControllerDiscovery.discoverDeviceAddressesByIdentifier(
        scannersToUse,
        identifierData,
        timeoutSeconds
      );
      const { result } = await import_ControllerDiscovery.ControllerDiscovery.iterateServerAddresses(
        discoveredDevices,
        import_MessageExchange.RetransmissionLimitReachedError,
        async () => scannersToUse.flatMap((scanner) => scanner.getDiscoveredCommissionableDevices(identifierData)),
        async (address, device) => {
          const channel = await this.initializePaseSecureChannel(address, passcode, device);
          discoveryData = device;
          return channel;
        }
      );
      paseSecureChannel = result;
    }
    return await this.commissionDevice(
      paseSecureChannel,
      commissioningOptions,
      discoveryData,
      completeCommissioningCallback
    );
  }
  async disconnect(nodeId) {
    await this.sessionManager.removeAllSessionsForNode(nodeId, true);
    await this.channelManager.removeAllNodeChannels(this.fabric, nodeId);
  }
  async removeNode(nodeId) {
    logger.info(`Removing commissioned node ${nodeId} from controller.`);
    await this.sessionManager.removeAllSessionsForNode(nodeId);
    await this.sessionManager.removeResumptionRecord(nodeId);
    await this.channelManager.removeAllNodeChannels(this.fabric, nodeId);
    this.commissionedNodes.delete(nodeId);
    await this.storeCommissionedNodes();
  }
  /**
   * Method to start commission process with a PASE pairing.
   * If this not successful and throws an RetransmissionLimitReachedError the address is invalid or the passcode
   * is wrong.
   */
  async initializePaseSecureChannel(address, passcode, device) {
    let paseChannel;
    if (device !== void 0) {
      logger.info(`Commissioning device`, import_MdnsScanner.MdnsScanner.discoveryDataDiagnostics(device));
    }
    if (address.type === "udp") {
      const { ip } = address;
      const isIpv6Address = (0, import_Ip.isIPv6)(ip);
      const paseInterface = isIpv6Address ? this.netInterfaceIpv6 : this.netInterfaceIpv4;
      if (paseInterface === void 0) {
        throw new PairRetransmissionLimitReachedError(
          `IPv${isIpv6Address ? "6" : "4"} interface not initialized. Cannot use ${ip} for commissioning.`
        );
      }
      paseChannel = await paseInterface.openChannel(address);
    } else {
      if (this.netInterfaceBle === void 0) {
        throw new PairRetransmissionLimitReachedError(
          `BLE interface not initialized. Cannot use ${address.peripheralAddress} for commissioning.`
        );
      }
      paseChannel = await this.netInterfaceBle.openChannel(address);
    }
    const unsecureSession = this.sessionManager.createUnsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: device?.SII,
        activeIntervalMs: device?.SAI,
        activeThresholdMs: device?.SAT
      },
      isInitiator: true
    });
    const paseUnsecureMessageChannel = new import_ExchangeManager.MessageChannel(paseChannel, unsecureSession);
    const paseExchange = this.exchangeManager.initiateExchangeWithChannel(
      paseUnsecureMessageChannel,
      import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID
    );
    let paseSecureSession;
    try {
      paseSecureSession = await this.paseClient.pair(this, paseExchange, passcode);
    } catch (e) {
      await paseExchange.close();
      throw e;
    }
    await unsecureSession.destroy();
    return new import_ExchangeManager.MessageChannel(paseChannel, paseSecureSession);
  }
  /**
   * Method to commission a device with a PASE secure channel. It returns the NodeId of the commissioned device on
   * success.
   */
  async commissionDevice(paseSecureMessageChannel, commissioningOptions, discoveryData, completeCommissioningCallback) {
    const peerNodeId = commissioningOptions.nodeId ?? import_NodeId.NodeId.randomOperationalNodeId();
    const commissioningManager = new import_ControllerCommissioner.ControllerCommissioner(
      // Use the created secure session to do the commissioning
      new import_InteractionClient.InteractionClient(new import_ExchangeManager.ExchangeProvider(this.exchangeManager, paseSecureMessageChannel), peerNodeId),
      this.certificateManager,
      this.fabric,
      commissioningOptions,
      peerNodeId,
      this.adminVendorId,
      async () => {
        await paseSecureMessageChannel.close();
        if (completeCommissioningCallback !== void 0) {
          if (!await completeCommissioningCallback(peerNodeId, discoveryData)) {
            throw new import_MessageExchange.RetransmissionLimitReachedError("Device could not be discovered");
          }
          throw new import_ControllerCommissioner.CommissioningSuccessfullyFinished();
        }
        return await this.connect(peerNodeId, 120, discoveryData);
      }
    );
    try {
      await commissioningManager.executeCommissioning();
    } catch (error) {
      if (this.commissionedNodes.has(peerNodeId)) {
        this.commissionedNodes.delete(peerNodeId);
      }
      throw error;
    }
    await this.fabricStorage?.set("fabric", this.fabric.toStorageObject());
    return peerNodeId;
  }
  /**
   * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.
   */
  async completeCommissioning(peerNodeId, discoveryData) {
    const interactionClient = await this.connect(peerNodeId, 120, discoveryData);
    const generalCommissioningClusterClient = (0, import_ClusterClient.ClusterClient)(
      import_GeneralCommissioningCluster.GeneralCommissioning.Cluster,
      (0, import_EndpointNumber.EndpointNumber)(0),
      interactionClient
    );
    const { errorCode, debugText } = await generalCommissioningClusterClient.commissioningComplete(void 0, {
      useExtendedFailSafeMessageResponseTimeout: true
    });
    if (errorCode !== import_GeneralCommissioningCluster.GeneralCommissioning.CommissioningError.Ok) {
      if (this.commissionedNodes.has(peerNodeId)) {
        this.commissionedNodes.delete(peerNodeId);
      }
      throw new import_ControllerCommissioner.CommissioningError(`Commission error on commissioningComplete: ${errorCode}, ${debugText}`);
    }
    await this.fabricStorage?.set("fabric", this.fabric.toStorageObject());
  }
  async reconnectLastKnownAddress(peerNodeId, operationalAddress, discoveryData) {
    const { ip, port } = operationalAddress;
    try {
      logger.debug(`Resume device connection to configured server at ${ip}:${port}`);
      const channel = await this.pair(peerNodeId, operationalAddress, discoveryData);
      await this.setOperationalDeviceData(peerNodeId, operationalAddress);
      return channel;
    } catch (error) {
      if (error instanceof import_MessageExchange.RetransmissionLimitReachedError || error instanceof Error && error.message.includes("EHOSTUNREACH")) {
        logger.debug(`Failed to resume device connection with ${ip}:${port}, discover the device ...`, error);
        return void 0;
      } else {
        throw error;
      }
    }
  }
  async connectOrDiscoverNode(peerNodeId, operationalAddress, timeoutSeconds, discoveryData) {
    if (this.mdnsScanner === void 0) {
      throw new import_MatterError.ImplementationError("Cannot discover device without mDNS scanner.");
    }
    const mdnsScanner = this.mdnsScanner;
    const discoveryPromises = new Array();
    let reconnectionPollingTimer;
    if (operationalAddress !== void 0) {
      const directReconnection = await this.reconnectLastKnownAddress(
        peerNodeId,
        operationalAddress,
        discoveryData
      );
      if (directReconnection !== void 0) {
        return directReconnection;
      }
      if (timeoutSeconds === void 0) {
        const { promise, resolver, rejecter } = (0, import_Promises.createPromise)();
        reconnectionPollingTimer = import_Time.Time.getPeriodicTimer(
          "Controller reconnect",
          RECONNECTION_POLLING_INTERVAL,
          async () => {
            try {
              logger.debug(`Polling for device at ${(0, import_ServerAddress.serverAddressToString)(operationalAddress)} ...`);
              const result = await this.reconnectLastKnownAddress(
                peerNodeId,
                operationalAddress,
                discoveryData
              );
              if (result !== void 0 && reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                resolver(result);
              }
            } catch (error) {
              if (reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                rejecter(error);
              }
            }
          }
        ).start();
        discoveryPromises.push(() => promise);
      }
    }
    discoveryPromises.push(async () => {
      const scanResult = await import_ControllerDiscovery.ControllerDiscovery.discoverOperationalDevice(
        this.fabric,
        peerNodeId,
        mdnsScanner,
        timeoutSeconds,
        timeoutSeconds === void 0
      );
      if (reconnectionPollingTimer?.isRunning) {
        reconnectionPollingTimer?.stop();
      }
      const { result } = await import_ControllerDiscovery.ControllerDiscovery.iterateServerAddresses(
        [scanResult],
        PairRetransmissionLimitReachedError,
        async () => {
          const device = mdnsScanner.getDiscoveredOperationalDevice(this.fabric, peerNodeId);
          return device !== void 0 ? [device] : [];
        },
        async (address, device) => {
          const result2 = await this.pair(peerNodeId, address, device);
          await this.setOperationalDeviceData(peerNodeId, address, {
            ...discoveryData,
            ...device
          });
          return result2;
        }
      );
      return result;
    });
    return await (0, import_Promises.anyPromise)(discoveryPromises);
  }
  /**
   * Resume a device connection and establish a CASE session that was previously paired with the controller. This
   * method will try to connect to the device using the previously used server address (if set). If that fails, the
   * device is discovered again using its operational instance details.
   * It returns the operational MessageChannel on success.
   */
  async resume(peerNodeId, timeoutSeconds, discoveryData) {
    const operationalAddress = this.getLastOperationalAddress(peerNodeId);
    try {
      return await this.connectOrDiscoverNode(peerNodeId, operationalAddress, timeoutSeconds, discoveryData);
    } catch (error) {
      if ((error instanceof import_ControllerDiscovery.DiscoveryError || error instanceof PairRetransmissionLimitReachedError) && this.commissionedNodes.has(peerNodeId)) {
        logger.info(`Resume failed, remove all sessions for node ${peerNodeId}`);
        await this.sessionManager.removeAllSessionsForNode(peerNodeId);
      }
      throw error;
    }
  }
  /** Pair with an operational device (already commissioned) and establish a CASE session. */
  async pair(peerNodeId, operationalServerAddress, discoveryData) {
    const { ip, port } = operationalServerAddress;
    const isIpv6Address = (0, import_Ip.isIPv6)(ip);
    const operationalInterface = isIpv6Address ? this.netInterfaceIpv6 : this.netInterfaceIpv4;
    if (operationalInterface === void 0) {
      throw new PairRetransmissionLimitReachedError(
        `IPv${isIpv6Address ? "6" : "4"} interface not initialized for port ${port}. Cannot use ${ip} for pairing.`
      );
    }
    const operationalChannel = await operationalInterface.openChannel(operationalServerAddress);
    const { sessionParameters } = this.findResumptionRecordByNodeId(peerNodeId) ?? {};
    const unsecureSession = this.sessionManager.createUnsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: discoveryData?.SII ?? sessionParameters?.idleIntervalMs,
        activeIntervalMs: discoveryData?.SAI ?? sessionParameters?.activeIntervalMs,
        activeThresholdMs: discoveryData?.SAT ?? sessionParameters?.activeThresholdMs
      },
      isInitiator: true
    });
    const operationalUnsecureMessageExchange = new import_ExchangeManager.MessageChannel(operationalChannel, unsecureSession);
    let operationalSecureSession;
    try {
      const exchange = this.exchangeManager.initiateExchangeWithChannel(
        operationalUnsecureMessageExchange,
        import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID
      );
      try {
        operationalSecureSession = await this.caseClient.pair(this, exchange, this.fabric, peerNodeId);
      } catch (e) {
        await exchange.close();
        throw e;
      }
    } catch (e) {
      import_MessageExchange.RetransmissionLimitReachedError.accept(e);
      throw new PairRetransmissionLimitReachedError(e.message);
    }
    await unsecureSession.destroy();
    const channel = new import_ExchangeManager.MessageChannel(operationalChannel, operationalSecureSession);
    await this.channelManager.setChannel(this.fabric, peerNodeId, channel);
    return channel;
  }
  isCommissioned() {
    return this.commissionedNodes.size > 0;
  }
  getCommissionedNodes() {
    return Array.from(this.commissionedNodes.keys());
  }
  getCommissionedNodesDetails() {
    return Array.from(this.commissionedNodes.entries()).map(
      ([nodeId, { operationalServerAddress, discoveryData, basicInformationData }]) => ({
        nodeId,
        operationalAddress: operationalServerAddress ? (0, import_ServerAddress.serverAddressToString)(operationalServerAddress) : void 0,
        advertisedName: discoveryData?.DN,
        discoveryData,
        basicInformationData
      })
    );
  }
  async setOperationalDeviceData(nodeId, operationalServerAddress, discoveryData) {
    const nodeDetails = this.commissionedNodes.get(nodeId) ?? {};
    nodeDetails.operationalServerAddress = operationalServerAddress;
    if (discoveryData !== void 0) {
      nodeDetails.discoveryData = {
        ...nodeDetails.discoveryData,
        ...discoveryData
      };
    }
    this.commissionedNodes.set(nodeId, nodeDetails);
    await this.storeCommissionedNodes();
  }
  async enhanceCommissionedNodeDetails(nodeId, data) {
    const nodeDetails = this.commissionedNodes.get(nodeId);
    if (nodeDetails === void 0) {
      throw new Error(`Node ${nodeId} is not commissioned.`);
    }
    const { basicInformationData } = data;
    nodeDetails.basicInformationData = basicInformationData;
    this.commissionedNodes.set(nodeId, nodeDetails);
    await this.storeCommissionedNodes();
  }
  getLastOperationalAddress(nodeId) {
    return this.commissionedNodes.get(nodeId)?.operationalServerAddress;
  }
  async storeCommissionedNodes() {
    await this.nodesStorage.set("commissionedNodes", Array.from(this.commissionedNodes.entries()));
  }
  /**
   * Connect to the device by opening a channel and creating a new CASE session if necessary.
   * Returns a InteractionClient on success.
   */
  async connect(peerNodeId, timeoutSeconds, discoveryData) {
    if (discoveryData == void 0) {
      discoveryData = this.commissionedNodes.get(peerNodeId)?.discoveryData;
    }
    let channel;
    try {
      channel = this.channelManager.getChannel(this.fabric, peerNodeId);
    } catch (error) {
      import_ChannelManager.NoChannelError.accept(error);
      channel = await this.resume(peerNodeId, timeoutSeconds, discoveryData);
    }
    return new import_InteractionClient.InteractionClient(
      new import_ExchangeManager.ExchangeProvider(this.exchangeManager, channel, async () => {
        await this.channelManager.removeAllNodeChannels(this.fabric, peerNodeId);
        await this.resume(peerNodeId, 60);
        return this.channelManager.getChannel(this.fabric, peerNodeId);
      }),
      peerNodeId
    );
  }
  async getNextAvailableSessionId() {
    return this.sessionManager.getNextAvailableSessionId();
  }
  getResumptionRecord(resumptionId) {
    return this.sessionManager.findResumptionRecordById(resumptionId);
  }
  findResumptionRecordByNodeId(nodeId) {
    return this.sessionManager.findResumptionRecordByNodeId(nodeId);
  }
  async saveResumptionRecord(resumptionRecord) {
    return this.sessionManager.saveResumptionRecord(resumptionRecord);
  }
  announce() {
  }
  async close() {
    await this.exchangeManager.close();
    await this.sessionManager.close();
    await this.channelManager.close();
    await this.netInterfaceBle?.close();
    await this.netInterfaceIpv4?.close();
    await this.netInterfaceIpv6?.close();
  }
  getActiveSessionInformation() {
    return this.sessionManager.getActiveSessionInformation();
  }
}
//# sourceMappingURL=MatterController.js.map
