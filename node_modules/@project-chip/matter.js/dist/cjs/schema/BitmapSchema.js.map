{
  "version": 3,
  "sources": ["../../../src/schema/BitmapSchema.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { UnexpectedDataError } from \"../common/MatterError.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { capitalize } from \"../util/String.js\";\nimport { Merge } from \"../util/Type.js\";\nimport { Schema } from \"./Schema.js\";\n\nconst enum BitRangeType {\n    Flag,\n    Number,\n    Enum,\n}\n\ntype BitRange<T, TType extends BitRangeType = BitRangeType> = {\n    type: TType;\n    offset: number;\n    length: number;\n    _type?: T;\n};\nconst BitRange = <T, TType extends BitRangeType = BitRangeType>(\n    type: TType,\n    offset: number,\n    length: number,\n): BitRange<T, TType> => ({ type, offset, length });\n\n/** Defines the bit position of a boolean flag. */\nexport type BitFlag = BitRange<boolean, BitRangeType.Flag>;\nexport const BitFlag = (offset: number): BitFlag => BitRange(BitRangeType.Flag, offset, 1);\n\n/** Defines the bit position and bit length of a numeric value. */\nexport type BitField = BitRange<number, BitRangeType.Number>;\nexport const BitField = (offset: number, length: number): BitField => BitRange(BitRangeType.Number, offset, length);\n\n/** Defines the bit position and bit length of an enum flag. */\nexport type BitFieldEnum<E extends number> = BitRange<E, BitRangeType.Enum>;\nexport const BitFieldEnum = <E extends number>(offset: number, length: number): BitFieldEnum<E> =>\n    BitRange(BitRangeType.Enum, offset, length);\n\nexport type BitSchema = { [key: string]: BitFlag | BitField | BitFieldEnum<any> };\nexport type TypeFromBitSchema<T extends BitSchema> = {\n    [K in keyof T]: T[K] extends BitFieldEnum<infer E> ? E : T[K] extends BitField ? number : boolean;\n};\nexport type TypeFromPartialBitSchema<T extends BitSchema> = {\n    [K in keyof T]?: T[K] extends BitFieldEnum<infer E> ? E : T[K] extends BitField ? number : boolean;\n};\nexport type TypeFromBitmapSchema<S extends Schema<any, any>> = S extends Schema<infer T, any> ? T : never;\n\ntype MaskFromBitSchema<T extends BitSchema> = { [K in keyof T]: number };\ntype MaskOffsetFromBitSchema<T extends BitSchema> = {\n    [K in keyof T]: { mask: number; byteOffset: number; bitOffset: number };\n};\n\nexport class BitmapSchemaInternal<T extends BitSchema> extends Schema<TypeFromBitSchema<T>, number> {\n    private readonly masks: MaskFromBitSchema<T>;\n\n    constructor(private readonly bitSchemas: T) {\n        super();\n\n        const masks = <MaskFromBitSchema<T>>{};\n        for (const name in this.bitSchemas) {\n            const { offset, length } = this.bitSchemas[name];\n            masks[name] = ((1 << length) - 1) << offset;\n        }\n        this.masks = masks;\n        // TODO: validate that bitSchemas is coherent\n    }\n\n    /**\n     * Allow to use a fully defined Bitmap schema as input, but also allow one where only the entries of bits set are\n     * provided, rest is unset.\n     */\n    override encode(value: TypeFromPartialBitSchema<T>) {\n        return super.encode(value as TypeFromBitSchema<T>);\n    }\n\n    override encodeInternal(value: TypeFromPartialBitSchema<T>) {\n        let result = 0;\n        for (const name in this.bitSchemas) {\n            const { type, offset } = this.bitSchemas[name];\n            switch (type) {\n                case BitRangeType.Flag:\n                    if (value[name]) result |= this.masks[name];\n                    break;\n                case BitRangeType.Enum:\n                case BitRangeType.Number:\n                    result |= (value[name] as number) << offset;\n            }\n        }\n        return result;\n    }\n\n    override decodeInternal(bitmap: number) {\n        const result = {} as any;\n        for (const name in this.bitSchemas) {\n            const { type, offset } = this.bitSchemas[name];\n            const mask = this.masks[name];\n            if (type === BitRangeType.Flag) {\n                result[name] = (bitmap & mask) !== 0;\n            } else {\n                result[name] = (bitmap & mask) >> offset;\n            }\n        }\n        return result as TypeFromBitSchema<T>;\n    }\n}\n\nexport class ByteArrayBitmapSchemaInternal<T extends BitSchema> extends Schema<TypeFromBitSchema<T>, ByteArray> {\n    private readonly byteArrayLength: number;\n    private readonly maskOffset: MaskOffsetFromBitSchema<T>;\n\n    constructor(private readonly bitSchemas: T) {\n        super();\n\n        let maxBitLength = 0;\n        const maskOffset = <MaskOffsetFromBitSchema<T>>{};\n        for (const name in this.bitSchemas) {\n            const { type, offset, length } = this.bitSchemas[name];\n            const bitOffset = offset % 8;\n            const byteOffset = (offset - bitOffset) / 8;\n            let mask: number;\n            if (type === BitRangeType.Flag) {\n                mask = 1 << bitOffset;\n            } else {\n                // Do not shift number mask, they might go beyond 2^32\n                mask = (1 << length) - 1;\n            }\n            maskOffset[name] = { bitOffset, byteOffset, mask };\n            maxBitLength = Math.max(maxBitLength, offset + length);\n        }\n        this.byteArrayLength = Math.ceil(maxBitLength / 8);\n        this.maskOffset = maskOffset;\n    }\n\n    override encodeInternal(value: TypeFromBitSchema<T>) {\n        const result = new ByteArray(this.byteArrayLength);\n        for (const name in this.bitSchemas) {\n            const { type } = this.bitSchemas[name];\n            let { bitOffset, byteOffset } = this.maskOffset[name];\n            const { mask } = this.maskOffset[name];\n            switch (type) {\n                case BitRangeType.Flag:\n                    if (value[name]) result[byteOffset] |= mask;\n                    break;\n                case BitRangeType.Enum:\n                case BitRangeType.Number: {\n                    let numValue = (value[name] as number) & mask;\n                    while (numValue !== 0) {\n                        result[byteOffset++] |= (numValue << bitOffset) & 0xff;\n                        const bitWritten = 8 - bitOffset;\n                        bitOffset = 0;\n                        numValue = numValue >> bitWritten;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    override decodeInternal(bitmap: ByteArray) {\n        if (bitmap.length !== this.byteArrayLength)\n            throw new UnexpectedDataError(`Unexpected length: ${bitmap.length}. Expected ${this.byteArrayLength}`);\n        const result = {} as any;\n        for (const name in this.bitSchemas) {\n            const { type } = this.bitSchemas[name];\n            let { mask, bitOffset, byteOffset } = this.maskOffset[name];\n            if (type === BitRangeType.Flag) {\n                result[name] = (bitmap[byteOffset] & mask) !== 0;\n            } else {\n                let value = 0;\n                let valueBitOffset = 0;\n                while (mask !== 0) {\n                    value |= ((bitmap[byteOffset++] >> bitOffset) & mask) << valueBitOffset;\n                    const bitRead = 8 - bitOffset;\n                    bitOffset = 0;\n                    valueBitOffset += bitRead;\n                    mask = mask >> bitRead;\n                }\n                result[name] = value;\n            }\n        }\n        return result as TypeFromBitSchema<T>;\n    }\n}\n\n/** Create a partial bitmap from a flag sequence */\nexport type FlagsToBitmap<T extends string[]> = {\n    [name in Uncapitalize<T[number]>]: true;\n};\n\n/** Create a type with specified bit flags set */\nexport type BitFlags<T extends BitSchema, F extends Capitalize<Extract<keyof T, string>>[]> = Merge<\n    { [key in keyof T]: false },\n    FlagsToBitmap<F>\n>;\n\n/** Create a bitmap schema with a named subset of flags set */\nexport function BitFlags<T extends BitSchema, F extends Capitalize<Extract<keyof T, string>>[]>(\n    bitSchemas: T,\n    ...flags: [...F]\n) {\n    return Object.fromEntries(\n        Object.keys(bitSchemas).map(name => [\n            name,\n            !(flags.indexOf(capitalize(name as Extract<keyof T, string>)) == -1),\n        ]),\n    ) as BitFlags<T, F>;\n}\n\n/** Create a full bitmap schema from a partial bitmap schema */\nexport function BitsFromPartial<S extends BitSchema, P extends TypeFromPartialBitSchema<S>>(schema: S, bits: P) {\n    const result = {} as { [key: string]: boolean | number };\n\n    for (const k in schema) {\n        const value = bits[k];\n        if (value !== undefined) {\n            result[k] = value;\n        } else {\n            result[k] = 0;\n        }\n    }\n\n    return result as TypeFromBitSchema<S>;\n}\n\n/** Declares a bitmap schema by indicating the bit position and their names. */\nexport const BitmapSchema = <T extends BitSchema>(bitSchemas: T) => new BitmapSchemaInternal(bitSchemas);\n\n/** Declares a bitmap schema backed by a ByteArray by indicating the bit position and their names. */\nexport const ByteArrayBitmapSchema = <T extends BitSchema>(bitSchemas: T) =>\n    new ByteArrayBitmapSchemaInternal(bitSchemas);\n"],
  "mappings": "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",
  "names": ["BitRangeType"]
}
