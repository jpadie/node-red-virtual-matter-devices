"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SessionManager_exports = {};
__export(SessionManager_exports, {
  SessionManager: () => SessionManager,
  UNICAST_UNSECURE_SESSION_ID: () => UNICAST_UNSECURE_SESSION_ID
});
module.exports = __toCommonJS(SessionManager_exports);
var import_MatterError = require("../common/MatterError.js");
var import_Crypto = require("../crypto/Crypto.js");
var import_NodeId = require("../datatype/NodeId.js");
var import_Logger = require("../log/Logger.js");
var import_MessageCounter = require("../protocol/MessageCounter.js");
var import_Observable = require("../util/Observable.js");
var import_Set = require("../util/Set.js");
var import_InsecureSession = require("./InsecureSession.js");
var import_SecureSession = require("./SecureSession.js");
var import_Session = require("./Session.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("SessionManager");
const UNICAST_UNSECURE_SESSION_ID = 0;
class SessionManager {
  constructor(context, sessionStorage) {
    this.context = context;
    this.#sessionStorage = sessionStorage;
  }
  #insecureSessions = /* @__PURE__ */ new Map();
  #sessions = new import_Set.BasicSet();
  #nextSessionId = import_Crypto.Crypto.getRandomUInt16();
  #resumptionRecords = /* @__PURE__ */ new Map();
  #sessionStorage;
  #globalUnencryptedMessageCounter = new import_MessageCounter.MessageCounter();
  #subscriptionsChanged = (0, import_Observable.Observable)();
  #sessionOpened = (0, import_Observable.Observable)();
  #sessionClosed = (0, import_Observable.AsyncObservable)();
  get subscriptionsChanged() {
    return this.#subscriptionsChanged;
  }
  get sessionOpened() {
    return this.#sessionOpened;
  }
  get sessionClosed() {
    return this.#sessionClosed;
  }
  createUnsecureSession(options) {
    const { initiatorNodeId, sessionParameters, isInitiator } = options;
    if (initiatorNodeId !== void 0) {
      if (this.#insecureSessions.has(initiatorNodeId)) {
        throw new import_MatterError.MatterFlowError(`UnsecureSession with NodeId ${initiatorNodeId} already exists.`);
      }
    }
    while (true) {
      const session = new import_InsecureSession.InsecureSession({
        context: this.context,
        messageCounter: this.#globalUnencryptedMessageCounter,
        closeCallback: async () => {
          logger.info(`End insecure session ${session.name}`);
          this.#insecureSessions.delete(session.nodeId);
        },
        initiatorNodeId,
        sessionParameters,
        isInitiator: isInitiator ?? false
      });
      const ephermalNodeId = session.nodeId;
      if (this.#insecureSessions.has(ephermalNodeId)) continue;
      this.#insecureSessions.set(ephermalNodeId, session);
      return session;
    }
  }
  async createSecureSession(args) {
    const {
      sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    } = args;
    const session = await import_SecureSession.SecureSession.create({
      context: this.context,
      id: sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      closeCallback: async () => {
        logger.info(`End ${session.isPase ? "PASE" : "CASE"} session ${session.name}`);
        this.#sessions.delete(session);
        await this.#sessionClosed.emit(session);
      },
      peerSessionParameters,
      caseAuthenticatedTags,
      subscriptionChangedCallback: () => {
        this.#subscriptionsChanged.emit(session);
      }
    });
    this.#sessions.add(session);
    this.#sessionOpened.emit(session);
    return session;
  }
  removeSession(sessionId) {
    const session = this.getSession(sessionId);
    if (session !== void 0) {
      this.#sessions.delete(session);
    }
  }
  async removeResumptionRecord(peerNodeId) {
    this.#resumptionRecords.delete(peerNodeId);
    await this.storeResumptionRecords();
  }
  findOldestInactiveSession() {
    let oldestSession = void 0;
    for (const session of this.#sessions) {
      if (!oldestSession || session.activeTimestamp < oldestSession.activeTimestamp) {
        oldestSession = session;
      }
    }
    if (oldestSession === void 0) {
      throw new import_MatterError.MatterFlowError("No session found to close and all session ids are taken.");
    }
    return oldestSession;
  }
  async getNextAvailableSessionId() {
    for (let i = 0; i < 65535; i++) {
      const id = this.#nextSessionId;
      this.#nextSessionId = this.#nextSessionId + 1 & 65535;
      if (this.#nextSessionId === 0) this.#nextSessionId++;
      if (this.getSession(id) === void 0) {
        return id;
      }
    }
    const oldestSession = this.findOldestInactiveSession();
    await oldestSession.end(true, false);
    this.#nextSessionId = oldestSession.id;
    return this.#nextSessionId++;
  }
  getSession(sessionId) {
    return this.#sessions.get("id", sessionId);
  }
  getPaseSession() {
    return [...this.#sessions].find(
      (session) => session.isSecure && session.isPase && !session.closingAfterExchangeFinished
    );
  }
  getSessionForNode(fabric, nodeId) {
    return [...this.#sessions].find((session) => {
      if (!session.isSecure) return false;
      const secureSession = session;
      return secureSession.fabric?.fabricId === fabric.fabricId && secureSession.peerNodeId === nodeId;
    });
  }
  async removeAllSessionsForNode(nodeId, sendClose = false) {
    for (const session of this.#sessions) {
      if (!session.isSecure) continue;
      const secureSession = session;
      if (secureSession.peerNodeId === nodeId) {
        await secureSession.destroy(sendClose, false);
      }
    }
  }
  getUnsecureSession(sourceNodeId) {
    if (sourceNodeId === void 0) {
      return this.#insecureSessions.get(import_NodeId.NodeId.UNSPECIFIED_NODE_ID);
    }
    return this.#insecureSessions.get(sourceNodeId);
  }
  findGroupSession(groupId, groupSessionId) {
    throw new Error(`Not implemented ${groupId} ${groupSessionId}`);
  }
  findResumptionRecordById(resumptionId) {
    return [...this.#resumptionRecords.values()].find((record) => record.resumptionId.equals(resumptionId));
  }
  findResumptionRecordByNodeId(nodeId) {
    return this.#resumptionRecords.get(nodeId);
  }
  async saveResumptionRecord(resumptionRecord) {
    this.#resumptionRecords.set(resumptionRecord.peerNodeId, resumptionRecord);
    await this.storeResumptionRecords();
  }
  async updateFabricForResumptionRecords(fabric) {
    const record = this.#resumptionRecords.get(fabric.rootNodeId);
    if (record === void 0) {
      throw new import_MatterError.MatterFlowError("Resumption record not found. Should never happen.");
    }
    this.#resumptionRecords.set(fabric.rootNodeId, { ...record, fabric });
    await this.storeResumptionRecords();
  }
  async storeResumptionRecords() {
    await this.#sessionStorage.set(
      "resumptionRecords",
      [...this.#resumptionRecords].map(
        ([
          nodeId,
          { sharedSecret, resumptionId, peerNodeId, fabric, sessionParameters, caseAuthenticatedTags }
        ]) => ({
          nodeId,
          sharedSecret,
          resumptionId,
          fabricId: fabric.fabricId,
          peerNodeId,
          sessionParameters,
          caseAuthenticatedTags
        })
      )
    );
  }
  async initFromStorage(fabrics) {
    const storedResumptionRecords = await this.#sessionStorage.get(
      "resumptionRecords",
      []
    );
    storedResumptionRecords.forEach(
      ({
        nodeId,
        sharedSecret,
        resumptionId,
        fabricId,
        peerNodeId,
        sessionParameters: {
          idleIntervalMs,
          activeIntervalMs,
          activeThresholdMs,
          dataModelRevision,
          interactionModelRevision,
          specificationVersion,
          maxPathsPerInvoke
        } = {},
        caseAuthenticatedTags
      }) => {
        logger.info("restoring resumption record for node", nodeId);
        const fabric = fabrics.find((fabric2) => fabric2.fabricId === fabricId);
        if (!fabric) {
          logger.error("fabric not found for resumption record", fabricId);
          return;
        }
        this.#resumptionRecords.set(nodeId, {
          sharedSecret,
          resumptionId,
          fabric,
          peerNodeId,
          sessionParameters: {
            // Make sure to initialize default values when restoring an older resumption record
            idleIntervalMs: idleIntervalMs ?? import_Session.SESSION_IDLE_INTERVAL_MS,
            activeIntervalMs: activeIntervalMs ?? import_Session.SESSION_ACTIVE_INTERVAL_MS,
            activeThresholdMs: activeThresholdMs ?? import_Session.SESSION_ACTIVE_THRESHOLD_MS,
            dataModelRevision: dataModelRevision ?? import_Session.FALLBACK_DATAMODEL_REVISION,
            interactionModelRevision: interactionModelRevision ?? import_Session.FALLBACK_INTERACTIONMODEL_REVISION,
            specificationVersion: specificationVersion ?? import_Session.FALLBACK_SPECIFICATION_VERSION,
            maxPathsPerInvoke: maxPathsPerInvoke ?? import_Session.FALLBACK_MAX_PATHS_PER_INVOKE
          },
          caseAuthenticatedTags
        });
      }
    );
  }
  getActiveSessionInformation() {
    return [...this.#sessions].filter((session) => session.isSecure && !session.isPase).map((session) => ({
      name: session.name,
      nodeId: session.nodeId,
      peerNodeId: session.peerNodeId,
      fabric: session instanceof import_SecureSession.SecureSession ? session.fabric?.externalInformation : void 0,
      isPeerActive: session.isPeerActive(),
      secure: session.isSecure,
      lastInteractionTimestamp: session instanceof import_SecureSession.SecureSession ? session.timestamp : void 0,
      lastActiveTimestamp: session instanceof import_SecureSession.SecureSession ? session.activeTimestamp : void 0,
      numberOfActiveSubscriptions: session instanceof import_SecureSession.SecureSession ? session.numberOfActiveSubscriptions : 0
    }));
  }
  async clearSubscriptionsForNode(fabricIndex, nodeId, flushSubscriptions) {
    for (const session of this.#sessions) {
      if (session.fabric?.fabricIndex === fabricIndex && session.peerNodeId === nodeId) {
        await session.clearSubscriptions(flushSubscriptions);
      }
    }
  }
  async close() {
    await this.storeResumptionRecords();
    for (const session of this.#sessions) {
      await session?.end(false);
      this.#sessions.delete(session);
    }
    for (const session of this.#insecureSessions.values()) {
      await session?.end();
      this.#insecureSessions.delete(session.nodeId);
    }
  }
}
//# sourceMappingURL=SessionManager.js.map
