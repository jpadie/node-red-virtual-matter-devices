{
  "version": 3,
  "sources": ["../../../../src/session/case/CaseServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterDevice } from \"../../MatterDevice.js\";\nimport { TlvOperationalCertificate } from \"../../certificate/CertificateManager.js\";\nimport { UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { Crypto } from \"../../crypto/Crypto.js\";\nimport { PublicKey } from \"../../crypto/Key.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { FabricNotFoundError } from \"../../fabric/FabricManager.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { MessageExchange } from \"../../protocol/MessageExchange.js\";\nimport { ProtocolHandler } from \"../../protocol/ProtocolHandler.js\";\nimport { ProtocolStatusCode, SECURE_CHANNEL_PROTOCOL_ID } from \"../../protocol/securechannel/SecureChannelMessages.js\";\nimport { ChannelStatusResponseError } from \"../../protocol/securechannel/SecureChannelMessenger.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport {\n    KDFSR1_KEY_INFO,\n    KDFSR2_INFO,\n    KDFSR2_KEY_INFO,\n    KDFSR3_INFO,\n    RESUME1_MIC_NONCE,\n    RESUME2_MIC_NONCE,\n    TBE_DATA2_NONCE,\n    TBE_DATA3_NONCE,\n    TlvEncryptedDataSigma2,\n    TlvEncryptedDataSigma3,\n    TlvSignedData,\n} from \"./CaseMessages.js\";\nimport { CaseServerMessenger } from \"./CaseMessenger.js\";\n\nconst logger = Logger.get(\"CaseServer\");\n\nexport class CaseServer implements ProtocolHandler<MatterDevice> {\n    async onNewExchange(exchange: MessageExchange<MatterDevice>) {\n        const messenger = new CaseServerMessenger(exchange);\n        try {\n            await this.handleSigma1(exchange.session.context, messenger);\n        } catch (error) {\n            logger.error(\"An error occurred during the commissioning\", error);\n\n            if (error instanceof FabricNotFoundError) {\n                await messenger.sendError(ProtocolStatusCode.NoSharedTrustRoots);\n            }\n            // If we received a ChannelStatusResponseError we do not need to send one back, so just cancel pairing\n            else if (!(error instanceof ChannelStatusResponseError)) {\n                await messenger.sendError(ProtocolStatusCode.InvalidParam);\n            }\n        } finally {\n            // Destroy the unsecure session used to establish the secure Case session\n            await exchange.session.destroy();\n        }\n    }\n\n    getId(): number {\n        return SECURE_CHANNEL_PROTOCOL_ID;\n    }\n\n    private async handleSigma1(server: MatterDevice, messenger: CaseServerMessenger) {\n        logger.info(`Received pairing request from ${messenger.getChannelName()}`);\n        // Generate pairing info\n        const responderRandom = Crypto.getRandom();\n\n        // Read and process sigma 1\n        const { sigma1Bytes, sigma1 } = await messenger.readSigma1();\n        const {\n            initiatorSessionId: peerSessionId,\n            resumptionId: peerResumptionId,\n            initiatorResumeMic: peerResumeMic,\n            destinationId,\n            initiatorRandom: peerRandom,\n            initiatorEcdhPublicKey: peerEcdhPublicKey,\n            initiatorSessionParams,\n        } = sigma1;\n\n        // Try to resume a previous session\n        const resumptionId = Crypto.getRandomData(16);\n\n        const resumptionRecord =\n            peerResumptionId !== undefined && peerResumeMic !== undefined\n                ? server.findResumptionRecordById(peerResumptionId)\n                : undefined;\n        // We try to resume the session\n        if (peerResumptionId !== undefined && peerResumeMic !== undefined && resumptionRecord !== undefined) {\n            const { sharedSecret, fabric, peerNodeId, caseAuthenticatedTags } = resumptionRecord;\n            const peerResumeKey = await Crypto.hkdf(\n                sharedSecret,\n                ByteArray.concat(peerRandom, peerResumptionId),\n                KDFSR1_KEY_INFO,\n            );\n            Crypto.decrypt(peerResumeKey, peerResumeMic, RESUME1_MIC_NONCE);\n\n            // All good! Create secure session\n            const responderSessionId = await server.getNextAvailableSessionId();\n            const secureSessionSalt = ByteArray.concat(peerRandom, peerResumptionId);\n            const secureSession = await server.sessionManager.createSecureSession({\n                sessionId: responderSessionId,\n                fabric,\n                peerNodeId,\n                peerSessionId,\n                sharedSecret,\n                salt: secureSessionSalt,\n                isInitiator: false,\n                isResumption: true,\n                peerSessionParameters: initiatorSessionParams,\n                caseAuthenticatedTags,\n            });\n\n            // Generate sigma 2 resume\n            const resumeSalt = ByteArray.concat(peerRandom, resumptionId);\n            const resumeKey = await Crypto.hkdf(sharedSecret, resumeSalt, KDFSR2_KEY_INFO);\n            const resumeMic = Crypto.encrypt(resumeKey, new ByteArray(0), RESUME2_MIC_NONCE);\n            try {\n                await messenger.sendSigma2Resume({\n                    resumptionId,\n                    resumeMic,\n                    responderSessionId,\n                    responderSessionParams: server.sessionParameters, // responder session parameters\n                });\n            } catch (error) {\n                // If we fail to send the resume, we destroy the session\n                await secureSession.destroy(false);\n                throw error;\n            }\n\n            logger.info(\n                `session ${secureSession.id} resumed with ${messenger.getChannelName()} for Fabric ${NodeId.toHexString(\n                    fabric.nodeId,\n                )}(index ${fabric.fabricIndex}) and PeerNode ${NodeId.toHexString(peerNodeId)}`,\n            );\n            resumptionRecord.resumptionId = resumptionId; /* Update the ID */\n\n            // Wait for success on the peer side\n            await messenger.waitForSuccess(\"Success after CASE Sigma2Resume\");\n\n            await messenger.close();\n            await server.saveResumptionRecord(resumptionRecord);\n        } else if (\n            (peerResumptionId === undefined && peerResumeMic === undefined) ||\n            (peerResumptionId !== undefined && peerResumeMic !== undefined && resumptionRecord === undefined)\n        ) {\n            // Generate sigma 2\n            // TODO: Pass through a group id?\n            const fabric = server.findFabricFromDestinationId(destinationId, peerRandom);\n            const { operationalCert: nodeOpCert, intermediateCACert, operationalIdentityProtectionKey } = fabric;\n            const { publicKey: responderEcdhPublicKey, sharedSecret } =\n                Crypto.ecdhGeneratePublicKeyAndSecret(peerEcdhPublicKey);\n            const sigma2Salt = ByteArray.concat(\n                operationalIdentityProtectionKey,\n                responderRandom,\n                responderEcdhPublicKey,\n                Crypto.hash(sigma1Bytes),\n            );\n            const sigma2Key = await Crypto.hkdf(sharedSecret, sigma2Salt, KDFSR2_INFO);\n            const signatureData = TlvSignedData.encode({\n                nodeOpCert,\n                intermediateCACert,\n                ecdhPublicKey: responderEcdhPublicKey,\n                peerEcdhPublicKey,\n            });\n            const signature = fabric.sign(signatureData);\n            const encryptedData = TlvEncryptedDataSigma2.encode({\n                nodeOpCert,\n                intermediateCACert,\n                signature,\n                resumptionId,\n            });\n            const encrypted = Crypto.encrypt(sigma2Key, encryptedData, TBE_DATA2_NONCE);\n            const responderSessionId = await server.getNextAvailableSessionId();\n            const sigma2Bytes = await messenger.sendSigma2({\n                responderRandom,\n                responderSessionId,\n                responderEcdhPublicKey,\n                encrypted,\n                responderSessionParams: server.sessionParameters, // responder session parameters\n            });\n\n            // Read and process sigma 3\n            const {\n                sigma3Bytes,\n                sigma3: { encrypted: peerEncrypted },\n            } = await messenger.readSigma3();\n            const sigma3Salt = ByteArray.concat(\n                operationalIdentityProtectionKey,\n                Crypto.hash([sigma1Bytes, sigma2Bytes]),\n            );\n            const sigma3Key = await Crypto.hkdf(sharedSecret, sigma3Salt, KDFSR3_INFO);\n            const peerDecryptedData = Crypto.decrypt(sigma3Key, peerEncrypted, TBE_DATA3_NONCE);\n            const {\n                nodeOpCert: peerNewOpCert,\n                intermediateCACert: peerIntermediateCACert,\n                signature: peerSignature,\n            } = TlvEncryptedDataSigma3.decode(peerDecryptedData);\n\n            fabric.verifyCredentials(peerNewOpCert, peerIntermediateCACert);\n\n            const peerSignatureData = TlvSignedData.encode({\n                nodeOpCert: peerNewOpCert,\n                intermediateCACert: peerIntermediateCACert,\n                ecdhPublicKey: peerEcdhPublicKey,\n                peerEcdhPublicKey: responderEcdhPublicKey,\n            });\n            const {\n                ellipticCurvePublicKey: peerPublicKey,\n                subject: { fabricId: peerFabricId, nodeId: peerNodeId, caseAuthenticatedTags },\n            } = TlvOperationalCertificate.decode(peerNewOpCert);\n\n            if (fabric.fabricId !== peerFabricId) {\n                throw new UnexpectedDataError(`Fabric ID mismatch: ${fabric.fabricId} !== ${peerFabricId}`);\n            }\n\n            Crypto.verify(PublicKey(peerPublicKey), peerSignatureData, peerSignature);\n\n            // All good! Create secure session\n            const secureSessionSalt = ByteArray.concat(\n                operationalIdentityProtectionKey,\n                Crypto.hash([sigma1Bytes, sigma2Bytes, sigma3Bytes]),\n            );\n            const secureSession = await server.sessionManager.createSecureSession({\n                sessionId: responderSessionId,\n                fabric,\n                peerNodeId,\n                peerSessionId,\n                sharedSecret,\n                salt: secureSessionSalt,\n                isInitiator: false,\n                isResumption: false,\n                peerSessionParameters: initiatorSessionParams,\n                caseAuthenticatedTags,\n            });\n            logger.info(\n                `session ${secureSession.id} created with ${messenger.getChannelName()} for Fabric ${NodeId.toHexString(\n                    fabric.nodeId,\n                )}(index ${fabric.fabricIndex}) and PeerNode ${NodeId.toHexString(peerNodeId)}`,\n            );\n            await messenger.sendSuccess();\n\n            const resumptionRecord = {\n                peerNodeId,\n                fabric,\n                sharedSecret,\n                resumptionId,\n                sessionParameters: secureSession.parameters,\n                caseAuthenticatedTags,\n            };\n\n            await messenger.close();\n            await server.saveResumptionRecord(resumptionRecord);\n        } else {\n            logger.info(\n                `Invalid resumption ID or resume MIC received from ${messenger.getChannelName()}`,\n                peerResumptionId,\n                peerResumeMic,\n            );\n            throw new UnexpectedDataError(\"Invalid resumption ID or resume MIC.\");\n        }\n    }\n\n    async close() {\n        // Nothing to do\n    }\n}\n"],
  "mappings": "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",
  "names": ["resumptionRecord"]
}
