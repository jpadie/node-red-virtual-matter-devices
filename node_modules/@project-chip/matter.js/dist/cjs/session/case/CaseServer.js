"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var CaseServer_exports = {};
__export(CaseServer_exports, {
  CaseServer: () => CaseServer
});
module.exports = __toCommonJS(CaseServer_exports);
var import_CertificateManager = require("../../certificate/CertificateManager.js");
var import_MatterError = require("../../common/MatterError.js");
var import_Crypto = require("../../crypto/Crypto.js");
var import_Key = require("../../crypto/Key.js");
var import_NodeId = require("../../datatype/NodeId.js");
var import_FabricManager = require("../../fabric/FabricManager.js");
var import_Logger = require("../../log/Logger.js");
var import_SecureChannelMessages = require("../../protocol/securechannel/SecureChannelMessages.js");
var import_SecureChannelMessenger = require("../../protocol/securechannel/SecureChannelMessenger.js");
var import_ByteArray = require("../../util/ByteArray.js");
var import_CaseMessages = require("./CaseMessages.js");
var import_CaseMessenger = require("./CaseMessenger.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("CaseServer");
class CaseServer {
  async onNewExchange(exchange) {
    const messenger = new import_CaseMessenger.CaseServerMessenger(exchange);
    try {
      await this.handleSigma1(exchange.session.context, messenger);
    } catch (error) {
      logger.error("An error occurred during the commissioning", error);
      if (error instanceof import_FabricManager.FabricNotFoundError) {
        await messenger.sendError(import_SecureChannelMessages.ProtocolStatusCode.NoSharedTrustRoots);
      } else if (!(error instanceof import_SecureChannelMessenger.ChannelStatusResponseError)) {
        await messenger.sendError(import_SecureChannelMessages.ProtocolStatusCode.InvalidParam);
      }
    } finally {
      await exchange.session.destroy();
    }
  }
  getId() {
    return import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID;
  }
  async handleSigma1(server, messenger) {
    logger.info(`Received pairing request from ${messenger.getChannelName()}`);
    const responderRandom = import_Crypto.Crypto.getRandom();
    const { sigma1Bytes, sigma1 } = await messenger.readSigma1();
    const {
      initiatorSessionId: peerSessionId,
      resumptionId: peerResumptionId,
      initiatorResumeMic: peerResumeMic,
      destinationId,
      initiatorRandom: peerRandom,
      initiatorEcdhPublicKey: peerEcdhPublicKey,
      initiatorSessionParams
    } = sigma1;
    const resumptionId = import_Crypto.Crypto.getRandomData(16);
    const resumptionRecord = peerResumptionId !== void 0 && peerResumeMic !== void 0 ? server.findResumptionRecordById(peerResumptionId) : void 0;
    if (peerResumptionId !== void 0 && peerResumeMic !== void 0 && resumptionRecord !== void 0) {
      const { sharedSecret, fabric, peerNodeId, caseAuthenticatedTags } = resumptionRecord;
      const peerResumeKey = await import_Crypto.Crypto.hkdf(
        sharedSecret,
        import_ByteArray.ByteArray.concat(peerRandom, peerResumptionId),
        import_CaseMessages.KDFSR1_KEY_INFO
      );
      import_Crypto.Crypto.decrypt(peerResumeKey, peerResumeMic, import_CaseMessages.RESUME1_MIC_NONCE);
      const responderSessionId = await server.getNextAvailableSessionId();
      const secureSessionSalt = import_ByteArray.ByteArray.concat(peerRandom, peerResumptionId);
      const secureSession = await server.sessionManager.createSecureSession({
        sessionId: responderSessionId,
        fabric,
        peerNodeId,
        peerSessionId,
        sharedSecret,
        salt: secureSessionSalt,
        isInitiator: false,
        isResumption: true,
        peerSessionParameters: initiatorSessionParams,
        caseAuthenticatedTags
      });
      const resumeSalt = import_ByteArray.ByteArray.concat(peerRandom, resumptionId);
      const resumeKey = await import_Crypto.Crypto.hkdf(sharedSecret, resumeSalt, import_CaseMessages.KDFSR2_KEY_INFO);
      const resumeMic = import_Crypto.Crypto.encrypt(resumeKey, new import_ByteArray.ByteArray(0), import_CaseMessages.RESUME2_MIC_NONCE);
      try {
        await messenger.sendSigma2Resume({
          resumptionId,
          resumeMic,
          responderSessionId,
          responderSessionParams: server.sessionParameters
          // responder session parameters
        });
      } catch (error) {
        await secureSession.destroy(false);
        throw error;
      }
      logger.info(
        `session ${secureSession.id} resumed with ${messenger.getChannelName()} for Fabric ${import_NodeId.NodeId.toHexString(
          fabric.nodeId
        )}(index ${fabric.fabricIndex}) and PeerNode ${import_NodeId.NodeId.toHexString(peerNodeId)}`
      );
      resumptionRecord.resumptionId = resumptionId;
      await messenger.waitForSuccess("Success after CASE Sigma2Resume");
      await messenger.close();
      await server.saveResumptionRecord(resumptionRecord);
    } else if (peerResumptionId === void 0 && peerResumeMic === void 0 || peerResumptionId !== void 0 && peerResumeMic !== void 0 && resumptionRecord === void 0) {
      const fabric = server.findFabricFromDestinationId(destinationId, peerRandom);
      const { operationalCert: nodeOpCert, intermediateCACert, operationalIdentityProtectionKey } = fabric;
      const { publicKey: responderEcdhPublicKey, sharedSecret } = import_Crypto.Crypto.ecdhGeneratePublicKeyAndSecret(peerEcdhPublicKey);
      const sigma2Salt = import_ByteArray.ByteArray.concat(
        operationalIdentityProtectionKey,
        responderRandom,
        responderEcdhPublicKey,
        import_Crypto.Crypto.hash(sigma1Bytes)
      );
      const sigma2Key = await import_Crypto.Crypto.hkdf(sharedSecret, sigma2Salt, import_CaseMessages.KDFSR2_INFO);
      const signatureData = import_CaseMessages.TlvSignedData.encode({
        nodeOpCert,
        intermediateCACert,
        ecdhPublicKey: responderEcdhPublicKey,
        peerEcdhPublicKey
      });
      const signature = fabric.sign(signatureData);
      const encryptedData = import_CaseMessages.TlvEncryptedDataSigma2.encode({
        nodeOpCert,
        intermediateCACert,
        signature,
        resumptionId
      });
      const encrypted = import_Crypto.Crypto.encrypt(sigma2Key, encryptedData, import_CaseMessages.TBE_DATA2_NONCE);
      const responderSessionId = await server.getNextAvailableSessionId();
      const sigma2Bytes = await messenger.sendSigma2({
        responderRandom,
        responderSessionId,
        responderEcdhPublicKey,
        encrypted,
        responderSessionParams: server.sessionParameters
        // responder session parameters
      });
      const {
        sigma3Bytes,
        sigma3: { encrypted: peerEncrypted }
      } = await messenger.readSigma3();
      const sigma3Salt = import_ByteArray.ByteArray.concat(
        operationalIdentityProtectionKey,
        import_Crypto.Crypto.hash([sigma1Bytes, sigma2Bytes])
      );
      const sigma3Key = await import_Crypto.Crypto.hkdf(sharedSecret, sigma3Salt, import_CaseMessages.KDFSR3_INFO);
      const peerDecryptedData = import_Crypto.Crypto.decrypt(sigma3Key, peerEncrypted, import_CaseMessages.TBE_DATA3_NONCE);
      const {
        nodeOpCert: peerNewOpCert,
        intermediateCACert: peerIntermediateCACert,
        signature: peerSignature
      } = import_CaseMessages.TlvEncryptedDataSigma3.decode(peerDecryptedData);
      fabric.verifyCredentials(peerNewOpCert, peerIntermediateCACert);
      const peerSignatureData = import_CaseMessages.TlvSignedData.encode({
        nodeOpCert: peerNewOpCert,
        intermediateCACert: peerIntermediateCACert,
        ecdhPublicKey: peerEcdhPublicKey,
        peerEcdhPublicKey: responderEcdhPublicKey
      });
      const {
        ellipticCurvePublicKey: peerPublicKey,
        subject: { fabricId: peerFabricId, nodeId: peerNodeId, caseAuthenticatedTags }
      } = import_CertificateManager.TlvOperationalCertificate.decode(peerNewOpCert);
      if (fabric.fabricId !== peerFabricId) {
        throw new import_MatterError.UnexpectedDataError(`Fabric ID mismatch: ${fabric.fabricId} !== ${peerFabricId}`);
      }
      import_Crypto.Crypto.verify((0, import_Key.PublicKey)(peerPublicKey), peerSignatureData, peerSignature);
      const secureSessionSalt = import_ByteArray.ByteArray.concat(
        operationalIdentityProtectionKey,
        import_Crypto.Crypto.hash([sigma1Bytes, sigma2Bytes, sigma3Bytes])
      );
      const secureSession = await server.sessionManager.createSecureSession({
        sessionId: responderSessionId,
        fabric,
        peerNodeId,
        peerSessionId,
        sharedSecret,
        salt: secureSessionSalt,
        isInitiator: false,
        isResumption: false,
        peerSessionParameters: initiatorSessionParams,
        caseAuthenticatedTags
      });
      logger.info(
        `session ${secureSession.id} created with ${messenger.getChannelName()} for Fabric ${import_NodeId.NodeId.toHexString(
          fabric.nodeId
        )}(index ${fabric.fabricIndex}) and PeerNode ${import_NodeId.NodeId.toHexString(peerNodeId)}`
      );
      await messenger.sendSuccess();
      const resumptionRecord2 = {
        peerNodeId,
        fabric,
        sharedSecret,
        resumptionId,
        sessionParameters: secureSession.parameters,
        caseAuthenticatedTags
      };
      await messenger.close();
      await server.saveResumptionRecord(resumptionRecord2);
    } else {
      logger.info(
        `Invalid resumption ID or resume MIC received from ${messenger.getChannelName()}`,
        peerResumptionId,
        peerResumeMic
      );
      throw new import_MatterError.UnexpectedDataError("Invalid resumption ID or resume MIC.");
    }
  }
  async close() {
  }
}
//# sourceMappingURL=CaseServer.js.map
