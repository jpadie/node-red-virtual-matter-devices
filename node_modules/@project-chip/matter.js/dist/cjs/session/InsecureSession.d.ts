/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { DecodedMessage, DecodedPacket, Message, Packet } from "../codec/MessageCodec.js";
import { NodeId } from "../datatype/NodeId.js";
import { Fabric } from "../fabric/Fabric.js";
import { MessageCounter } from "../protocol/MessageCounter.js";
import { ByteArray } from "../util/ByteArray.js";
import { Session, SessionParameterOptions } from "./Session.js";
export declare class InsecureSession<T> extends Session<T> {
    #private;
    readonly closingAfterExchangeFinished = false;
    readonly supportsMRP = true;
    constructor(args: {
        context: T;
        messageCounter: MessageCounter;
        closeCallback: () => Promise<void>;
        initiatorNodeId?: NodeId;
        sessionParameters?: SessionParameterOptions;
        isInitiator?: boolean;
    });
    get isSecure(): boolean;
    get isPase(): boolean;
    decode(packet: DecodedPacket): DecodedMessage;
    encode(message: Message): Packet;
    get attestationChallengeKey(): ByteArray;
    setFabric(_fabric: Fabric): void;
    get name(): string;
    get context(): T;
    get id(): number;
    get peerSessionId(): number;
    get nodeId(): NodeId;
    get peerNodeId(): undefined;
    get associatedFabric(): Fabric;
    destroy(): Promise<void>;
    end(): Promise<void>;
}
//# sourceMappingURL=InsecureSession.d.ts.map