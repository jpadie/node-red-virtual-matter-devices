{
  "version": 3,
  "sources": ["../../../src/session/SecureSession.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DecodedMessage, DecodedPacket, Message, MessageCodec, Packet } from \"../codec/MessageCodec.js\";\nimport { MatterFlowError } from \"../common/MatterError.js\";\nimport { CRYPTO_SYMMETRIC_KEY_LENGTH, Crypto } from \"../crypto/Crypto.js\";\nimport { CaseAuthenticatedTag } from \"../datatype/CaseAuthenticatedTag.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { MessageCounter } from \"../protocol/MessageCounter.js\";\nimport { MessageReceptionStateEncryptedWithoutRollover } from \"../protocol/MessageReceptionState.js\";\nimport { StatusCode, StatusResponseError } from \"../protocol/interaction/StatusCode.js\";\nimport { SubscriptionHandler } from \"../protocol/interaction/SubscriptionHandler.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataWriter } from \"../util/DataWriter.js\";\nimport { Session, SessionParameterOptions } from \"./Session.js\";\n\nconst logger = Logger.get(\"SecureSession\");\n\nconst SESSION_KEYS_INFO = ByteArray.fromString(\"SessionKeys\");\nconst SESSION_RESUMPTION_KEYS_INFO = ByteArray.fromString(\"SessionResumptionKeys\");\n\nexport class NoAssociatedFabricError extends StatusResponseError {\n    constructor(message: string) {\n        super(message, StatusCode.UnsupportedAccess);\n    }\n}\n\nexport class SecureSession<T> extends Session<T> {\n    readonly #subscriptions = new Array<SubscriptionHandler>();\n    #closingAfterExchangeFinished = false;\n    #sendCloseMessageWhenClosing = true;\n    readonly #context: T;\n    readonly #id: number;\n    #fabric: Fabric | undefined;\n    readonly #peerNodeId: NodeId;\n    readonly #peerSessionId: number;\n    readonly #decryptKey: ByteArray;\n    readonly #encryptKey: ByteArray;\n    readonly #attestationKey: ByteArray;\n    readonly #subscriptionChangedCallback: () => void;\n    #caseAuthenticatedTags: CaseAuthenticatedTag[];\n    readonly supportsMRP = true;\n\n    static async create<T>(args: {\n        context: T;\n        id: number;\n        fabric: Fabric | undefined;\n        peerNodeId: NodeId;\n        peerSessionId: number;\n        sharedSecret: ByteArray;\n        salt: ByteArray;\n        isInitiator: boolean;\n        isResumption: boolean;\n        closeCallback: () => Promise<void>;\n        subscriptionChangedCallback?: () => void;\n        peerSessionParameters?: SessionParameterOptions;\n        caseAuthenticatedTags?: CaseAuthenticatedTag[];\n    }) {\n        const {\n            context,\n            id,\n            fabric,\n            peerNodeId,\n            peerSessionId,\n            sharedSecret,\n            salt,\n            isInitiator,\n            isResumption,\n            closeCallback,\n            peerSessionParameters,\n            caseAuthenticatedTags,\n            subscriptionChangedCallback,\n        } = args;\n        const keys = await Crypto.hkdf(\n            sharedSecret,\n            salt,\n            isResumption ? SESSION_RESUMPTION_KEYS_INFO : SESSION_KEYS_INFO,\n            CRYPTO_SYMMETRIC_KEY_LENGTH * 3,\n        );\n        const decryptKey = isInitiator ? keys.slice(16, 32) : keys.slice(0, 16);\n        const encryptKey = isInitiator ? keys.slice(0, 16) : keys.slice(16, 32);\n        const attestationKey = keys.slice(32, 48);\n        return new SecureSession({\n            context,\n            id,\n            fabric,\n            peerNodeId,\n            peerSessionId,\n            decryptKey,\n            encryptKey,\n            attestationKey,\n            closeCallback,\n            subscriptionChangedCallback,\n            sessionParameters: peerSessionParameters,\n            isInitiator,\n            caseAuthenticatedTags,\n        });\n    }\n\n    constructor(args: {\n        context: T;\n        id: number;\n        fabric: Fabric | undefined;\n        peerNodeId: NodeId;\n        peerSessionId: number;\n        decryptKey: ByteArray;\n        encryptKey: ByteArray;\n        attestationKey: ByteArray;\n        closeCallback: () => Promise<void>;\n        subscriptionChangedCallback?: () => void;\n        sessionParameters?: SessionParameterOptions;\n        caseAuthenticatedTags?: CaseAuthenticatedTag[];\n        isInitiator: boolean;\n    }) {\n        super({\n            ...args,\n            setActiveTimestamp: true, // We always set the active timestamp for Secure sessions\n            // Can be changed to a PersistedMessageCounter if we implement session storage\n            messageCounter: new MessageCounter(() => {\n                // Secure Session Message Counter\n                // Expire/End the session before the counter rolls over\n                this.end(true, true).catch(error => logger.error(`Error while closing session: ${error}`));\n            }),\n            messageReceptionState: new MessageReceptionStateEncryptedWithoutRollover(),\n        });\n        const {\n            context,\n            id,\n            fabric,\n            peerNodeId,\n            peerSessionId,\n            decryptKey,\n            encryptKey,\n            attestationKey,\n            subscriptionChangedCallback = () => {},\n            caseAuthenticatedTags,\n        } = args;\n\n        this.#context = context;\n        this.#id = id;\n        this.#fabric = fabric;\n        this.#peerNodeId = peerNodeId;\n        this.#peerSessionId = peerSessionId;\n        this.#decryptKey = decryptKey;\n        this.#encryptKey = encryptKey;\n        this.#attestationKey = attestationKey;\n        this.#subscriptionChangedCallback = subscriptionChangedCallback;\n        this.#caseAuthenticatedTags = caseAuthenticatedTags ?? [];\n\n        fabric?.addSession(this);\n\n        logger.debug(\n            `Created secure ${this.isPase ? \"PASE\" : \"CASE\"} session for fabric index ${fabric?.fabricIndex}`,\n            this.name,\n            Diagnostic.dict({\n                idleIntervalMs: this.idleIntervalMs,\n                activeIntervalMs: this.activeIntervalMs,\n                activeThresholdMs: this.activeThresholdMs,\n                dataModelRevision: this.dataModelRevision,\n                interactionModelRevision: this.interactionModelRevision,\n                specificationVersion: this.specificationVersion,\n                maxPathsPerInvoke: this.maxPathsPerInvoke,\n            }),\n        );\n    }\n\n    get caseAuthenticatedTags() {\n        return this.#caseAuthenticatedTags;\n    }\n\n    get closingAfterExchangeFinished() {\n        return this.#closingAfterExchangeFinished;\n    }\n\n    get sendCloseMessageWhenClosing() {\n        return this.#sendCloseMessageWhenClosing;\n    }\n\n    get isSecure(): boolean {\n        return true;\n    }\n\n    get isPase(): boolean {\n        return this.#peerNodeId === NodeId.UNSPECIFIED_NODE_ID;\n    }\n\n    async close(closeAfterExchangeFinished?: boolean) {\n        if (closeAfterExchangeFinished === undefined) {\n            closeAfterExchangeFinished = this.isPeerActive(); // We delay session close if the peer is actively communicating with us\n        }\n        await this.end(true, closeAfterExchangeFinished);\n    }\n\n    decode({ header, applicationPayload, messageExtension }: DecodedPacket, aad: ByteArray): DecodedMessage {\n        if (header.hasMessageExtensions) {\n            logger.info(`Message extensions are not supported. Ignoring ${messageExtension?.toHex()}`);\n        }\n        const nonce = this.generateNonce(header.securityFlags, header.messageId, this.#peerNodeId);\n        const message = MessageCodec.decodePayload({\n            header,\n            applicationPayload: Crypto.decrypt(this.#decryptKey, applicationPayload, nonce, aad),\n        });\n\n        if (message.payloadHeader.hasSecuredExtension) {\n            logger.info(`Secured extensions are not supported. Ignoring ${message.securityExtension?.toHex()}`);\n        }\n\n        return message;\n    }\n\n    encode(message: Message): Packet {\n        message.packetHeader.sessionId = this.#peerSessionId;\n        const { header, applicationPayload } = MessageCodec.encodePayload(message);\n        const headerBytes = MessageCodec.encodePacketHeader(message.packetHeader);\n        const securityFlags = headerBytes[3];\n        const sessionNodeId = this.isPase\n            ? NodeId.UNSPECIFIED_NODE_ID\n            : (this.#fabric?.nodeId ?? NodeId.UNSPECIFIED_NODE_ID);\n        const nonce = this.generateNonce(securityFlags, header.messageId, sessionNodeId);\n        return { header, applicationPayload: Crypto.encrypt(this.#encryptKey, applicationPayload, nonce, headerBytes) };\n    }\n\n    get attestationChallengeKey(): ByteArray {\n        return this.#attestationKey;\n    }\n\n    get fabric() {\n        return this.#fabric;\n    }\n\n    addAssociatedFabric(fabric: Fabric) {\n        if (this.#fabric !== undefined) {\n            throw new MatterFlowError(\"Session already has an associated Fabric. Cannot change this.\");\n        }\n        this.#fabric = fabric;\n    }\n\n    get id() {\n        return this.#id;\n    }\n\n    get name() {\n        return `secure/${this.#id}`;\n    }\n\n    get context() {\n        return this.#context;\n    }\n\n    get peerSessionId(): number {\n        return this.#peerSessionId;\n    }\n\n    get nodeId() {\n        return this.#fabric?.nodeId ?? NodeId.UNSPECIFIED_NODE_ID;\n    }\n\n    get peerNodeId() {\n        return this.#peerNodeId;\n    }\n\n    get numberOfActiveSubscriptions() {\n        return this.#subscriptions.length;\n    }\n\n    get associatedFabric(): Fabric {\n        if (this.#fabric === undefined) {\n            throw new NoAssociatedFabricError(\n                `${this.isPase ? \"PASE \" : \"\"}Session needs to have an associated Fabric for fabric sensitive data handling.`,\n            );\n        }\n        return this.#fabric;\n    }\n\n    addSubscription(subscription: SubscriptionHandler) {\n        this.#subscriptions.push(subscription);\n        logger.debug(`Added subscription ${subscription.subscriptionId} to ${this.name}`);\n        this.#subscriptionChangedCallback();\n    }\n\n    removeSubscription(subscriptionId: number) {\n        const index = this.#subscriptions.findIndex(subscription => subscription.subscriptionId === subscriptionId);\n        if (index !== -1) {\n            this.#subscriptions.splice(index, 1);\n            logger.debug(`Removed subscription ${subscriptionId} from ${this.name}`);\n            this.#subscriptionChangedCallback();\n        }\n    }\n\n    async clearSubscriptions(flushSubscriptions = false) {\n        const subscriptions = [...this.#subscriptions]; // get all values because subscriptions will remove themselves when cancelled\n        for (const subscription of subscriptions) {\n            await subscription.cancel(flushSubscriptions);\n        }\n        this.#subscriptions.length = 0;\n    }\n\n    /** Ends a session. Outstanding subscription data will be flushed before the session is destroyed. */\n    async end(sendClose: boolean, closeAfterExchangeFinished = false) {\n        await this.clearSubscriptions(true);\n        await this.destroy(sendClose, closeAfterExchangeFinished);\n    }\n\n    /** Destroys a session. Outstanding subscription data will be discarded. */\n    async destroy(sendClose = false, closeAfterExchangeFinished = true) {\n        await this.clearSubscriptions(false);\n        this.#fabric?.removeSession(this);\n        if (!sendClose) {\n            this.#sendCloseMessageWhenClosing = false;\n        }\n\n        if (closeAfterExchangeFinished) {\n            logger.info(`Register Session ${this.name} to send a close when exchange is ended.`);\n            this.#closingAfterExchangeFinished = true;\n        } else {\n            await this.closeCallback();\n        }\n    }\n\n    private generateNonce(securityFlags: number, messageId: number, nodeId: NodeId) {\n        const writer = new DataWriter(Endian.Little);\n        writer.writeUInt8(securityFlags);\n        writer.writeUInt32(messageId);\n        writer.writeUInt64(nodeId);\n        return writer.toByteArray();\n    }\n}\n\nexport function assertSecureSession<T>(session: Session<T>, errorText?: string): asserts session is SecureSession<T> {\n    if (!session.isSecure) {\n        throw new MatterFlowError(errorText ?? \"Insecure session in secure context\");\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
