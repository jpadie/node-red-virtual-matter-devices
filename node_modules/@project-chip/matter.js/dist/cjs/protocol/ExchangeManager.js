"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ExchangeManager_exports = {};
__export(ExchangeManager_exports, {
  ChannelNotConnectedError: () => ChannelNotConnectedError,
  ExchangeCounter: () => ExchangeCounter,
  ExchangeManager: () => ExchangeManager,
  ExchangeProvider: () => ExchangeProvider,
  MessageChannel: () => MessageChannel
});
module.exports = __toCommonJS(ExchangeManager_exports);
var import_MessageCodec = require("../codec/MessageCodec.js");
var import_MatterError = require("../common/MatterError.js");
var import_Crypto = require("../crypto/Crypto.js");
var import_NodeId = require("../datatype/NodeId.js");
var import_Logger = require("../log/Logger.js");
var import_UdpInterface = require("../net/UdpInterface.js");
var import_InteractionServer = require("../protocol/interaction/InteractionServer.js");
var import_SessionManager = require("../session/SessionManager.js");
var import_ByteArray = require("../util/ByteArray.js");
var import_MessageExchange = require("./MessageExchange.js");
var import_MessageReceptionState = require("./MessageReceptionState.js");
var import_SecureChannelMessages = require("./securechannel/SecureChannelMessages.js");
var import_SecureChannelMessenger = require("./securechannel/SecureChannelMessenger.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("ExchangeManager");
class ChannelNotConnectedError extends import_MatterError.MatterError {
}
class MessageChannel {
  constructor(channel, session, closeCallback) {
    this.channel = channel;
    this.session = session;
    this.#closeCallback = closeCallback;
  }
  closed = false;
  #closeCallback;
  set closeCallback(callback) {
    this.#closeCallback = callback;
  }
  /** Is the underlying transport reliable? */
  get isReliable() {
    return this.channel.isReliable;
  }
  get type() {
    return this.channel.type;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel. The full encoded matter
   * message payload sent here can be as huge as allowed by the channel.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize;
  }
  send(message) {
    logger.debug("Message \xBB", import_MessageCodec.MessageCodec.messageDiagnostics(message));
    const packet = this.session.encode(message);
    const bytes = import_MessageCodec.MessageCodec.encodePacket(packet);
    if (bytes.length > this.maxPayloadSize) {
      logger.warn(
        `Matter message to send to ${this.name} is ${bytes.length}bytes long, which is larger than the maximum allowed size of ${this.maxPayloadSize}. This only works if both nodes support it.`
      );
    }
    return this.channel.send(bytes);
  }
  get name() {
    return `${this.channel.name} on session ${this.session.name}`;
  }
  async close() {
    const wasAlreadyClosed = this.closed;
    this.closed = true;
    await this.channel.close();
    if (!wasAlreadyClosed) {
      await this.#closeCallback?.();
    }
  }
}
class ExchangeManager {
  constructor(sessionManager, channelManager) {
    this.sessionManager = sessionManager;
    this.channelManager = channelManager;
  }
  exchangeCounter = new ExchangeCounter();
  exchanges = /* @__PURE__ */ new Map();
  protocols = /* @__PURE__ */ new Map();
  transportListeners = new Array();
  closingSessions = /* @__PURE__ */ new Set();
  addTransportInterface(netInterface) {
    const udpInterface = netInterface instanceof import_UdpInterface.UdpInterface;
    this.transportListeners.push(
      netInterface.onData((socket, data) => {
        if (udpInterface && data.length > socket.maxPayloadSize) {
          logger.warn(
            `Ignoring UDP message with size ${data.length} from ${socket.name}, which is larger than the maximum allowed size of ${socket.maxPayloadSize}.`
          );
          return;
        }
        try {
          this.onMessage(socket, data).catch((error) => logger.error(error));
        } catch (error) {
          logger.warn("Ignoring UDP message with error", error);
        }
      })
    );
  }
  hasProtocolHandler(protocolId) {
    return this.protocols.has(protocolId);
  }
  getProtocolHandler(protocolId) {
    return this.protocols.get(protocolId);
  }
  addProtocolHandler(protocol) {
    if (this.hasProtocolHandler(protocol.getId())) {
      throw new import_MatterError.ImplementationError(`Handler for protocol ${protocol.getId()} already registered.`);
    }
    this.protocols.set(protocol.getId(), protocol);
  }
  initiateExchange(fabric, nodeId, protocolId) {
    return this.initiateExchangeWithChannel(this.channelManager.getChannel(fabric, nodeId), protocolId);
  }
  initiateExchangeWithChannel(channel, protocolId) {
    const exchangeId = this.exchangeCounter.getIncrementedCounter();
    const exchangeIndex = exchangeId | 65536;
    const exchange = import_MessageExchange.MessageExchange.initiate(channel, exchangeId, protocolId);
    this.#addExchange(exchangeIndex, exchange);
    return exchange;
  }
  async close() {
    for (const protocol of this.protocols.values()) {
      await protocol.close();
    }
    for (const netListener of this.transportListeners) {
      await netListener.close();
    }
    this.transportListeners.length = 0;
    for (const exchange of this.exchanges.values()) {
      await exchange.destroy();
    }
    this.exchanges.clear();
  }
  async onMessage(channel, messageBytes) {
    const packet = import_MessageCodec.MessageCodec.decodePacket(messageBytes);
    if (packet.header.sessionType === import_MessageCodec.SessionType.Group)
      throw new import_MatterError.NotImplementedError("Group messages are not supported");
    let session;
    if (packet.header.sessionType === import_MessageCodec.SessionType.Unicast) {
      if (packet.header.sessionId === import_SessionManager.UNICAST_UNSECURE_SESSION_ID) {
        const initiatorNodeId = packet.header.sourceNodeId ?? import_NodeId.NodeId.UNSPECIFIED_NODE_ID;
        session = this.sessionManager.getUnsecureSession(initiatorNodeId) ?? this.sessionManager.createUnsecureSession({
          initiatorNodeId
        });
      } else {
        session = this.sessionManager.getSession(packet.header.sessionId);
      }
    } else if (packet.header.sessionType === import_MessageCodec.SessionType.Group) {
      if (packet.header.sourceNodeId !== void 0) {
      }
    }
    if (session === void 0) {
      throw new import_MatterError.MatterFlowError(
        `Cannot find a session for ID ${packet.header.sessionId}${packet.header.sourceNodeId !== void 0 ? ` and source NodeId ${packet.header.sourceNodeId}` : ""}`
      );
    }
    const messageId = packet.header.messageId;
    let isDuplicate;
    try {
      session?.updateMessageCounter(packet.header.messageId, packet.header.sourceNodeId);
      isDuplicate = false;
    } catch (e) {
      import_MessageReceptionState.DuplicateMessageError.accept(e);
      isDuplicate = true;
    }
    const aad = messageBytes.slice(0, messageBytes.length - packet.applicationPayload.length);
    const message = session.decode(packet, aad);
    const exchangeIndex = message.payloadHeader.isInitiatorMessage ? message.payloadHeader.exchangeId : message.payloadHeader.exchangeId | 65536;
    let exchange = this.exchanges.get(exchangeIndex);
    if (exchange !== void 0 && (exchange.session.id !== session.id || exchange.isInitiator === message.payloadHeader.isInitiatorMessage)) {
      exchange = void 0;
    }
    if (exchange !== void 0) {
      await exchange.onMessageReceived(message, isDuplicate);
    } else {
      if (session.closingAfterExchangeFinished) {
        throw new import_MatterError.MatterFlowError(
          `Session with ID ${packet.header.sessionId} marked for closure, decline new exchange creation.`
        );
      }
      const protocolHandler = this.protocols.get(message.payloadHeader.protocolId);
      if (protocolHandler !== void 0 && message.payloadHeader.isInitiatorMessage && !isDuplicate) {
        const exchange2 = import_MessageExchange.MessageExchange.fromInitialMessage(
          await this.channelManager.getOrCreateChannel(channel, session),
          message
        );
        this.#addExchange(exchangeIndex, exchange2);
        await exchange2.onMessageReceived(message);
        await protocolHandler.onNewExchange(exchange2, message);
      } else if (message.payloadHeader.requiresAck) {
        const exchange2 = import_MessageExchange.MessageExchange.fromInitialMessage(
          await this.channelManager.getOrCreateChannel(channel, session),
          message
        );
        this.#addExchange(exchangeIndex, exchange2);
        await exchange2.send(import_SecureChannelMessages.MessageType.StandaloneAck, new import_ByteArray.ByteArray(0), {
          includeAcknowledgeMessageId: message.packetHeader.messageId
        });
        await exchange2.close();
        logger.debug(
          `Ignoring unsolicited message ${messageId} for protocol ${message.payloadHeader.protocolId}.`
        );
      } else {
        if (protocolHandler === void 0) {
          throw new import_MatterError.MatterFlowError(`Unsupported protocol ${message.payloadHeader.protocolId}`);
        }
        if (isDuplicate) {
          logger.info(
            `Ignoring duplicate message ${messageId} (requires no ack) for protocol ${message.payloadHeader.protocolId}.`
          );
          return;
        } else {
          logger.info(
            `Discarding unexpected message ${messageId} for protocol ${message.payloadHeader.protocolId}, exchangeIndex ${exchangeIndex} and sessionId ${session.id} : ${import_Logger.Logger.toJSON(message)}`
          );
        }
      }
    }
  }
  async deleteExchange(exchangeIndex) {
    const exchange = this.exchanges.get(exchangeIndex);
    if (exchange === void 0) {
      logger.info(`Exchange with index ${exchangeIndex} to delete not found or already deleted.`);
      return;
    }
    const { session } = exchange;
    if (session.isSecure && session.closingAfterExchangeFinished) {
      logger.debug(
        `Exchange index ${exchangeIndex} Session ${session.name} is already marked for closure. Close session now.`
      );
      try {
        await this.closeSession(session);
      } catch (error) {
        logger.error(`Error closing session ${session.name}. Ignoring.`, error);
      }
    }
    this.exchanges.delete(exchangeIndex);
  }
  async closeSession(session) {
    const sessionId = session.id;
    const sessionName = session.name;
    if (this.sessionManager.getSession(sessionId) === void 0) {
      return;
    }
    if (this.closingSessions.has(sessionId)) {
      return;
    }
    this.closingSessions.add(sessionId);
    for (const [_exchangeIndex, exchange] of this.exchanges.entries()) {
      if (exchange.session.id === sessionId) {
        await exchange.destroy();
      }
    }
    if (session.sendCloseMessageWhenClosing) {
      const channel = this.channelManager.getChannelForSession(session);
      logger.debug(`Channel for session ${session.name} is ${channel?.name}`);
      if (channel !== void 0) {
        const exchange = this.initiateExchangeWithChannel(channel, import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID);
        logger.debug(`Initiated exchange ${!!exchange} to close session ${sessionName}`);
        if (exchange !== void 0) {
          try {
            const messenger = new import_SecureChannelMessenger.SecureChannelMessenger(exchange);
            await messenger.sendCloseSession();
            await messenger.close();
          } catch (error) {
            if (error instanceof ChannelNotConnectedError) {
              logger.debug("Session already closed because channel is disconnected.");
            } else {
              logger.error("Error closing session", error);
            }
          }
        }
        await exchange.destroy();
      }
    }
    if (session.closingAfterExchangeFinished) {
      await session.destroy(false, false);
    }
    this.sessionManager.removeSession(sessionId);
    this.closingSessions.delete(sessionId);
  }
  #addExchange(exchangeIndex, exchange) {
    exchange.closed.on(() => this.deleteExchange(exchangeIndex));
    this.exchanges.set(exchangeIndex, exchange);
  }
}
class ExchangeCounter {
  exchangeCounter = import_Crypto.Crypto.getRandomUInt16();
  getIncrementedCounter() {
    this.exchangeCounter++;
    if (this.exchangeCounter > 65535) {
      this.exchangeCounter = 0;
    }
    return this.exchangeCounter;
  }
}
class ExchangeProvider {
  constructor(exchangeManager, channel, reconnectChannelFunc) {
    this.exchangeManager = exchangeManager;
    this.channel = channel;
    this.reconnectChannelFunc = reconnectChannelFunc;
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  getProtocolHandler(protocolId) {
    return this.exchangeManager.getProtocolHandler(protocolId);
  }
  addProtocolHandler(handler) {
    this.exchangeManager.addProtocolHandler(handler);
  }
  initiateExchange() {
    return this.exchangeManager.initiateExchangeWithChannel(this.channel, import_InteractionServer.INTERACTION_PROTOCOL_ID);
  }
  async reconnectChannel() {
    if (this.reconnectChannelFunc === void 0) return false;
    this.channel = await this.reconnectChannelFunc();
    return true;
  }
  get session() {
    return this.channel.session;
  }
  get channelType() {
    return this.channel.type;
  }
}
//# sourceMappingURL=ExchangeManager.js.map
