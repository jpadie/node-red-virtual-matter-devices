{
  "version": 3,
  "sources": ["../../../src/protocol/MessageReceptionState.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError, MatterError } from \"../common/MatterError.js\";\nimport { MAX_COUNTER_VALUE_32BIT } from \"./MessageCounter.js\";\n\n/** 2^31 used for Duplicate detection in some cases. */\nconst MAX_COUNTER_INCREASE_2POW31 = Math.pow(2, 31);\n\n/** Maximum number of previously processed message counters to accept from a given Node and key. */\nconst MSG_COUNTER_WINDOW_SIZE = 32;\n\nexport class DuplicateMessageError extends MatterError {}\n\nexport abstract class MessageReceptionState {\n    abstract updateMessageCounter(messageCounter: number): void;\n}\n\n/**\n * Implements a message reception state for encrypted messages without rollover.\n * A counter in the range [(max_message_counter + 1) to (232 - 1)] SHALL be considered new, and cause the\n * max_message_counter value to be updated.\n * Message counters within the range of the bitmap SHALL be considered duplicate if the corresponding bit\n * offset is set to true. All other message counters SHALL be considered duplicate.\n */\nexport class MessageReceptionStateEncryptedWithoutRollover extends MessageReceptionState {\n    protected maximumMessageCounter: number | undefined;\n    private messageCounterBitmap = 0xffffffff; // All bits set to 1\n\n    constructor(messageCounter?: number) {\n        super();\n        if (messageCounter !== undefined) {\n            this.initialize(messageCounter);\n        }\n    }\n\n    /** Initialize the message counter state. */\n    private initialize(messageCounter: number) {\n        this.maximumMessageCounter = messageCounter;\n        this.messageCounterBitmap = 0xffffffff; // All bits set to 1\n    }\n\n    /**\n     * Calculate plain diff without rollover.\n     * This method is mainly overridden for other counter types and follow the following semantic\n     * Return number is:\n     * * negative if the new message counter is smaller than the current maximum. Smaller values within the Window size\n     *   are check separately within the window. Other smaller values are considered DUPLICATE\n     * * positive if the new message counter is larger than the current maximum and are always NEW\n     */\n    protected calculateDiff(messageCounter: number) {\n        if (this.maximumMessageCounter === undefined) {\n            return 0;\n        }\n        return messageCounter - this.maximumMessageCounter;\n    }\n\n    /** Update or move the message counter window. */\n    private calculateMessageCounterBitmap(messageCounterBitmap: number, diff: number) {\n        if (diff < 0) {\n            // negative value means the new message counter is smaller than the current maximum\n            if (diff < -MSG_COUNTER_WINDOW_SIZE) {\n                throw new InternalError(`Message counter difference too large: ${diff}`);\n            }\n            // set the corresponding bit\n            const bit = 1 << (-diff - 1);\n            messageCounterBitmap |= bit;\n        } else if (diff > 0) {\n            // positive value means new message counter is larger than the current maximum\n            if (diff <= MSG_COUNTER_WINDOW_SIZE) {\n                // shift the bitmap and set the bit for the previous maximum\n                const bit = 1 << (diff - 1);\n                messageCounterBitmap = ((messageCounterBitmap << diff) >>> 0) | bit;\n            } else {\n                // diff is larger than the window size, so no previous message counter is known\n                messageCounterBitmap = 0;\n            }\n        }\n        return messageCounterBitmap >>> 0; // Stay 32 bit unsigned integer\n    }\n\n    /** Update the message counter and window. */\n    private updateMessageCounterAndBitmap(messageCounter: number, diff: number) {\n        if (this.maximumMessageCounter === undefined) {\n            this.initialize(messageCounter);\n            return;\n        }\n\n        this.messageCounterBitmap = this.calculateMessageCounterBitmap(this.messageCounterBitmap, diff);\n\n        if (diff > 0 || diff < -MSG_COUNTER_WINDOW_SIZE) {\n            this.maximumMessageCounter = messageCounter;\n        }\n    }\n\n    /** Check if the message counter is known in the bitmap. */\n    private isCounterKnownInBitmap(diff: number) {\n        if (diff < -MSG_COUNTER_WINDOW_SIZE || diff >= 0) {\n            throw new InternalError(`Invalid Message counter difference for check: ${diff}`);\n        }\n        const bit = 1 << (-diff - 1);\n        return (this.messageCounterBitmap & bit) !== 0;\n    }\n\n    /**\n     * Returns true if the message counter is a duplicate.\n     */\n    updateMessageCounter(messageCounter: number) {\n        if (messageCounter < 0 || messageCounter > MAX_COUNTER_VALUE_32BIT) {\n            throw new InternalError(`Invalid message counter value: ${messageCounter}`);\n        }\n        if (this.maximumMessageCounter === undefined) {\n            this.updateMessageCounterAndBitmap(messageCounter, 0);\n            return;\n        }\n        if (messageCounter === this.maximumMessageCounter) {\n            throw new DuplicateMessageError(\"Message counter equals the maximum message counter.\");\n        }\n\n        const diff = this.calculateDiff(messageCounter);\n        // A counter in the range [(max_message_counter + 1) to (232 - 1)] SHALL be considered new, and cause the\n        // max_message_counter value to be updated.\n        // Message counters within the range of the bitmap SHALL be considered duplicate if the corresponding bit\n        // offset is set to true. All other message counters SHALL be considered duplicate.\n        if (diff < 0) {\n            if (diff < -MSG_COUNTER_WINDOW_SIZE) {\n                throw new DuplicateMessageError(\"Message counter is considered duplicate.\");\n            }\n            if (this.isCounterKnownInBitmap(diff)) {\n                throw new DuplicateMessageError(\"Message counter is within the message counter window and duplicate.\");\n            }\n        }\n        this.updateMessageCounterAndBitmap(messageCounter, diff);\n    }\n}\n\n/**\n * Implements a message reception state for encrypted messages with rollover.\n * A message counter with rollover is a free running message counter that monotonically increases, but rolls\n * over to zero when it exceeds the maximum value of the counter (32-bits). If the difference is below 2^31 then it is\n * considered a rollover and not a smaller value\n */\nexport class MessageReceptionStateEncryptedWithRollover extends MessageReceptionStateEncryptedWithoutRollover {\n    protected override calculateDiff(messageCounter: number) {\n        if (this.maximumMessageCounter === undefined) {\n            return 0;\n        }\n        // A message counter with rollover is a free running message counter that monotonically increases, but rolls\n        // over to zero when it exceeds the maximum value of the counter (32-bits). if the difference is below 2^31 then it is considered a rollover and not a smaller value\n        const diff = messageCounter - this.maximumMessageCounter;\n\n        if (diff > 0) {\n            // positive value means new message counter is larger than the current maximum\n            if (diff < MAX_COUNTER_INCREASE_2POW31) {\n                return diff;\n            }\n            return diff - MAX_COUNTER_VALUE_32BIT - 1;\n        } else if (diff < 0) {\n            // negative value means the new message counter is smaller than the current maximum\n            if (diff >= -MAX_COUNTER_INCREASE_2POW31) {\n                return diff;\n            }\n            return diff + MAX_COUNTER_VALUE_32BIT + 1;\n        }\n        return 0;\n    }\n}\n\n/**\n * Implements a message reception state for unencrypted messages without rollover.\n * Any message counter equal to max_message_counter or within the message counter window, where the corresponding bit\n * is set to true SHALL be considered duplicate. All other message counters, whether behind the window or ahead of\n * max_message_counter, are considered new and SHALL update max_message_counter and shift the window accordingly.\n * Messages with a counter behind the window are likely caused by a node rebooting and are thus processed as rolling\n * back the window to the current location.\n */\nexport class MessageReceptionStateUnencryptedWithRollover extends MessageReceptionStateEncryptedWithoutRollover {\n    protected override calculateDiff(messageCounter: number) {\n        if (this.maximumMessageCounter === undefined) {\n            return 0;\n        }\n        // A message counter with rollover is a free running message counter that monotonically increases, but rolls\n        // over to zero when it exceeds the maximum value of the counter (32-bits).\n        // Any message counter equal to max_message_counter or within the message counter window, where the corresponding\n        // bit is set to true SHALL be considered duplicate. All other message counters, whether behind the window or\n        // ahead of max_message_counter, are considered new and SHALL update max_message_counter\n        const diff = messageCounter - this.maximumMessageCounter;\n\n        if (diff > 0) {\n            // positive value means new message counter is larger than the current maximum\n            if (-diff + MAX_COUNTER_VALUE_32BIT < MSG_COUNTER_WINDOW_SIZE) {\n                return diff - MAX_COUNTER_VALUE_32BIT - 1;\n            }\n            return diff;\n        } else if (diff < 0) {\n            // negative value means the new message counter is smaller than the current maximum\n            if (diff < -MSG_COUNTER_WINDOW_SIZE) {\n                return MAX_COUNTER_VALUE_32BIT + diff;\n            }\n            return diff;\n        }\n        return 0;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
