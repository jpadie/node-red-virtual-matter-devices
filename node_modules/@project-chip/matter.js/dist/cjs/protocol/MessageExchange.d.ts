/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Message } from "../codec/MessageCodec.js";
import { MatterError } from "../common/MatterError.js";
import { NodeId } from "../datatype/NodeId.js";
import { Session } from "../session/Session.js";
import { ByteArray } from "../util/ByteArray.js";
import { AsyncObservable } from "../util/Observable.js";
import { MessageChannel } from "./ExchangeManager.js";
export declare class RetransmissionLimitReachedError extends MatterError {
}
export declare class UnexpectedMessageError extends MatterError {
    readonly receivedMessage: Message;
    constructor(message: string, receivedMessage: Message);
}
export type ExchangeSendOptions = {
    /**
     * The response to this send should be an ack only and no StatusResponse or such. If a StatusResponse is returned
     * then this is handled as error.
     */
    expectAckOnly?: boolean;
    /**
     * Define a minimum Response Timeout. This setting only increases the response timeout! The minimum four
     * resubmissions are always done regardless of what is specified here. The logic will check if the timeout is
     * reached after each resubmission, so it is not checked exact at the given timeout.
     */
    minimumResponseTimeoutMs?: number;
    /** Allows to specify if the send message requires to be acknowledged by the receiver or not. */
    requiresAck?: boolean;
    /** Use the provided acknowledge MessageId instead checking the latest to send one */
    includeAcknowledgeMessageId?: number;
};
/**
 * Message size overhead of a Matter message:
 * 26 (Matter Message Header) + 12 (Matter Payload Header) taken from https://github.com/project-chip/connectedhomeip/blob/2d97cda23024e72f36216900ca667bf1a0d9499f/src/system/SystemConfig.h#L327
 * 16 byte MIC is then also needed to be excluded from the max payload size
 * Secure Extensions and Message Extensions need to be handled by exchange additionally!
 */
export declare const MATTER_MESSAGE_OVERHEAD: number;
export declare class MessageExchange<ContextT> {
    #private;
    readonly session: Session<ContextT>;
    readonly channel: MessageChannel<ContextT>;
    readonly isInitiator: boolean;
    static fromInitialMessage<ContextT>(channel: MessageChannel<ContextT>, initialMessage: Message): MessageExchange<ContextT>;
    static initiate<ContextT>(channel: MessageChannel<ContextT>, exchangeId: number, protocolId: number): MessageExchange<ContextT>;
    constructor(session: Session<ContextT>, channel: MessageChannel<ContextT>, isInitiator: boolean, peerSessionId: number, nodeId: NodeId | undefined, peerNodeId: NodeId | undefined, exchangeId: number, protocolId: number);
    get closed(): AsyncObservable<[], void>;
    /**
     * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter
     * protocol overhead.
     */
    get maxPayloadSize(): number;
    sendStandaloneAckForMessage(message: Message): Promise<void>;
    onMessageReceived(message: Message, isDuplicate?: boolean): Promise<void>;
    send(messageType: number, payload: ByteArray, options?: ExchangeSendOptions): Promise<void>;
    nextMessage(): Promise<Message>;
    waitFor(messageType: number, timeoutMs?: number): Promise<Message>;
    /** @see {@link MatterSpecification.v10.Core}, section 4.11.2.1 */
    private getResubmissionBackOffTime;
    private retransmitMessage;
    destroy(): Promise<void>;
    startTimedInteraction(timeoutMs: number): void;
    clearTimedInteraction(): void;
    hasTimedInteraction(): boolean;
    hasActiveTimedInteraction(): boolean;
    hasExpiredTimedInteraction(): boolean;
    close(): Promise<void>;
    private closeInternal;
}
//# sourceMappingURL=MessageExchange.d.ts.map