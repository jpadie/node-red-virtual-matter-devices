/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterController } from "../MatterController.js";
import { Message } from "../codec/MessageCodec.js";
import { Channel } from "../common/Channel.js";
import { MatterError } from "../common/MatterError.js";
import { TransportInterface } from "../common/TransportInterface.js";
import { NodeId } from "../datatype/NodeId.js";
import { Fabric } from "../fabric/Fabric.js";
import { SecureSession } from "../session/SecureSession.js";
import { Session } from "../session/Session.js";
import { SessionManager } from "../session/SessionManager.js";
import { ByteArray } from "../util/ByteArray.js";
import { ChannelManager } from "./ChannelManager.js";
import { MessageExchange } from "./MessageExchange.js";
import { ProtocolHandler } from "./ProtocolHandler.js";
export declare class ChannelNotConnectedError extends MatterError {
}
export declare class MessageChannel<ContextT> implements Channel<Message> {
    #private;
    readonly channel: Channel<ByteArray>;
    readonly session: Session<ContextT>;
    closed: boolean;
    constructor(channel: Channel<ByteArray>, session: Session<ContextT>, closeCallback?: () => Promise<void>);
    set closeCallback(callback: () => Promise<void>);
    /** Is the underlying transport reliable? */
    get isReliable(): boolean;
    get type(): import("../common/Channel.js").ChannelType;
    /**
     * Max Payload size of the exchange which bases on the maximum payload size of the channel. The full encoded matter
     * message payload sent here can be as huge as allowed by the channel.
     */
    get maxPayloadSize(): number;
    send(message: Message): Promise<void>;
    get name(): string;
    close(): Promise<void>;
}
export declare class ExchangeManager<ContextT> {
    #private;
    private readonly sessionManager;
    private readonly channelManager;
    private readonly exchangeCounter;
    private readonly exchanges;
    private readonly protocols;
    private readonly transportListeners;
    private readonly closingSessions;
    constructor(sessionManager: SessionManager<ContextT>, channelManager: ChannelManager);
    addTransportInterface(netInterface: TransportInterface): void;
    hasProtocolHandler(protocolId: number): boolean;
    getProtocolHandler(protocolId: number): ProtocolHandler<ContextT> | undefined;
    addProtocolHandler(protocol: ProtocolHandler<ContextT>): void;
    initiateExchange(fabric: Fabric, nodeId: NodeId, protocolId: number): MessageExchange<ContextT>;
    initiateExchangeWithChannel(channel: MessageChannel<ContextT>, protocolId: number): MessageExchange<ContextT>;
    close(): Promise<void>;
    private onMessage;
    deleteExchange(exchangeIndex: number): Promise<void>;
    closeSession(session: SecureSession<any>): Promise<void>;
}
export declare class ExchangeCounter {
    private exchangeCounter;
    getIncrementedCounter(): number;
}
export declare class ExchangeProvider {
    private readonly exchangeManager;
    private channel;
    private readonly reconnectChannelFunc?;
    constructor(exchangeManager: ExchangeManager<MatterController>, channel: MessageChannel<MatterController>, reconnectChannelFunc?: (() => Promise<MessageChannel<MatterController>>) | undefined);
    hasProtocolHandler(protocolId: number): boolean;
    getProtocolHandler(protocolId: number): ProtocolHandler<MatterController> | undefined;
    addProtocolHandler(handler: ProtocolHandler<MatterController>): void;
    initiateExchange(): MessageExchange<MatterController>;
    reconnectChannel(): Promise<boolean>;
    get session(): Session<MatterController>;
    get channelType(): import("../common/Channel.js").ChannelType;
}
//# sourceMappingURL=ExchangeManager.d.ts.map