"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MessageExchange_exports = {};
__export(MessageExchange_exports, {
  MATTER_MESSAGE_OVERHEAD: () => MATTER_MESSAGE_OVERHEAD,
  MessageExchange: () => MessageExchange,
  RetransmissionLimitReachedError: () => RetransmissionLimitReachedError,
  UnexpectedMessageError: () => UnexpectedMessageError
});
module.exports = __toCommonJS(MessageExchange_exports);
var import_MessageCodec = require("../codec/MessageCodec.js");
var import_MatterError = require("../common/MatterError.js");
var import_CryptoConstants = require("../crypto/CryptoConstants.js");
var import_Diagnostic = require("../log/Diagnostic.js");
var import_Logger = require("../log/Logger.js");
var import_Session = require("../session/Session.js");
var import_Time = require("../time/Time.js");
var import_ByteArray = require("../util/ByteArray.js");
var import_Observable = require("../util/Observable.js");
var import_Promises = require("../util/Promises.js");
var import_Queue = require("../util/Queue.js");
var import_ExchangeManager = require("./ExchangeManager.js");
var import_StatusCode = require("./interaction/StatusCode.js");
var import_SecureChannelMessages = require("./securechannel/SecureChannelMessages.js");
var import_SecureChannelProtocol = require("./securechannel/SecureChannelProtocol.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("MessageExchange");
class RetransmissionLimitReachedError extends import_MatterError.MatterError {
}
class UnexpectedMessageError extends import_MatterError.MatterError {
  constructor(message, receivedMessage) {
    super(`(${import_MessageCodec.MessageCodec.messageDiagnostics(receivedMessage)}) ${message}`);
    this.receivedMessage = receivedMessage;
  }
}
const MRP_MAX_TRANSMISSIONS = 5;
const MRP_BACKOFF_BASE = 1.6;
const MRP_BACKOFF_JITTER = 0.25;
const MRP_BACKOFF_MARGIN = 1.1;
const MRP_BACKOFF_THRESHOLD = 1;
const MRP_STANDALONE_ACK_TIMEOUT_MS = 200;
const MATTER_MESSAGE_OVERHEAD = 26 + 12 + import_CryptoConstants.CRYPTO_AEAD_MIC_LENGTH_BYTES;
class MessageExchange {
  constructor(session, channel, isInitiator, peerSessionId, nodeId, peerNodeId, exchangeId, protocolId) {
    this.session = session;
    this.channel = channel;
    this.isInitiator = isInitiator;
    this.#peerSessionId = peerSessionId;
    this.#nodeId = nodeId;
    this.#peerNodeId = peerNodeId;
    this.#exchangeId = exchangeId;
    this.#protocolId = protocolId;
    const { activeIntervalMs, idleIntervalMs, activeThresholdMs } = session.parameters;
    this.#activeIntervalMs = activeIntervalMs ?? import_Session.SESSION_ACTIVE_INTERVAL_MS;
    this.#idleIntervalMs = idleIntervalMs ?? import_Session.SESSION_IDLE_INTERVAL_MS;
    this.#activeThresholdMs = activeThresholdMs ?? import_Session.SESSION_ACTIVE_THRESHOLD_MS;
    this.#maxTransmissions = MRP_MAX_TRANSMISSIONS;
    this.#useMRP = session.supportsMRP && !channel.isReliable;
    logger.debug(
      "New exchange",
      import_Diagnostic.Diagnostic.dict({
        channel: channel.name,
        protocol: this.#protocolId,
        id: this.#exchangeId,
        session: session.name,
        peerSessionId: this.#peerSessionId,
        "active threshold ms": this.#activeThresholdMs,
        "active interval ms": this.#activeIntervalMs,
        "idle interval ms": this.#idleIntervalMs,
        maxTransmissions: this.#maxTransmissions,
        useMrp: this.#useMRP
      })
    );
  }
  static fromInitialMessage(channel, initialMessage) {
    const { session } = channel;
    return new MessageExchange(
      session,
      channel,
      false,
      session.id,
      initialMessage.packetHeader.destNodeId,
      initialMessage.packetHeader.sourceNodeId,
      initialMessage.payloadHeader.exchangeId,
      initialMessage.payloadHeader.protocolId
    );
  }
  static initiate(channel, exchangeId, protocolId) {
    const { session } = channel;
    return new MessageExchange(
      session,
      channel,
      true,
      session.peerSessionId,
      session.nodeId,
      session.peerNodeId,
      exchangeId,
      protocolId
    );
  }
  #activeIntervalMs;
  #idleIntervalMs;
  #activeThresholdMs;
  #maxTransmissions;
  #messagesQueue = new import_Queue.Queue();
  #receivedMessageToAck;
  #receivedMessageAckTimer = import_Time.Time.getTimer("Ack receipt timeout", MRP_STANDALONE_ACK_TIMEOUT_MS, () => {
    if (this.#receivedMessageToAck !== void 0) {
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      this.sendStandaloneAckForMessage(messageToAck).catch(
        (error) => logger.error("An error happened when sending a standalone ack", error)
      );
    }
  });
  #sentMessageToAck;
  #sentMessageAckSuccess;
  #sentMessageAckFailure;
  #retransmissionTimer;
  #retransmissionCounter = 0;
  #closeTimer;
  #timedInteractionTimer;
  #peerSessionId;
  #nodeId;
  #peerNodeId;
  #exchangeId;
  #protocolId;
  #closed = (0, import_Observable.AsyncObservable)();
  #useMRP;
  get closed() {
    return this.#closed;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter
   * protocol overhead.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize - MATTER_MESSAGE_OVERHEAD;
  }
  async sendStandaloneAckForMessage(message) {
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck }
    } = message;
    if (!requiresAck || !this.#useMRP) return;
    await this.send(import_SecureChannelMessages.MessageType.StandaloneAck, new import_ByteArray.ByteArray(0), { includeAcknowledgeMessageId: messageId });
  }
  async onMessageReceived(message, isDuplicate = false) {
    logger.debug("Message \xAB", import_MessageCodec.MessageCodec.messageDiagnostics(message, isDuplicate));
    if (message.payloadHeader.requiresAck && !this.#useMRP) {
      logger.debug("Ignoring ack-required flag because MRP is not used for this exchange");
      message.payloadHeader.requiresAck = false;
    }
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck, ackedMessageId, protocolId, messageType }
    } = message;
    const isStandaloneAck = import_SecureChannelProtocol.SecureChannelProtocol.isStandaloneAck(protocolId, messageType);
    if (protocolId !== this.#protocolId && !isStandaloneAck) {
      throw new import_MatterError.MatterFlowError(
        `Drop received a message for an unexpected protocol. Expected: ${this.#protocolId}, received: ${protocolId}`
      );
    }
    this.session.notifyActivity(true);
    if (isDuplicate) {
      if (requiresAck) {
        await this.sendStandaloneAckForMessage(message);
      }
      return;
    }
    if (messageId === this.#sentMessageToAck?.payloadHeader.ackedMessageId) {
      await this.channel.send(this.#sentMessageToAck);
      return;
    }
    const sentMessageIdToAck = this.#sentMessageToAck?.packetHeader.messageId;
    if (sentMessageIdToAck !== void 0) {
      if (ackedMessageId === void 0) {
        throw new import_MatterError.MatterFlowError("Previous message ack is missing");
      } else if (ackedMessageId !== sentMessageIdToAck) {
        if (isStandaloneAck) {
        } else {
          throw new import_MatterError.MatterFlowError(
            `Incorrect ack received. Expected ${sentMessageIdToAck}, received: ${ackedMessageId}`
          );
        }
      } else {
        this.#retransmissionTimer?.stop();
        this.#retransmissionCounter = 0;
        this.#sentMessageAckSuccess?.(message);
        this.#sentMessageAckSuccess = void 0;
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageToAck = void 0;
        if (isStandaloneAck && this.#closeTimer !== void 0) {
          return this.closeInternal();
        }
      }
    }
    if (isStandaloneAck) {
      return;
    }
    if (requiresAck) {
      if (this.#receivedMessageToAck !== void 0) {
        this.#receivedMessageAckTimer.stop();
        await this.sendStandaloneAckForMessage(this.#receivedMessageToAck);
        return;
      }
      this.#receivedMessageToAck = message;
      this.#receivedMessageAckTimer.start();
    }
    await this.#messagesQueue.write(message);
  }
  async send(messageType, payload, options) {
    if (options?.requiresAck && !this.#useMRP) {
      options.requiresAck = false;
    }
    const {
      expectAckOnly = false,
      minimumResponseTimeoutMs,
      requiresAck,
      includeAcknowledgeMessageId
    } = options ?? {};
    if (!this.#useMRP && includeAcknowledgeMessageId !== void 0) {
      throw new import_MatterError.InternalError("Cannot include an acknowledge message ID when MRP is not used");
    }
    if (messageType === import_SecureChannelMessages.MessageType.StandaloneAck) {
      if (!this.#useMRP) {
        return;
      }
      if (requiresAck) {
        throw new import_MatterError.MatterFlowError("A standalone ack may not require acknowledgement.");
      }
    }
    if (this.#sentMessageToAck !== void 0 && messageType !== import_SecureChannelMessages.MessageType.StandaloneAck)
      throw new import_MatterError.MatterFlowError("The previous message has not been acked yet, cannot send a new message.");
    this.session.notifyActivity(false);
    let ackedMessageId = includeAcknowledgeMessageId;
    if (ackedMessageId === void 0 && this.#useMRP) {
      ackedMessageId = this.#receivedMessageToAck?.packetHeader.messageId;
      if (ackedMessageId !== void 0) {
        this.#receivedMessageAckTimer.stop();
        this.#receivedMessageToAck = void 0;
      }
    }
    const message = {
      packetHeader: {
        sessionId: this.#peerSessionId,
        sessionType: import_MessageCodec.SessionType.Unicast,
        // TODO: support multicast/groups
        messageId: await this.session.getIncrementedMessageCounter(),
        destNodeId: this.#peerNodeId,
        sourceNodeId: this.#nodeId,
        hasPrivacyEnhancements: false,
        isControlMessage: false,
        hasMessageExtensions: false
      },
      payloadHeader: {
        exchangeId: this.#exchangeId,
        protocolId: messageType === import_SecureChannelMessages.MessageType.StandaloneAck ? import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID : this.#protocolId,
        messageType,
        isInitiatorMessage: this.isInitiator,
        requiresAck: requiresAck ?? (this.#useMRP && messageType !== import_SecureChannelMessages.MessageType.StandaloneAck),
        ackedMessageId,
        hasSecuredExtension: false
      },
      payload
    };
    let ackPromise;
    if (this.#useMRP && message.payloadHeader.requiresAck) {
      this.#sentMessageToAck = message;
      this.#retransmissionTimer = import_Time.Time.getTimer(
        "Message retransmission",
        this.getResubmissionBackOffTime(0),
        () => this.retransmitMessage(
          message,
          minimumResponseTimeoutMs !== void 0 ? import_Time.Time.nowMs() + minimumResponseTimeoutMs : void 0
        )
      );
      const { promise, resolver, rejecter } = (0, import_Promises.createPromise)();
      ackPromise = promise;
      this.#sentMessageAckSuccess = resolver;
      this.#sentMessageAckFailure = rejecter;
    }
    await this.channel.send(message);
    if (ackPromise !== void 0) {
      this.#retransmissionCounter = 0;
      this.#retransmissionTimer?.start();
      const responseMessage = await ackPromise;
      this.#sentMessageAckSuccess = void 0;
      this.#sentMessageAckFailure = void 0;
      const {
        payloadHeader: { protocolId, messageType: messageType2 }
      } = responseMessage;
      if (expectAckOnly && !import_SecureChannelProtocol.SecureChannelProtocol.isStandaloneAck(protocolId, messageType2)) {
        throw new UnexpectedMessageError("Expected ack only", responseMessage);
      }
    }
  }
  nextMessage() {
    return this.#messagesQueue.read();
  }
  async waitFor(messageType, timeoutMs = 18e4) {
    const message = await this.#messagesQueue.read(timeoutMs);
    const {
      payloadHeader: { messageType: receivedMessageType }
    } = message;
    if (receivedMessageType !== messageType)
      throw new import_MatterError.MatterFlowError(
        `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(
          16
        )}`
      );
    return message;
  }
  /** @see {@link MatterSpecification.v10.Core}, section 4.11.2.1 */
  getResubmissionBackOffTime(retransmissionCount) {
    const baseInterval = this.session.isPeerActive() ? this.#activeIntervalMs : this.#idleIntervalMs;
    return Math.floor(
      MRP_BACKOFF_MARGIN * baseInterval * Math.pow(MRP_BACKOFF_BASE, Math.max(0, retransmissionCount - MRP_BACKOFF_THRESHOLD)) * (1 + Math.random() * MRP_BACKOFF_JITTER)
    );
  }
  retransmitMessage(message, notTimeoutBeforeTimeMs) {
    this.#retransmissionCounter++;
    if (this.#retransmissionCounter >= this.#maxTransmissions && (notTimeoutBeforeTimeMs === void 0 || import_Time.Time.nowMs() > notTimeoutBeforeTimeMs)) {
      if (this.#sentMessageToAck !== void 0 && this.#sentMessageAckFailure !== void 0) {
        this.#receivedMessageToAck = void 0;
        this.#sentMessageAckFailure(new RetransmissionLimitReachedError());
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageAckSuccess = void 0;
      }
      if (this.#closeTimer !== void 0) {
        this.closeInternal().catch((error) => logger.error("An error happened when closing the exchange", error));
      }
      return;
    }
    this.session.notifyActivity(false);
    if (this.#retransmissionCounter === 1) {
    }
    const resubmissionBackoffTime = this.getResubmissionBackOffTime(this.#retransmissionCounter);
    logger.debug(
      `Resubmit message ${message.packetHeader.messageId} (retransmission attempt ${this.#retransmissionCounter}, backoff time ${resubmissionBackoffTime}ms))`
    );
    this.channel.send(message).then(() => {
      this.#retransmissionTimer = import_Time.Time.getTimer(
        "Message retransmission",
        resubmissionBackoffTime,
        () => this.retransmitMessage(message, notTimeoutBeforeTimeMs)
      ).start();
    }).catch((error) => {
      logger.error("An error happened when retransmitting a message", error);
      if (error instanceof import_ExchangeManager.ChannelNotConnectedError) {
        this.closeInternal().catch(
          (error2) => logger.error("An error happened when closing the exchange", error2)
        );
      }
    });
  }
  async destroy() {
    if (this.#closeTimer === void 0 && this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
    }
    await this.closeInternal();
  }
  startTimedInteraction(timeoutMs) {
    if (this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning) {
      this.#timedInteractionTimer.stop();
      throw new import_StatusCode.StatusResponseError(
        "Timed interaction already running for this exchange",
        import_StatusCode.StatusCode.InvalidAction
      );
    }
    logger.debug(
      `Starting timed interaction with Transaction ID ${this.#exchangeId} for ${timeoutMs}ms from ${this.channel.name}`
    );
    this.#timedInteractionTimer = import_Time.Time.getTimer("Timed interaction", timeoutMs, () => {
      logger.debug(
        `Timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name} timed out`
      );
    }).start();
  }
  clearTimedInteraction() {
    if (this.#timedInteractionTimer !== void 0) {
      logger.debug(
        `Clearing timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name}`
      );
      this.#timedInteractionTimer.stop();
      this.#timedInteractionTimer = void 0;
    }
  }
  hasTimedInteraction() {
    return this.#timedInteractionTimer !== void 0;
  }
  hasActiveTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning;
  }
  hasExpiredTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && !this.#timedInteractionTimer.isRunning;
  }
  async close() {
    if (this.#closeTimer !== void 0) return;
    if (this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
    } else if (this.#sentMessageToAck === void 0) {
      return this.closeInternal();
    }
    let maxResubmissionTime = 0;
    for (let i = this.#retransmissionCounter; i <= this.#maxTransmissions; i++) {
      maxResubmissionTime += this.getResubmissionBackOffTime(i);
    }
    this.#closeTimer = import_Time.Time.getTimer(
      "Message exchange cleanup",
      maxResubmissionTime,
      async () => await this.closeInternal()
    ).start();
  }
  async closeInternal() {
    this.#retransmissionTimer?.stop();
    this.#closeTimer?.stop();
    this.#timedInteractionTimer?.stop();
    this.#messagesQueue.close();
    await this.#closed.emit();
  }
}
//# sourceMappingURL=MessageExchange.js.map
