"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SecureChannelMessenger_exports = {};
__export(SecureChannelMessenger_exports, {
  ChannelStatusResponseError: () => ChannelStatusResponseError,
  SecureChannelMessenger: () => SecureChannelMessenger
});
module.exports = __toCommonJS(SecureChannelMessenger_exports);
var import_MatterError = require("../../common/MatterError.js");
var import_SecureChannelMessages = require("./SecureChannelMessages.js");
var import_SecureChannelStatusMessageSchema = require("./SecureChannelStatusMessageSchema.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class ChannelStatusResponseError extends import_MatterError.MatterError {
  constructor(message, generalStatusCode, protocolStatusCode) {
    super(`(${generalStatusCode}/${protocolStatusCode}) ${message}`);
    this.generalStatusCode = generalStatusCode;
    this.protocolStatusCode = protocolStatusCode;
  }
}
class SecureChannelMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  async nextMessage(expectedMessageInfo, expectedMessageType) {
    const message = await this.exchange.nextMessage();
    const messageType = message.payloadHeader.messageType;
    this.throwIfErrorStatusReport(message, expectedMessageInfo);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType)
      throw new import_MatterError.UnexpectedDataError(
        `Received unexpected message type: ${messageType}, expected: ${expectedMessageType} (${expectedMessageInfo})`
      );
    return message;
  }
  async nextMessageDecoded(expectedMessageType, schema, expectedMessageInfo) {
    return schema.decode((await this.nextMessage(expectedMessageInfo, expectedMessageType)).payload);
  }
  async waitForSuccess(expectedMessageInfo) {
    await this.nextMessage(expectedMessageInfo, import_SecureChannelMessages.MessageType.StatusReport);
  }
  async send(message, type, schema) {
    const payload = schema.encode(message);
    await this.exchange.send(type, payload);
    return payload;
  }
  sendError(code) {
    return this.sendStatusReport(import_SecureChannelMessages.GeneralStatusCode.Failure, code);
  }
  sendSuccess() {
    return this.sendStatusReport(import_SecureChannelMessages.GeneralStatusCode.Success, import_SecureChannelMessages.ProtocolStatusCode.Success);
  }
  sendCloseSession() {
    return this.sendStatusReport(import_SecureChannelMessages.GeneralStatusCode.Success, import_SecureChannelMessages.ProtocolStatusCode.CloseSession, false);
  }
  getChannelName() {
    return this.exchange.channel.channel.name;
  }
  async close() {
    await this.exchange.close();
  }
  async sendStatusReport(generalStatus, protocolStatus, requiresAck) {
    await this.exchange.send(
      import_SecureChannelMessages.MessageType.StatusReport,
      import_SecureChannelStatusMessageSchema.TlvSecureChannelStatusMessage.encode({
        generalStatus,
        protocolId: import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID,
        protocolStatus
      }),
      { requiresAck }
    );
  }
  throwIfErrorStatusReport(message, logHint) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== import_SecureChannelMessages.MessageType.StatusReport) return;
    const { generalStatus, protocolId, protocolStatus } = import_SecureChannelStatusMessageSchema.TlvSecureChannelStatusMessage.decode(payload);
    if (generalStatus !== import_SecureChannelMessages.GeneralStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general error status for protocol ${protocolId}${logHint ? ` (${logHint})` : ""}`,
        generalStatus,
        protocolStatus
      );
    }
    if (protocolStatus !== import_SecureChannelMessages.ProtocolStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general success status, but protocol status is not Success${logHint ? ` (${logHint})` : ""}`,
        generalStatus,
        protocolStatus
      );
    }
  }
}
//# sourceMappingURL=SecureChannelMessenger.js.map
