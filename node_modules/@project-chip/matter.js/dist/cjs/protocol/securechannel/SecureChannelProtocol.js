"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SecureChannelProtocol_exports = {};
__export(SecureChannelProtocol_exports, {
  SecureChannelProtocol: () => SecureChannelProtocol,
  StatusReportOnlySecureChannelProtocol: () => StatusReportOnlySecureChannelProtocol
});
module.exports = __toCommonJS(SecureChannelProtocol_exports);
var import_MatterError = require("../../common/MatterError.js");
var import_Logger = require("../../log/Logger.js");
var import_SecureSession = require("../../session/SecureSession.js");
var import_CaseServer = require("../../session/case/CaseServer.js");
var import_PaseServer = require("../../session/pase/PaseServer.js");
var import_StatusCode = require("../interaction/StatusCode.js");
var import_SecureChannelMessages = require("./SecureChannelMessages.js");
var import_SecureChannelMessenger = require("./SecureChannelMessenger.js");
var import_SecureChannelStatusMessageSchema = require("./SecureChannelStatusMessageSchema.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("SecureChannelProtocol");
class StatusReportOnlySecureChannelProtocol {
  getId() {
    return import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID;
  }
  async onNewExchange(exchange, message) {
    const messageType = message.payloadHeader.messageType;
    switch (messageType) {
      case import_SecureChannelMessages.MessageType.StatusReport:
        await this.handleInitialStatusReport(exchange, message);
        break;
      default:
        if (messageType !== import_SecureChannelMessages.MessageType.StandaloneAck) {
          throw new import_StatusCode.StatusResponseError(
            `Unexpected initial message on secure channel protocol: ${messageType.toString(16)}`,
            import_StatusCode.StatusCode.InvalidAction
          );
        }
    }
  }
  async handleInitialStatusReport(exchange, message) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== import_SecureChannelMessages.MessageType.StatusReport) {
      throw new import_MatterError.MatterFlowError(
        `Unexpected message type on secure channel protocol, expected StatusReport: ${messageType.toString(
          16
        )}`
      );
    }
    const { generalStatus, protocolId, protocolStatus } = import_SecureChannelStatusMessageSchema.TlvSecureChannelStatusMessage.decode(payload);
    if (generalStatus !== import_SecureChannelMessages.GeneralStatusCode.Success) {
      throw new import_SecureChannelMessenger.ChannelStatusResponseError(
        `Received general error status (${protocolId})`,
        generalStatus,
        protocolStatus
      );
    }
    if (protocolStatus !== import_SecureChannelMessages.ProtocolStatusCode.CloseSession) {
      throw new import_SecureChannelMessenger.ChannelStatusResponseError(
        `Received general success status, but protocol status is not CloseSession`,
        generalStatus,
        protocolStatus
      );
    }
    const { session } = exchange;
    (0, import_SecureSession.assertSecureSession)(session);
    logger.debug(`Peer requested to close session ${session.name}. Remove session now.`);
    await session.destroy(false, false);
  }
  async close() {
  }
}
class SecureChannelProtocol extends StatusReportOnlySecureChannelProtocol {
  constructor(commissioningCancelledCallback) {
    super();
    this.commissioningCancelledCallback = commissioningCancelledCallback;
  }
  paseCommissioner;
  caseCommissioner = new import_CaseServer.CaseServer();
  setPaseCommissioner(paseServer) {
    this.paseCommissioner = paseServer;
  }
  removePaseCommissioner() {
    this.paseCommissioner = void 0;
  }
  async onNewExchange(exchange, message) {
    const messageType = message.payloadHeader.messageType;
    switch (messageType) {
      case import_SecureChannelMessages.MessageType.PbkdfParamRequest:
        if (this.paseCommissioner === void 0) {
          const messenger = new import_SecureChannelMessenger.SecureChannelMessenger(exchange);
          await messenger.sendError(import_SecureChannelMessages.ProtocolStatusCode.InvalidParam);
          await messenger.close();
          return;
        }
        try {
          await this.paseCommissioner.onNewExchange(exchange);
        } catch (error) {
          import_PaseServer.MaximumPasePairingErrorsReachedError.accept(error);
          logger.info("Maximum number of PASE pairing errors reached, cancelling commissioning.");
          await this.commissioningCancelledCallback();
        }
        break;
      case import_SecureChannelMessages.MessageType.Sigma1:
        await this.caseCommissioner.onNewExchange(exchange);
        break;
      default:
        await super.onNewExchange(exchange, message);
    }
  }
  static isStandaloneAck(protocolId, messageType) {
    return protocolId === import_SecureChannelMessages.SECURE_CHANNEL_PROTOCOL_ID && messageType === import_SecureChannelMessages.MessageType.StandaloneAck;
  }
}
//# sourceMappingURL=SecureChannelProtocol.js.map
