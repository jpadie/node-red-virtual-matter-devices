{
  "version": 3,
  "sources": ["../../../../src/protocol/securechannel/SecureChannelProtocol.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Message } from \"../../codec/MessageCodec.js\";\nimport { MatterFlowError } from \"../../common/MatterError.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { MessageExchange } from \"../../protocol/MessageExchange.js\";\nimport { ProtocolHandler } from \"../../protocol/ProtocolHandler.js\";\nimport { assertSecureSession } from \"../../session/SecureSession.js\";\nimport { CaseServer } from \"../../session/case/CaseServer.js\";\nimport { MaximumPasePairingErrorsReachedError, PaseServer } from \"../../session/pase/PaseServer.js\";\nimport { StatusCode, StatusResponseError } from \"../interaction/StatusCode.js\";\nimport {\n    GeneralStatusCode,\n    MessageType,\n    ProtocolStatusCode,\n    SECURE_CHANNEL_PROTOCOL_ID,\n} from \"./SecureChannelMessages.js\";\nimport { ChannelStatusResponseError, SecureChannelMessenger } from \"./SecureChannelMessenger.js\";\nimport { TlvSecureChannelStatusMessage } from \"./SecureChannelStatusMessageSchema.js\";\n\nconst logger = Logger.get(\"SecureChannelProtocol\");\n\nexport class StatusReportOnlySecureChannelProtocol implements ProtocolHandler<any> {\n    getId(): number {\n        return SECURE_CHANNEL_PROTOCOL_ID;\n    }\n\n    async onNewExchange(exchange: MessageExchange<any>, message: Message) {\n        const messageType = message.payloadHeader.messageType;\n\n        switch (messageType) {\n            case MessageType.StatusReport:\n                await this.handleInitialStatusReport(exchange, message);\n                break;\n            default:\n                // We silently ignore incoming Standalone Ack messages that we do not expect here\n                if (messageType !== MessageType.StandaloneAck) {\n                    throw new StatusResponseError(\n                        `Unexpected initial message on secure channel protocol: ${messageType.toString(16)}`,\n                        StatusCode.InvalidAction,\n                    );\n                }\n        }\n    }\n\n    async handleInitialStatusReport(exchange: MessageExchange<any>, message: Message) {\n        const {\n            payloadHeader: { messageType },\n            payload,\n        } = message;\n        if (messageType !== MessageType.StatusReport) {\n            throw new MatterFlowError(\n                `Unexpected message type on secure channel protocol, expected StatusReport: ${messageType.toString(\n                    16,\n                )}`,\n            );\n        }\n\n        const { generalStatus, protocolId, protocolStatus } = TlvSecureChannelStatusMessage.decode(payload);\n        if (generalStatus !== GeneralStatusCode.Success) {\n            throw new ChannelStatusResponseError(\n                `Received general error status (${protocolId})`,\n                generalStatus,\n                protocolStatus,\n            );\n        }\n        if (protocolStatus !== ProtocolStatusCode.CloseSession) {\n            throw new ChannelStatusResponseError(\n                `Received general success status, but protocol status is not CloseSession`,\n                generalStatus,\n                protocolStatus,\n            );\n        }\n\n        const { session } = exchange;\n        assertSecureSession(session);\n        logger.debug(`Peer requested to close session ${session.name}. Remove session now.`);\n        // TODO: and do more - see Core Specs 5.5\n        await session.destroy(false, false);\n    }\n\n    async close() {\n        // Nothing to do\n    }\n}\n\nexport class SecureChannelProtocol extends StatusReportOnlySecureChannelProtocol {\n    private paseCommissioner: PaseServer | undefined;\n    private readonly caseCommissioner = new CaseServer();\n\n    constructor(private commissioningCancelledCallback: () => Promise<void>) {\n        super();\n    }\n\n    setPaseCommissioner(paseServer: PaseServer) {\n        this.paseCommissioner = paseServer;\n    }\n\n    removePaseCommissioner() {\n        this.paseCommissioner = undefined;\n    }\n\n    override async onNewExchange(exchange: MessageExchange<any>, message: Message) {\n        const messageType = message.payloadHeader.messageType;\n\n        switch (messageType) {\n            case MessageType.PbkdfParamRequest:\n                if (this.paseCommissioner === undefined) {\n                    // Cleaner to return an error (ok for chip-tool as it seems)?\n                    // Formally we should not respond at all which leads to retries and such\n                    const messenger = new SecureChannelMessenger(exchange);\n                    await messenger.sendError(ProtocolStatusCode.InvalidParam);\n                    await messenger.close(); // also closes exchange\n                    return;\n                }\n                try {\n                    await this.paseCommissioner.onNewExchange(exchange);\n                } catch (error) {\n                    MaximumPasePairingErrorsReachedError.accept(error);\n\n                    logger.info(\"Maximum number of PASE pairing errors reached, cancelling commissioning.\");\n                    await this.commissioningCancelledCallback();\n                }\n                break;\n            case MessageType.Sigma1:\n                await this.caseCommissioner.onNewExchange(exchange);\n                break;\n            default:\n                await super.onNewExchange(exchange, message);\n        }\n    }\n\n    static isStandaloneAck(protocolId: number, messageType: number) {\n        return protocolId === SECURE_CHANNEL_PROTOCOL_ID && messageType === MessageType.StandaloneAck;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,yBAAgC;AAChC,oBAAuB;AAGvB,2BAAoC;AACpC,wBAA2B;AAC3B,wBAAiE;AACjE,wBAAgD;AAChD,mCAKO;AACP,oCAAmE;AACnE,8CAA8C;AAtB9C;AAAA;AAAA;AAAA;AAAA;AAwBA,MAAM,SAAS,qBAAO,IAAI,uBAAuB;AAE1C,MAAM,sCAAsE;AAAA,EAC/E,QAAgB;AACZ,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,cAAc,UAAgC,SAAkB;AAClE,UAAM,cAAc,QAAQ,cAAc;AAE1C,YAAQ,aAAa;AAAA,MACjB,KAAK,yCAAY;AACb,cAAM,KAAK,0BAA0B,UAAU,OAAO;AACtD;AAAA,MACJ;AAEI,YAAI,gBAAgB,yCAAY,eAAe;AAC3C,gBAAM,IAAI;AAAA,YACN,0DAA0D,YAAY,SAAS,EAAE,CAAC;AAAA,YAClF,6BAAW;AAAA,UACf;AAAA,QACJ;AAAA,IACR;AAAA,EACJ;AAAA,EAEA,MAAM,0BAA0B,UAAgC,SAAkB;AAC9E,UAAM;AAAA,MACF,eAAe,EAAE,YAAY;AAAA,MAC7B;AAAA,IACJ,IAAI;AACJ,QAAI,gBAAgB,yCAAY,cAAc;AAC1C,YAAM,IAAI;AAAA,QACN,8EAA8E,YAAY;AAAA,UACtF;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,UAAM,EAAE,eAAe,YAAY,eAAe,IAAI,sEAA8B,OAAO,OAAO;AAClG,QAAI,kBAAkB,+CAAkB,SAAS;AAC7C,YAAM,IAAI;AAAA,QACN,kCAAkC,UAAU;AAAA,QAC5C;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,mBAAmB,gDAAmB,cAAc;AACpD,YAAM,IAAI;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,EAAE,QAAQ,IAAI;AACpB,kDAAoB,OAAO;AAC3B,WAAO,MAAM,mCAAmC,QAAQ,IAAI,uBAAuB;AAEnF,UAAM,QAAQ,QAAQ,OAAO,KAAK;AAAA,EACtC;AAAA,EAEA,MAAM,QAAQ;AAAA,EAEd;AACJ;AAEO,MAAM,8BAA8B,sCAAsC;AAAA,EAI7E,YAAoB,gCAAqD;AACrE,UAAM;AADU;AAAA,EAEpB;AAAA,EALQ;AAAA,EACS,mBAAmB,IAAI,6BAAW;AAAA,EAMnD,oBAAoB,YAAwB;AACxC,SAAK,mBAAmB;AAAA,EAC5B;AAAA,EAEA,yBAAyB;AACrB,SAAK,mBAAmB;AAAA,EAC5B;AAAA,EAEA,MAAe,cAAc,UAAgC,SAAkB;AAC3E,UAAM,cAAc,QAAQ,cAAc;AAE1C,YAAQ,aAAa;AAAA,MACjB,KAAK,yCAAY;AACb,YAAI,KAAK,qBAAqB,QAAW;AAGrC,gBAAM,YAAY,IAAI,qDAAuB,QAAQ;AACrD,gBAAM,UAAU,UAAU,gDAAmB,YAAY;AACzD,gBAAM,UAAU,MAAM;AACtB;AAAA,QACJ;AACA,YAAI;AACA,gBAAM,KAAK,iBAAiB,cAAc,QAAQ;AAAA,QACtD,SAAS,OAAO;AACZ,iEAAqC,OAAO,KAAK;AAEjD,iBAAO,KAAK,0EAA0E;AACtF,gBAAM,KAAK,+BAA+B;AAAA,QAC9C;AACA;AAAA,MACJ,KAAK,yCAAY;AACb,cAAM,KAAK,iBAAiB,cAAc,QAAQ;AAClD;AAAA,MACJ;AACI,cAAM,MAAM,cAAc,UAAU,OAAO;AAAA,IACnD;AAAA,EACJ;AAAA,EAEA,OAAO,gBAAgB,YAAoB,aAAqB;AAC5D,WAAO,eAAe,2DAA8B,gBAAgB,yCAAY;AAAA,EACpF;AACJ;",
  "names": []
}
