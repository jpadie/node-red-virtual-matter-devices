{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/AttributeDataDecoder.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Attribute, AttributeError, AttributeJsType } from \"../../cluster/Cluster.js\";\nimport { getClusterAttributeById, getClusterById } from \"../../cluster/ClusterHelper.js\";\nimport { UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { TlvAny } from \"../../tlv/TlvAny.js\";\nimport { ArraySchema } from \"../../tlv/TlvArray.js\";\nimport { TlvSchema, TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { TlvAttributeData, TlvAttributeReport } from \"./InteractionProtocol.js\";\n\nconst logger = Logger.get(\"AttributeDataDecoder\");\n\n/** Represents a fully qualified and decoded attribute value from a received DataReport */\nexport type DecodedAttributeReportValue<T> = {\n    path: {\n        nodeId?: NodeId;\n        endpointId: EndpointNumber;\n        clusterId: ClusterId;\n        attributeId: AttributeId;\n        attributeName: string;\n    };\n    version: number;\n    value: T;\n};\n\n/** Represents a decoded attribute value from a received DataReport where data version could be optional. */\nexport type DecodedAttributeValue<T> = Omit<DecodedAttributeReportValue<T>, \"version\"> & {\n    version?: number;\n};\n\n/**\n * Parses, normalizes (e.g. un-chunk arrays and resolve Tag compression if used) and decodes the attribute data from\n * a received DataReport.\n */\nexport function normalizeAndDecodeReadAttributeReport(\n    data: TypeFromSchema<typeof TlvAttributeReport>[],\n): DecodedAttributeReportValue<any>[] {\n    // TODO Decide how to handle the attribute report status field, right now we ignore it\n    const dataValues = data.flatMap(({ attributeData }) => (attributeData !== undefined ? attributeData : []));\n\n    return normalizeAndDecodeAttributeData(dataValues) as DecodedAttributeReportValue<any>[]; // dataVersion existing in incoming data, so must also in outgoing data\n}\n\nexport function expandPathsInAttributeData(\n    data: TypeFromSchema<typeof TlvAttributeData>[],\n    acceptWildcardPaths = false,\n): TypeFromSchema<typeof TlvAttributeData>[] {\n    // Fill in missing path elements and restore dataVersion when tag compression is used\n    let lastPath:\n        | {\n              nodeId?: NodeId;\n              endpointId: EndpointNumber;\n              clusterId: ClusterId;\n              attributeId: AttributeId;\n              dataVersion?: number;\n          }\n        | undefined;\n    data.forEach(value => {\n        if (value === undefined) return;\n        const { path } = value;\n        if (path.enableTagCompression) {\n            if (lastPath === undefined) throw new UnexpectedDataError(\"Tag compression enabled, but no previous path\");\n            if (path.nodeId === undefined && lastPath.nodeId !== undefined) path.nodeId = lastPath.nodeId;\n            if (path.endpointId === undefined) path.endpointId = lastPath.endpointId;\n            if (path.clusterId === undefined) path.clusterId = lastPath.clusterId;\n            if (path.attributeId === undefined) path.attributeId = lastPath.attributeId;\n            if (value.dataVersion === undefined && lastPath.dataVersion !== undefined)\n                value.dataVersion = lastPath.dataVersion;\n        } else if (path.endpointId !== undefined && path.clusterId !== undefined && path.attributeId !== undefined) {\n            lastPath = {\n                nodeId: path.nodeId,\n                endpointId: path.endpointId,\n                clusterId: path.clusterId,\n                attributeId: path.attributeId,\n                dataVersion: value.dataVersion,\n            };\n        } else if (!acceptWildcardPaths) {\n            throw new UnexpectedDataError(\"Tag compression disabled, but path is incomplete: \" + Logger.toJSON(path));\n        }\n    });\n    return data;\n}\n\n/**\n * Normalizes (e.g. prepare data for array un-chinking and resolve Tag compression if used) the attribute details from\n * a received DataReport.\n */\nexport function normalizeAttributeData(\n    data: TypeFromSchema<typeof TlvAttributeData>[],\n    acceptWildcardPaths = false,\n): TypeFromSchema<typeof TlvAttributeData>[][] {\n    const expandedData = expandPathsInAttributeData(data, acceptWildcardPaths);\n    // Put all returned values into a map to group by path\n    const responseList = new Map<string, TypeFromSchema<typeof TlvAttributeData>[]>();\n    expandedData.forEach(value => {\n        if (!value) return;\n        const {\n            path: { nodeId, endpointId, clusterId, attributeId },\n        } = value;\n        const mapId = `${nodeId}-${endpointId}-${clusterId}-${attributeId}`;\n        const list = responseList.get(mapId) || [];\n        list.push(value);\n        responseList.set(mapId, list);\n    });\n\n    return Array.from(responseList.values());\n}\n\n/**\n * Normalizes (e.g. un-chunk arrays and resolve Tag compression if used) and decodes the attribute data from a received\n * DataReport.\n */\nexport function normalizeAndDecodeAttributeData(\n    data: TypeFromSchema<typeof TlvAttributeData>[],\n): DecodedAttributeValue<any>[] {\n    const responseList = normalizeAttributeData(data);\n    const result = new Array<DecodedAttributeValue<any>>();\n    responseList.forEach(values => {\n        const {\n            path: { nodeId, endpointId, clusterId, attributeId },\n            dataVersion,\n        } = values[0];\n\n        if (endpointId === undefined || clusterId === undefined || attributeId === undefined) {\n            throw new UnexpectedDataError(`Invalid attribute path ${endpointId}/${clusterId}/${attributeId}`);\n        }\n        try {\n            const cluster = getClusterById(clusterId);\n            const attributeDetail = getClusterAttributeById(cluster, attributeId);\n            if (attributeDetail === undefined) {\n                logger.debug(\n                    `Decode unknown attribute ${Diagnostic.hex(clusterId)}/${Diagnostic.hex(attributeId)} via the AnySchema.`,\n                );\n\n                const attributeName = `Unknown (${Diagnostic.hex(attributeId)})`;\n                const value = decodeUnknownAttributeValue(values);\n                result.push({\n                    path: { nodeId, endpointId, clusterId, attributeId, attributeName },\n                    version: dataVersion,\n                    value,\n                });\n\n                return;\n            }\n            const { attribute, name } = attributeDetail;\n            const value = decodeValueForAttribute(attribute, values);\n            result.push({\n                path: { nodeId, endpointId, clusterId, attributeId, attributeName: name },\n                version: dataVersion,\n                value,\n            });\n        } catch (error: any) {\n            logger.error(\n                `Error decoding attribute ${endpointId}/${Diagnostic.hex(clusterId)}/${Diagnostic.hex(attributeId)}: ${\n                    error.message\n                }`,\n            );\n        }\n    });\n    return result;\n}\n\n/** Decodes the data for one known attribute identified by its Attribute definition including array un-chunking. */\nfunction decodeValueForAttribute<A extends Attribute<any, any>>(\n    attribute: A,\n    values: TypeFromSchema<typeof TlvAttributeData>[],\n): AttributeJsType<A> | undefined {\n    const { schema, optional, default: conformanceValue } = attribute;\n\n    // No values, so use default value if available\n    if (!values.length) {\n        if (optional) return undefined;\n        if (conformanceValue === undefined) throw new AttributeError(`Attribute not found.`);\n        return conformanceValue;\n    }\n\n    return decodeAttributeValueWithSchema(schema, values);\n}\n\nexport function decodeListAttributeValueWithSchema<T>(\n    schema: TlvSchema<T>,\n    values: TypeFromSchema<typeof TlvAttributeData>[],\n    currentValue?: T,\n): T | undefined {\n    // Return contained multiple tlv values as an array\n    if (!(schema instanceof ArraySchema)) {\n        throw new UnexpectedDataError(`Attribute is not an list but multiple values were returned.`);\n    }\n    return schema.decodeFromChunkedArray(\n        values.map(({ data, path: { listIndex } }) => ({ listIndex, element: data })),\n        currentValue as any,\n    ) as T;\n}\n\n/** Decodes the data for one attribute via a schema including array un-chunking. */\nexport function decodeAttributeValueWithSchema<T>(\n    schema: TlvSchema<T>,\n    values: TypeFromSchema<typeof TlvAttributeData>[],\n    defaultValue?: T,\n): T | undefined {\n    // No values, so use default value if available\n    if (!values.length) {\n        return defaultValue;\n    }\n\n    // The value was returned as one Tlv value, so decode it normally\n    if (values.length === 1 && values[0].path.listIndex === undefined) {\n        return schema.decodeTlv(values[0].data);\n    }\n\n    return decodeListAttributeValueWithSchema(schema, values, defaultValue);\n}\n\n/** Decodes the data for one unknown attribute via the AnySchema including array un-chunking. */\nexport function decodeUnknownAttributeValue(values: TypeFromSchema<typeof TlvAttributeData>[]): any {\n    const schema = TlvAny;\n    // No values, so use default value if available\n    if (!values.length) {\n        return undefined;\n    }\n\n    // The value was returned as one Tlv value, so decode it normally\n    if (values.length === 1 && values[0].path.listIndex === undefined) {\n        const tlvEncoded = schema.decodeTlv(values[0].data);\n        return schema.decodeAnyTlvStream(tlvEncoded);\n    } else {\n        // Chunked any data\n        const tlvEncoded = new ArraySchema(schema).decodeFromChunkedArray(\n            values.map(({ data, path: { listIndex } }) => ({ listIndex, element: data })),\n        );\n        return tlvEncoded.map(element => schema.decodeAnyTlvStream(element));\n    }\n}\n\n/** Structure the data of a received DataReport into an endpointId/clusterId/attributeName object structure. */\nexport function structureReadAttributeDataToClusterObject(data: DecodedAttributeReportValue<any>[]) {\n    const structure: { [key: number]: { [key: number]: { [key: string]: any } } } = {};\n    for (const {\n        path: { endpointId, clusterId, attributeName },\n        value,\n    } of data) {\n        if (structure[endpointId] === undefined) {\n            structure[endpointId] = {};\n        }\n        if (structure[endpointId][clusterId] === undefined) {\n            structure[endpointId][clusterId] = {};\n        }\n        structure[endpointId][clusterId][attributeName] = value;\n    }\n    return structure;\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
