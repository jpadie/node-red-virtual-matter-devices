{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/AccessControlManager.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2023 Project CHIP Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AccessLevel } from \"../../cluster/Cluster.js\";\nimport { AccessControl } from \"../../cluster/definitions/AccessControlCluster.js\";\nimport { MatterFlowError } from \"../../common/MatterError.js\";\nimport { CaseAuthenticatedTag } from \"../../datatype/CaseAuthenticatedTag.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { FabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { Fabric } from \"../../fabric/Fabric.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { TypeFromBitmapSchema } from \"../../schema/BitmapSchema.js\";\nimport { SecureSession } from \"../../session/SecureSession.js\";\nimport { toHex } from \"../../util/Number.js\";\nimport { StatusCode, StatusResponseError } from \"./StatusCode.js\";\n\nconst logger = Logger.get(\"AccessControlManager\");\n\nexport type AclEntry = Omit<TypeFromBitmapSchema<typeof AccessControl.TlvAccessControlEntry>, \"privilege\"> & {\n    privilege: AccessLevel;\n};\nexport type AclList = AclEntry[];\n\nexport type AclExtensionEntry = TypeFromBitmapSchema<typeof AccessControl.TlvAccessControlExtension>;\nexport type AclExtensionList = AclExtensionEntry[];\n\nconst ImplicitDefaultPaseAclEntry: AclEntry = {\n    fabricIndex: FabricIndex.NO_FABRIC, // not fabric-specific\n    privilege: AccessLevel.Administer,\n    authMode: AccessControl.AccessControlEntryAuthMode.Pase,\n    subjects: [],\n    targets: [], // entire node\n};\n\nenum AuthModeNone {\n    None = 0,\n}\n\nexport type IncomingSubjectDescriptor = {\n    isCommissioning: boolean;\n    authMode: AccessControl.AccessControlEntryAuthMode | AuthModeNone;\n    subjects: NodeId[];\n    fabricIndex: FabricIndex;\n};\n\nexport class AccessDeniedError extends StatusResponseError {\n    constructor(message?: string) {\n        super(message ?? \"Unauthorized\", StatusCode.UnsupportedAccess);\n    }\n}\n\n/**\n * Implements Access Control Logic as per Matter Specification @see {@link MatterSpecification.v12.Core} \u00A7 6.6.5.2.\n */\nexport class AccessControlManager {\n    #aclList: AclList;\n    #extensionEntryAccessCheck: (\n        aclList: AclList,\n        aclEntry: AclEntry,\n        subjectDesc: IncomingSubjectDescriptor,\n        endpoint: EndpointInterface,\n        clusterId: ClusterId,\n    ) => boolean = () => true;\n\n    constructor(\n        aclList: AccessControl.AccessControlEntry[] = [],\n        extensionEntryAccessCheck?: (\n            aclList: AclList,\n            aclEntry: AclEntry,\n            subjectDesc: IncomingSubjectDescriptor,\n            endpoint: EndpointInterface,\n            clusterId: ClusterId,\n        ) => boolean,\n    ) {\n        this.#aclList = aclList as unknown as AclList; // It is the same structure we just use an internal type for privilege\n        if (extensionEntryAccessCheck !== undefined) {\n            this.#extensionEntryAccessCheck = extensionEntryAccessCheck;\n        }\n    }\n\n    /**\n     * Public method used to update the Access Control List on changes.\n     */\n    updateAccessControlList(aclList: AccessControl.AccessControlEntry[] = []): void {\n        this.#aclList = [...aclList] as unknown as AclList; // It is the same structure we just use an internal type for privilege\n    }\n\n    /**\n     * Get the Access Control List for a given fabric.\n     */\n    #getAccessControlEntriesForFabric(fabric: Fabric): AclList {\n        return this.#aclList.filter(entry => entry.fabricIndex === fabric.fabricIndex);\n    }\n\n    /**\n     * Subjects must match exactly, or both are CAT with matching CAT ID and acceptable CAT version\n     */\n    #subjectMatches(aclSubject: NodeId, isdSubject: NodeId): boolean {\n        if (aclSubject === isdSubject) {\n            return true;\n        }\n        if (!NodeId.isCaseAuthenticatedTag(aclSubject) || !NodeId.isCaseAuthenticatedTag(isdSubject)) {\n            return false;\n        }\n        const aclSubjectCat = NodeId.extractAsCaseAuthenticatedTag(aclSubject);\n        const isdSubjectCat = NodeId.extractAsCaseAuthenticatedTag(isdSubject);\n        return (\n            CaseAuthenticatedTag.getIdentifyValue(aclSubjectCat) ===\n                CaseAuthenticatedTag.getIdentifyValue(isdSubjectCat) &&\n            CaseAuthenticatedTag.getVersion(isdSubjectCat) >= CaseAuthenticatedTag.getVersion(aclSubjectCat)\n        );\n    }\n\n    /**\n     * Add the new privilege to the granted privileges set and also add any privileges subsumed by the new privilege.\n     */\n    #addGrantedPrivilege(grantedPrivileges: Set<AccessLevel>, privilege: AccessLevel): void {\n        // Add the new privilege to the granted privileges set\n        grantedPrivileges.add(privilege);\n        // Also add any privileges subsumed by the new privilege\n        switch (privilege) {\n            case AccessLevel.ProxyView:\n                grantedPrivileges.add(AccessLevel.View);\n                break;\n            case AccessLevel.Operate:\n                grantedPrivileges.add(AccessLevel.View);\n                break;\n            case AccessLevel.Manage:\n                grantedPrivileges.add(AccessLevel.Operate);\n                grantedPrivileges.add(AccessLevel.View);\n                break;\n            case AccessLevel.Administer:\n                grantedPrivileges.add(AccessLevel.Manage);\n                grantedPrivileges.add(AccessLevel.Operate);\n                grantedPrivileges.add(AccessLevel.ProxyView);\n                grantedPrivileges.add(AccessLevel.View);\n                break;\n        }\n    }\n\n    /**\n     * Check if the given ACL entry is allowed to be used for the given subject descriptor, endpoint, and cluster ID.\n     */\n    allowsPrivilege(\n        session: SecureSession<any>,\n        endpoint: EndpointInterface,\n        clusterId: ClusterId,\n        privilege: AccessLevel,\n    ): boolean {\n        const grantedPrivileges = this.getGrantedPrivileges(session, endpoint, clusterId);\n        if (grantedPrivileges.includes(privilege)) {\n            return true;\n        }\n\n        logger.notice(\n            `Failed access control check for ${endpoint.number}/${toHex(clusterId)} and fabricIndex ${session.associatedFabric.fabricIndex}, acl=`,\n            this.#getAccessControlEntriesForFabric(session.associatedFabric),\n            \"granted privileges=\",\n            grantedPrivileges,\n        );\n\n        return false;\n    }\n\n    /**\n     * Determines the granted privileges for the given session, endpoint, and cluster ID and returns them.\n     */\n    getGrantedPrivileges(\n        session: SecureSession<any>,\n        endpoint: EndpointInterface,\n        clusterId: ClusterId,\n    ): AccessLevel[] {\n        const endpointId = endpoint.number;\n        const fabric = session.fabric;\n        const subjectDesc = this.#getIsdFromMessage(session);\n        const acl = fabric ? this.#getAccessControlEntriesForFabric(fabric) : [ImplicitDefaultPaseAclEntry];\n\n        // Granted privileges set is initially empty\n        const grantedPrivileges = new Set<AccessLevel>();\n\n        // PASE commissioning channel implicitly grants administer privilege to commissioner\n        if (subjectDesc.authMode === AccessControl.AccessControlEntryAuthMode.Pase && subjectDesc.isCommissioning) {\n            this.#addGrantedPrivilege(grantedPrivileges, AccessLevel.Administer);\n        }\n\n        for (const aclEntry of acl) {\n            if (grantedPrivileges.has(AccessLevel.Administer)) {\n                // End checking if highest privilege is granted\n                break;\n            }\n\n            // Fabric index must match, there are no valid entries with FabricIndex == 0\n            // other than the implicit PASE entry, which we will not see explicitly in the\n            // access control list\n            if (aclEntry.fabricIndex === FabricIndex.NO_FABRIC || aclEntry.fabricIndex !== subjectDesc.fabricIndex) {\n                logger.debug(\n                    \"Skipping ACL entry with mismatched fabric index\",\n                    aclEntry.fabricIndex,\n                    subjectDesc.fabricIndex,\n                );\n                continue;\n            }\n\n            // Auth mode must match\n            if (aclEntry.authMode !== subjectDesc.authMode) {\n                logger.debug(\"Skipping ACL entry with mismatched auth mode\", aclEntry.authMode, subjectDesc.authMode);\n                continue;\n            }\n\n            // Subject must match, or be \"wildcard\"\n            if (aclEntry.subjects === null || aclEntry.subjects.length === 0) {\n                // Precondition: only CASE and Group auth can have empty subjects\n                if (\n                    aclEntry.authMode !== AccessControl.AccessControlEntryAuthMode.Case &&\n                    aclEntry.authMode !== AccessControl.AccessControlEntryAuthMode.Group\n                ) {\n                    throw new MatterFlowError(\"ACL error: only CASE and Group auth can have empty subjects\");\n                }\n                // ... Empty is wildcard, no match required\n            } else {\n                // Non-empty requires a match\n                let matchedSubject = false;\n                subjectLoop: for (const aclSubject of aclEntry.subjects) {\n                    for (const isdSubject of subjectDesc.subjects) {\n                        if (this.#subjectMatches(aclSubject, isdSubject)) {\n                            matchedSubject = true;\n                            break subjectLoop;\n                        }\n                    }\n                }\n                if (!matchedSubject) {\n                    continue;\n                }\n            }\n\n            // Target must match, or be \"wildcard\"\n            if (aclEntry.targets === null || aclEntry.targets.length === 0) {\n                // Empty is wildcard, no match required\n            } else {\n                // Non-empty requires a match\n                let matchedTarget = false;\n                for (const {\n                    cluster: targetClusterId,\n                    endpoint: targetEndpointId,\n                    deviceType: targetDeviceType,\n                } of aclEntry.targets) {\n                    // Precondition: target cannot be empty\n                    if (targetClusterId === null && targetEndpointId === null && targetDeviceType === null) {\n                        throw new MatterFlowError(\"ACL error: target cannot be empty\");\n                    }\n                    // Precondition: target cannot specify both endpoint and device type\n                    if (targetEndpointId !== null && targetDeviceType !== null) {\n                        throw new MatterFlowError(\"ACL error: target cannot specify both endpoint and device type\");\n                    }\n                    // Cluster must match, or be wildcard\n                    if (targetClusterId !== null && targetClusterId !== clusterId) {\n                        continue;\n                    }\n                    // Endpoint must match, or be wildcard\n                    if (targetEndpointId !== null && targetEndpointId !== endpointId) {\n                        continue;\n                    }\n                    // Endpoint may be specified indirectly via device type\n                    // TODO adjust to array check once we use multiple devicetypes\n                    if (targetDeviceType !== null && endpoint.deviceType !== targetDeviceType) {\n                        continue;\n                    }\n                    matchedTarget = true;\n                    break;\n                }\n                if (!matchedTarget) {\n                    continue;\n                }\n            }\n\n            // Extensions processing must not fail\n            if (!this.#extensionEntryAccessCheck(acl, aclEntry, subjectDesc, endpoint, clusterId)) {\n                continue;\n            }\n\n            // All checks have passed, add privilege to granted privilege set\n            this.#addGrantedPrivilege(grantedPrivileges, aclEntry.privilege);\n        }\n        // Should never grant Administer privilege to a Group.\n        if (\n            subjectDesc.authMode === AccessControl.AccessControlEntryAuthMode.Group &&\n            grantedPrivileges.has(AccessLevel.Administer)\n        ) {\n            throw new MatterFlowError(\"ACL error: should never grant Administer privilege to a Group\");\n        }\n\n        return [...grantedPrivileges];\n    }\n\n    /**\n     * Determines the Incoming Subject Descriptor (ISD) from the given session.\n     */\n    #getIsdFromMessage(session: SecureSession<any>) {\n        const fabric = session.fabric;\n        const isd: IncomingSubjectDescriptor = {\n            isCommissioning: false,\n            authMode: AuthModeNone.None,\n            subjects: new Array<NodeId>(),\n            fabricIndex: FabricIndex.NO_FABRIC,\n        };\n\n        if (session.isPase) {\n            isd.authMode = AccessControl.AccessControlEntryAuthMode.Pase;\n            isd.isCommissioning = true; // Or how \"commissioning channel\" is defined?\n            isd.subjects.push(NodeId(0)); // Default Commissioning Passcode ID\n            if (fabric) {\n                isd.fabricIndex = fabric.fabricIndex;\n            }\n        } else {\n            // TODO Add Group session handling when implementing groups\n            // if (session instanceof SecureGroupSession) {\n            //   Groups\n            //   # Message is assumed to have been decrypted and matched properly prior to\n            //       # this procedure occurring.\n            //       group_id = message.get_dst_group_id()\n            //       group_key_id = sessions_metadata.get_group_key_id(message)\n            //       # Group membership must be verified against Group Key Management Cluster\n            //       if group_key_management_cluster.group_key_map_has_mapping(group_id, group_key_id):\n            //         isd.AuthMode = AuthModeEnum.Group\n            //         isd.Subjects.append(group_id)\n            //         isd.FabricIndex = sessions_metadata.get_fabric_index(message)\n            //         assert(isd.FabricIndex != 0) # cannot be zero\n            //\n            //     isd.authMode = AccessControl.AccessControlEntryAuthMode.Group;\n            // } else {\n\n            // CASE session\n            isd.authMode = AccessControl.AccessControlEntryAuthMode.Case;\n            isd.subjects.push(session.peerNodeId);\n            // Append CASE session CATs which also serve as subjects\n            session.caseAuthenticatedTags.forEach(cat => isd.subjects.push(NodeId.fromCaseAuthenticatedTag(cat)));\n            // }\n            if (fabric === undefined) {\n                throw new MatterFlowError(\"ACL error: fabric is undefined\");\n            }\n            isd.fabricIndex = fabric.fabricIndex;\n        }\n\n        return isd;\n    }\n}\n"],
  "mappings": "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",
  "names": ["AuthModeNone"]
}
