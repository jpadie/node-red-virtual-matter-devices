/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AnyAttributeServer } from "../../cluster/server/AttributeServer.js";
import { AnyEventServer } from "../../cluster/server/EventServer.js";
import { SecureSession } from "../../session/SecureSession.js";
import { TlvSchema, TypeFromSchema } from "../../tlv/TlvSchema.js";
import { MaybePromise } from "../../util/Promises.js";
import { EventStorageData } from "./EventHandler.js";
import { InteractionEndpointStructure } from "./InteractionEndpointStructure.js";
import { InteractionServerMessenger } from "./InteractionMessenger.js";
import { TlvAttributePath, TlvDataVersionFilter, TlvEventFilter, TlvEventPath } from "./InteractionProtocol.js";
import { AttributePath, EventPath } from "./InteractionServer.js";
import { SubscriptionOptions } from "./SubscriptionOptions.js";
export declare class SubscriptionHandler {
    #private;
    readonly subscriptionId: number;
    private readonly session;
    private readonly endpointStructure;
    private readonly attributeRequests?;
    private readonly dataVersionFilters?;
    private readonly eventRequests?;
    private readonly eventFilters?;
    private readonly isFabricFiltered;
    private readonly cancelCallback;
    private readonly readAttribute;
    private readonly readEvent;
    private lastUpdateTimeMs;
    private updateTimer;
    private readonly sendDelayTimer;
    private readonly outstandingAttributeUpdates;
    private readonly outstandingEventUpdates;
    private readonly attributeListeners;
    private readonly eventListeners;
    private sendUpdatesActivated;
    private readonly minIntervalFloorMs;
    private readonly maxIntervalCeilingMs;
    private readonly server;
    private readonly fabric;
    private readonly peerNodeId;
    private sendingUpdateInProgress;
    private sendNextUpdateImmediately;
    private sendUpdateErrorCounter;
    private attributeUpdatePromises;
    constructor(options: {
        subscriptionId: number;
        session: SecureSession<any>;
        endpointStructure: InteractionEndpointStructure;
        attributeRequests?: TypeFromSchema<typeof TlvAttributePath>[];
        dataVersionFilters?: TypeFromSchema<typeof TlvDataVersionFilter>[];
        eventRequests?: TypeFromSchema<typeof TlvEventPath>[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered: boolean;
        minIntervalFloor: number;
        maxIntervalCeiling: number;
        cancelCallback: () => void;
        subscriptionOptions: SubscriptionOptions.Configuration;
        readAttribute: (path: AttributePath, attribute: AnyAttributeServer<any>) => Promise<any>;
        readEvent: (path: EventPath, event: AnyEventServer<any, any>, eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined) => Promise<EventStorageData<any>[]>;
    });
    private determineSendingIntervals;
    private registerNewAttributes;
    unregisterAttributeListeners(list: Array<string>): void;
    private registerNewEvents;
    unregisterEventListeners(list: Array<string>): void;
    /**
     * Update the session after an endpoint structure change. The method will initialize all missing new attributes and
     * events and will remove listeners no longer needed.
     * Newly added attributes are then treated ad "changed values" and will be sent as subscription data update to the
     * controller. The data of newly added events are not sent automatically.
     */
    updateSubscription(): Promise<void>;
    get maxInterval(): number;
    get sendInterval(): number;
    activateSendingUpdates(): void;
    /**
     * Check if data should be sent straight away or delayed because the minimum interval is not reached. Delay real
     * sending by 50ms in any case to mke sure to catch all updates.
     */
    prepareDataUpdate(): void;
    /**
     * Determine all attributes that have changed since the last update and send them tout to the subscriber.
     */
    sendUpdate(): Promise<void>;
    sendInitialReport(messenger: InteractionServerMessenger): Promise<void>;
    attributeChangeListener<T>(path: AttributePath, schema: TlvSchema<T>, version: number, value: T): void;
    attributeChangeHandler<T>(path: AttributePath, schema: TlvSchema<T>, version: number, value: T): MaybePromise<void>;
    eventChangeListener<T>(path: EventPath, schema: TlvSchema<T>, newEvent: EventStorageData<T>): void;
    flush(): Promise<void>;
    cancel(flush?: boolean, cancelledByPeer?: boolean): Promise<void>;
    private sendUpdateMessage;
}
//# sourceMappingURL=SubscriptionHandler.d.ts.map