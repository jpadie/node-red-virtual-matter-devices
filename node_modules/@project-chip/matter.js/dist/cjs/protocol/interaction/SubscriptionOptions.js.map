{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/SubscriptionOptions.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We use 3 minutes as global max interval because with 60 min as defined by spec the timeframe until the controller\n// establishes a new subscription after e.g a reboot can be up to 60 min and the controller would assume that the value\n// is unchanged. This is too long.\n//\n// chip-tool is not using the option to choose an appropriate interval and respect the 60 min for that and only uses the\n// max sent by the controller which can lead to spamming the network with unneeded packages. So I decided for 3 minutes\n// for now as a compromise until we have something better. This value is fine for non-battery devices and might be\n// overridden for otherwise.\n//\n// To officially match the specs the developer needs to set these 60Minutes in the Subscription options!\nexport const MAX_INTERVAL_PUBLISHER_LIMIT_S = 60 * 60; /** 1 hour */\nconst INTERNAL_INTERVAL_PUBLISHER_LIMIT_S = 3 * 60; /** 3 min */\nconst MIN_INTERVAL_S = 2; // We do not send faster than 2 seconds\nconst DEFAULT_RANDOMIZATION_WINDOW_S = 10; // 10 seconds\n\n/**\n * Server options that control subscription handling.\n */\nexport interface SubscriptionOptions {\n    /**\n     * Optional maximum subscription interval to use for sending subscription reports. It will be used if not too\n     * low and inside the range requested by the connected controller.\n     */\n    maxIntervalSeconds?: number;\n\n    /**\n     * Optional minimum subscription interval to use for sending subscription reports. It will be used when other\n     * calculated values are smaller than it. Use this to make sure your device hardware can handle the load and to\n     * set limits.\n     */\n    minIntervalSeconds?: number;\n\n    /**\n     * Optional subscription randomization window to use for sending subscription reports. This specifies a window\n     * in seconds from which a random part is added to the calculated maximum interval to make sure that devices\n     * that get powered on in parallel not all send at the same timepoint.\n     */\n    randomizationWindowSeconds?: number;\n}\n\nexport namespace SubscriptionOptions {\n    /**\n     * Validate options and set defaults.\n     *\n     * @returns the resulting options\n     */\n    export function configurationFor(options?: SubscriptionOptions) {\n        return {\n            maxIntervalSeconds: options?.maxIntervalSeconds ?? INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,\n            minIntervalSeconds: Math.max(options?.minIntervalSeconds ?? MIN_INTERVAL_S, MIN_INTERVAL_S),\n            randomizationWindowSeconds: options?.randomizationWindowSeconds ?? DEFAULT_RANDOMIZATION_WINDOW_S,\n        };\n    }\n\n    export interface Configuration extends ReturnType<typeof configurationFor> {}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBO,MAAM,iCAAiC,KAAK;AACnD,MAAM,sCAAsC,IAAI;AAChD,MAAM,iBAAiB;AACvB,MAAM,iCAAiC;AA2BhC,IAAU;AAAA,CAAV,CAAUA,yBAAV;AAMI,WAAS,iBAAiB,SAA+B;AAC5D,WAAO;AAAA,MACH,oBAAoB,SAAS,sBAAsB;AAAA,MACnD,oBAAoB,KAAK,IAAI,SAAS,sBAAsB,gBAAgB,cAAc;AAAA,MAC1F,4BAA4B,SAAS,8BAA8B;AAAA,IACvE;AAAA,EACJ;AANO,EAAAA,qBAAS;AAAA,GANH;",
  "names": ["SubscriptionOptions"]
}
