{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/EventHandler.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { EventPriority } from \"../../cluster/Cluster.js\";\nimport { resolveEventName } from \"../../cluster/ClusterHelper.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { EventNumber } from \"../../datatype/EventNumber.js\";\nimport { FabricIndex } from \"../../datatype/FabricIndex.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { Storage, StorageOperationResult } from \"../../storage/Storage.js\";\nimport { StorageContext } from \"../../storage/StorageContext.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { Construction } from \"../../util/Construction.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { TlvEventFilter, TlvEventPath } from \"./InteractionProtocol.js\";\n\nconst logger = Logger.get(\"EventHandler\");\n\nconst MAX_EVENTS = 10_000;\n\n/**\n * Data of one Event\n */\nexport interface EventData<T> {\n    endpointId: EndpointNumber;\n    clusterId: ClusterId;\n    eventId: EventId;\n    epochTimestamp: number;\n    priority: EventPriority;\n    data: T;\n}\n\n/**\n * Data of an event which was triggered and stored internally\n */\nexport interface EventStorageData<T> extends EventData<T> {\n    eventNumber: EventNumber;\n}\n\n/**\n * Class that collects all triggered events up to a certain limit of events and handle logic\n * to handle subscriptions (TBD)\n */\nexport class EventHandler<S extends Storage = any> {\n    private eventNumber = EventNumber(0);\n    private storedEventCount = 0;\n    private readonly events = {\n        [EventPriority.Critical]: new Array<EventStorageData<any>>(),\n        [EventPriority.Info]: new Array<EventStorageData<any>>(),\n        [EventPriority.Debug]: new Array<EventStorageData<any>>(),\n    };\n    #construction: Construction<EventHandler>;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    static async create(eventStorage: StorageContext) {\n        const handler = new EventHandler(eventStorage);\n        await handler.#construction;\n        return handler;\n    }\n\n    constructor(private readonly eventStorage: StorageContext<S>) {\n        this.#construction = Construction(this, async () => {\n            this.eventNumber = await this.eventStorage.get(\"lastEventNumber\", this.eventNumber);\n            logger.debug(`Set/Restore last event number: ${this.eventNumber}`);\n        });\n    }\n\n    getEvents(\n        eventPath: TypeFromSchema<typeof TlvEventPath>,\n        filters?: TypeFromSchema<typeof TlvEventFilter>[],\n        filterForFabricIndex?: FabricIndex,\n    ) {\n        const eventFilter =\n            filters !== undefined && filters.length > 0\n                ? (event: EventStorageData<any>) =>\n                      filters.some(\n                          filter => filter.eventMin !== undefined && event.eventNumber >= EventNumber(filter.eventMin),\n                      )\n                : () => true; // TODO also add Node Id check\n        const events = new Array<EventStorageData<any>>();\n        const { endpointId, clusterId, eventId } = eventPath;\n        for (const priority of [EventPriority.Critical, EventPriority.Info, EventPriority.Debug]) {\n            const eventsToCheck = this.events[priority];\n            for (const event of eventsToCheck) {\n                if (endpointId === event.endpointId && clusterId === event.clusterId && eventId === event.eventId) {\n                    if (eventFilter(event)) {\n                        events.push(event);\n                    }\n                }\n            }\n        }\n        logger.debug(\n            `Got ${events.length} events for ${resolveEventName(eventPath)} with filters: ${Logger.toJSON(filters)}`,\n        );\n\n        if (filterForFabricIndex !== undefined) {\n            return events.filter(({ data }) => !(\"fabricIndex\" in data) || data.fabricIndex === filterForFabricIndex);\n        }\n\n        return events;\n    }\n\n    pushEvent(event: EventData<any>) {\n        const eventData = {\n            eventNumber: EventNumber(++this.eventNumber),\n            ...event,\n        };\n        logger.debug(`Received event: ${Logger.toJSON(eventData)}`);\n        this.events[event.priority].push(eventData);\n        this.storedEventCount++;\n        const setPromise = this.eventStorage.set(\"lastEventNumber\", this.eventNumber);\n        if (MaybePromise.is(setPromise)) {\n            return setPromise.then(() => {\n                this.cleanUpEvents();\n                return eventData;\n            }) as StorageOperationResult<S, EventStorageData<any>>;\n        }\n        this.cleanUpEvents();\n        return eventData as StorageOperationResult<S, EventStorageData<any>>;\n    }\n\n    cleanUpEvents() {\n        if (this.storedEventCount < MAX_EVENTS) return;\n        const eventsToDelete = this.storedEventCount - MAX_EVENTS; // should be always 1, but let's be sure\n        for (const priority of [EventPriority.Debug, EventPriority.Info, EventPriority.Critical]) {\n            const events = this.events[priority];\n            if (events.length > 0) {\n                const removedEvents = events.splice(0, events.length - eventsToDelete);\n                logger.debug(`Removed ${removedEvents.length} events from priority ${priority}`);\n                return;\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
