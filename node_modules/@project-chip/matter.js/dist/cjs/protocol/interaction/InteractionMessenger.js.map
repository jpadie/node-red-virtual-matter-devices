{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/InteractionMessenger.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterController } from \"../../MatterController.js\";\nimport { MatterDevice } from \"../../MatterDevice.js\";\nimport { Status } from \"../../cluster/globals/index.js\";\nimport { Message, SessionType } from \"../../codec/MessageCodec.js\";\nimport { ImplementationError, MatterFlowError, UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { ExchangeProvider } from \"../../protocol/ExchangeManager.js\";\nimport {\n    ExchangeSendOptions,\n    MessageExchange,\n    RetransmissionLimitReachedError,\n    UnexpectedMessageError,\n} from \"../../protocol/MessageExchange.js\";\nimport { TlvAny } from \"../../tlv/TlvAny.js\";\nimport { TlvSchema, TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport {\n    DataReportPayload,\n    canAttributePayloadBeChunked,\n    chunkAttributePayload,\n    encodeAttributePayload,\n    encodeEventPayload,\n} from \"./AttributeDataEncoder.js\";\nimport {\n    TlvAttributeReport,\n    TlvDataReport,\n    TlvDataReportForSend,\n    TlvEventReport,\n    TlvInvokeRequest,\n    TlvInvokeResponse,\n    TlvReadRequest,\n    TlvStatusResponse,\n    TlvSubscribeRequest,\n    TlvSubscribeResponse,\n    TlvTimedRequest,\n    TlvWriteRequest,\n    TlvWriteResponse,\n} from \"./InteractionProtocol.js\";\nimport { INTERACTION_MODEL_REVISION } from \"./InteractionServer.js\";\nimport { StatusCode, StatusResponseError } from \"./StatusCode.js\";\n\nexport enum MessageType {\n    StatusResponse = 0x01,\n    ReadRequest = 0x02,\n    SubscribeRequest = 0x03,\n    SubscribeResponse = 0x04,\n    ReportData = 0x05,\n    WriteRequest = 0x06,\n    WriteResponse = 0x07,\n    InvokeRequest = 0x08,\n    InvokeResponse = 0x09,\n    TimedRequest = 0x0a,\n}\n\nexport type ReadRequest = TypeFromSchema<typeof TlvReadRequest>;\nexport type DataReport = TypeFromSchema<typeof TlvDataReport>;\nexport type SubscribeRequest = TypeFromSchema<typeof TlvSubscribeRequest>;\nexport type SubscribeResponse = TypeFromSchema<typeof TlvSubscribeResponse>;\nexport type InvokeRequest = TypeFromSchema<typeof TlvInvokeRequest>;\nexport type InvokeResponse = TypeFromSchema<typeof TlvInvokeResponse>;\nexport type TimedRequest = TypeFromSchema<typeof TlvTimedRequest>;\nexport type WriteRequest = TypeFromSchema<typeof TlvWriteRequest>;\nexport type WriteResponse = TypeFromSchema<typeof TlvWriteResponse>;\n\nconst logger = Logger.get(\"InteractionMessenger\");\n\nclass InteractionMessenger<ContextT> {\n    constructor(protected exchange: MessageExchange<ContextT>) {}\n\n    send(messageType: number, payload: ByteArray, options?: ExchangeSendOptions) {\n        return this.exchange.send(messageType, payload, options);\n    }\n\n    sendStatus(status: StatusCode) {\n        return this.send(\n            MessageType.StatusResponse,\n            TlvStatusResponse.encode({ status, interactionModelRevision: INTERACTION_MODEL_REVISION }),\n        );\n    }\n\n    async waitForSuccess() {\n        // If the status is not Success, this would throw an Error.\n        await this.nextMessage(MessageType.StatusResponse);\n    }\n\n    async nextMessage(expectedMessageType?: number) {\n        const message = await this.exchange.nextMessage();\n        const messageType = message.payloadHeader.messageType;\n        this.throwIfErrorStatusMessage(message);\n        if (expectedMessageType !== undefined && messageType !== expectedMessageType) {\n            throw new UnexpectedDataError(\n                `Received unexpected message type: ${messageType}, expected: ${expectedMessageType}`,\n            );\n        }\n        return message;\n    }\n\n    async close() {\n        await this.exchange.close();\n    }\n\n    protected throwIfErrorStatusMessage(message: Message) {\n        const {\n            payloadHeader: { messageType },\n            payload,\n        } = message;\n\n        if (messageType !== MessageType.StatusResponse) return;\n        const { status } = TlvStatusResponse.decode(payload);\n        if (status !== StatusCode.Success) throw new StatusResponseError(`Received error status: ${status}`, status);\n    }\n\n    getExchangeChannelName() {\n        return this.exchange.channel.name;\n    }\n}\n\nexport interface InteractionRecipient {\n    handleReadRequest(\n        exchange: MessageExchange<MatterDevice>,\n        request: ReadRequest,\n        message: Message,\n    ): Promise<DataReport>;\n    handleWriteRequest(\n        exchange: MessageExchange<MatterDevice>,\n        request: WriteRequest,\n        message: Message,\n    ): Promise<WriteResponse>;\n    handleSubscribeRequest(\n        exchange: MessageExchange<MatterDevice>,\n        request: SubscribeRequest,\n        messenger: InteractionServerMessenger,\n        message: Message,\n    ): Promise<void>;\n    handleInvokeRequest(\n        exchange: MessageExchange<MatterDevice>,\n        request: InvokeRequest,\n        messenger: InteractionServerMessenger,\n        message: Message,\n    ): Promise<void>;\n    handleTimedRequest(exchange: MessageExchange<MatterDevice>, request: TimedRequest, message: Message): void;\n}\n\nexport class InteractionServerMessenger extends InteractionMessenger<MatterDevice> {\n    async handleRequest(recipient: InteractionRecipient) {\n        let continueExchange = true; // are more messages expected in this \"transaction\"?\n        let isGroupSession = false;\n        try {\n            while (continueExchange) {\n                const message = await this.exchange.nextMessage();\n                isGroupSession = message.packetHeader.sessionType === SessionType.Group;\n                continueExchange = false;\n                switch (message.payloadHeader.messageType) {\n                    case MessageType.ReadRequest: {\n                        if (isGroupSession) {\n                            throw new StatusResponseError(\n                                `ReadRequest is not supported in group sessions`,\n                                Status.InvalidAction,\n                            );\n                        }\n                        const readRequest = TlvReadRequest.decode(message.payload);\n                        // This potentially sends multiple DataReport Messages\n                        await this.sendDataReport(\n                            await recipient.handleReadRequest(this.exchange, readRequest, message),\n                            readRequest.isFabricFiltered,\n                        );\n                        break;\n                    }\n                    case MessageType.WriteRequest: {\n                        const writeRequest = TlvWriteRequest.decode(message.payload);\n                        const { suppressResponse } = writeRequest;\n                        const writeResponse = await recipient.handleWriteRequest(this.exchange, writeRequest, message);\n                        if (!suppressResponse && !isGroupSession) {\n                            await this.send(MessageType.WriteResponse, TlvWriteResponse.encode(writeResponse));\n                        }\n                        break;\n                    }\n                    case MessageType.SubscribeRequest: {\n                        const subscribeRequest = TlvSubscribeRequest.decode(message.payload);\n                        await recipient.handleSubscribeRequest(this.exchange, subscribeRequest, this, message);\n                        // response is sent by handler\n                        break;\n                    }\n                    case MessageType.InvokeRequest: {\n                        const invokeRequest = TlvInvokeRequest.decode(message.payload);\n                        await recipient.handleInvokeRequest(this.exchange, invokeRequest, this, message);\n                        // response is sent by the handler\n                        break;\n                    }\n                    case MessageType.TimedRequest: {\n                        const timedRequest = TlvTimedRequest.decode(message.payload);\n                        recipient.handleTimedRequest(this.exchange, timedRequest, message);\n                        await this.sendStatus(StatusCode.Success);\n                        continueExchange = true;\n                        break;\n                    }\n                    default:\n                        throw new StatusResponseError(\n                            `Unsupported message type ${message.payloadHeader.messageType}`,\n                            Status.InvalidAction,\n                        );\n                }\n            }\n        } catch (error: any) {\n            let errorStatusCode = StatusCode.Failure;\n            if (error instanceof StatusResponseError) {\n                logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);\n                errorStatusCode = error.code;\n            } else {\n                logger.error(error);\n            }\n            if (!isGroupSession) {\n                await this.sendStatus(errorStatusCode);\n            }\n        } finally {\n            await this.exchange.close();\n        }\n    }\n\n    /**\n     * Handle DataReportPayload with the content of a DataReport to send, split them into multiple DataReport\n     * messages and send them out based on the size.\n     */\n    async sendDataReport(dataReportPayload: DataReportPayload, forFabricFilteredRead: boolean) {\n        const {\n            subscriptionId,\n            attributeReportsPayload,\n            eventReportsPayload,\n            suppressResponse,\n            interactionModelRevision,\n        } = dataReportPayload;\n\n        const dataReport: TypeFromSchema<typeof TlvDataReportForSend> = {\n            subscriptionId,\n            suppressResponse,\n            interactionModelRevision,\n            attributeReports: undefined,\n            eventReports: undefined,\n        };\n\n        if (attributeReportsPayload !== undefined || eventReportsPayload !== undefined) {\n            // TODO Add tag compressing once https://github.com/project-chip/connectedhomeip/issues/29359 is solved\n\n            const attributeReportsToSend = [...(attributeReportsPayload ?? [])];\n            const eventReportsToSend = [...(eventReportsPayload ?? [])];\n\n            dataReport.moreChunkedMessages = true; // Assume we have multiple chunks, also for size calculation\n            const emptyDataReportBytes = TlvDataReportForSend.encode(dataReport);\n\n            let firstAttributeAddedToReportMessage = false;\n            let firstEventAddedToReportMessage = false;\n            const sendAndResetReport = async () => {\n                await this.sendDataReportMessage(dataReport);\n                dataReport.attributeReports = undefined;\n                dataReport.eventReports = undefined;\n                messageSize = emptyDataReportBytes.length;\n                firstAttributeAddedToReportMessage = false;\n                firstEventAddedToReportMessage = false;\n            };\n\n            let messageSize = emptyDataReportBytes.length;\n            while (true) {\n                if (attributeReportsToSend.length > 0) {\n                    const attributeReport = attributeReportsToSend.shift();\n                    if (attributeReport !== undefined) {\n                        if (!firstAttributeAddedToReportMessage) {\n                            firstAttributeAddedToReportMessage = true;\n                            messageSize += 3; // Array element is added now which needs 3 bytes\n                        }\n                        const allowMissingFieldsForNonFabricFilteredRead =\n                            !forFabricFilteredRead && attributeReport.hasFabricSensitiveData;\n                        const encodedAttribute = encodeAttributePayload(attributeReport, {\n                            allowMissingFieldsForNonFabricFilteredRead,\n                        });\n                        const attributeReportBytes = TlvAny.getEncodedByteLength(encodedAttribute);\n                        if (messageSize + attributeReportBytes > this.exchange.maxPayloadSize) {\n                            if (canAttributePayloadBeChunked(attributeReport)) {\n                                // Attribute is a non-empty array: chunk it and add the chunks to the beginning of the queue\n                                attributeReportsToSend.unshift(...chunkAttributePayload(attributeReport));\n                                continue;\n                            }\n                            await sendAndResetReport();\n                        }\n                        messageSize += attributeReportBytes;\n                        if (dataReport.attributeReports === undefined) dataReport.attributeReports = [];\n                        dataReport.attributeReports.push(encodedAttribute);\n                    }\n                } else if (eventReportsToSend.length > 0) {\n                    const eventReport = eventReportsToSend.shift();\n                    if (eventReport === undefined) {\n                        // No more chunks to send\n                        delete dataReport.moreChunkedMessages;\n                        break;\n                    }\n                    if (!firstEventAddedToReportMessage) {\n                        firstEventAddedToReportMessage = true;\n                        messageSize += 3; // Array element is added now which needs 3 bytes\n                    }\n                    const allowMissingFieldsForNonFabricFilteredRead =\n                        !forFabricFilteredRead && eventReport.hasFabricSensitiveData;\n                    const encodedEvent = encodeEventPayload(eventReport, {\n                        allowMissingFieldsForNonFabricFilteredRead,\n                    });\n                    const eventReportBytes = TlvAny.getEncodedByteLength(encodedEvent);\n                    if (messageSize + eventReportBytes > this.exchange.maxPayloadSize) {\n                        await sendAndResetReport();\n                    }\n                    messageSize += eventReportBytes;\n                    if (dataReport.eventReports === undefined) dataReport.eventReports = [];\n                    dataReport.eventReports.push(encodedEvent);\n                } else {\n                    // No more chunks to send\n                    delete dataReport.moreChunkedMessages;\n                    break;\n                }\n            }\n        }\n\n        await this.sendDataReportMessage(dataReport);\n    }\n\n    async sendDataReportMessage(dataReport: TypeFromSchema<typeof TlvDataReportForSend>) {\n        const dataReportToSend = {\n            ...dataReport,\n            suppressResponse: dataReport.moreChunkedMessages ? false : dataReport.suppressResponse, // always false when moreChunkedMessages is true\n        };\n        const encodedMessage = TlvDataReportForSend.encode(dataReportToSend);\n        if (encodedMessage.length > this.exchange.maxPayloadSize) {\n            throw new MatterFlowError(\n                `DataReport is too long to fit in a single chunk, This should not happen! Data: ${Logger.toJSON(\n                    dataReportToSend,\n                )}`,\n            );\n        }\n        logger.debug(\n            `Sending DataReport chunk with ${dataReportToSend.attributeReports?.length ?? 0} attributes and ${\n                dataReportToSend.eventReports?.length ?? 0\n            } events: ${encodedMessage.length} bytes (moreChunkedMessages: ${dataReportToSend.moreChunkedMessages ?? false}, suppressResponse: ${dataReportToSend.suppressResponse})`,\n        );\n\n        if (dataReportToSend.suppressResponse) {\n            // We do not expect a response other than a Standalone Ack, so if we receive anything else, we throw an error\n            try {\n                await this.exchange.send(MessageType.ReportData, encodedMessage, {\n                    expectAckOnly: true,\n                });\n            } catch (e) {\n                UnexpectedMessageError.accept(e);\n\n                const { receivedMessage } = e;\n                this.throwIfErrorStatusMessage(receivedMessage);\n            }\n        } else {\n            await this.exchange.send(MessageType.ReportData, encodedMessage);\n            await this.waitForSuccess();\n        }\n    }\n}\n\nexport class IncomingInteractionClientMessenger extends InteractionMessenger<MatterController> {\n    async readDataReports(sendFinalAckMessage = true): Promise<DataReport> {\n        let subscriptionId: number | undefined;\n        const attributeValues: TypeFromSchema<typeof TlvAttributeReport>[] = [];\n        const eventValues: TypeFromSchema<typeof TlvEventReport>[] = [];\n\n        while (true) {\n            const dataReportMessage = await this.exchange.waitFor(MessageType.ReportData);\n            const report = TlvDataReport.decode(dataReportMessage.payload);\n            if (subscriptionId === undefined && report.subscriptionId !== undefined) {\n                subscriptionId = report.subscriptionId;\n            } else if (\n                (subscriptionId !== undefined || report.subscriptionId !== undefined) &&\n                report.subscriptionId !== subscriptionId\n            ) {\n                throw new UnexpectedDataError(`Invalid subscription ID ${report.subscriptionId} received`);\n            }\n\n            logger.debug(\n                `Received DataReport chunk with ${report.attributeReports?.length ?? 0} attributes and ${report.eventReports?.length ?? 0} events, suppressResponse: ${report.suppressResponse}, moreChunkedMessages: ${report.moreChunkedMessages}`,\n            );\n\n            if (Array.isArray(report.attributeReports) && report.attributeReports.length > 0) {\n                attributeValues.push(...report.attributeReports);\n            }\n            if (Array.isArray(report.eventReports) && report.eventReports.length > 0) {\n                eventValues.push(...report.eventReports);\n            }\n\n            if (report.moreChunkedMessages || (sendFinalAckMessage && !report.suppressResponse)) {\n                await this.sendStatus(StatusCode.Success);\n            }\n\n            if (!report.moreChunkedMessages) {\n                report.attributeReports = attributeValues;\n                report.eventReports = eventValues;\n                return report;\n            }\n        }\n    }\n}\n\nexport class InteractionClientMessenger extends IncomingInteractionClientMessenger {\n    constructor(private readonly exchangeProvider: ExchangeProvider) {\n        super(exchangeProvider.initiateExchange());\n    }\n\n    /** Implements a send method with an automatic reconnection mechanism */\n    override async send(messageType: number, payload: ByteArray, options?: ExchangeSendOptions) {\n        if (this.exchange.channel.closed) {\n            throw new ImplementationError(\"The exchange channel is closed. Please connect the device first.\");\n        }\n        try {\n            return await this.exchange.send(messageType, payload, options);\n        } catch (error) {\n            // When retransmission failed (most likely due to a lost connection or invalid session),\n            // try to reconnect if possible and resend the message once\n            if (error instanceof RetransmissionLimitReachedError) {\n                await this.exchange.close();\n                if (await this.exchangeProvider.reconnectChannel()) {\n                    this.exchange = this.exchangeProvider.initiateExchange();\n                    return await this.exchange.send(messageType, payload);\n                }\n            }\n            throw error;\n        }\n    }\n\n    async sendReadRequest(readRequest: ReadRequest) {\n        await this.send(MessageType.ReadRequest, TlvReadRequest.encode(readRequest));\n\n        return this.readDataReports();\n    }\n\n    async sendSubscribeRequest(subscribeRequest: SubscribeRequest) {\n        await this.send(MessageType.SubscribeRequest, TlvSubscribeRequest.encode(subscribeRequest));\n\n        const report = await this.readDataReports();\n        const { subscriptionId } = report;\n\n        if (subscriptionId === undefined) {\n            throw new UnexpectedDataError(`Subscription ID not provided in report`);\n        }\n\n        const subscribeResponseMessage = await this.nextMessage(MessageType.SubscribeResponse);\n        const subscribeResponse = TlvSubscribeResponse.decode(subscribeResponseMessage.payload);\n\n        if (subscribeResponse.subscriptionId !== subscriptionId) {\n            throw new MatterFlowError(\n                `Received subscription ID ${subscribeResponse.subscriptionId} instead of ${subscriptionId}`,\n            );\n        }\n\n        return {\n            subscribeResponse,\n            report,\n        };\n    }\n\n    async sendInvokeCommand(invokeRequest: InvokeRequest, minimumResponseTimeoutMs?: number) {\n        if (invokeRequest.suppressResponse) {\n            await this.requestWithSuppressedResponse(\n                MessageType.InvokeRequest,\n                TlvInvokeRequest,\n                invokeRequest,\n                minimumResponseTimeoutMs,\n            );\n        } else {\n            return await this.request(\n                MessageType.InvokeRequest,\n                TlvInvokeRequest,\n                MessageType.InvokeResponse,\n                TlvInvokeResponse,\n                invokeRequest,\n                minimumResponseTimeoutMs,\n            );\n        }\n    }\n\n    async sendWriteCommand(writeRequest: WriteRequest) {\n        if (writeRequest.suppressResponse) {\n            await this.requestWithSuppressedResponse(MessageType.WriteRequest, TlvWriteRequest, writeRequest);\n        } else {\n            return await this.request(\n                MessageType.WriteRequest,\n                TlvWriteRequest,\n                MessageType.WriteResponse,\n                TlvWriteResponse,\n                writeRequest,\n            );\n        }\n    }\n\n    sendTimedRequest(timeoutSeconds: number) {\n        return this.request(MessageType.TimedRequest, TlvTimedRequest, MessageType.StatusResponse, TlvStatusResponse, {\n            timeout: timeoutSeconds,\n            interactionModelRevision: INTERACTION_MODEL_REVISION,\n        });\n    }\n\n    private async requestWithSuppressedResponse<RequestT>(\n        requestMessageType: number,\n        requestSchema: TlvSchema<RequestT>,\n        request: RequestT,\n        minimumResponseTimeoutMs?: number,\n    ): Promise<void> {\n        await this.send(requestMessageType, requestSchema.encode(request), {\n            expectAckOnly: true,\n            minimumResponseTimeoutMs,\n        });\n    }\n\n    private async request<RequestT, ResponseT>(\n        requestMessageType: number,\n        requestSchema: TlvSchema<RequestT>,\n        responseMessageType: number,\n        responseSchema: TlvSchema<ResponseT>,\n        request: RequestT,\n        minimumResponseTimeoutMs?: number,\n    ): Promise<ResponseT> {\n        await this.send(requestMessageType, requestSchema.encode(request), {\n            expectAckOnly: false,\n            minimumResponseTimeoutMs,\n        });\n        const responseMessage = await this.nextMessage(responseMessageType);\n        return responseSchema.decode(responseMessage.payload);\n    }\n}\n"],
  "mappings": "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",
  "names": ["MessageType"]
}
