"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionClient_exports = {};
__export(InteractionClient_exports, {
  InteractionClient: () => InteractionClient,
  SubscriptionClient: () => SubscriptionClient
});
module.exports = __toCommonJS(InteractionClient_exports);
var import_Cluster = require("../../cluster/Cluster.js");
var import_ClusterHelper = require("../../cluster/ClusterHelper.js");
var import_MatterError = require("../../common/MatterError.js");
var import_Logger = require("../../log/Logger.js");
var import_Time = require("../../time/Time.js");
var import_AttributeDataDecoder = require("./AttributeDataDecoder.js");
var import_EventDataDecoder = require("./EventDataDecoder.js");
var import_InteractionMessenger = require("./InteractionMessenger.js");
var import_InteractionServer = require("./InteractionServer.js");
var import_StatusCode = require("./StatusCode.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("InteractionClient");
const REQUEST_ALL = [{}];
const DEFAULT_TIMED_REQUEST_TIMEOUT_MS = 1e4;
const DEFAULT_MINIMUM_RESPONSE_TIMEOUT_WITH_FAILSAFE_MS = 3e4;
class SubscriptionClient {
  subscriptionListeners = /* @__PURE__ */ new Map();
  subscriptionUpdateTimers = /* @__PURE__ */ new Map();
  constructor() {
  }
  getId() {
    return import_InteractionServer.INTERACTION_PROTOCOL_ID;
  }
  registerSubscriptionListener(subscriptionId, listener) {
    this.subscriptionListeners.set(subscriptionId, listener);
  }
  removeSubscriptionListener(subscriptionId) {
    this.subscriptionListeners.delete(subscriptionId);
  }
  registerSubscriptionUpdateTimer(subscriptionId, timer) {
    this.subscriptionUpdateTimers.set(subscriptionId, timer);
  }
  removeSubscriptionUpdateTimer(subscriptionId) {
    this.subscriptionUpdateTimers.get(subscriptionId)?.stop();
    this.subscriptionUpdateTimers.delete(subscriptionId);
  }
  async onNewExchange(exchange) {
    const messenger = new import_InteractionMessenger.IncomingInteractionClientMessenger(exchange);
    const dataReport = await messenger.readDataReports(false);
    const subscriptionId = dataReport.subscriptionId;
    if (subscriptionId === void 0) {
      await messenger.sendStatus(import_StatusCode.StatusCode.InvalidSubscription);
      throw new import_MatterError.UnexpectedDataError("Invalid Data report without Subscription ID");
    }
    const listener = this.subscriptionListeners.get(subscriptionId);
    const timer = this.subscriptionUpdateTimers.get(subscriptionId);
    if (listener === void 0) {
      await messenger.sendStatus(import_StatusCode.StatusCode.InvalidSubscription);
      logger.info(`Received data for unknown subscription ID ${subscriptionId}. Cancel this subscription.`);
      if (timer !== void 0) {
        this.removeSubscriptionUpdateTimer(subscriptionId);
      }
      await messenger.close();
      return;
    }
    await messenger.sendStatus(import_StatusCode.StatusCode.Success);
    await messenger.close();
    if (timer !== void 0) {
      timer.stop().start();
    }
    listener(dataReport);
  }
  async close() {
    this.subscriptionListeners.clear();
    this.subscriptionUpdateTimers.forEach((timer) => timer.stop());
    this.subscriptionUpdateTimers.clear();
  }
}
class InteractionClient {
  constructor(exchangeProvider, nodeId) {
    this.exchangeProvider = exchangeProvider;
    this.nodeId = nodeId;
    if (this.exchangeProvider.hasProtocolHandler(import_InteractionServer.INTERACTION_PROTOCOL_ID)) {
      const client = this.exchangeProvider.getProtocolHandler(import_InteractionServer.INTERACTION_PROTOCOL_ID);
      if (!(client instanceof SubscriptionClient)) {
        throw new import_MatterError.ImplementationError(
          `Already existing protocol handler ${import_InteractionServer.INTERACTION_PROTOCOL_ID} is not a SubscriptionClient.`
        );
      }
      this.subscriptionClient = client;
    } else {
      this.subscriptionClient = new SubscriptionClient();
      this.exchangeProvider.addProtocolHandler(this.subscriptionClient);
    }
  }
  // TODO Add storage for these data to be able to optimize follow up subscriptions by only request updated data
  subscribedLocalValues = /* @__PURE__ */ new Map();
  subscribedClusterDataVersions = /* @__PURE__ */ new Map();
  ownSubscriptionIds = /* @__PURE__ */ new Set();
  subscriptionClient;
  registerSubscriptionListener(subscriptionId, listener) {
    this.ownSubscriptionIds.add(subscriptionId);
    this.subscriptionClient.registerSubscriptionListener(subscriptionId, listener);
  }
  removeSubscription(subscriptionId) {
    this.ownSubscriptionIds.delete(subscriptionId);
    this.subscriptionClient.removeSubscriptionListener(subscriptionId);
    this.subscriptionClient.removeSubscriptionUpdateTimer(subscriptionId);
  }
  async getAllAttributes(options = {}) {
    const { dataVersionFilters, isFabricFiltered } = options;
    return (await this.getMultipleAttributesAndEvents({
      attributes: REQUEST_ALL,
      dataVersionFilters,
      isFabricFiltered
    })).attributeReports;
  }
  async getAllEvents(options = {}) {
    const { eventFilters, isFabricFiltered } = options;
    return (await this.getMultipleAttributesAndEvents({ events: REQUEST_ALL, eventFilters, isFabricFiltered })).eventReports;
  }
  async getAllAttributesAndEvents(options = {}) {
    const { dataVersionFilters, eventFilters, isFabricFiltered } = options;
    return this.getMultipleAttributesAndEvents({
      attributes: REQUEST_ALL,
      events: REQUEST_ALL,
      eventFilters,
      dataVersionFilters,
      isFabricFiltered
    });
  }
  async getMultipleAttributes(options = {}) {
    const { attributes, dataVersionFilters, isFabricFiltered } = options;
    return (await this.getMultipleAttributesAndEvents({ attributes, dataVersionFilters, isFabricFiltered })).attributeReports;
  }
  async getMultipleEvents(options = {}) {
    const { events, eventFilters, isFabricFiltered } = options;
    return (await this.getMultipleAttributesAndEvents({ events, eventFilters, isFabricFiltered })).eventReports;
  }
  async getMultipleAttributesAndEvents(options = {}) {
    const {
      attributes: attributeRequests,
      dataVersionFilters,
      events: eventRequests,
      eventFilters,
      isFabricFiltered = true
    } = options;
    if (attributeRequests === void 0 && eventRequests === void 0) {
      throw new import_MatterError.ImplementationError("When reading attributes and events, at least one must be specified.");
    }
    const readPathsCount = (attributeRequests?.length ?? 0) + (eventRequests?.length ?? 0);
    if (readPathsCount > 9) {
      logger.debug(
        "Read interactions with more then 9 paths might be not allowed by the device. Consider splitting then into several read requests."
      );
    }
    return this.withMessenger(async (messenger) => {
      return await this.processReadRequest(messenger, {
        attributeRequests,
        dataVersionFilters: dataVersionFilters?.map(({ endpointId, clusterId, dataVersion }) => ({
          path: { endpointId, clusterId },
          dataVersion
        })),
        eventRequests,
        eventFilters,
        isFabricFiltered,
        interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION
      });
    });
  }
  async getAttribute(options) {
    const { endpointId, clusterId, attribute, alwaysRequestFromRemote = false, isFabricFiltered } = options;
    const response = await this.getAttributeWithVersion({
      endpointId,
      clusterId,
      attribute,
      alwaysRequestFromRemote,
      isFabricFiltered
    });
    return response?.value;
  }
  async getAttributeWithVersion(options) {
    const { endpointId, clusterId, attribute, alwaysRequestFromRemote = false, isFabricFiltered } = options;
    const { id: attributeId } = attribute;
    if (!alwaysRequestFromRemote) {
      const value = this.subscribedLocalValues.get((0, import_InteractionServer.attributePathToId)({ endpointId, clusterId, attributeId }));
      const version = this.subscribedClusterDataVersions.get((0, import_InteractionServer.clusterPathToId)({ endpointId, clusterId }));
      if (value !== void 0 && version !== void 0) {
        return { value, version };
      }
    }
    const { attributeReports } = await this.getMultipleAttributesAndEvents({
      attributes: [{ endpointId, clusterId, attributeId }],
      isFabricFiltered
    });
    if (attributeReports.length === 0) {
      return void 0;
    }
    if (attributeReports.length > 1) {
      throw new import_MatterError.UnexpectedDataError("Unexpected response with more then one attribute");
    }
    return { value: attributeReports[0].value, version: attributeReports[0].version };
  }
  async getEvent(options) {
    const { endpointId, clusterId, event, minimumEventNumber, isFabricFiltered = true } = options;
    const { id: eventId } = event;
    const response = await this.getMultipleAttributesAndEvents({
      events: [{ endpointId, clusterId, eventId }],
      eventFilters: minimumEventNumber !== void 0 ? [{ eventMin: minimumEventNumber }] : void 0,
      isFabricFiltered
    });
    return response?.eventReports[0]?.events;
  }
  async processReadRequest(messenger, request) {
    const { attributeRequests, eventRequests } = request;
    logger.debug(
      `Sending read request to ${messenger.getExchangeChannelName()} for attributes ${attributeRequests?.map((path) => (0, import_ClusterHelper.resolveAttributeName)(path)).join(", ")} and events ${eventRequests?.map((path) => (0, import_ClusterHelper.resolveEventName)(path)).join(", ")}`
    );
    const response = await messenger.sendReadRequest(request);
    const normalizedResult = {
      attributeReports: (0, import_AttributeDataDecoder.normalizeAndDecodeReadAttributeReport)(response.attributeReports ?? []),
      eventReports: (0, import_EventDataDecoder.normalizeAndDecodeReadEventReport)(response.eventReports ?? [])
    };
    logger.debug(
      `Received read response with attributes ${normalizedResult.attributeReports.map(({ path, value }) => `${(0, import_ClusterHelper.resolveAttributeName)(path)} = ${import_Logger.Logger.toJSON(value)}`).join(", ")} and events ${normalizedResult.eventReports.map(({ path, events }) => `${(0, import_ClusterHelper.resolveEventName)(path)} = ${import_Logger.Logger.toJSON(events)}`).join(", ")}`
    );
    return normalizedResult;
  }
  async setAttribute(options) {
    const { attributeData, asTimedRequest, timedRequestTimeoutMs, suppressResponse } = options;
    const { endpointId, clusterId, attribute, value, dataVersion } = attributeData;
    const response = await this.setMultipleAttributes({
      attributes: [{ endpointId, clusterId, attribute, value, dataVersion }],
      asTimedRequest,
      timedRequestTimeoutMs,
      suppressResponse
    });
    if (response.length) {
      const {
        path: { endpointId: endpointId2, clusterId: clusterId2, attributeId },
        status
      } = response[0];
      if (status !== void 0 && status !== import_StatusCode.StatusCode.Success) {
        throw new import_StatusCode.StatusResponseError(
          `Error setting attribute ${endpointId2}/${clusterId2}/${attributeId}`,
          status
        );
      }
    }
  }
  async setMultipleAttributes(options) {
    const {
      attributes,
      asTimedRequest,
      timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,
      suppressResponse = false
      // TODO needs to be TRUE for Group writes
    } = options;
    return this.withMessenger(async (messenger) => {
      logger.debug(
        `Sending write request: ${attributes.map(
          ({ endpointId, clusterId, attribute: { id }, value, dataVersion }) => `${(0, import_ClusterHelper.resolveAttributeName)({ endpointId, clusterId, attributeId: id })} = ${import_Logger.Logger.toJSON(
            value
          )} (version=${dataVersion})`
        ).join(", ")}`
      );
      const writeRequests = attributes.map(
        ({ endpointId, clusterId, attribute: { id, schema }, value, dataVersion }) => ({
          path: { endpointId, clusterId, attributeId: id },
          data: schema.encodeTlv(value, { forWriteInteraction: true }),
          dataVersion
        })
      );
      const timedRequest = attributes.some(({ attribute: { timed } }) => timed) || asTimedRequest === true || options.timedRequestTimeoutMs !== void 0;
      if (timedRequest) {
        await messenger.sendTimedRequest(timedRequestTimeoutMs);
      }
      const response = await messenger.sendWriteCommand({
        suppressResponse,
        timedRequest,
        writeRequests,
        moreChunkedMessages: false,
        interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION
      });
      if (response === void 0) {
        if (!suppressResponse) {
          throw new import_MatterError.MatterFlowError(`No response received from write interaction but expected.`);
        }
        return [];
      }
      return response.writeResponses.flatMap(
        ({ status: { status, clusterStatus }, path: { nodeId, endpointId, clusterId, attributeId } }) => {
          return {
            path: { nodeId, endpointId, clusterId, attributeId },
            status: status ?? clusterStatus ?? import_StatusCode.StatusCode.Failure
          };
        }
      ).filter(({ status }) => status !== import_StatusCode.StatusCode.Success);
    });
  }
  async subscribeAttribute(options) {
    const {
      endpointId,
      clusterId,
      attribute,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      isFabricFiltered = true,
      listener,
      knownDataVersion,
      keepSubscriptions = true,
      updateTimeoutHandler
    } = options;
    return this.withMessenger(async (messenger) => {
      const { id: attributeId } = attribute;
      logger.debug(
        `Sending subscribe request for attribute: ${(0, import_ClusterHelper.resolveAttributeName)({
          endpointId,
          clusterId,
          attributeId
        })}`
      );
      const {
        report,
        subscribeResponse: { subscriptionId, maxInterval }
      } = await messenger.sendSubscribeRequest({
        interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION,
        attributeRequests: [{ endpointId, clusterId, attributeId }],
        dataVersionFilters: knownDataVersion !== void 0 ? [{ path: { endpointId, clusterId }, dataVersion: knownDataVersion }] : void 0,
        keepSubscriptions,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isFabricFiltered
      });
      const subscriptionListener = (dataReport) => {
        if (!Array.isArray(dataReport.attributeReports) || !dataReport.attributeReports.length) {
          logger.debug("Subscription result empty");
          return;
        }
        const data = (0, import_AttributeDataDecoder.normalizeAndDecodeReadAttributeReport)(dataReport.attributeReports);
        if (data.length === 0) {
          throw new import_MatterError.MatterFlowError("Subscription result reporting undefined/no value not specified");
        }
        if (data.length > 1) {
          throw new import_MatterError.UnexpectedDataError("Unexpected response with more then one attribute");
        }
        const {
          path: { endpointId: endpointId2, clusterId: clusterId2, attributeId: attributeId2 },
          value,
          version
        } = data[0];
        if (value === void 0)
          throw new import_MatterError.MatterFlowError("Subscription result reporting undefined value not specified.");
        this.subscribedLocalValues.set((0, import_InteractionServer.attributePathToId)({ endpointId: endpointId2, clusterId: clusterId2, attributeId: attributeId2 }), value);
        this.subscribedClusterDataVersions.set((0, import_InteractionServer.clusterPathToId)({ endpointId: endpointId2, clusterId: clusterId2 }), version);
        listener?.(value, version);
      };
      this.registerSubscriptionListener(subscriptionId, subscriptionListener);
      if (updateTimeoutHandler !== void 0) {
        this.registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler);
      }
      subscriptionListener(report);
      return;
    });
  }
  async subscribeEvent(options) {
    return this.withMessenger(async (messenger) => {
      const {
        endpointId,
        clusterId,
        event,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isUrgent,
        minimumEventNumber,
        isFabricFiltered = true,
        listener,
        updateTimeoutHandler
      } = options;
      const { id: eventId } = event;
      logger.debug(
        `Sending subscribe request for event: ${(0, import_ClusterHelper.resolveEventName)({ endpointId, clusterId, eventId })}`
      );
      const {
        report,
        subscribeResponse: { subscriptionId, maxInterval }
      } = await messenger.sendSubscribeRequest({
        interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION,
        eventRequests: [{ endpointId, clusterId, eventId, isUrgent }],
        eventFilters: minimumEventNumber !== void 0 ? [{ eventMin: minimumEventNumber }] : void 0,
        keepSubscriptions: true,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isFabricFiltered
      });
      const subscriptionListener = (dataReport) => {
        if (!Array.isArray(dataReport.eventReports) || !dataReport.eventReports.length) {
          logger.debug("Subscription result empty");
          return;
        }
        const data = (0, import_EventDataDecoder.normalizeAndDecodeReadEventReport)(dataReport.eventReports);
        if (data.length === 0) {
          throw new import_MatterError.MatterFlowError("Received empty subscription result value.");
        }
        if (data.length > 1) {
          throw new import_MatterError.UnexpectedDataError("Unexpected response with more then one attribute.");
        }
        const { events } = data[0];
        if (events === void 0)
          throw new import_MatterError.MatterFlowError("Subscription result reporting undefined value not specified.");
        events.forEach((event2) => listener?.(event2));
      };
      this.registerSubscriptionListener(subscriptionId, subscriptionListener);
      if (updateTimeoutHandler !== void 0) {
        this.registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler);
      }
      subscriptionListener(report);
      return;
    });
  }
  async subscribeAllAttributesAndEvents(options) {
    const {
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      attributeListener,
      eventListener,
      isUrgent,
      keepSubscriptions = true,
      isFabricFiltered = true,
      eventFilters,
      dataVersionFilters,
      updateTimeoutHandler
    } = options;
    return this.subscribeMultipleAttributesAndEvents({
      attributes: REQUEST_ALL,
      events: [{ isUrgent }],
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      keepSubscriptions,
      isFabricFiltered,
      attributeListener,
      eventListener,
      eventFilters,
      dataVersionFilters,
      updateTimeoutHandler
    });
  }
  async subscribeMultipleAttributesAndEvents(options) {
    const {
      attributes: attributeRequests,
      events: eventRequests,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      keepSubscriptions = true,
      isFabricFiltered = true,
      attributeListener,
      eventListener,
      eventFilters,
      dataVersionFilters,
      updateTimeoutHandler
    } = options;
    const subscriptionPathsCount = (attributeRequests?.length ?? 0) + (eventRequests?.length ?? 0);
    if (subscriptionPathsCount > 3) {
      logger.debug("Subscribe interactions with more then 3 paths might be not allowed by the device.");
    }
    return this.withMessenger(async (messenger) => {
      logger.debug(
        `Sending subscribe request: attributes: ${attributeRequests.map((path) => (0, import_ClusterHelper.resolveAttributeName)(path)).join(", ")} and events: ${eventRequests.map((path) => (0, import_ClusterHelper.resolveEventName)(path)).join(", ")}`
      );
      const {
        report,
        subscribeResponse: { subscriptionId, maxInterval }
      } = await messenger.sendSubscribeRequest({
        interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION,
        attributeRequests,
        eventRequests,
        keepSubscriptions,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isFabricFiltered,
        eventFilters,
        dataVersionFilters: dataVersionFilters?.map(({ endpointId, clusterId, dataVersion }) => ({
          path: { endpointId, clusterId },
          dataVersion
        }))
      });
      logger.info(
        `Subscription successfully initialized with ID ${subscriptionId} and maxInterval ${maxInterval}s.`
      );
      const subscriptionListener = (dataReport) => {
        if ((!Array.isArray(dataReport.attributeReports) || !dataReport.attributeReports.length) && (!Array.isArray(dataReport.eventReports) || !dataReport.eventReports.length)) {
          logger.debug("Subscription result empty");
          return;
        }
        const { attributeReports, eventReports } = dataReport;
        if (attributeReports !== void 0) {
          attributeReports.forEach((data) => {
            const {
              path: { endpointId, clusterId, attributeId },
              value,
              version
            } = data;
            logger.debug(
              `Received attribute update: ${(0, import_ClusterHelper.resolveAttributeName)({
                endpointId,
                clusterId,
                attributeId
              })} = ${import_Logger.Logger.toJSON(value)} (version=${version})`
            );
            if (value === void 0) throw new import_MatterError.MatterFlowError("Received empty subscription result value.");
            this.subscribedLocalValues.set(
              (0, import_InteractionServer.attributePathToId)({ endpointId, clusterId, attributeId }),
              value
            );
            this.subscribedClusterDataVersions.set((0, import_InteractionServer.clusterPathToId)({ endpointId, clusterId }), version);
            attributeListener?.(data);
          });
        }
        if (eventReports !== void 0) {
          eventReports.forEach((data) => {
            logger.debug(
              `Received event update: ${(0, import_ClusterHelper.resolveEventName)(data.path)}: ${import_Logger.Logger.toJSON(data.events)}`
            );
            eventListener?.(data);
          });
        }
      };
      this.registerSubscriptionListener(subscriptionId, (dataReport) => {
        subscriptionListener({
          attributeReports: dataReport.attributeReports !== void 0 ? (0, import_AttributeDataDecoder.normalizeAndDecodeReadAttributeReport)(dataReport.attributeReports) : void 0,
          eventReports: dataReport.eventReports !== void 0 ? (0, import_EventDataDecoder.normalizeAndDecodeReadEventReport)(dataReport.eventReports) : void 0
        });
      });
      if (updateTimeoutHandler !== void 0) {
        this.registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler);
      }
      const seedReport = {
        attributeReports: report.attributeReports !== void 0 ? (0, import_AttributeDataDecoder.normalizeAndDecodeReadAttributeReport)(report.attributeReports) : void 0,
        eventReports: report.eventReports !== void 0 ? (0, import_EventDataDecoder.normalizeAndDecodeReadEventReport)(report.eventReports) : void 0
      };
      subscriptionListener(seedReport);
      return seedReport;
    });
  }
  async invoke(options) {
    const {
      endpointId,
      clusterId,
      request,
      command: { requestId, requestSchema, responseId, responseSchema, optional, timed },
      asTimedRequest,
      timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,
      useExtendedFailSafeMessageResponseTimeout = false
    } = options;
    const timedRequest = timed || asTimedRequest === true || options.timedRequestTimeoutMs !== void 0;
    return this.withMessenger(async (messenger) => {
      logger.debug(
        `Invoking command: ${(0, import_ClusterHelper.resolveCommandName)({
          endpointId,
          clusterId,
          commandId: requestId
        })} with ${import_Logger.Logger.toJSON(request)}`
      );
      requestSchema.validate(request);
      const commandFields = requestSchema.encodeTlv(request);
      if (timedRequest) {
        await messenger.sendTimedRequest(timedRequestTimeoutMs);
      }
      const invokeResponse = await messenger.sendInvokeCommand(
        {
          invokeRequests: [{ commandPath: { endpointId, clusterId, commandId: requestId }, commandFields }],
          timedRequest,
          suppressResponse: false,
          interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION
        },
        useExtendedFailSafeMessageResponseTimeout ? DEFAULT_MINIMUM_RESPONSE_TIMEOUT_WITH_FAILSAFE_MS : void 0
      );
      if (invokeResponse === void 0) {
        throw new import_MatterError.MatterFlowError("No response received from invoke interaction but expected.");
      }
      const { invokeResponses } = invokeResponse;
      if (invokeResponses.length === 0) {
        throw new import_MatterError.MatterFlowError("Received invoke response with no invoke results.");
      }
      const { command, status } = invokeResponses[0];
      if (status !== void 0) {
        const resultCode = status.status.status;
        if (resultCode !== import_StatusCode.StatusCode.Success)
          throw new import_StatusCode.StatusResponseError(
            `Received non-success result: ${resultCode}`,
            resultCode ?? import_StatusCode.StatusCode.Failure,
            status.status.clusterStatus
          );
        if (responseSchema !== import_Cluster.TlvNoResponse)
          throw new import_MatterError.MatterFlowError("A response was expected for this command.");
        return void 0;
      }
      if (command !== void 0) {
        const {
          commandPath: { commandId },
          commandFields: commandFields2
        } = command;
        if (commandId !== responseId) {
          throw new import_MatterError.MatterFlowError(
            `Received invoke response with unexpected command ID ${commandId}, expected ${responseId}.`
          );
        }
        if (commandFields2 === void 0) {
          if (responseSchema !== import_Cluster.TlvNoResponse)
            throw new import_MatterError.MatterFlowError(`A response was expected for command ${requestId}.`);
          return void 0;
        }
        const response = responseSchema.decodeTlv(commandFields2);
        logger.debug(
          `Received invoke response: ${(0, import_ClusterHelper.resolveCommandName)({
            endpointId,
            clusterId,
            commandId: requestId
          })} with ${import_Logger.Logger.toJSON(response)})}`
        );
        return response;
      }
      if (optional) {
        return void 0;
      }
      throw new import_MatterError.MatterFlowError("Received invoke response with no result nor response.");
    });
  }
  // TODO Add to ClusterClient when needed/when Group communication is implemented
  async invokeWithSuppressedResponse(options) {
    const {
      endpointId,
      clusterId,
      request,
      command: { requestId, requestSchema, timed },
      asTimedRequest,
      timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS
    } = options;
    const timedRequest = timed || asTimedRequest === true || options.timedRequestTimeoutMs !== void 0;
    return this.withMessenger(async (messenger) => {
      logger.debug(
        `Invoking command with suppressedResponse: ${(0, import_ClusterHelper.resolveCommandName)({
          endpointId,
          clusterId,
          commandId: requestId
        })} with ${import_Logger.Logger.toJSON(request)}`
      );
      const commandFields = requestSchema.encodeTlv(request);
      if (timedRequest) {
        await messenger.sendTimedRequest(timedRequestTimeoutMs);
      }
      const invokeResponse = await messenger.sendInvokeCommand({
        invokeRequests: [{ commandPath: { endpointId, clusterId, commandId: requestId }, commandFields }],
        timedRequest,
        suppressResponse: true,
        interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION
      });
      if (invokeResponse !== void 0) {
        throw new import_MatterError.MatterFlowError(
          "Response received from invoke interaction but none expected because response is suppressed."
        );
      }
      logger.debug(
        `Invoke successful: ${(0, import_ClusterHelper.resolveCommandName)({
          endpointId,
          clusterId,
          commandId: requestId
        })}`
      );
    });
  }
  async withMessenger(invoke) {
    const messenger = new import_InteractionMessenger.InteractionClientMessenger(this.exchangeProvider);
    try {
      return await invoke(messenger);
    } finally {
      await messenger.close();
    }
  }
  registerSubscriptionUpdateTimer(subscriptionId, maxInterval, updateTimeoutHandler) {
    if (!this.ownSubscriptionIds.has(subscriptionId)) {
      throw new import_MatterError.MatterFlowError(
        `Cannot register update timer for subscription ${subscriptionId} because it is not owned by this client.`
      );
    }
    maxInterval += 5;
    const timer = import_Time.Time.getTimer("Subscription retry", maxInterval * 1e3, () => {
      logger.info(`Subscription ${subscriptionId} timed out ...`);
      this.removeSubscription(subscriptionId);
      this.subscribedLocalValues.clear();
      this.subscribedClusterDataVersions.clear();
      updateTimeoutHandler();
    }).start();
    this.subscriptionClient.registerSubscriptionUpdateTimer(subscriptionId, timer);
  }
  close() {
    for (const subscriptionId of this.ownSubscriptionIds) {
      this.removeSubscription(subscriptionId);
    }
    this.subscribedLocalValues.clear();
    this.subscribedClusterDataVersions.clear();
  }
  get session() {
    return this.exchangeProvider.session;
  }
  get channelType() {
    return this.exchangeProvider.channelType;
  }
}
//# sourceMappingURL=InteractionClient.js.map
