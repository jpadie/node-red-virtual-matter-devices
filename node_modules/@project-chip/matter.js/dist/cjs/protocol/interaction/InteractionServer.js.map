{
  "version": 3,
  "sources": ["../../../../src/protocol/interaction/InteractionServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterDevice } from \"../../MatterDevice.js\";\nimport { TlvNoResponse } from \"../../cluster/Cluster.js\";\nimport {\n    AnyAttributeServer,\n    AttributeServer,\n    FabricScopedAttributeServer,\n} from \"../../cluster/server/AttributeServer.js\";\nimport { CommandServer } from \"../../cluster/server/CommandServer.js\";\nimport { AnyEventServer } from \"../../cluster/server/EventServer.js\";\nimport { Message, SessionType } from \"../../codec/MessageCodec.js\";\nimport { InternalError, MatterFlowError } from \"../../common/MatterError.js\";\nimport { ValidationError } from \"../../common/ValidationError.js\";\nimport { Crypto } from \"../../crypto/Crypto.js\";\nimport { AttributeId } from \"../../datatype/AttributeId.js\";\nimport { ClusterId } from \"../../datatype/ClusterId.js\";\nimport { CommandId } from \"../../datatype/CommandId.js\";\nimport { EndpointNumber } from \"../../datatype/EndpointNumber.js\";\nimport { EventId } from \"../../datatype/EventId.js\";\nimport { EventNumber } from \"../../datatype/EventNumber.js\";\nimport { NodeId } from \"../../datatype/NodeId.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { Logger } from \"../../log/Logger.js\";\nimport { Specification } from \"../../model/definitions/Specification.js\";\nimport { AttributeModel, ClusterModel, CommandModel, GLOBAL_IDS, MatterModel } from \"../../model/index.js\";\nimport { MessageExchange } from \"../../protocol/MessageExchange.js\";\nimport { ProtocolHandler } from \"../../protocol/ProtocolHandler.js\";\nimport { NoAssociatedFabricError, SecureSession, assertSecureSession } from \"../../session/SecureSession.js\";\nimport { TlvAny } from \"../../tlv/TlvAny.js\";\nimport { ArraySchema } from \"../../tlv/TlvArray.js\";\nimport { TlvNoArguments } from \"../../tlv/TlvNoArguments.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport {\n    decodeAttributeValueWithSchema,\n    decodeListAttributeValueWithSchema,\n    expandPathsInAttributeData,\n} from \"./AttributeDataDecoder.js\";\nimport { AttributeReportPayload, DataReportPayload, EventReportPayload } from \"./AttributeDataEncoder.js\";\nimport { InteractionEndpointStructure } from \"./InteractionEndpointStructure.js\";\nimport {\n    InteractionRecipient,\n    InteractionServerMessenger,\n    InvokeRequest,\n    MessageType,\n    ReadRequest,\n    SubscribeRequest,\n    TimedRequest,\n    WriteRequest,\n    WriteResponse,\n} from \"./InteractionMessenger.js\";\nimport {\n    TlvAttributePath,\n    TlvClusterPath,\n    TlvCommandPath,\n    TlvEventFilter,\n    TlvEventPath,\n    TlvInvokeResponseData,\n    TlvInvokeResponseForSend,\n    TlvSubscribeResponse,\n} from \"./InteractionProtocol.js\";\nimport { StatusCode, StatusResponseError } from \"./StatusCode.js\";\nimport { SubscriptionHandler } from \"./SubscriptionHandler.js\";\nimport { SubscriptionOptions } from \"./SubscriptionOptions.js\";\n\n/** Protocol ID for the Interaction Protocol as per Matter specification. */\nexport const INTERACTION_PROTOCOL_ID = 0x0001;\n\n/** Backward compatible re-export for Interaction Model version we support currently. */\nexport const INTERACTION_MODEL_REVISION = Specification.INTERACTION_MODEL_REVISION;\n\n/** We use 10 as max to show that we support more then 1. Once we get a better real-world maximum we can change that. */\nexport const DEFAULT_MAX_PATHS_PER_INVOKE = 10;\n\nconst logger = Logger.get(\"InteractionServer\");\n\nexport interface CommandPath {\n    nodeId?: NodeId;\n    endpointId: EndpointNumber;\n    clusterId: ClusterId;\n    commandId: CommandId;\n}\n\nexport interface AttributePath {\n    nodeId?: NodeId;\n    endpointId: EndpointNumber;\n    clusterId: ClusterId;\n    attributeId: AttributeId;\n}\n\nexport interface EventPath {\n    nodeId?: NodeId;\n    endpointId: EndpointNumber;\n    clusterId: ClusterId;\n    eventId: EventId;\n    isUrgent?: boolean;\n}\n\nexport interface AttributeWithPath {\n    path: AttributePath;\n    attribute: AnyAttributeServer<any>;\n}\n\nexport interface EventWithPath {\n    path: EventPath;\n    event: AnyEventServer<any, any>;\n}\n\nexport interface CommandWithPath {\n    path: CommandPath;\n    command: CommandServer<any, any>;\n}\n\nexport function genericElementPathToId(\n    endpointId: EndpointNumber | undefined,\n    clusterId: ClusterId | undefined,\n    elementId: number | undefined,\n) {\n    return `${endpointId}/${clusterId}/${elementId}`;\n}\n\nexport function commandPathToId({ endpointId, clusterId, commandId }: CommandPath) {\n    return genericElementPathToId(endpointId, clusterId, commandId);\n}\n\nexport function attributePathToId({ endpointId, clusterId, attributeId }: TypeFromSchema<typeof TlvAttributePath>) {\n    return genericElementPathToId(endpointId, clusterId, attributeId);\n}\n\nexport function eventPathToId({ endpointId, clusterId, eventId }: TypeFromSchema<typeof TlvEventPath>) {\n    return genericElementPathToId(endpointId, clusterId, eventId);\n}\n\nexport function clusterPathToId({ nodeId, endpointId, clusterId }: TypeFromSchema<typeof TlvClusterPath>) {\n    return `${nodeId}/${endpointId}/${clusterId}`;\n}\n\nfunction isConcreteAttributePath(\n    path: TypeFromSchema<typeof TlvAttributePath>,\n): path is TypeFromSchema<typeof TlvAttributePath> & AttributePath {\n    const { endpointId, clusterId, attributeId } = path;\n    return endpointId !== undefined && clusterId !== undefined && attributeId !== undefined;\n}\n\nexport function validateReadAttributesPath(path: TypeFromSchema<typeof TlvAttributePath>, isGroupSession = false) {\n    if (isGroupSession) {\n        throw new StatusResponseError(\"Illegal read request with group session\", StatusCode.InvalidAction);\n    }\n    const { clusterId, attributeId } = path;\n    if (clusterId === undefined && attributeId !== undefined) {\n        if (!GLOBAL_IDS.has(attributeId)) {\n            throw new StatusResponseError(\n                `Illegal read request for wildcard cluster and non global attribute ${attributeId}`,\n                StatusCode.InvalidAction,\n            );\n        }\n    }\n}\n\nfunction validateWriteAttributesPath(path: TypeFromSchema<typeof TlvAttributePath>, isGroupSession = false) {\n    const { endpointId, clusterId, attributeId } = path;\n    if (clusterId === undefined || attributeId === undefined) {\n        throw new StatusResponseError(\n            \"Illegal write request with wildcard cluster or attribute ID\",\n            StatusCode.InvalidAction,\n        );\n    }\n    if (isGroupSession && endpointId !== undefined) {\n        throw new StatusResponseError(\"Illegal write request with group ID and endpoint ID\", StatusCode.InvalidAction);\n    }\n}\n\nfunction isConcreteEventPath(\n    path: TypeFromSchema<typeof TlvEventPath>,\n): path is TypeFromSchema<typeof TlvEventPath> & EventPath {\n    const { endpointId, clusterId, eventId } = path;\n    return endpointId !== undefined && clusterId !== undefined && eventId !== undefined;\n}\n\nexport function validateReadEventPath(path: TypeFromSchema<typeof TlvEventPath>, isGroupSession = false) {\n    const { clusterId, eventId } = path;\n    if (clusterId === undefined && eventId !== undefined) {\n        throw new StatusResponseError(\"Illegal read request with wildcard cluster ID\", StatusCode.InvalidAction);\n    }\n    if (isGroupSession) {\n        throw new StatusResponseError(\"Illegal read request with group session\", StatusCode.InvalidAction);\n    }\n}\n\nfunction isConcreteCommandPath(\n    path: TypeFromSchema<typeof TlvCommandPath>,\n): path is TypeFromSchema<typeof TlvCommandPath> & CommandPath {\n    const { endpointId, clusterId, commandId } = path;\n    return endpointId !== undefined && clusterId !== undefined && commandId !== undefined;\n}\n\nfunction validateCommandPath(path: TypeFromSchema<typeof TlvCommandPath>, isGroupSession = false) {\n    const { endpointId, clusterId, commandId } = path;\n    if (clusterId === undefined || commandId === undefined) {\n        throw new StatusResponseError(\n            \"Illegal write request with wildcard cluster or attribute ID\",\n            StatusCode.InvalidAction,\n        );\n    }\n    if (isGroupSession && endpointId !== undefined) {\n        throw new StatusResponseError(\"Illegal write request with group ID and endpoint ID\", StatusCode.InvalidAction);\n    }\n}\n\nfunction getMatterModelCluster(clusterId: ClusterId) {\n    return MatterModel.standard.get(ClusterModel, clusterId);\n}\n\nfunction getMatterModelClusterAttribute(clusterId: ClusterId, attributeId: AttributeId) {\n    return getMatterModelCluster(clusterId)?.get(AttributeModel, attributeId);\n}\n\nfunction getMatterModelClusterCommand(clusterId: ClusterId, commandId: CommandId) {\n    return getMatterModelCluster(clusterId)?.get(CommandModel, commandId);\n}\n\n/**\n * Translates interactions from the Matter protocol to Matter.js APIs.\n */\nexport class InteractionServer implements ProtocolHandler<MatterDevice>, InteractionRecipient {\n    readonly #endpointStructure;\n    #nextSubscriptionId = Crypto.getRandomUInt32();\n    readonly #subscriptionMap = new Map<number, SubscriptionHandler>();\n    #isClosing = false;\n    readonly #subscriptionConfig: SubscriptionOptions.Configuration;\n    readonly #maxPathsPerInvoke;\n\n    constructor({\n        subscriptionOptions,\n        endpointStructure,\n        maxPathsPerInvoke = DEFAULT_MAX_PATHS_PER_INVOKE,\n    }: InteractionServer.Configuration) {\n        this.#subscriptionConfig = SubscriptionOptions.configurationFor(subscriptionOptions);\n        this.#endpointStructure = endpointStructure;\n        this.#maxPathsPerInvoke = maxPathsPerInvoke;\n\n        this.#endpointStructure.change.on(async () => {\n            for (const subscription of this.#subscriptionMap.values()) {\n                await subscription.updateSubscription();\n            }\n        });\n    }\n\n    getId() {\n        return INTERACTION_PROTOCOL_ID;\n    }\n\n    protected get isClosing() {\n        return this.#isClosing;\n    }\n\n    get maxPathsPerInvoke() {\n        return this.#maxPathsPerInvoke;\n    }\n\n    async onNewExchange(exchange: MessageExchange<MatterDevice>) {\n        // Note - changes here must be copied to TransactionalInteractionServer as it does not call super() to avoid\n        // the stack frame\n        if (this.#isClosing) return; // We are closing, ignore anything newly incoming\n        await new InteractionServerMessenger(exchange).handleRequest(this);\n    }\n\n    async handleReadRequest(\n        exchange: MessageExchange<MatterDevice>,\n        {\n            attributeRequests,\n            dataVersionFilters,\n            eventRequests,\n            eventFilters,\n            isFabricFiltered,\n            interactionModelRevision,\n        }: ReadRequest,\n        message: Message,\n    ): Promise<DataReportPayload> {\n        logger.debug(\n            `Received read request from ${exchange.channel.name}: attributes:${\n                attributeRequests?.map(path => this.#endpointStructure.resolveAttributeName(path)).join(\", \") ?? \"none\"\n            }, events:${\n                eventRequests?.map(path => this.#endpointStructure.resolveEventName(path)).join(\", \") ?? \"none\"\n            } isFabricFiltered=${isFabricFiltered}`,\n        );\n\n        if (interactionModelRevision > INTERACTION_MODEL_REVISION) {\n            logger.debug(\n                `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${INTERACTION_MODEL_REVISION}.`,\n            );\n        }\n        if (attributeRequests === undefined && eventRequests === undefined) {\n            throw new StatusResponseError(\n                \"Only Read requests with attributeRequests or eventRequests are supported right now\",\n                StatusCode.UnsupportedRead,\n            );\n        }\n\n        if (message.packetHeader.sessionType !== SessionType.Unicast) {\n            throw new StatusResponseError(\n                \"Subscriptions are only allowed on unicast sessions\",\n                StatusCode.InvalidAction,\n            );\n        }\n\n        const dataVersionFilterMap = new Map<string, number>(\n            dataVersionFilters?.map(({ path, dataVersion }) => [clusterPathToId(path), dataVersion]) ?? [],\n        );\n        if (dataVersionFilterMap.size > 0) {\n            logger.debug(\n                `DataVersionFilters: ${Array.from(dataVersionFilterMap.entries())\n                    .map(([path, version]) => `${path}=${version}`)\n                    .join(\", \")}`,\n            );\n        }\n\n        const attributeReportsPayload = new Array<AttributeReportPayload>();\n        for (const requestPath of attributeRequests ?? []) {\n            validateReadAttributesPath(requestPath);\n\n            const attributes = this.#endpointStructure.getAttributes([requestPath]);\n\n            // Requested attribute path not found in any cluster server on any endpoint\n            if (attributes.length === 0) {\n                // TODO Add checks for nodeId -> UnknownNode\n                if (isConcreteAttributePath(requestPath)) {\n                    const { endpointId, clusterId, attributeId } = requestPath;\n                    // Concrete path, but still unknown for us, so generate the right error status\n                    try {\n                        this.#endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);\n                        throw new InternalError(\n                            \"validateConcreteAttributePath should throw StatusResponseError but did not.\",\n                        );\n                    } catch (e) {\n                        StatusResponseError.accept(e);\n                        logger.debug(\n                            `Error reading attribute from ${\n                                exchange.channel.name\n                            }: ${this.#endpointStructure.resolveAttributeName(requestPath)}: unsupported path: Status=${\n                                e.code\n                            }`,\n                        );\n                        attributeReportsPayload.push({\n                            hasFabricSensitiveData: false,\n                            attributeStatus: { path: requestPath, status: { status: e.code } },\n                        });\n                    }\n                }\n\n                // Wildcard path and we do not know any of the attributes: Ignore the error\n                logger.debug(\n                    `Read from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(\n                        requestPath,\n                    )}: ${this.#endpointStructure.resolveAttributeName(requestPath)}: ignore non-existing attribute`,\n                );\n                continue;\n            }\n\n            // Process all known attributes for the given path\n            for (const { path, attribute } of attributes) {\n                const { nodeId, endpointId, clusterId } = path;\n\n                try {\n                    // We accept attributes not in the model ans readable, because existence is checked already\n                    if (getMatterModelClusterAttribute(clusterId, attribute.id)?.readable === false) {\n                        throw new StatusResponseError(\n                            `Attribute ${attribute.id} is not readable.`,\n                            StatusCode.UnsupportedRead,\n                        );\n                    }\n\n                    let value, version;\n                    try {\n                        ({ value, version } = await this.readAttribute(\n                            path,\n                            attribute,\n                            exchange,\n                            isFabricFiltered,\n                            message,\n                            this.#endpointStructure.getEndpoint(endpointId)!,\n                        ));\n                    } catch (e) {\n                        NoAssociatedFabricError.accept(e);\n\n                        // TODO: Remove when we remove legacy API\n                        //  This is not fully correct but should be sufficient for now\n                        //  This is fixed in the new API already, so this error should never throw\n                        //  Fabric scoped attributes are access errors, fabric sensitive attributes are just filtered\n                        //  Assume for now that in this place we only need to handle fabric sensitive case\n                        if (endpointId === undefined || clusterId === undefined) {\n                            throw new MatterFlowError(\"Should never happen\");\n                        }\n                        const cluster = this.#endpointStructure.getClusterServer(endpointId, clusterId);\n                        if (cluster === undefined || cluster.datasource == undefined) {\n                            throw new MatterFlowError(\"Should never happen\");\n                        }\n                        version = cluster.datasource.version;\n                        value = [];\n                    }\n\n                    const versionFilterValue =\n                        endpointId !== undefined && clusterId !== undefined\n                            ? dataVersionFilterMap.get(clusterPathToId({ nodeId, endpointId, clusterId }))\n                            : undefined;\n                    if (versionFilterValue !== undefined && versionFilterValue === version) {\n                        logger.debug(\n                            `Read attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(\n                                path,\n                            )}=${Logger.toJSON(value)} (version=${version}) ignored because of dataVersionFilter`,\n                        );\n                        continue;\n                    }\n\n                    logger.debug(\n                        `Read attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(\n                            path,\n                        )}=${Logger.toJSON(value)} (version=${version})`,\n                    );\n\n                    const { schema } = attribute;\n                    attributeReportsPayload.push({\n                        hasFabricSensitiveData: attribute.hasFabricSensitiveData,\n                        attributeData: { path, dataVersion: version, payload: value, schema },\n                    });\n                } catch (error) {\n                    logger.error(\n                        `Error while reading attribute from ${\n                            exchange.channel.name\n                        } to ${this.#endpointStructure.resolveAttributeName(path)}:`,\n                        error,\n                    );\n\n                    StatusResponseError.accept(error);\n\n                    // Add StatusResponseErrors, but only when the initial path was concrete, else error are ignored\n                    if (isConcreteAttributePath(requestPath)) {\n                        attributeReportsPayload.push({\n                            hasFabricSensitiveData: false,\n                            attributeStatus: { path, status: { status: error.code } },\n                        });\n                    }\n                }\n            }\n        }\n\n        let eventReportsPayload: undefined | EventReportPayload[];\n        if (eventRequests) {\n            eventReportsPayload = [];\n            for (const requestPath of eventRequests) {\n                validateReadEventPath(requestPath);\n\n                const events = this.#endpointStructure.getEvents([requestPath]);\n\n                // Requested event path not found in any cluster server on any endpoint\n                if (events.length === 0) {\n                    if (isConcreteEventPath(requestPath)) {\n                        const { endpointId, clusterId, eventId } = requestPath;\n                        try {\n                            this.#endpointStructure.validateConcreteEventPath(endpointId, clusterId, eventId);\n                            throw new InternalError(\n                                \"validateConcreteEventPath should throw StatusResponseError but did not.\",\n                            );\n                        } catch (e) {\n                            StatusResponseError.accept(e);\n\n                            logger.debug(\n                                `Read event from ${\n                                    exchange.channel.name\n                                }: ${this.#endpointStructure.resolveEventName(requestPath)}: unsupported path: Status=${\n                                    e.code\n                                }`,\n                            );\n                            eventReportsPayload?.push({\n                                hasFabricSensitiveData: false,\n                                eventStatus: { path: requestPath, status: { status: e.code } },\n                            });\n                        }\n                    }\n                    // Wildcard path: Just leave out values\n                    logger.debug(\n                        `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(\n                            requestPath,\n                        )}: ignore non-existing event`,\n                    );\n                    continue;\n                }\n\n                const reportsForPath = new Array<EventReportPayload>();\n                for (const { path, event } of events) {\n                    try {\n                        const { endpointId } = path;\n                        const matchingEvents = await this.readEvent(\n                            path,\n                            eventFilters,\n                            event,\n                            exchange,\n                            isFabricFiltered,\n                            message,\n                            this.#endpointStructure.getEndpoint(endpointId)!,\n                        );\n                        logger.debug(\n                            `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(\n                                path,\n                            )}=${Logger.toJSON(matchingEvents)}`,\n                        );\n                        const { schema } = event;\n                        reportsForPath.push(\n                            ...matchingEvents.map(({ eventNumber, priority, epochTimestamp, data }) => ({\n                                hasFabricSensitiveData: event.hasFabricSensitiveData,\n                                eventData: {\n                                    path,\n                                    eventNumber,\n                                    priority,\n                                    epochTimestamp,\n                                    payload: data,\n                                    schema,\n                                },\n                            })),\n                        );\n                    } catch (error) {\n                        logger.error(\n                            `Error while reading event from ${\n                                exchange.channel.name\n                            } to ${this.#endpointStructure.resolveEventName(path)}:`,\n                            error,\n                        );\n\n                        StatusResponseError.accept(error);\n\n                        // Add StatusResponseErrors, but only when the initial path was concrete, else error are ignored\n                        if (isConcreteEventPath(requestPath)) {\n                            eventReportsPayload?.push({\n                                hasFabricSensitiveData: false,\n                                eventStatus: { path, status: { status: error.code } },\n                            });\n                        }\n                    }\n                }\n                eventReportsPayload.push(\n                    ...reportsForPath.sort((a, b) => {\n                        const eventNumberA = a.eventData?.eventNumber ?? EventNumber(0);\n                        const eventNumberB = b.eventData?.eventNumber ?? EventNumber(0);\n                        if (eventNumberA > eventNumberB) {\n                            return 1;\n                        } else if (eventNumberA < eventNumberB) {\n                            return -1;\n                        } else {\n                            return 0;\n                        }\n                    }),\n                );\n            }\n        }\n\n        return {\n            interactionModelRevision: INTERACTION_MODEL_REVISION,\n            suppressResponse: true,\n            attributeReportsPayload,\n            eventReportsPayload,\n        };\n    }\n\n    protected async readAttribute(\n        _path: AttributePath,\n        attribute: AnyAttributeServer<any>,\n        exchange: MessageExchange<MatterDevice>,\n        isFabricFiltered: boolean,\n        message: Message,\n        _endpoint: EndpointInterface,\n    ) {\n        return attribute.getWithVersion(exchange.session, isFabricFiltered, message);\n    }\n\n    protected async readEvent(\n        _path: EventPath,\n        eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined,\n        event: AnyEventServer<any, any>,\n        exchange: MessageExchange<MatterDevice>,\n        isFabricFiltered: boolean,\n        message: Message,\n        _endpoint: EndpointInterface,\n    ) {\n        return event.get(exchange.session, isFabricFiltered, message, eventFilters);\n    }\n\n    async handleWriteRequest(\n        exchange: MessageExchange<MatterDevice>,\n        { suppressResponse, timedRequest, writeRequests, interactionModelRevision, moreChunkedMessages }: WriteRequest,\n        message: Message,\n    ): Promise<WriteResponse> {\n        const sessionType = message.packetHeader.sessionType;\n        logger.debug(\n            `Received write request from ${exchange.channel.name}: ${writeRequests\n                .map(req => this.#endpointStructure.resolveAttributeName(req.path))\n                .join(\", \")}, suppressResponse=${suppressResponse}, moreChunkedMessages=${moreChunkedMessages}`,\n        );\n\n        if (moreChunkedMessages && suppressResponse) {\n            throw new StatusResponseError(\n                \"MoreChunkedMessages and SuppressResponse cannot be used together in write messages\",\n                StatusCode.InvalidAction,\n            );\n        }\n\n        if (interactionModelRevision > INTERACTION_MODEL_REVISION) {\n            logger.debug(\n                `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${INTERACTION_MODEL_REVISION}.`,\n            );\n        }\n\n        const receivedWithinTimedInteraction = exchange.hasActiveTimedInteraction();\n\n        if (receivedWithinTimedInteraction && moreChunkedMessages) {\n            throw new StatusResponseError(\n                \"Write Request action that is part of a Timed Write Interaction SHALL NOT be chunked.\",\n                StatusCode.InvalidAction,\n            );\n        }\n\n        if (exchange.hasExpiredTimedInteraction()) {\n            exchange.clearTimedInteraction(); // ??\n            throw new StatusResponseError(`Timed request window expired. Decline write request.`, StatusCode.Timeout);\n        }\n\n        if (timedRequest !== exchange.hasTimedInteraction()) {\n            throw new StatusResponseError(\n                `timedRequest flag of write interaction (${timedRequest}) mismatch with expected timed interaction (${receivedWithinTimedInteraction}).`,\n                StatusCode.TimedRequestMismatch,\n            );\n        }\n\n        if (receivedWithinTimedInteraction) {\n            logger.debug(\n                `Write request from ${exchange.channel.name} successfully received while timed interaction is running.`,\n            );\n            exchange.clearTimedInteraction();\n            if (sessionType !== SessionType.Unicast) {\n                throw new StatusResponseError(\n                    \"Write requests are only allowed on unicast sessions when a timed interaction is running.\",\n                    StatusCode.InvalidAction,\n                );\n            }\n        }\n\n        if (sessionType === SessionType.Group && !suppressResponse) {\n            throw new StatusResponseError(\n                \"Write requests are only allowed as group casts when suppressResponse=true.\",\n                StatusCode.InvalidAction,\n            );\n        }\n\n        const writeData = expandPathsInAttributeData(writeRequests, true);\n\n        const writeResults = new Array<{\n            path: TypeFromSchema<typeof TlvAttributePath>;\n            statusCode: StatusCode;\n            clusterStatusCode?: number;\n        }>();\n        const attributeListWrites = new Set<AttributeServer<any>>();\n        const clusterDataVersionInfo = new Map<string, number>();\n        const inaccessiblePaths = new Set<string>();\n\n        // TODO Add handling for moreChunkedMessages here when adopting for Matter 1.3\n\n        for (const writeRequest of writeData) {\n            const { path: writePath, dataVersion } = writeRequest;\n\n            validateWriteAttributesPath(writePath);\n\n            const attributes = this.#endpointStructure.getAttributes([writePath], true);\n\n            // No existing attribute matches the given path and is writable\n            if (attributes.length === 0) {\n                if (isConcreteAttributePath(writePath)) {\n                    const { endpointId, clusterId, attributeId } = writePath;\n\n                    // was a concrete path\n                    try {\n                        this.#endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);\n\n                        // Ok it is a valid  concrete path, so it is not writable\n                        throw new StatusResponseError(\n                            `Attribute ${attributeId} is not writable.`,\n                            StatusCode.UnsupportedWrite,\n                        );\n                    } catch (e) {\n                        StatusResponseError.accept(e);\n\n                        logger.debug(\n                            `Write from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(\n                                writePath,\n                            )} not allowed: Status=${e.code}`,\n                        );\n                        writeResults.push({ path: writePath, statusCode: e.code });\n                    }\n                } else {\n                    // Wildcard path: Just ignore\n                    logger.debug(\n                        `Write from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(\n                            writePath,\n                        )}: ignore non-existing (wildcard) attribute`,\n                    );\n                }\n                continue;\n            }\n\n            // Concrete path and found and writable\n            if (attributes.length === 1 && isConcreteAttributePath(writePath)) {\n                const { endpointId, clusterId } = writePath;\n                const { attribute } = attributes[0];\n\n                if (attribute.requiresTimedInteraction && !receivedWithinTimedInteraction) {\n                    logger.debug(`This write requires a timed interaction which is not initialized.`);\n                    writeResults.push({ path: writePath, statusCode: StatusCode.NeedsTimedInteraction });\n                    continue;\n                }\n\n                if (\n                    attribute instanceof FabricScopedAttributeServer &&\n                    (!exchange.session.isSecure || !(exchange.session as SecureSession<MatterDevice>).fabric)\n                ) {\n                    logger.debug(`This write requires a secure session with a fabric assigned which is missing.`);\n                    writeResults.push({ path: writePath, statusCode: StatusCode.UnsupportedAccess });\n                    continue;\n                }\n\n                // Check the provided dataVersion with the dataVersion of the cluster\n                // And remember this initial dataVersion for all checks inside this write transaction to allow proper\n                // processing of chunked lists\n                if (dataVersion !== undefined) {\n                    const datasource = this.#endpointStructure.getClusterServer(endpointId, clusterId)?.datasource;\n                    const { nodeId } = writePath;\n                    const clusterKey = clusterPathToId({ nodeId, endpointId, clusterId });\n                    const currentDataVersion = clusterDataVersionInfo.get(clusterKey) ?? datasource?.version;\n\n                    if (currentDataVersion !== undefined) {\n                        if (dataVersion !== currentDataVersion) {\n                            logger.debug(\n                                `This write requires a specific data version (${dataVersion}) which do not match the current cluster data version (${currentDataVersion}).`,\n                            );\n                            writeResults.push({ path: writePath, statusCode: StatusCode.DataVersionMismatch });\n                            continue;\n                        }\n                        clusterDataVersionInfo.set(clusterKey, currentDataVersion);\n                    }\n                }\n            }\n\n            for (const { path, attribute } of attributes) {\n                const { schema, defaultValue } = attribute;\n                const pathId = attributePathToId(path);\n\n                try {\n                    if (\n                        !(attribute instanceof AttributeServer) &&\n                        !(attribute instanceof FabricScopedAttributeServer)\n                    ) {\n                        throw new StatusResponseError(\n                            \"Fixed attributes cannot be written\",\n                            StatusCode.UnsupportedWrite,\n                        );\n                    }\n\n                    if (inaccessiblePaths.has(pathId)) {\n                        logger.debug(`This write is not allowed due to previous access denied.`);\n                        continue;\n                    }\n\n                    const { endpointId } = path;\n                    const { listIndex } = writePath;\n                    const value =\n                        listIndex === undefined\n                            ? decodeAttributeValueWithSchema(schema, [writeRequest], defaultValue)\n                            : decodeListAttributeValueWithSchema(\n                                  schema,\n                                  [writeRequest],\n                                  (\n                                      await this.readAttribute(\n                                          path,\n                                          attribute,\n                                          exchange,\n                                          true,\n                                          message,\n                                          this.#endpointStructure.getEndpoint(endpointId)!,\n                                      )\n                                  ).value ?? defaultValue,\n                              );\n                    logger.debug(\n                        `Handle write request from ${\n                            exchange.channel.name\n                        } resolved to: ${this.#endpointStructure.resolveAttributeName(path)}=${Logger.toJSON(\n                            value,\n                        )} (listIndex=${listIndex}, for-version=${dataVersion})`,\n                    );\n\n                    if (attribute.requiresTimedInteraction && !receivedWithinTimedInteraction) {\n                        logger.debug(`This write requires a timed interaction which is not initialized.`);\n                        throw new StatusResponseError(\n                            \"This write requires a timed interaction which is not initialized.\",\n                            StatusCode.NeedsTimedInteraction,\n                        );\n                    }\n\n                    await this.writeAttribute(\n                        path,\n                        attribute,\n                        value,\n                        exchange,\n                        message,\n                        this.#endpointStructure.getEndpoint(endpointId)!,\n                        receivedWithinTimedInteraction,\n                        schema instanceof ArraySchema,\n                    );\n                    if (schema instanceof ArraySchema && !attributeListWrites.has(attribute)) {\n                        attributeListWrites.add(attribute);\n                    }\n                } catch (error: any) {\n                    if (StatusResponseError.is(error, StatusCode.UnsupportedAccess)) {\n                        inaccessiblePaths.add(pathId);\n                    }\n                    if (attributes.length === 1 && isConcreteAttributePath(writePath)) {\n                        // For Multi-Attribute-Writes we ignore errors\n                        logger.error(\n                            `Error while handling write request from ${\n                                exchange.channel.name\n                            } to ${this.#endpointStructure.resolveAttributeName(path)}:`,\n                            error instanceof StatusResponseError ? error.message : error,\n                        );\n                        if (error instanceof StatusResponseError) {\n                            writeResults.push({ path, statusCode: error.code, clusterStatusCode: error.clusterCode });\n                            continue;\n                        }\n                        writeResults.push({ path, statusCode: StatusCode.ConstraintError });\n                        continue;\n                    } else {\n                        logger.debug(\n                            `While handling write request from ${\n                                exchange.channel.name\n                            } to ${this.#endpointStructure.resolveAttributeName(path)} ignored: ${error.message}`,\n                        );\n\n                        // TODO - This behavior may be wrong.\n                        //\n                        // If a wildcard write fails we should either:\n                        //\n                        //   1. Ignore entirely (add nothing to write results), or\n                        //   2. Add an error response for the concrete attribute that failed.\n                        //\n                        // Spec is a little ambiguous.  After request path expansion, in core 1.2 8.7.3.2 it states:\n                        //\n                        //   \"If the path indicates attribute data that is not writable, then the path SHALL be\n                        //    discarded\"\n                        //\n                        // So is this \"not writable\" -- so it should be #1 -- or is this \"writable\" but with invalid\n                        // data?  The latter is error case #2 but spec doesn't make clear what the status code would\n                        // be...  We could fall back to CONSTRAINT_ERROR like we do above though\n                        //\n                        // Currently what we do is add a success response for every concrete path that fails.\n                    }\n                }\n                writeResults.push({ path, statusCode: StatusCode.Success });\n            }\n            //.filter(({ statusCode }) => statusCode !== StatusCode.Success); // see https://github.com/project-chip/connectedhomeip/issues/26198\n        }\n\n        const errorResults = writeResults.filter(({ statusCode }) => statusCode !== StatusCode.Success);\n        logger.debug(\n            `Write request from ${exchange.channel.name} done ${\n                errorResults.length\n                    ? `with following errors: ${errorResults\n                          .map(\n                              ({ path, statusCode }) =>\n                                  `${this.#endpointStructure.resolveAttributeName(path)}=${Logger.toJSON(statusCode)}`,\n                          )\n                          .join(\", \")}`\n                    : \"without errors\"\n            }`,\n        );\n\n        const response = {\n            interactionModelRevision: INTERACTION_MODEL_REVISION,\n            writeResponses: writeResults.map(({ path, statusCode, clusterStatusCode }) => ({\n                path,\n                status: { status: statusCode, clusterStatus: clusterStatusCode },\n            })),\n        };\n\n        // Trigger attribute events for delayed list writes\n        for (const attribute of attributeListWrites.values()) {\n            try {\n                attribute.triggerDelayedChangeEvents();\n            } catch (error) {\n                logger.error(\n                    `Ignored Error while writing attribute from ${exchange.channel.name} to ${attribute.name}:`,\n                    error,\n                );\n            }\n        }\n\n        return response;\n    }\n\n    protected async writeAttribute(\n        _path: AttributePath,\n        attribute: AttributeServer<any>,\n        value: any,\n        exchange: MessageExchange<MatterDevice>,\n        message: Message,\n        _endpoint: EndpointInterface,\n        _receivedWithinTimedInteraction?: boolean,\n        isListWrite = false,\n    ) {\n        attribute.set(value, exchange.session, message, isListWrite);\n    }\n\n    async handleSubscribeRequest(\n        exchange: MessageExchange<MatterDevice>,\n        {\n            minIntervalFloorSeconds,\n            maxIntervalCeilingSeconds,\n            attributeRequests,\n            dataVersionFilters,\n            eventRequests,\n            eventFilters,\n            keepSubscriptions,\n            isFabricFiltered,\n            interactionModelRevision,\n        }: SubscribeRequest,\n        messenger: InteractionServerMessenger,\n        message: Message,\n    ): Promise<void> {\n        logger.debug(\n            `Received subscribe request from ${exchange.channel.name} (keepSubscriptions=${keepSubscriptions}, isFabricFiltered=${isFabricFiltered})`,\n        );\n\n        if (interactionModelRevision > INTERACTION_MODEL_REVISION) {\n            logger.debug(\n                `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${INTERACTION_MODEL_REVISION}.`,\n            );\n        }\n\n        if (message.packetHeader.sessionType !== SessionType.Unicast) {\n            throw new StatusResponseError(\n                \"Subscriptions are only allowed on unicast sessions\",\n                StatusCode.InvalidAction,\n            );\n        }\n\n        assertSecureSession(exchange.session, \"Subscriptions are only implemented on secure sessions\");\n        const session = exchange.session;\n        const fabric = session.fabric;\n        if (fabric === undefined)\n            throw new StatusResponseError(\n                \"Subscriptions are only implemented after a fabric has been assigned\",\n                StatusCode.InvalidAction,\n            );\n\n        if (\n            (!Array.isArray(attributeRequests) || attributeRequests.length === 0) &&\n            (!Array.isArray(eventRequests) || eventRequests.length === 0)\n        ) {\n            throw new StatusResponseError(\"No attributes or events requested\", StatusCode.InvalidAction);\n        }\n\n        logger.debug(\n            `Subscribe to attributes:${\n                attributeRequests?.map(path => this.#endpointStructure.resolveAttributeName(path)).join(\", \") ?? \"none\"\n            }, events:${\n                eventRequests?.map(path => this.#endpointStructure.resolveEventName(path)).join(\", \") ?? \"none\"\n            }`,\n        );\n\n        if (dataVersionFilters !== undefined && dataVersionFilters.length > 0) {\n            logger.debug(\n                `DataVersionFilters: ${dataVersionFilters\n                    .map(\n                        ({ path: { nodeId, endpointId, clusterId }, dataVersion }) =>\n                            `${clusterPathToId({ nodeId, endpointId, clusterId })}=${dataVersion}`,\n                    )\n                    .join(\", \")}`,\n            );\n        }\n        if (eventFilters !== undefined && eventFilters.length > 0)\n            logger.debug(\n                `Event filters: ${eventFilters.map(filter => `${filter.nodeId}/${filter.eventMin}`).join(\", \")}`,\n            );\n\n        // Validate of the paths before proceeding\n        attributeRequests?.forEach(path => validateReadAttributesPath(path));\n        eventRequests?.forEach(path => validateReadEventPath(path));\n\n        if (minIntervalFloorSeconds < 0) {\n            throw new StatusResponseError(\n                \"minIntervalFloorSeconds should be greater or equal to 0\",\n                StatusCode.InvalidAction,\n            );\n        }\n        if (maxIntervalCeilingSeconds < 0) {\n            throw new StatusResponseError(\n                \"maxIntervalCeilingSeconds should be greater or equal to 1\",\n                StatusCode.InvalidAction,\n            );\n        }\n        if (maxIntervalCeilingSeconds < minIntervalFloorSeconds) {\n            throw new StatusResponseError(\n                \"maxIntervalCeilingSeconds should be greater or equal to minIntervalFloorSeconds\",\n                StatusCode.InvalidAction,\n            );\n        }\n\n        // TODO: Interpret specs:\n        // The publisher SHALL compute an appropriate value for the MaxInterval field in the action. This SHALL respect the following constraint: MinIntervalFloor \u2264 MaxInterval \u2264 MAX(SUBSCRIPTION_MAX_INTERVAL_PUBLISHER_LIMIT=60mn, MaxIntervalCeiling)\n\n        if (this.#nextSubscriptionId === 0xffffffff) this.#nextSubscriptionId = 0;\n        const subscriptionId = this.#nextSubscriptionId++;\n        const subscriptionHandler = new SubscriptionHandler({\n            subscriptionId,\n            session,\n            endpointStructure: this.#endpointStructure,\n            attributeRequests,\n            dataVersionFilters,\n            eventRequests,\n            eventFilters,\n            isFabricFiltered,\n            minIntervalFloor: minIntervalFloorSeconds,\n            maxIntervalCeiling: maxIntervalCeilingSeconds,\n            cancelCallback: () => this.#subscriptionMap.delete(subscriptionId),\n            subscriptionOptions: this.#subscriptionConfig,\n            readAttribute: (path, attribute) =>\n                this.readAttribute(\n                    path,\n                    attribute,\n                    exchange,\n                    isFabricFiltered,\n                    message,\n                    this.#endpointStructure.getEndpoint(path.endpointId)!,\n                ),\n            readEvent: (path, event, eventFilters) =>\n                this.readEvent(\n                    path,\n                    eventFilters,\n                    event,\n                    exchange,\n                    isFabricFiltered,\n                    message,\n                    this.#endpointStructure.getEndpoint(path.endpointId)!,\n                ),\n        });\n\n        try {\n            // Send initial data report to prime the subscription with initial data\n            await subscriptionHandler.sendInitialReport(messenger);\n        } catch (error: any) {\n            logger.error(\n                `Subscription ${subscriptionId} for Session ${session.id}: Error while sending initial data reports`,\n                error,\n            );\n            await subscriptionHandler.cancel(); // Cleanup\n            if (error instanceof StatusResponseError) {\n                logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);\n                await messenger.sendStatus(error.code);\n            }\n            await messenger.close();\n            return; // Make sure to not bubble up the exception\n        }\n\n        if (!keepSubscriptions) {\n            logger.debug(\n                `Clear subscriptions for Subscriber node ${session.peerNodeId} because keepSubscriptions=false`,\n            );\n            await session.context.clearSubscriptionsForNode(fabric.fabricIndex, session.peerNodeId, true);\n        }\n\n        const maxInterval = subscriptionHandler.maxInterval;\n        logger.info(\n            `Successfully created subscription ${subscriptionId} for Session ${\n                session.id\n            }. Updates: ${minIntervalFloorSeconds} - ${maxIntervalCeilingSeconds} => ${maxInterval} seconds (sendInterval = ${subscriptionHandler.sendInterval} seconds)`,\n        );\n        // Then send the subscription response\n        await messenger.send(\n            MessageType.SubscribeResponse,\n            TlvSubscribeResponse.encode({\n                subscriptionId,\n                maxInterval,\n                interactionModelRevision: INTERACTION_MODEL_REVISION,\n            }),\n        );\n\n        // When an error occurs while sending the response, the subscription is not yet active and will be cleaned up by GC\n        this.#subscriptionMap.set(subscriptionId, subscriptionHandler);\n        session.addSubscription(subscriptionHandler);\n        subscriptionHandler.activateSendingUpdates();\n    }\n\n    async handleInvokeRequest(\n        exchange: MessageExchange<MatterDevice>,\n        { invokeRequests, timedRequest, suppressResponse, interactionModelRevision }: InvokeRequest,\n        messenger: InteractionServerMessenger,\n        message: Message,\n    ): Promise<void> {\n        logger.debug(\n            `Received invoke request from ${exchange.channel.name}${invokeRequests.length > 0 ? ` with ${invokeRequests.length} commands` : \"\"}: ${invokeRequests\n                .map(({ commandPath: { endpointId, clusterId, commandId } }) =>\n                    this.#endpointStructure.resolveCommandName({ endpointId, clusterId, commandId }),\n                )\n                .join(\", \")}, suppressResponse=${suppressResponse}`,\n        );\n\n        if (interactionModelRevision > INTERACTION_MODEL_REVISION) {\n            logger.debug(\n                `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${INTERACTION_MODEL_REVISION}.`,\n            );\n        }\n\n        const receivedWithinTimedInteraction = exchange.hasActiveTimedInteraction();\n        if (exchange.hasExpiredTimedInteraction()) {\n            exchange.clearTimedInteraction(); // ??\n            throw new StatusResponseError(`Timed request window expired. Decline invoke request.`, StatusCode.Timeout);\n        }\n\n        if (timedRequest !== exchange.hasTimedInteraction()) {\n            throw new StatusResponseError(\n                `timedRequest flag of invoke interaction (${timedRequest}) mismatch with expected timed interaction (${receivedWithinTimedInteraction}).`,\n                StatusCode.TimedRequestMismatch,\n            );\n        }\n\n        if (receivedWithinTimedInteraction) {\n            logger.debug(`Invoke request from ${exchange.channel.name} received while timed interaction is running.`);\n            exchange.clearTimedInteraction();\n            if (message.packetHeader.sessionType !== SessionType.Unicast) {\n                throw new StatusResponseError(\n                    \"Invoke requests are only allowed on unicast sessions when a timed interaction is running.\",\n                    StatusCode.InvalidAction,\n                );\n            }\n        }\n\n        if (invokeRequests.length > this.#maxPathsPerInvoke) {\n            throw new StatusResponseError(\n                `Only ${this.#maxPathsPerInvoke} invoke requests are supported in one message. This message contains ${invokeRequests.length}`,\n                StatusCode.InvalidAction,\n            );\n        }\n\n        // Validate all commandPaths before proceeding to make sure not to have executed partial commands\n        invokeRequests.forEach(({ commandPath }) => validateCommandPath(commandPath));\n\n        if (invokeRequests.length > 1) {\n            const invokeUniqueSet = new Set<string>();\n            invokeRequests.forEach(({ commandPath }) => {\n                if (!isConcreteCommandPath(commandPath)) {\n                    throw new StatusResponseError(\n                        \"Wildcard paths are not supported in multi-command invoke requests\",\n                        StatusCode.InvalidAction,\n                    );\n                }\n                const commandPathId = commandPathToId(commandPath);\n                if (invokeUniqueSet.has(commandPathId)) {\n                    throw new StatusResponseError(\n                        `Duplicate command paths (${commandPathId}) are not allowed in multi-command invoke requests`,\n                        StatusCode.InvalidAction,\n                    );\n                }\n                invokeUniqueSet.add(commandPathId);\n            });\n        }\n\n        const isGroupSession = message.packetHeader.sessionType === SessionType.Group;\n        const invokeResponseMessage: TypeFromSchema<typeof TlvInvokeResponseForSend> = {\n            suppressResponse: false, // Deprecated but must be present\n            interactionModelRevision: INTERACTION_MODEL_REVISION,\n            invokeResponses: [],\n            moreChunkedMessages: invokeRequests.length > 1, // Assume for now we have multiple responses when having multiple invokes\n        };\n        const emptyInvokeResponseBytes = TlvInvokeResponseForSend.encode(invokeResponseMessage);\n        let messageSize = emptyInvokeResponseBytes.length;\n        let invokeResultsProcessed = 0;\n\n        // To lower potential latency when we would process all invoke messages and just send responses at the end we\n        // assemble response on the fly locally here and send when message becomes too big\n        const processResponseResult = async (\n            invokeResponse: TypeFromSchema<typeof TlvInvokeResponseData>,\n        ): Promise<void> => {\n            invokeResultsProcessed++;\n\n            if (isGroupSession) {\n                // We send no responses at all for group sessions\n                return;\n            }\n            const encodedInvokeResponse = TlvInvokeResponseData.encodeTlv(invokeResponse);\n            const invokeResponseBytes = TlvAny.getEncodedByteLength(encodedInvokeResponse);\n\n            if (\n                messageSize + invokeResponseBytes > exchange.maxPayloadSize ||\n                invokeResultsProcessed === invokeRequests.length\n            ) {\n                let lastMessageProcessed = false;\n                if (messageSize + invokeResponseBytes <= exchange.maxPayloadSize) {\n                    // last invoke response and matches in the message\n                    invokeResponseMessage.invokeResponses.push(encodedInvokeResponse);\n                    lastMessageProcessed = true;\n                }\n                // Send the response when the message is full or when all responses are processed\n                if (invokeResponseMessage.invokeResponses.length > 0) {\n                    if (invokeRequests.length > 1) {\n                        logger.debug(\n                            `Send ${lastMessageProcessed ? \"final \" : \"\"}invoke response for ${invokeResponseMessage.invokeResponses} commands`,\n                        );\n                    }\n                    await messenger.send(\n                        MessageType.InvokeResponse,\n                        TlvInvokeResponseForSend.encode({\n                            ...invokeResponseMessage,\n                            moreChunkedMessages: invokeResultsProcessed < invokeRequests.length ? true : undefined,\n                        }),\n                    );\n                    invokeResponseMessage.invokeResponses = [];\n                    messageSize = emptyInvokeResponseBytes.length;\n                }\n                if (!lastMessageProcessed) {\n                    invokeResultsProcessed--; // Correct counter again because we recall the method\n                    return processResponseResult(invokeResponse);\n                }\n            } else {\n                invokeResponseMessage.invokeResponses.push(encodedInvokeResponse);\n                messageSize += invokeResponseBytes;\n            }\n        };\n\n        // We could do more fancy parallel command processing, but it makes no sense for now, so lets simply process\n        // invoked commands one by one sequentially\n        for (const { commandPath, commandFields, commandRef } of invokeRequests) {\n            const commands = this.#endpointStructure.getCommands([commandPath]);\n\n            if (commands.length === 0) {\n                if (isConcreteCommandPath(commandPath)) {\n                    const { endpointId, clusterId, commandId } = commandPath;\n\n                    let result;\n\n                    try {\n                        this.#endpointStructure.validateConcreteCommandPath(endpointId, clusterId, commandId);\n                        throw new InternalError(\n                            \"validateConcreteCommandPath should throw StatusResponseError but did not.\",\n                        );\n                    } catch (e) {\n                        StatusResponseError.accept(e);\n\n                        logger.debug(\n                            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(\n                                commandPath,\n                            )} unsupported path: Status=${e.code}`,\n                        );\n                        result = { status: { commandPath, status: { status: e.code }, commandRef } };\n                    }\n\n                    await processResponseResult(result);\n                } else {\n                    // Wildcard path: Just ignore\n                    logger.debug(\n                        `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(\n                            commandPath,\n                        )} ignore non-existing command`,\n                    );\n                }\n                continue;\n            }\n\n            const isConcretePath = isConcreteCommandPath(commandPath);\n            for (const { command, path } of commands) {\n                const { endpointId, clusterId, commandId } = path;\n                if (endpointId === undefined) {\n                    // Should never happen\n                    logger.error(\n                        `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(\n                            path,\n                        )} invalid path because empty endpoint!`,\n                    );\n                    if (isConcretePath) {\n                        await processResponseResult({\n                            status: {\n                                commandPath: path,\n                                status: { status: StatusCode.UnsupportedEndpoint },\n                                commandRef,\n                            },\n                        });\n                    }\n                    continue;\n                }\n                const endpoint = this.#endpointStructure.getEndpoint(endpointId);\n                if (endpoint === undefined) {\n                    // Should never happen\n                    logger.error(\n                        `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(\n                            path,\n                        )} invalid path because endpoint not found!`,\n                    );\n                    if (isConcretePath) {\n                        await processResponseResult({\n                            status: {\n                                commandPath: path,\n                                status: { status: StatusCode.UnsupportedEndpoint },\n                                commandRef,\n                            },\n                        });\n                    }\n                    continue;\n                }\n                if (command.requiresTimedInteraction && !receivedWithinTimedInteraction) {\n                    logger.debug(`This invoke requires a timed interaction which is not initialized.`);\n                    if (isConcretePath) {\n                        await processResponseResult({\n                            status: {\n                                commandPath: path,\n                                status: { status: StatusCode.NeedsTimedInteraction },\n                                commandRef,\n                            },\n                        });\n                    }\n                    continue;\n                }\n                if (\n                    getMatterModelClusterCommand(clusterId, commandId)?.fabricScoped &&\n                    (!exchange.session.isSecure || !(exchange.session as SecureSession<MatterDevice>).fabric)\n                ) {\n                    logger.debug(`This invoke requires a secure session with a fabric assigned which is missing.`);\n                    if (isConcretePath) {\n                        await processResponseResult({\n                            status: { commandPath: path, status: { status: StatusCode.UnsupportedAccess }, commandRef },\n                        });\n                    }\n                    continue;\n                }\n\n                let result;\n                try {\n                    result = await this.invokeCommand(\n                        path,\n                        command,\n                        exchange,\n                        commandFields ?? TlvNoArguments.encodeTlv(commandFields),\n                        message,\n                        endpoint,\n                        receivedWithinTimedInteraction,\n                    );\n                } catch (e) {\n                    StatusResponseError.accept(e);\n\n                    let errorCode = e.code;\n                    const errorLogText = `Error ${Diagnostic.hex(errorCode)}${\n                        e.clusterCode !== undefined ? `/${Diagnostic.hex(e.clusterCode)}` : \"\"\n                    } while invoking command: ${e.message}`;\n\n                    if (e instanceof ValidationError) {\n                        logger.info(\n                            `Validation-${errorLogText}${e.fieldName !== undefined ? ` in field ${e.fieldName}` : \"\"}`,\n                        );\n                        if (errorCode === StatusCode.InvalidAction) {\n                            errorCode = StatusCode.InvalidCommand;\n                        }\n                    } else {\n                        logger.info(errorLogText);\n                    }\n\n                    result = {\n                        code: errorCode,\n                        clusterCode: e.clusterCode,\n                        responseId: command.responseId,\n                        response: TlvNoResponse.encodeTlv(),\n                    };\n                }\n                const { code, clusterCode, responseId, response } = result;\n                if (response.length === 0) {\n                    await processResponseResult({\n                        status: { commandPath: path, status: { status: code, clusterStatus: clusterCode }, commandRef },\n                    });\n                } else {\n                    await processResponseResult({\n                        command: {\n                            commandPath: { ...path, commandId: responseId },\n                            commandFields: response,\n                            commandRef,\n                        },\n                    });\n                }\n            }\n        }\n    }\n\n    protected async invokeCommand(\n        _path: CommandPath,\n        command: CommandServer<any, any>,\n        exchange: MessageExchange<MatterDevice>,\n        commandFields: any,\n        message: Message,\n        endpoint: EndpointInterface,\n        _receivedWithinTimedInteraction = false,\n    ) {\n        return command.invoke(exchange.session, commandFields, message, endpoint);\n    }\n\n    handleTimedRequest(exchange: MessageExchange<MatterDevice>, { timeout, interactionModelRevision }: TimedRequest) {\n        logger.debug(`Received timed request (${timeout}ms) from ${exchange.channel.name}`);\n\n        if (interactionModelRevision > INTERACTION_MODEL_REVISION) {\n            logger.debug(\n                `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${INTERACTION_MODEL_REVISION}.`,\n            );\n        }\n\n        exchange.startTimedInteraction(timeout);\n    }\n\n    async close() {\n        this.#isClosing = true;\n        for (const subscription of this.#subscriptionMap.values()) {\n            await subscription.cancel(true);\n        }\n    }\n}\n\nexport namespace InteractionServer {\n    export interface Configuration {\n        readonly subscriptionOptions?: SubscriptionOptions;\n        readonly endpointStructure: InteractionEndpointStructure;\n        readonly maxPathsPerInvoke?: number;\n    }\n}\n"],
  "mappings": "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",
  "names": ["eventFilters"]
}
