"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionMessenger_exports = {};
__export(InteractionMessenger_exports, {
  IncomingInteractionClientMessenger: () => IncomingInteractionClientMessenger,
  InteractionClientMessenger: () => InteractionClientMessenger,
  InteractionServerMessenger: () => InteractionServerMessenger,
  MessageType: () => MessageType
});
module.exports = __toCommonJS(InteractionMessenger_exports);
var import_globals = require("../../cluster/globals/index.js");
var import_MessageCodec = require("../../codec/MessageCodec.js");
var import_MatterError = require("../../common/MatterError.js");
var import_Logger = require("../../log/Logger.js");
var import_MessageExchange = require("../../protocol/MessageExchange.js");
var import_TlvAny = require("../../tlv/TlvAny.js");
var import_AttributeDataEncoder = require("./AttributeDataEncoder.js");
var import_InteractionProtocol = require("./InteractionProtocol.js");
var import_InteractionServer = require("./InteractionServer.js");
var import_StatusCode = require("./StatusCode.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["StatusResponse"] = 1] = "StatusResponse";
  MessageType2[MessageType2["ReadRequest"] = 2] = "ReadRequest";
  MessageType2[MessageType2["SubscribeRequest"] = 3] = "SubscribeRequest";
  MessageType2[MessageType2["SubscribeResponse"] = 4] = "SubscribeResponse";
  MessageType2[MessageType2["ReportData"] = 5] = "ReportData";
  MessageType2[MessageType2["WriteRequest"] = 6] = "WriteRequest";
  MessageType2[MessageType2["WriteResponse"] = 7] = "WriteResponse";
  MessageType2[MessageType2["InvokeRequest"] = 8] = "InvokeRequest";
  MessageType2[MessageType2["InvokeResponse"] = 9] = "InvokeResponse";
  MessageType2[MessageType2["TimedRequest"] = 10] = "TimedRequest";
  return MessageType2;
})(MessageType || {});
const logger = import_Logger.Logger.get("InteractionMessenger");
class InteractionMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  send(messageType, payload, options) {
    return this.exchange.send(messageType, payload, options);
  }
  sendStatus(status) {
    return this.send(
      1 /* StatusResponse */,
      import_InteractionProtocol.TlvStatusResponse.encode({ status, interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION })
    );
  }
  async waitForSuccess() {
    await this.nextMessage(1 /* StatusResponse */);
  }
  async nextMessage(expectedMessageType) {
    const message = await this.exchange.nextMessage();
    const messageType = message.payloadHeader.messageType;
    this.throwIfErrorStatusMessage(message);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType) {
      throw new import_MatterError.UnexpectedDataError(
        `Received unexpected message type: ${messageType}, expected: ${expectedMessageType}`
      );
    }
    return message;
  }
  async close() {
    await this.exchange.close();
  }
  throwIfErrorStatusMessage(message) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== 1 /* StatusResponse */) return;
    const { status } = import_InteractionProtocol.TlvStatusResponse.decode(payload);
    if (status !== import_StatusCode.StatusCode.Success) throw new import_StatusCode.StatusResponseError(`Received error status: ${status}`, status);
  }
  getExchangeChannelName() {
    return this.exchange.channel.name;
  }
}
class InteractionServerMessenger extends InteractionMessenger {
  async handleRequest(recipient) {
    let continueExchange = true;
    let isGroupSession = false;
    try {
      while (continueExchange) {
        const message = await this.exchange.nextMessage();
        isGroupSession = message.packetHeader.sessionType === import_MessageCodec.SessionType.Group;
        continueExchange = false;
        switch (message.payloadHeader.messageType) {
          case 2 /* ReadRequest */: {
            if (isGroupSession) {
              throw new import_StatusCode.StatusResponseError(
                `ReadRequest is not supported in group sessions`,
                import_globals.Status.InvalidAction
              );
            }
            const readRequest = import_InteractionProtocol.TlvReadRequest.decode(message.payload);
            await this.sendDataReport(
              await recipient.handleReadRequest(this.exchange, readRequest, message),
              readRequest.isFabricFiltered
            );
            break;
          }
          case 6 /* WriteRequest */: {
            const writeRequest = import_InteractionProtocol.TlvWriteRequest.decode(message.payload);
            const { suppressResponse } = writeRequest;
            const writeResponse = await recipient.handleWriteRequest(this.exchange, writeRequest, message);
            if (!suppressResponse && !isGroupSession) {
              await this.send(7 /* WriteResponse */, import_InteractionProtocol.TlvWriteResponse.encode(writeResponse));
            }
            break;
          }
          case 3 /* SubscribeRequest */: {
            const subscribeRequest = import_InteractionProtocol.TlvSubscribeRequest.decode(message.payload);
            await recipient.handleSubscribeRequest(this.exchange, subscribeRequest, this, message);
            break;
          }
          case 8 /* InvokeRequest */: {
            const invokeRequest = import_InteractionProtocol.TlvInvokeRequest.decode(message.payload);
            await recipient.handleInvokeRequest(this.exchange, invokeRequest, this, message);
            break;
          }
          case 10 /* TimedRequest */: {
            const timedRequest = import_InteractionProtocol.TlvTimedRequest.decode(message.payload);
            recipient.handleTimedRequest(this.exchange, timedRequest, message);
            await this.sendStatus(import_StatusCode.StatusCode.Success);
            continueExchange = true;
            break;
          }
          default:
            throw new import_StatusCode.StatusResponseError(
              `Unsupported message type ${message.payloadHeader.messageType}`,
              import_globals.Status.InvalidAction
            );
        }
      }
    } catch (error) {
      let errorStatusCode = import_StatusCode.StatusCode.Failure;
      if (error instanceof import_StatusCode.StatusResponseError) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        errorStatusCode = error.code;
      } else {
        logger.error(error);
      }
      if (!isGroupSession) {
        await this.sendStatus(errorStatusCode);
      }
    } finally {
      await this.exchange.close();
    }
  }
  /**
   * Handle DataReportPayload with the content of a DataReport to send, split them into multiple DataReport
   * messages and send them out based on the size.
   */
  async sendDataReport(dataReportPayload, forFabricFilteredRead) {
    const {
      subscriptionId,
      attributeReportsPayload,
      eventReportsPayload,
      suppressResponse,
      interactionModelRevision
    } = dataReportPayload;
    const dataReport = {
      subscriptionId,
      suppressResponse,
      interactionModelRevision,
      attributeReports: void 0,
      eventReports: void 0
    };
    if (attributeReportsPayload !== void 0 || eventReportsPayload !== void 0) {
      const attributeReportsToSend = [...attributeReportsPayload ?? []];
      const eventReportsToSend = [...eventReportsPayload ?? []];
      dataReport.moreChunkedMessages = true;
      const emptyDataReportBytes = import_InteractionProtocol.TlvDataReportForSend.encode(dataReport);
      let firstAttributeAddedToReportMessage = false;
      let firstEventAddedToReportMessage = false;
      const sendAndResetReport = async () => {
        await this.sendDataReportMessage(dataReport);
        dataReport.attributeReports = void 0;
        dataReport.eventReports = void 0;
        messageSize = emptyDataReportBytes.length;
        firstAttributeAddedToReportMessage = false;
        firstEventAddedToReportMessage = false;
      };
      let messageSize = emptyDataReportBytes.length;
      while (true) {
        if (attributeReportsToSend.length > 0) {
          const attributeReport = attributeReportsToSend.shift();
          if (attributeReport !== void 0) {
            if (!firstAttributeAddedToReportMessage) {
              firstAttributeAddedToReportMessage = true;
              messageSize += 3;
            }
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && attributeReport.hasFabricSensitiveData;
            const encodedAttribute = (0, import_AttributeDataEncoder.encodeAttributePayload)(attributeReport, {
              allowMissingFieldsForNonFabricFilteredRead
            });
            const attributeReportBytes = import_TlvAny.TlvAny.getEncodedByteLength(encodedAttribute);
            if (messageSize + attributeReportBytes > this.exchange.maxPayloadSize) {
              if ((0, import_AttributeDataEncoder.canAttributePayloadBeChunked)(attributeReport)) {
                attributeReportsToSend.unshift(...(0, import_AttributeDataEncoder.chunkAttributePayload)(attributeReport));
                continue;
              }
              await sendAndResetReport();
            }
            messageSize += attributeReportBytes;
            if (dataReport.attributeReports === void 0) dataReport.attributeReports = [];
            dataReport.attributeReports.push(encodedAttribute);
          }
        } else if (eventReportsToSend.length > 0) {
          const eventReport = eventReportsToSend.shift();
          if (eventReport === void 0) {
            delete dataReport.moreChunkedMessages;
            break;
          }
          if (!firstEventAddedToReportMessage) {
            firstEventAddedToReportMessage = true;
            messageSize += 3;
          }
          const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && eventReport.hasFabricSensitiveData;
          const encodedEvent = (0, import_AttributeDataEncoder.encodeEventPayload)(eventReport, {
            allowMissingFieldsForNonFabricFilteredRead
          });
          const eventReportBytes = import_TlvAny.TlvAny.getEncodedByteLength(encodedEvent);
          if (messageSize + eventReportBytes > this.exchange.maxPayloadSize) {
            await sendAndResetReport();
          }
          messageSize += eventReportBytes;
          if (dataReport.eventReports === void 0) dataReport.eventReports = [];
          dataReport.eventReports.push(encodedEvent);
        } else {
          delete dataReport.moreChunkedMessages;
          break;
        }
      }
    }
    await this.sendDataReportMessage(dataReport);
  }
  async sendDataReportMessage(dataReport) {
    const dataReportToSend = {
      ...dataReport,
      suppressResponse: dataReport.moreChunkedMessages ? false : dataReport.suppressResponse
      // always false when moreChunkedMessages is true
    };
    const encodedMessage = import_InteractionProtocol.TlvDataReportForSend.encode(dataReportToSend);
    if (encodedMessage.length > this.exchange.maxPayloadSize) {
      throw new import_MatterError.MatterFlowError(
        `DataReport is too long to fit in a single chunk, This should not happen! Data: ${import_Logger.Logger.toJSON(
          dataReportToSend
        )}`
      );
    }
    logger.debug(
      `Sending DataReport chunk with ${dataReportToSend.attributeReports?.length ?? 0} attributes and ${dataReportToSend.eventReports?.length ?? 0} events: ${encodedMessage.length} bytes (moreChunkedMessages: ${dataReportToSend.moreChunkedMessages ?? false}, suppressResponse: ${dataReportToSend.suppressResponse})`
    );
    if (dataReportToSend.suppressResponse) {
      try {
        await this.exchange.send(5 /* ReportData */, encodedMessage, {
          expectAckOnly: true
        });
      } catch (e) {
        import_MessageExchange.UnexpectedMessageError.accept(e);
        const { receivedMessage } = e;
        this.throwIfErrorStatusMessage(receivedMessage);
      }
    } else {
      await this.exchange.send(5 /* ReportData */, encodedMessage);
      await this.waitForSuccess();
    }
  }
}
class IncomingInteractionClientMessenger extends InteractionMessenger {
  async readDataReports(sendFinalAckMessage = true) {
    let subscriptionId;
    const attributeValues = [];
    const eventValues = [];
    while (true) {
      const dataReportMessage = await this.exchange.waitFor(5 /* ReportData */);
      const report = import_InteractionProtocol.TlvDataReport.decode(dataReportMessage.payload);
      if (subscriptionId === void 0 && report.subscriptionId !== void 0) {
        subscriptionId = report.subscriptionId;
      } else if ((subscriptionId !== void 0 || report.subscriptionId !== void 0) && report.subscriptionId !== subscriptionId) {
        throw new import_MatterError.UnexpectedDataError(`Invalid subscription ID ${report.subscriptionId} received`);
      }
      logger.debug(
        `Received DataReport chunk with ${report.attributeReports?.length ?? 0} attributes and ${report.eventReports?.length ?? 0} events, suppressResponse: ${report.suppressResponse}, moreChunkedMessages: ${report.moreChunkedMessages}`
      );
      if (Array.isArray(report.attributeReports) && report.attributeReports.length > 0) {
        attributeValues.push(...report.attributeReports);
      }
      if (Array.isArray(report.eventReports) && report.eventReports.length > 0) {
        eventValues.push(...report.eventReports);
      }
      if (report.moreChunkedMessages || sendFinalAckMessage && !report.suppressResponse) {
        await this.sendStatus(import_StatusCode.StatusCode.Success);
      }
      if (!report.moreChunkedMessages) {
        report.attributeReports = attributeValues;
        report.eventReports = eventValues;
        return report;
      }
    }
  }
}
class InteractionClientMessenger extends IncomingInteractionClientMessenger {
  constructor(exchangeProvider) {
    super(exchangeProvider.initiateExchange());
    this.exchangeProvider = exchangeProvider;
  }
  /** Implements a send method with an automatic reconnection mechanism */
  async send(messageType, payload, options) {
    if (this.exchange.channel.closed) {
      throw new import_MatterError.ImplementationError("The exchange channel is closed. Please connect the device first.");
    }
    try {
      return await this.exchange.send(messageType, payload, options);
    } catch (error) {
      if (error instanceof import_MessageExchange.RetransmissionLimitReachedError) {
        await this.exchange.close();
        if (await this.exchangeProvider.reconnectChannel()) {
          this.exchange = this.exchangeProvider.initiateExchange();
          return await this.exchange.send(messageType, payload);
        }
      }
      throw error;
    }
  }
  async sendReadRequest(readRequest) {
    await this.send(2 /* ReadRequest */, import_InteractionProtocol.TlvReadRequest.encode(readRequest));
    return this.readDataReports();
  }
  async sendSubscribeRequest(subscribeRequest) {
    await this.send(3 /* SubscribeRequest */, import_InteractionProtocol.TlvSubscribeRequest.encode(subscribeRequest));
    const report = await this.readDataReports();
    const { subscriptionId } = report;
    if (subscriptionId === void 0) {
      throw new import_MatterError.UnexpectedDataError(`Subscription ID not provided in report`);
    }
    const subscribeResponseMessage = await this.nextMessage(4 /* SubscribeResponse */);
    const subscribeResponse = import_InteractionProtocol.TlvSubscribeResponse.decode(subscribeResponseMessage.payload);
    if (subscribeResponse.subscriptionId !== subscriptionId) {
      throw new import_MatterError.MatterFlowError(
        `Received subscription ID ${subscribeResponse.subscriptionId} instead of ${subscriptionId}`
      );
    }
    return {
      subscribeResponse,
      report
    };
  }
  async sendInvokeCommand(invokeRequest, minimumResponseTimeoutMs) {
    if (invokeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(
        8 /* InvokeRequest */,
        import_InteractionProtocol.TlvInvokeRequest,
        invokeRequest,
        minimumResponseTimeoutMs
      );
    } else {
      return await this.request(
        8 /* InvokeRequest */,
        import_InteractionProtocol.TlvInvokeRequest,
        9 /* InvokeResponse */,
        import_InteractionProtocol.TlvInvokeResponse,
        invokeRequest,
        minimumResponseTimeoutMs
      );
    }
  }
  async sendWriteCommand(writeRequest) {
    if (writeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(6 /* WriteRequest */, import_InteractionProtocol.TlvWriteRequest, writeRequest);
    } else {
      return await this.request(
        6 /* WriteRequest */,
        import_InteractionProtocol.TlvWriteRequest,
        7 /* WriteResponse */,
        import_InteractionProtocol.TlvWriteResponse,
        writeRequest
      );
    }
  }
  sendTimedRequest(timeoutSeconds) {
    return this.request(10 /* TimedRequest */, import_InteractionProtocol.TlvTimedRequest, 1 /* StatusResponse */, import_InteractionProtocol.TlvStatusResponse, {
      timeout: timeoutSeconds,
      interactionModelRevision: import_InteractionServer.INTERACTION_MODEL_REVISION
    });
  }
  async requestWithSuppressedResponse(requestMessageType, requestSchema, request, minimumResponseTimeoutMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: true,
      minimumResponseTimeoutMs
    });
  }
  async request(requestMessageType, requestSchema, responseMessageType, responseSchema, request, minimumResponseTimeoutMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: false,
      minimumResponseTimeoutMs
    });
    const responseMessage = await this.nextMessage(responseMessageType);
    return responseSchema.decode(responseMessage.payload);
  }
}
//# sourceMappingURL=InteractionMessenger.js.map
