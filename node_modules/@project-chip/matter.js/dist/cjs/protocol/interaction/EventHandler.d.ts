/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { EventPriority } from "../../cluster/Cluster.js";
import { ClusterId } from "../../datatype/ClusterId.js";
import { EndpointNumber } from "../../datatype/EndpointNumber.js";
import { EventId } from "../../datatype/EventId.js";
import { EventNumber } from "../../datatype/EventNumber.js";
import { FabricIndex } from "../../datatype/FabricIndex.js";
import { Storage, StorageOperationResult } from "../../storage/Storage.js";
import { StorageContext } from "../../storage/StorageContext.js";
import { TypeFromSchema } from "../../tlv/TlvSchema.js";
import { Construction } from "../../util/Construction.js";
import { TlvEventFilter, TlvEventPath } from "./InteractionProtocol.js";
/**
 * Data of one Event
 */
export interface EventData<T> {
    endpointId: EndpointNumber;
    clusterId: ClusterId;
    eventId: EventId;
    epochTimestamp: number;
    priority: EventPriority;
    data: T;
}
/**
 * Data of an event which was triggered and stored internally
 */
export interface EventStorageData<T> extends EventData<T> {
    eventNumber: EventNumber;
}
/**
 * Class that collects all triggered events up to a certain limit of events and handle logic
 * to handle subscriptions (TBD)
 */
export declare class EventHandler<S extends Storage = any> {
    #private;
    private readonly eventStorage;
    private eventNumber;
    private storedEventCount;
    private readonly events;
    get construction(): Construction<EventHandler<any>>;
    static create(eventStorage: StorageContext): Promise<EventHandler<any>>;
    constructor(eventStorage: StorageContext<S>);
    getEvents(eventPath: TypeFromSchema<typeof TlvEventPath>, filters?: TypeFromSchema<typeof TlvEventFilter>[], filterForFabricIndex?: FabricIndex): EventStorageData<any>[];
    pushEvent(event: EventData<any>): StorageOperationResult<S, EventStorageData<any>>;
    cleanUpEvents(): void;
}
//# sourceMappingURL=EventHandler.d.ts.map