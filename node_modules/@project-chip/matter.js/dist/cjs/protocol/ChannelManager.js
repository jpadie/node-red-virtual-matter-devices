"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ChannelManager_exports = {};
__export(ChannelManager_exports, {
  ChannelManager: () => ChannelManager,
  NoChannelError: () => NoChannelError
});
module.exports = __toCommonJS(ChannelManager_exports);
var import_MatterError = require("../common/MatterError.js");
var import_Logger = require("../log/Logger.js");
var import_ExchangeManager = require("./ExchangeManager.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("ChannelManager");
class NoChannelError extends import_MatterError.MatterError {
}
class ChannelManager {
  #channels = /* @__PURE__ */ new Map();
  #paseChannels = /* @__PURE__ */ new Map();
  #caseSessionsPerFabricAndNode;
  // TODO evaluate with controller the effects of limiting the entries just for FabricIndex and not also NodeId
  constructor(caseSessionsPerFabricAndNode = 3) {
    this.#caseSessionsPerFabricAndNode = caseSessionsPerFabricAndNode;
  }
  #getChannelKey(fabric, nodeId) {
    return `${fabric.fabricIndex}/${nodeId}`;
  }
  #findLeastActiveChannel(channels) {
    let oldest = channels[0];
    for (const channel of channels) {
      if (channel.session.timestamp < oldest.session.timestamp) {
        oldest = channel;
      }
    }
    return oldest;
  }
  async setChannel(fabric, nodeId, channel) {
    channel.closeCallback = async () => this.removeChannel(fabric, nodeId, channel.session);
    const channelsKey = this.#getChannelKey(fabric, nodeId);
    const currentChannels = this.#channels.get(channelsKey) ?? [];
    if (currentChannels.length >= this.#caseSessionsPerFabricAndNode) {
      const oldestChannel = this.#findLeastActiveChannel(currentChannels);
      currentChannels.splice(currentChannels.indexOf(oldestChannel), 1);
      currentChannels.push(channel);
      this.#channels.set(channelsKey, currentChannels);
      const { session } = oldestChannel;
      if (session.id !== oldestChannel.session.id) {
        logger.debug(
          `Existing channel for fabricIndex ${fabric.fabricIndex} and node ${nodeId} with session ${session.name} gets replaced. Consider former session already inactive and so close it.`
        );
        await session.destroy(false, false);
      }
      logger.info(`Close oldest channel for fabric ${fabric.fabricIndex} node ${nodeId}`);
      await oldestChannel.close();
    } else {
      currentChannels.push(channel);
      this.#channels.set(channelsKey, currentChannels);
    }
  }
  getChannel(fabric, nodeId, session) {
    let results = this.#channels.get(this.#getChannelKey(fabric, nodeId)) ?? [];
    if (session !== void 0) {
      results = results.filter((channel) => channel.session.id === session.id);
    }
    if (results.length === 0) throw new NoChannelError(`Can't find a channel to node ${nodeId}`);
    return results[results.length - 1];
  }
  /**
   * Returns the last established session for a Fabric and Node
   */
  getChannelForSession(session) {
    if (session.isSecure && !session.isPase) {
      const secureSession = session;
      const fabric = secureSession.fabric;
      const nodeId = secureSession.peerNodeId;
      if (fabric === void 0) {
        return this.#paseChannels.get(session);
      }
      return this.getChannel(fabric, nodeId, session);
    }
    return this.#paseChannels.get(session);
  }
  async removeAllNodeChannels(fabric, nodeId) {
    const channelsKey = this.#getChannelKey(fabric, nodeId);
    const channelsToRemove = this.#channels.get(channelsKey) ?? [];
    for (const channel of channelsToRemove) {
      await channel.close();
    }
  }
  async removeChannel(fabric, nodeId, session) {
    const channelsKey = this.#getChannelKey(fabric, nodeId);
    const fabricChannels = this.#channels.get(channelsKey) ?? [];
    const channelEntryIndex = fabricChannels.findIndex(
      ({ session: entrySession }) => entrySession.id === session.id
    );
    const channelEntry = fabricChannels.splice(channelEntryIndex, 1)[0];
    if (channelEntry === void 0) {
      return;
    }
    await channelEntry.close();
    this.#channels.set(channelsKey, fabricChannels);
  }
  getOrCreateAsPaseChannel(byteArrayChannel, session) {
    const msgChannel = new import_ExchangeManager.MessageChannel(
      byteArrayChannel,
      session,
      async () => void this.#paseChannels.delete(session)
    );
    this.#paseChannels.set(session, msgChannel);
    return msgChannel;
  }
  async getOrCreateChannel(byteArrayChannel, session) {
    if (!session.isSecure) {
      return this.getOrCreateAsPaseChannel(byteArrayChannel, session);
    }
    const secureSession = session;
    const fabric = secureSession.fabric;
    const nodeId = secureSession.peerNodeId;
    if (fabric === void 0) {
      return this.getOrCreateAsPaseChannel(byteArrayChannel, session);
    }
    try {
      return this.getChannel(fabric, nodeId, session);
    } catch (e) {
      NoChannelError.accept(e);
    }
    const result = new import_ExchangeManager.MessageChannel(
      byteArrayChannel,
      session,
      async () => this.removeChannel(fabric, nodeId, session)
    );
    await this.setChannel(fabric, nodeId, result);
    return result;
  }
  async close() {
    for (const channel of this.#paseChannels.values()) {
      await channel.close();
    }
    this.#paseChannels.clear();
    for (const channels of this.#channels.values()) {
      for (const channel of channels) {
        await channel.close();
      }
    }
    this.#channels.clear();
  }
}
//# sourceMappingURL=ChannelManager.js.map
