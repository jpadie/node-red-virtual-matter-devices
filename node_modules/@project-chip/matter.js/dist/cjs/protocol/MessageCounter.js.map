{
  "version": 3,
  "sources": ["../../../src/protocol/MessageCounter.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../common/MatterError.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { StorageContext } from \"../storage/StorageContext.js\";\nimport { Construction, asyncNew } from \"../util/Construction.js\";\n\n/** Maximum 32 bit counter value. */\nexport const MAX_COUNTER_VALUE_32BIT = 0xfffffffe;\n\n/** Default number of messages before a rollover callback is called. */\nconst ROLLOVER_INFO_DIFFERENCE = 1000;\n\nexport enum MessageCounterTypes {\n    /**\n     * Used for \"Unsecure\" sessions\n     * Rollover allowed, Persistence: Optional\n     */\n    GlobalUnencrypted,\n\n    /**\n     * Used for \"Group\" sessions to encode regular data messages encrypted with a group key.\n     * Lifetime: Operational Group Key, Rollover allowed, Persistence: Mandatory\n     */\n    GlobalEncryptedData,\n\n    /**\n     * Used for \"Group\" sessions to encode control messages encrypted with a group key.\n     * Lifetime: Operational Group Key, Rollover allowed, Persistence: Mandatory\n     */\n    GlobalEncryptedControl,\n\n    /**\n     * Used for \"Unicast\" sessions\n     * Lifetime: Session Key, Rollover expires, Persistence: Optional\n     */\n    SecureSession,\n}\n\n/**\n * Represents a message counter which gets randomly initialized and then incremented for each message.\n * Rollover can be allowed or forbidden and a callback can be provided to be notified before a rollover would happen.\n */\nexport class MessageCounter {\n    protected messageCounter = (Crypto.getRandomUInt32() >>> 4) + 1; // 28 bit random number plus 1\n\n    /**\n     * Creates a new message counter with a random start value. If a aboutToRolloverCallback is provided this\n     * counter is not allowed to rollover and the callback is called before a rollover would happen. Optionally provide\n     * a number of messages before the rollover callback is called (Default 1000).\n     */\n    constructor(\n        protected readonly aboutToRolloverCallback?: () => void,\n        protected readonly rolloverInfoDifference = ROLLOVER_INFO_DIFFERENCE,\n    ) {}\n\n    async getIncrementedCounter() {\n        this.messageCounter++;\n        if (this.messageCounter > MAX_COUNTER_VALUE_32BIT) {\n            if (this.aboutToRolloverCallback !== undefined) {\n                this.messageCounter = 0;\n            } else {\n                throw new InternalError(\"Message counter rollover not allowed.\");\n            }\n        } else if (\n            this.aboutToRolloverCallback !== undefined &&\n            this.messageCounter === MAX_COUNTER_VALUE_32BIT - this.rolloverInfoDifference\n        ) {\n            this.aboutToRolloverCallback();\n        }\n        return this.messageCounter;\n    }\n}\n\n/** Enhanced Message counter that can be persisted and will be initialized from the persisted value (if existing). */\nexport class PersistedMessageCounter extends MessageCounter {\n    #construction: Construction<PersistedMessageCounter>;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    static async create(\n        storageContext: StorageContext,\n        storageKey: string,\n        aboutToRolloverCallback?: () => void,\n        rolloverInfoDifference = ROLLOVER_INFO_DIFFERENCE,\n    ) {\n        return asyncNew(\n            PersistedMessageCounter,\n            storageContext,\n            storageKey,\n            aboutToRolloverCallback,\n            rolloverInfoDifference,\n        );\n    }\n\n    constructor(\n        private readonly storageContext: StorageContext,\n        private readonly storageKey: string,\n        aboutToRolloverCallback?: () => void,\n        rolloverInfoDifference = ROLLOVER_INFO_DIFFERENCE,\n    ) {\n        super(aboutToRolloverCallback, rolloverInfoDifference);\n        this.#construction = Construction(this, async () => {\n            if (await storageContext.has(storageKey)) {\n                this.messageCounter = await storageContext.get<number>(storageKey);\n                if (this.messageCounter < 0 || this.messageCounter > MAX_COUNTER_VALUE_32BIT) {\n                    throw new InternalError(`Invalid message counter value: ${this.messageCounter}`);\n                }\n                // Make sure to call the callback if we are close to a rollover also for edge cases on initialization\n                if (\n                    this.aboutToRolloverCallback !== undefined &&\n                    this.messageCounter >= MAX_COUNTER_VALUE_32BIT - this.rolloverInfoDifference\n                ) {\n                    this.aboutToRolloverCallback();\n                }\n            }\n        });\n    }\n\n    override async getIncrementedCounter() {\n        const counter = await super.getIncrementedCounter();\n        await this.storageContext.set(this.storageKey, counter);\n        return counter;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,yBAA8B;AAC9B,oBAAuB;AAEvB,0BAAuC;AATvC;AAAA;AAAA;AAAA;AAAA;AAYO,MAAM,0BAA0B;AAGvC,MAAM,2BAA2B;AAE1B,IAAK,sBAAL,kBAAKA,yBAAL;AAKH,EAAAA,0CAAA;AAMA,EAAAA,0CAAA;AAMA,EAAAA,0CAAA;AAMA,EAAAA,0CAAA;AAvBQ,SAAAA;AAAA,GAAA;AA8BL,MAAM,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQxB,YACuB,yBACA,yBAAyB,0BAC9C;AAFqB;AACA;AAAA,EACpB;AAAA,EAVO,kBAAkB,qBAAO,gBAAgB,MAAM,KAAK;AAAA,EAY9D,MAAM,wBAAwB;AAC1B,SAAK;AACL,QAAI,KAAK,iBAAiB,yBAAyB;AAC/C,UAAI,KAAK,4BAA4B,QAAW;AAC5C,aAAK,iBAAiB;AAAA,MAC1B,OAAO;AACH,cAAM,IAAI,iCAAc,uCAAuC;AAAA,MACnE;AAAA,IACJ,WACI,KAAK,4BAA4B,UACjC,KAAK,mBAAmB,0BAA0B,KAAK,wBACzD;AACE,WAAK,wBAAwB;AAAA,IACjC;AACA,WAAO,KAAK;AAAA,EAChB;AACJ;AAGO,MAAM,gCAAgC,eAAe;AAAA,EAsBxD,YACqB,gBACA,YACjB,yBACA,yBAAyB,0BAC3B;AACE,UAAM,yBAAyB,sBAAsB;AALpC;AACA;AAKjB,SAAK,oBAAgB,kCAAa,MAAM,YAAY;AAChD,UAAI,MAAM,eAAe,IAAI,UAAU,GAAG;AACtC,aAAK,iBAAiB,MAAM,eAAe,IAAY,UAAU;AACjE,YAAI,KAAK,iBAAiB,KAAK,KAAK,iBAAiB,yBAAyB;AAC1E,gBAAM,IAAI,iCAAc,kCAAkC,KAAK,cAAc,EAAE;AAAA,QACnF;AAEA,YACI,KAAK,4BAA4B,UACjC,KAAK,kBAAkB,0BAA0B,KAAK,wBACxD;AACE,eAAK,wBAAwB;AAAA,QACjC;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EA3CA;AAAA,EAEA,IAAI,eAAe;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,aAAa,OACT,gBACA,YACA,yBACA,yBAAyB,0BAC3B;AACE,eAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA,EA0BA,MAAe,wBAAwB;AACnC,UAAM,UAAU,MAAM,MAAM,sBAAsB;AAClD,UAAM,KAAK,eAAe,IAAI,KAAK,YAAY,OAAO;AACtD,WAAO;AAAA,EACX;AACJ;",
  "names": ["MessageCounterTypes"]
}
