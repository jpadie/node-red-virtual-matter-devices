{
  "version": 3,
  "sources": ["../../../src/protocol/ControllerDiscovery.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { PairRetransmissionLimitReachedError } from \"../MatterController.js\";\nimport { MatterError } from \"../common/MatterError.js\";\nimport {\n    AddressTypeFromDevice,\n    CommissionableDevice,\n    CommissionableDeviceIdentifiers,\n    DiscoverableDevice,\n    OperationalDevice,\n    Scanner,\n} from \"../common/Scanner.js\";\nimport { serverAddressToString } from \"../common/ServerAddress.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { MdnsScanner } from \"../mdns/MdnsScanner.js\";\nimport { CommissioningError } from \"../protocol/ControllerCommissioner.js\";\nimport { anyPromise } from \"../util/Promises.js\";\nimport { ClassExtends } from \"../util/Type.js\";\n\nconst logger = Logger.get(\"ControllerDiscovery\");\n\nexport class DiscoveryError extends MatterError {}\n\nexport class ControllerDiscovery {\n    /**\n     * Discovers devices by a provided identifier and a list of scanners (e.g. IP and BLE in parallel).\n     * It returns after the timeout or if at least one device was found.\n     * The method returns a list of addresses of the discovered devices.\n     */\n    static async discoverDeviceAddressesByIdentifier(\n        scanners: Array<Scanner>,\n        identifier: CommissionableDeviceIdentifiers,\n        timeoutSeconds = 30,\n    ): Promise<CommissionableDevice[]> {\n        logger.info(`Start Discovering devices using identifier ${Logger.toJSON(identifier)} ...`);\n\n        const scanResults = scanners.map(async scanner => {\n            const foundDevices = await scanner.findCommissionableDevices(identifier, timeoutSeconds);\n            logger.info(`Found ${foundDevices.length} devices using identifier ${Logger.toJSON(identifier)}`);\n            if (foundDevices.length === 0) {\n                throw new CommissioningError(\n                    `No device discovered using identifier ${Logger.toJSON(\n                        identifier,\n                    )}! Please check that the relevant device is online.`,\n                );\n            }\n\n            const devices = foundDevices.filter(device => device.addresses.length > 0);\n            if (devices.length === 0) {\n                throw new CommissioningError(\n                    `Device discovered using identifier ${Logger.toJSON(\n                        identifier,\n                    )}, but no Network addresses discovered.`,\n                );\n            }\n            return devices;\n        });\n\n        return await anyPromise(scanResults);\n    }\n\n    static async discoverCommissionableDevices(\n        scanners: Array<Scanner>,\n        timeoutSeconds: number,\n        identifier: CommissionableDeviceIdentifiers = {},\n        discoveredCallback?: (device: CommissionableDevice) => void,\n    ): Promise<CommissionableDevice[]> {\n        const discoveredDevices = new Map<string, CommissionableDevice>();\n\n        await Promise.all(\n            scanners.map(async scanner => {\n                await scanner.findCommissionableDevicesContinuously(\n                    identifier,\n                    device => {\n                        const { deviceIdentifier } = device;\n                        if (!discoveredDevices.has(deviceIdentifier)) {\n                            discoveredDevices.set(deviceIdentifier, device);\n                            discoveredCallback?.(device);\n                        }\n                    },\n                    timeoutSeconds,\n                );\n            }),\n        );\n\n        // The final answer only consists the devices still left, so expired ones will be excluded\n        const finalDiscoveredDevices = new Map<string, CommissionableDevice>();\n        scanners.forEach(scanner => {\n            const devices = scanner.getDiscoveredCommissionableDevices(identifier);\n            devices.forEach(device => {\n                const { deviceIdentifier } = device;\n                if (!discoveredDevices.has(deviceIdentifier)) {\n                    discoveredDevices.set(deviceIdentifier, device);\n                    discoveredCallback?.(device);\n                }\n                if (!finalDiscoveredDevices.has(deviceIdentifier)) {\n                    finalDiscoveredDevices.set(deviceIdentifier, device);\n                }\n            });\n        });\n\n        return Array.from(finalDiscoveredDevices.values());\n    }\n\n    static async discoverOperationalDevice(\n        fabric: Fabric,\n        peerNodeId: NodeId,\n        scanner: MdnsScanner,\n        timeoutSeconds?: number,\n        ignoreExistingRecords?: boolean,\n    ): Promise<OperationalDevice> {\n        const foundDevice = await scanner.findOperationalDevice(\n            fabric,\n            peerNodeId,\n            timeoutSeconds,\n            ignoreExistingRecords,\n        );\n        if (foundDevice === undefined) {\n            throw new DiscoveryError(\n                \"The operational device cannot be found on the network. Please make sure it is online.\",\n            );\n        }\n        return foundDevice;\n    }\n\n    static cancelOperationalDeviceDiscovery(fabric: Fabric, peerNodeId: NodeId, scanner: MdnsScanner) {\n        scanner.cancelOperationalDeviceDiscovery(fabric, peerNodeId);\n    }\n\n    static cancelCommissionableDeviceDiscovery(scanner: Scanner, identifier: CommissionableDeviceIdentifiers = {}) {\n        scanner.cancelCommissionableDeviceDiscovery(identifier);\n    }\n\n    /**\n     * Helper method to iterate through a list of server addresses and try to execute a method on each of them. If the\n     * method throws a configurable error (or EHOSTUNREACH), the server address list is updated (to also add later\n     * discovered addresses or devices) and then next server address is tried.The result of the first successful method\n     * call is returned. The logic makes sure to only try each unique address (IP/port) once.\n     */\n    static async iterateServerAddresses<DD extends DiscoverableDevice<any>, T, E extends Error>(\n        devices: DD[],\n        errorType: ClassExtends<E>,\n        updateDevicesFunc: () => Promise<DD[]>,\n        func: (address: AddressTypeFromDevice<DD>, device?: DD) => Promise<T>,\n        lastKnownAddress?: AddressTypeFromDevice<DD>,\n    ): Promise<{ result: T; resultAddress: AddressTypeFromDevice<DD>; resultDevice?: DD }> {\n        const processOneAddress = async (\n            address: AddressTypeFromDevice<DD>,\n            device?: DD,\n        ): Promise<{ result: T; resultAddress: AddressTypeFromDevice<DD>; resultDevice?: DD } | undefined> => {\n            const serverKey = serverAddressToString(address);\n\n            logger.debug(`Try to communicate with ${serverKey} ...`);\n            try {\n                return { result: await func(address, device), resultAddress: address, resultDevice: device };\n            } catch (error) {\n                if (error instanceof errorType || (error instanceof Error && error.message.includes(\"EHOSTUNREACH\"))) {\n                    logger.debug(`Failed to communicate with ${serverKey}, try other servers ...`, error);\n                } else {\n                    throw error;\n                }\n            }\n        };\n\n        const addresses = new Map<string, { address: AddressTypeFromDevice<DD>; device?: DD }>();\n\n        devices.forEach(device =>\n            device.addresses.forEach(address => addresses.set(serverAddressToString(address), { address, device })),\n        );\n        const triedAddresses = new Set<string>();\n\n        if (lastKnownAddress !== undefined) {\n            const knownKey = serverAddressToString(lastKnownAddress);\n            const knownDevice = addresses.has(serverAddressToString(lastKnownAddress))\n                ? addresses.get(knownKey)?.device\n                : undefined;\n            addresses.delete(knownKey);\n            const result = await processOneAddress(lastKnownAddress, knownDevice);\n            if (result !== undefined) {\n                return result;\n            }\n            triedAddresses.add(knownKey);\n        }\n\n        while (true) {\n            logger.debug(\n                `Server addresses to try: ${Array.from(addresses)\n                    .map(([addressString, { device }]) => `${device?.DN}: ${addressString}`)\n                    .join(\",\")}`,\n            );\n\n            let triedOne = false;\n            for (const { address, device } of addresses.values()) {\n                const serverKey = serverAddressToString(address);\n                if (triedAddresses.has(serverKey)) continue;\n                triedAddresses.add(serverKey);\n\n                try {\n                    triedOne = true;\n                    const result = await processOneAddress(address, device);\n                    if (result !== undefined) {\n                        return result;\n                    }\n                } catch (error) {\n                    if (\n                        error instanceof errorType ||\n                        (error instanceof Error && error.message.includes(\"EHOSTUNREACH\"))\n                    ) {\n                        logger.debug(`Failed to communicate with ${serverKey}, try next server ...`, error);\n                    } else {\n                        throw error;\n                    }\n                }\n            }\n            if (triedOne) {\n                (await updateDevicesFunc()).forEach(device =>\n                    device.addresses.forEach(address =>\n                        addresses.set(serverAddressToString(address), { address, device }),\n                    ),\n                ); // Update list and add new\n            } else {\n                throw new PairRetransmissionLimitReachedError(`Failed to connect on any discovered server`);\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
