{
  "version": 3,
  "sources": ["../../src/MatterController.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Important note: This file is part of the legacy matter-node (internal) API and should not be used anymore directly!\n * Please use the new API classes!\n * @deprecated\n */\n\nimport { NodeCommissioningOptions } from \"./CommissioningController.js\";\nimport { Ble } from \"./ble/Ble.js\";\nimport { RootCertificateManager } from \"./certificate/RootCertificateManager.js\";\nimport { ClusterClient } from \"./cluster/client/ClusterClient.js\";\nimport { GeneralCommissioning } from \"./cluster/definitions/GeneralCommissioningCluster.js\";\nimport { Channel } from \"./common/Channel.js\";\nimport { ImplementationError, NoProviderError } from \"./common/MatterError.js\";\nimport { CommissionableDevice, DiscoveryData, Scanner } from \"./common/Scanner.js\";\nimport { ServerAddress, ServerAddressIp, serverAddressToString } from \"./common/ServerAddress.js\";\nimport { CRYPTO_SYMMETRIC_KEY_LENGTH, Crypto } from \"./crypto/Crypto.js\";\nimport { CaseAuthenticatedTag } from \"./datatype/CaseAuthenticatedTag.js\";\nimport { EndpointNumber } from \"./datatype/EndpointNumber.js\";\nimport { FabricId } from \"./datatype/FabricId.js\";\nimport { FabricIndex } from \"./datatype/FabricIndex.js\";\nimport { NodeId } from \"./datatype/NodeId.js\";\nimport { VendorId } from \"./datatype/VendorId.js\";\nimport { Fabric, FabricBuilder, FabricJsonObject } from \"./fabric/Fabric.js\";\nimport { Logger } from \"./log/Logger.js\";\nimport { MdnsScanner } from \"./mdns/MdnsScanner.js\";\nimport { Specification } from \"./model/definitions/Specification.js\";\nimport { NetInterface } from \"./net/NetInterface.js\";\nimport { ChannelManager, NoChannelError } from \"./protocol/ChannelManager.js\";\nimport {\n    CommissioningError,\n    CommissioningOptions,\n    CommissioningSuccessfullyFinished,\n    ControllerCommissioner,\n} from \"./protocol/ControllerCommissioner.js\";\nimport { ControllerDiscovery, DiscoveryError } from \"./protocol/ControllerDiscovery.js\";\nimport { ExchangeManager, ExchangeProvider, MessageChannel } from \"./protocol/ExchangeManager.js\";\nimport { RetransmissionLimitReachedError } from \"./protocol/MessageExchange.js\";\nimport { InteractionClient } from \"./protocol/interaction/InteractionClient.js\";\nimport { SECURE_CHANNEL_PROTOCOL_ID } from \"./protocol/securechannel/SecureChannelMessages.js\";\nimport { StatusReportOnlySecureChannelProtocol } from \"./protocol/securechannel/SecureChannelProtocol.js\";\nimport { TypeFromPartialBitSchema } from \"./schema/BitmapSchema.js\";\nimport { DiscoveryCapabilitiesBitmap } from \"./schema/PairingCodeSchema.js\";\nimport {\n    SESSION_ACTIVE_INTERVAL_MS,\n    SESSION_ACTIVE_THRESHOLD_MS,\n    SESSION_IDLE_INTERVAL_MS,\n    SessionParameters,\n} from \"./session/Session.js\";\nimport { ResumptionRecord, SessionManager } from \"./session/SessionManager.js\";\nimport { CaseClient } from \"./session/case/CaseClient.js\";\nimport { PaseClient } from \"./session/pase/PaseClient.js\";\nimport { StorageBackendMemory } from \"./storage/StorageBackendMemory.js\";\nimport { StorageContext } from \"./storage/StorageContext.js\";\nimport { StorageManager } from \"./storage/StorageManager.js\";\nimport { SupportedStorageTypes } from \"./storage/StringifyTools.js\";\nimport { Time, Timer } from \"./time/Time.js\";\nimport { TlvEnum } from \"./tlv/TlvNumber.js\";\nimport { TlvField, TlvObject } from \"./tlv/TlvObject.js\";\nimport { TypeFromSchema } from \"./tlv/TlvSchema.js\";\nimport { TlvString } from \"./tlv/TlvString.js\";\nimport { ByteArray } from \"./util/ByteArray.js\";\nimport { Construction } from \"./util/Construction.js\";\nimport { isIPv6 } from \"./util/Ip.js\";\nimport { anyPromise, createPromise } from \"./util/Promises.js\";\n\nconst TlvCommissioningSuccessFailureResponse = TlvObject({\n    /** Contain the result of the operation. */\n    errorCode: TlvField(0, TlvEnum<GeneralCommissioning.CommissioningError>()),\n\n    /** Should help developers in troubleshooting errors. The value MAY go into logs or crash reports, not User UIs. */\n    debugText: TlvField(1, TlvString.bound({ maxLength: 128 })),\n});\nexport type CommissioningSuccessFailureResponse = TypeFromSchema<typeof TlvCommissioningSuccessFailureResponse>;\n\nexport type CommissionedNodeDetails = {\n    operationalServerAddress?: ServerAddressIp;\n    discoveryData?: DiscoveryData;\n    basicInformationData?: Record<string, SupportedStorageTypes>;\n};\n\nconst DEFAULT_FABRIC_INDEX = FabricIndex(1);\nconst DEFAULT_FABRIC_ID = FabricId(1);\nconst DEFAULT_ADMIN_VENDOR_ID = VendorId(0xfff1);\n\nconst RECONNECTION_POLLING_INTERVAL = 10 * 60 * 1000; // 10 minutes\n\nconst CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE = 3;\nconst CONTROLLER_MAX_PATHS_PER_INVOKE = 10;\n\nconst logger = Logger.get(\"MatterController\");\n\n/**\n * Special Error instance used to detect if the retransmission limit was reached during pairing for case or pase.\n * Mainly means that the device was not responding to the pairing request.\n */\nexport class PairRetransmissionLimitReachedError extends RetransmissionLimitReachedError {}\n\nexport class MatterController {\n    public static async create(options: {\n        sessionStorage: StorageContext;\n        rootCertificateStorage: StorageContext;\n        fabricStorage: StorageContext;\n        nodesStorage: StorageContext;\n        mdnsScanner: MdnsScanner;\n        netInterfaceIpv4: NetInterface | undefined;\n        netInterfaceIpv6: NetInterface;\n        sessionClosedCallback?: (peerNodeId: NodeId) => void;\n        adminVendorId?: VendorId;\n        adminFabricId?: FabricId;\n        adminFabricIndex?: FabricIndex;\n        caseAuthenticatedTags?: CaseAuthenticatedTag[];\n    }): Promise<MatterController> {\n        const {\n            sessionStorage,\n            rootCertificateStorage,\n            fabricStorage,\n            nodesStorage,\n            mdnsScanner,\n            netInterfaceIpv4,\n            netInterfaceIpv6,\n            sessionClosedCallback,\n            adminVendorId = VendorId(DEFAULT_ADMIN_VENDOR_ID),\n            adminFabricId = FabricId(DEFAULT_FABRIC_ID),\n            adminFabricIndex = FabricIndex(DEFAULT_FABRIC_INDEX),\n            caseAuthenticatedTags,\n        } = options;\n\n        const certificateManager = await RootCertificateManager.create(rootCertificateStorage);\n\n        let controller: MatterController;\n        // Check if we have a fabric stored in the storage, if yes initialize this one, else build a new one\n        if (await fabricStorage.has(\"fabric\")) {\n            const fabric = Fabric.createFromStorageObject(await fabricStorage.get<FabricJsonObject>(\"fabric\"));\n            controller = new MatterController({\n                sessionStorage,\n                fabricStorage,\n                nodesStorage,\n                mdnsScanner,\n                netInterfaceIpv4,\n                netInterfaceIpv6,\n                certificateManager,\n                fabric,\n                adminVendorId: fabric.rootVendorId,\n                sessionClosedCallback,\n            });\n        } else {\n            const rootNodeId = NodeId.randomOperationalNodeId();\n            const ipkValue = Crypto.getRandomData(CRYPTO_SYMMETRIC_KEY_LENGTH);\n            const fabricBuilder = new FabricBuilder()\n                .setRootCert(certificateManager.rootCert)\n                .setRootNodeId(rootNodeId)\n                .setIdentityProtectionKey(ipkValue)\n                .setRootVendorId(adminVendorId);\n            fabricBuilder.setOperationalCert(\n                certificateManager.generateNoc(\n                    fabricBuilder.publicKey,\n                    adminFabricId,\n                    rootNodeId,\n                    caseAuthenticatedTags,\n                ),\n            );\n            const fabric = await fabricBuilder.build(adminFabricIndex);\n\n            controller = new MatterController({\n                sessionStorage,\n                fabricStorage,\n                nodesStorage,\n                mdnsScanner,\n                netInterfaceIpv4,\n                netInterfaceIpv6,\n                certificateManager,\n                fabric,\n                adminVendorId,\n                sessionClosedCallback,\n            });\n        }\n        await controller.construction;\n        return controller;\n    }\n\n    public static async createAsPaseCommissioner(options: {\n        rootCertificateData: RootCertificateManager.Data;\n        fabricData: FabricJsonObject;\n        mdnsScanner?: MdnsScanner;\n        netInterfaceIpv4?: NetInterface | undefined;\n        netInterfaceIpv6?: NetInterface;\n        sessionClosedCallback?: (peerNodeId: NodeId) => void;\n    }): Promise<MatterController> {\n        const {\n            rootCertificateData,\n            fabricData,\n            mdnsScanner,\n            netInterfaceIpv4,\n            netInterfaceIpv6,\n            sessionClosedCallback,\n        } = options;\n\n        // Verify BLE initialization\n        try {\n            Ble.get();\n        } catch (error) {\n            NoProviderError.accept(error);\n\n            if (!mdnsScanner || !netInterfaceIpv6) {\n                throw new ImplementationError(\n                    \"Ble must be initialized to create a Sub Commissioner without an IP network!\",\n                );\n            }\n            logger.info(\"BLE is not enabled. Using only IP network for commissioning.\");\n        }\n\n        const certificateManager = await RootCertificateManager.create(rootCertificateData);\n\n        // Stored data are temporary anyway and no node will be connected, so just use an in-memory storage\n        const storageManager = new StorageManager(new StorageBackendMemory());\n        await storageManager.initialize();\n        const sessionStorage = storageManager.createContext(\"sessions\");\n        const nodesStorage = storageManager.createContext(\"nodes\");\n\n        const fabric = Fabric.createFromStorageObject(fabricData);\n        // Check if we have a fabric stored in the storage, if yes initialize this one, else build a new one\n        const controller = new MatterController({\n            sessionStorage,\n            nodesStorage,\n            mdnsScanner,\n            netInterfaceIpv4,\n            netInterfaceIpv6,\n            certificateManager,\n            fabric,\n            adminVendorId: fabric.rootVendorId,\n            sessionClosedCallback,\n        });\n        await controller.construction;\n        return controller;\n    }\n\n    readonly sessionManager: SessionManager<MatterController>;\n    private readonly channelManager = new ChannelManager(CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE);\n    private readonly exchangeManager: ExchangeManager<MatterController>;\n    private readonly paseClient = new PaseClient();\n    private readonly caseClient = new CaseClient();\n    private netInterfaceBle: NetInterface | undefined;\n    private bleScanner: Scanner | undefined;\n    private readonly commissionedNodes = new Map<NodeId, CommissionedNodeDetails>();\n    #construction: Construction<MatterController>;\n\n    readonly sessionStorage: StorageContext;\n    readonly fabricStorage?: StorageContext;\n    readonly nodesStorage: StorageContext;\n    private readonly mdnsScanner: MdnsScanner | undefined;\n    private readonly netInterfaceIpv4: NetInterface | undefined;\n    private readonly netInterfaceIpv6: NetInterface | undefined;\n    private readonly certificateManager: RootCertificateManager;\n    private readonly fabric: Fabric;\n    private readonly adminVendorId: VendorId;\n    private readonly sessionClosedCallback?: (peerNodeId: NodeId) => void;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    constructor(options: {\n        sessionStorage: StorageContext;\n        fabricStorage?: StorageContext;\n        nodesStorage: StorageContext;\n        mdnsScanner?: MdnsScanner;\n        netInterfaceIpv4?: NetInterface;\n        netInterfaceIpv6?: NetInterface;\n        certificateManager: RootCertificateManager;\n        fabric: Fabric;\n        adminVendorId: VendorId;\n        sessionClosedCallback?: (peerNodeId: NodeId) => void;\n    }) {\n        const {\n            sessionStorage,\n            fabricStorage,\n            nodesStorage,\n            mdnsScanner,\n            netInterfaceIpv4,\n            netInterfaceIpv6,\n            certificateManager,\n            fabric,\n            sessionClosedCallback,\n            adminVendorId,\n        } = options;\n        this.sessionStorage = sessionStorage;\n        this.fabricStorage = fabricStorage;\n        this.nodesStorage = nodesStorage;\n        this.mdnsScanner = mdnsScanner;\n        this.netInterfaceIpv4 = netInterfaceIpv4;\n        this.netInterfaceIpv6 = netInterfaceIpv6;\n        this.certificateManager = certificateManager;\n        this.fabric = fabric;\n        this.sessionClosedCallback = sessionClosedCallback;\n        this.adminVendorId = adminVendorId;\n\n        this.sessionManager = new SessionManager(this, sessionStorage);\n        this.sessionManager.sessionClosed.on(async session => {\n            if (!session.closingAfterExchangeFinished) {\n                // Delayed closing is executed when exchange is closed\n                await this.exchangeManager.closeSession(session);\n            }\n            this.sessionClosedCallback?.(session.peerNodeId);\n        });\n\n        this.exchangeManager = new ExchangeManager<MatterController>(this.sessionManager, this.channelManager);\n        this.exchangeManager.addProtocolHandler(new StatusReportOnlySecureChannelProtocol());\n\n        if (netInterfaceIpv4 !== undefined) {\n            this.addTransportInterface(netInterfaceIpv4);\n        }\n        if (netInterfaceIpv6 !== undefined) {\n            this.addTransportInterface(netInterfaceIpv6);\n        }\n\n        this.#construction = Construction(this, async () => {\n            // If controller has a stored operational server address, use it, irrelevant what was passed in the constructor\n            if (await this.nodesStorage.has(\"commissionedNodes\")) {\n                const commissionedNodes =\n                    await this.nodesStorage.get<[NodeId, CommissionedNodeDetails][]>(\"commissionedNodes\");\n                this.commissionedNodes.clear();\n                for (const [nodeId, details] of commissionedNodes) {\n                    this.commissionedNodes.set(nodeId, details);\n                }\n            }\n\n            await this.sessionManager.initFromStorage([this.fabric]);\n        });\n    }\n\n    get nodeId() {\n        return this.fabric.rootNodeId;\n    }\n\n    get rootCertificateData() {\n        return this.certificateManager.data;\n    }\n\n    get fabricData() {\n        return this.fabric.toStorageObject();\n    }\n\n    /** Returns our default session parameters for us as a controller. */\n    get sessionParameters(): SessionParameters {\n        return {\n            idleIntervalMs: SESSION_IDLE_INTERVAL_MS,\n            activeIntervalMs: SESSION_ACTIVE_INTERVAL_MS,\n            activeThresholdMs: SESSION_ACTIVE_THRESHOLD_MS,\n            dataModelRevision: Specification.DATA_MODEL_REVISION,\n            interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,\n            specificationVersion: Specification.SPECIFICATION_VERSION,\n            maxPathsPerInvoke: CONTROLLER_MAX_PATHS_PER_INVOKE,\n        };\n    }\n\n    public addTransportInterface(netInterface: NetInterface) {\n        this.exchangeManager.addTransportInterface(netInterface);\n    }\n\n    public collectScanners(\n        discoveryCapabilities: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap> = { onIpNetwork: true },\n    ) {\n        const scannersToUse = new Array<Scanner>();\n\n        if (this.mdnsScanner !== undefined) {\n            scannersToUse.push(this.mdnsScanner); // Scan always on IP Network if available\n        }\n\n        if (discoveryCapabilities.ble) {\n            if (this.bleScanner === undefined) {\n                let ble: Ble;\n                try {\n                    ble = Ble.get();\n                    this.netInterfaceBle = ble.getBleCentralInterface();\n                    this.addTransportInterface(this.netInterfaceBle);\n\n                    this.bleScanner = ble.getBleScanner();\n                } catch (error) {\n                    NoProviderError.accept(error);\n\n                    logger.warn(\"BLE is not supported on this platform. The device to commission might not be found!\");\n                }\n            }\n            // If we have an BLE Scanner then we use it\n            if (this.bleScanner !== undefined) {\n                scannersToUse.push(this.bleScanner);\n            }\n        }\n        return scannersToUse;\n    }\n\n    /**\n     * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first\n     * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after\n     * each other. It returns the NodeId of the commissioned device.\n     * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing\n     * request or the passode did not match to any discovered device/address.\n     *\n     * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and\n     * to complete the commissioning process.\n     * Return true when the commissioning process is completed successfully, false on error.\n     */\n    async commission(\n        options: NodeCommissioningOptions,\n        completeCommissioningCallback?: (peerNodeId: NodeId, discoveryData?: DiscoveryData) => Promise<boolean>,\n    ): Promise<NodeId> {\n        const {\n            commissioning: commissioningOptions = {\n                regulatoryLocation: GeneralCommissioning.RegulatoryLocationType.Outdoor, // Set to the most restrictive if relevant\n                regulatoryCountryCode: \"XX\",\n            },\n            discovery: { timeoutSeconds = 30 },\n            passcode,\n        } = options;\n        const commissionableDevice =\n            \"commissionableDevice\" in options.discovery ? options.discovery.commissionableDevice : undefined;\n        let {\n            discovery: { discoveryCapabilities = {}, knownAddress },\n        } = options;\n        let identifierData = \"identifierData\" in options.discovery ? options.discovery.identifierData : {};\n\n        if (this.mdnsScanner !== undefined && this.netInterfaceIpv6 !== undefined) {\n            discoveryCapabilities.onIpNetwork = true; // We always discover on network as defined by specs\n        }\n        if (commissionableDevice !== undefined) {\n            let { addresses } = commissionableDevice;\n            if (discoveryCapabilities.ble === true) {\n                discoveryCapabilities = { onIpNetwork: true, ble: addresses.some(address => address.type === \"ble\") };\n            } else if (discoveryCapabilities.onIpNetwork === true) {\n                // do not use BLE if not specified, even if existing\n                addresses = addresses.filter(address => address.type !== \"ble\");\n            }\n            addresses.sort(a => (a.type === \"udp\" ? -1 : 1)); // Sort addresses to use UDP first\n            knownAddress = addresses[0];\n            if (\"instanceId\" in commissionableDevice && commissionableDevice.instanceId !== undefined) {\n                // it is an UDP discovery\n                identifierData = { instanceId: commissionableDevice.instanceId as string };\n            } else {\n                identifierData = { longDiscriminator: commissionableDevice.D };\n            }\n        }\n\n        const scannersToUse = this.collectScanners(discoveryCapabilities);\n\n        logger.info(\n            `Commissioning device with identifier ${Logger.toJSON(identifierData)} and ${\n                scannersToUse.length\n            } scanners and knownAddress ${Logger.toJSON(knownAddress)}`,\n        );\n\n        // If we have a known address we try this first before we discover the device\n        let paseSecureChannel: MessageChannel<MatterController> | undefined;\n        let discoveryData: DiscoveryData | undefined;\n\n        // If we have a last known address, try this first\n        if (knownAddress !== undefined) {\n            try {\n                paseSecureChannel = await this.initializePaseSecureChannel(knownAddress, passcode);\n            } catch (error) {\n                RetransmissionLimitReachedError.accept(error);\n            }\n        }\n        if (paseSecureChannel === undefined) {\n            const discoveredDevices = await ControllerDiscovery.discoverDeviceAddressesByIdentifier(\n                scannersToUse,\n                identifierData,\n                timeoutSeconds,\n            );\n\n            const { result } = await ControllerDiscovery.iterateServerAddresses(\n                discoveredDevices,\n                RetransmissionLimitReachedError,\n                async () =>\n                    scannersToUse.flatMap(scanner => scanner.getDiscoveredCommissionableDevices(identifierData)),\n                async (address, device) => {\n                    const channel = await this.initializePaseSecureChannel(address, passcode, device);\n                    discoveryData = device;\n                    return channel;\n                },\n            );\n\n            // Pairing was successful, so store the address and assign the established secure channel\n            paseSecureChannel = result;\n        }\n\n        return await this.commissionDevice(\n            paseSecureChannel,\n            commissioningOptions,\n            discoveryData,\n            completeCommissioningCallback,\n        );\n    }\n\n    async disconnect(nodeId: NodeId) {\n        await this.sessionManager.removeAllSessionsForNode(nodeId, true);\n        await this.channelManager.removeAllNodeChannels(this.fabric, nodeId);\n    }\n\n    async removeNode(nodeId: NodeId) {\n        logger.info(`Removing commissioned node ${nodeId} from controller.`);\n        await this.sessionManager.removeAllSessionsForNode(nodeId);\n        await this.sessionManager.removeResumptionRecord(nodeId);\n        await this.channelManager.removeAllNodeChannels(this.fabric, nodeId);\n        this.commissionedNodes.delete(nodeId);\n        await this.storeCommissionedNodes();\n    }\n\n    /**\n     * Method to start commission process with a PASE pairing.\n     * If this not successful and throws an RetransmissionLimitReachedError the address is invalid or the passcode\n     * is wrong.\n     */\n    private async initializePaseSecureChannel(\n        address: ServerAddress,\n        passcode: number,\n        device?: CommissionableDevice,\n    ): Promise<MessageChannel<MatterController>> {\n        let paseChannel: Channel<ByteArray>;\n        if (device !== undefined) {\n            logger.info(`Commissioning device`, MdnsScanner.discoveryDataDiagnostics(device));\n        }\n        if (address.type === \"udp\") {\n            const { ip } = address;\n\n            const isIpv6Address = isIPv6(ip);\n            const paseInterface = isIpv6Address ? this.netInterfaceIpv6 : this.netInterfaceIpv4;\n            if (paseInterface === undefined) {\n                // mainly IPv6 address when IPv4 is disabled\n                throw new PairRetransmissionLimitReachedError(\n                    `IPv${isIpv6Address ? \"6\" : \"4\"} interface not initialized. Cannot use ${ip} for commissioning.`,\n                );\n            }\n            paseChannel = await paseInterface.openChannel(address);\n        } else {\n            if (this.netInterfaceBle === undefined) {\n                throw new PairRetransmissionLimitReachedError(\n                    `BLE interface not initialized. Cannot use ${address.peripheralAddress} for commissioning.`,\n                );\n            }\n            // TODO Have a Timeout mechanism here for connections\n            paseChannel = await this.netInterfaceBle.openChannel(address);\n        }\n\n        // Do PASE paring\n        const unsecureSession = this.sessionManager.createUnsecureSession({\n            // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks\n            sessionParameters: {\n                idleIntervalMs: device?.SII,\n                activeIntervalMs: device?.SAI,\n                activeThresholdMs: device?.SAT,\n            },\n            isInitiator: true,\n        });\n        const paseUnsecureMessageChannel = new MessageChannel(paseChannel, unsecureSession);\n        const paseExchange = this.exchangeManager.initiateExchangeWithChannel(\n            paseUnsecureMessageChannel,\n            SECURE_CHANNEL_PROTOCOL_ID,\n        );\n\n        let paseSecureSession;\n        try {\n            paseSecureSession = await this.paseClient.pair(this, paseExchange, passcode);\n        } catch (e) {\n            // Close the exchange and rethrow\n            await paseExchange.close();\n            throw e;\n        }\n\n        await unsecureSession.destroy();\n        return new MessageChannel(paseChannel, paseSecureSession);\n    }\n\n    /**\n     * Method to commission a device with a PASE secure channel. It returns the NodeId of the commissioned device on\n     * success.\n     */\n    private async commissionDevice(\n        paseSecureMessageChannel: MessageChannel<MatterController>,\n        commissioningOptions: CommissioningOptions,\n        discoveryData?: DiscoveryData,\n        completeCommissioningCallback?: (peerNodeId: NodeId, discoveryData?: DiscoveryData) => Promise<boolean>,\n    ): Promise<NodeId> {\n        // TODO: Create the fabric only when needed before commissioning (to do when refactoring MatterController away)\n        // TODO also move certificateManager and other parts into that class to get rid of them here\n        // TODO Depending on the Error type during commissioning we can do a retry ...\n        /*\n            Whenever the Fail-Safe timer is armed, Commissioners and Administrators SHALL NOT consider any cluster\n            operation to have timed-out before waiting at least 30 seconds for a valid response from the cluster server.\n            Some commands and attributes with complex side-effects MAY require longer and have specific timing requirements\n            stated in their respective cluster specification.\n\n            In concurrent connection commissioning flow, the failure of any of the steps 2 through 10 SHALL result in the\n            Commissioner and Commissionee returning to step 2 (device discovery and commissioning channel establishment) and\n            repeating each step. The failure of any of the steps 11 through 15 in concurrent connection commissioning flow\n            SHALL result in the Commissioner and Commissionee returning to step 11 (configuration of operational network\n            information). In the case of failure of any of the steps 11 through 15 in concurrent connection commissioning\n            flow, the Commissioner and Commissionee SHALL reuse the existing PASE-derived encryption keys over the\n            commissioning channel and all steps up to and including step 10 are considered to have been successfully\n            completed.\n            In non-concurrent connection commissioning flow, the failure of any of the steps 2 through 15 SHALL result in\n            the Commissioner and Commissionee returning to step 2 (device discovery and commissioning channel establishment)\n            and repeating each step.\n\n            Commissioners that need to restart from step 2 MAY immediately expire the fail-safe by invoking the ArmFailSafe\n            command with an ExpiryLengthSeconds field set to 0. Otherwise, Commissioners will need to wait until the current\n            fail-safe timer has expired for the Commissionee to begin accepting PASE again.\n            In both concurrent connection commissioning flow and non-concurrent connection commissioning flow, the\n            Commissionee SHALL exit Commissioning Mode after 20 failed attempts.\n         */\n\n        const peerNodeId = commissioningOptions.nodeId ?? NodeId.randomOperationalNodeId();\n        const commissioningManager = new ControllerCommissioner(\n            // Use the created secure session to do the commissioning\n            new InteractionClient(new ExchangeProvider(this.exchangeManager, paseSecureMessageChannel), peerNodeId),\n            this.certificateManager,\n            this.fabric,\n            commissioningOptions,\n            peerNodeId,\n            this.adminVendorId,\n            async () => {\n                // TODO Right now we always close after step 12 because we do not check for commissioning flow requirements\n                /*\n                    In concurrent connection commissioning flow the commissioning channel SHALL terminate after\n                    successful step 15 (CommissioningComplete command invocation). In non-concurrent connection\n                    commissioning flow the commissioning channel SHALL terminate after successful step 12 (trigger\n                    joining of operational network at Commissionee). The PASE-derived encryption keys SHALL be deleted\n                    when commissioning channel terminates. The PASE session SHALL be terminated by both Commissioner and\n                    Commissionee once the CommissioningComplete command is received by the Commissionee.\n                 */\n                await paseSecureMessageChannel.close(); // We reconnect using Case, so close PASE connection\n\n                if (completeCommissioningCallback !== undefined) {\n                    if (!(await completeCommissioningCallback(peerNodeId, discoveryData))) {\n                        throw new RetransmissionLimitReachedError(\"Device could not be discovered\");\n                    }\n                    throw new CommissioningSuccessfullyFinished();\n                }\n                // Look for the device broadcast over MDNS and do CASE pairing\n                return await this.connect(peerNodeId, 120, discoveryData); // Wait maximum 120s to find the operational device for commissioning process\n            },\n        );\n\n        try {\n            await commissioningManager.executeCommissioning();\n        } catch (error) {\n            if (this.commissionedNodes.has(peerNodeId)) {\n                // We might have added data for an operational address that we need to cleanup\n                this.commissionedNodes.delete(peerNodeId);\n            }\n            throw error;\n        }\n\n        await this.fabricStorage?.set(\"fabric\", this.fabric.toStorageObject());\n\n        return peerNodeId;\n    }\n\n    /**\n     * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.\n     */\n    async completeCommissioning(peerNodeId: NodeId, discoveryData?: DiscoveryData) {\n        // Look for the device broadcast over MDNS and do CASE pairing\n        const interactionClient = await this.connect(peerNodeId, 120, discoveryData); // Wait maximum 120s to find the operational device for commissioning process\n        const generalCommissioningClusterClient = ClusterClient(\n            GeneralCommissioning.Cluster,\n            EndpointNumber(0),\n            interactionClient,\n        );\n        const { errorCode, debugText } = await generalCommissioningClusterClient.commissioningComplete(undefined, {\n            useExtendedFailSafeMessageResponseTimeout: true,\n        });\n        if (errorCode !== GeneralCommissioning.CommissioningError.Ok) {\n            if (this.commissionedNodes.has(peerNodeId)) {\n                // We might have added data for an operational address that we need to cleanup\n                this.commissionedNodes.delete(peerNodeId);\n            }\n            throw new CommissioningError(`Commission error on commissioningComplete: ${errorCode}, ${debugText}`);\n        }\n        await this.fabricStorage?.set(\"fabric\", this.fabric.toStorageObject());\n    }\n\n    private async reconnectLastKnownAddress(\n        peerNodeId: NodeId,\n        operationalAddress: ServerAddressIp,\n        discoveryData?: DiscoveryData,\n    ): Promise<MessageChannel<MatterController> | undefined> {\n        const { ip, port } = operationalAddress;\n        try {\n            logger.debug(`Resume device connection to configured server at ${ip}:${port}`);\n            const channel = await this.pair(peerNodeId, operationalAddress, discoveryData);\n            await this.setOperationalDeviceData(peerNodeId, operationalAddress);\n            return channel;\n        } catch (error) {\n            if (\n                error instanceof RetransmissionLimitReachedError ||\n                (error instanceof Error && error.message.includes(\"EHOSTUNREACH\"))\n            ) {\n                logger.debug(`Failed to resume device connection with ${ip}:${port}, discover the device ...`, error);\n                return undefined;\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    private async connectOrDiscoverNode(\n        peerNodeId: NodeId,\n        operationalAddress?: ServerAddressIp,\n        timeoutSeconds?: number,\n        discoveryData?: DiscoveryData,\n    ) {\n        if (this.mdnsScanner === undefined) {\n            throw new ImplementationError(\"Cannot discover device without mDNS scanner.\");\n        }\n        const mdnsScanner = this.mdnsScanner;\n\n        const discoveryPromises = new Array<() => Promise<MessageChannel<MatterController>>>();\n\n        // Additionally to general discovery we also try to poll the formerly known operational address\n        let reconnectionPollingTimer: Timer | undefined;\n\n        if (operationalAddress !== undefined) {\n            const directReconnection = await this.reconnectLastKnownAddress(\n                peerNodeId,\n                operationalAddress,\n                discoveryData,\n            );\n            if (directReconnection !== undefined) {\n                return directReconnection;\n            }\n\n            if (timeoutSeconds === undefined) {\n                const { promise, resolver, rejecter } = createPromise<MessageChannel<MatterController>>();\n\n                reconnectionPollingTimer = Time.getPeriodicTimer(\n                    \"Controller reconnect\",\n                    RECONNECTION_POLLING_INTERVAL,\n                    async () => {\n                        try {\n                            logger.debug(`Polling for device at ${serverAddressToString(operationalAddress)} ...`);\n                            const result = await this.reconnectLastKnownAddress(\n                                peerNodeId,\n                                operationalAddress,\n                                discoveryData,\n                            );\n                            if (result !== undefined && reconnectionPollingTimer?.isRunning) {\n                                reconnectionPollingTimer?.stop();\n                                resolver(result);\n                            }\n                        } catch (error) {\n                            if (reconnectionPollingTimer?.isRunning) {\n                                reconnectionPollingTimer?.stop();\n                                rejecter(error);\n                            }\n                        }\n                    },\n                ).start();\n\n                discoveryPromises.push(() => promise);\n            }\n        }\n\n        discoveryPromises.push(async () => {\n            const scanResult = await ControllerDiscovery.discoverOperationalDevice(\n                this.fabric,\n                peerNodeId,\n                mdnsScanner,\n                timeoutSeconds,\n                timeoutSeconds === undefined,\n            );\n            if (reconnectionPollingTimer?.isRunning) {\n                reconnectionPollingTimer?.stop();\n            }\n\n            const { result } = await ControllerDiscovery.iterateServerAddresses(\n                [scanResult],\n                PairRetransmissionLimitReachedError,\n                async () => {\n                    const device = mdnsScanner.getDiscoveredOperationalDevice(this.fabric, peerNodeId);\n                    return device !== undefined ? [device] : [];\n                },\n                async (address, device) => {\n                    const result = await this.pair(peerNodeId, address, device);\n                    await this.setOperationalDeviceData(peerNodeId, address, {\n                        ...discoveryData,\n                        ...device,\n                    });\n                    return result;\n                },\n            );\n\n            return result;\n        });\n\n        return await anyPromise(discoveryPromises);\n    }\n\n    /**\n     * Resume a device connection and establish a CASE session that was previously paired with the controller. This\n     * method will try to connect to the device using the previously used server address (if set). If that fails, the\n     * device is discovered again using its operational instance details.\n     * It returns the operational MessageChannel on success.\n     */\n    private async resume(peerNodeId: NodeId, timeoutSeconds?: number, discoveryData?: DiscoveryData) {\n        const operationalAddress = this.getLastOperationalAddress(peerNodeId);\n\n        try {\n            return await this.connectOrDiscoverNode(peerNodeId, operationalAddress, timeoutSeconds, discoveryData);\n        } catch (error) {\n            if (\n                (error instanceof DiscoveryError || error instanceof PairRetransmissionLimitReachedError) &&\n                this.commissionedNodes.has(peerNodeId)\n            ) {\n                logger.info(`Resume failed, remove all sessions for node ${peerNodeId}`);\n                // We remove all sessions, this also informs the PairedNode class\n                await this.sessionManager.removeAllSessionsForNode(peerNodeId);\n            }\n            throw error;\n        }\n    }\n\n    /** Pair with an operational device (already commissioned) and establish a CASE session. */\n    private async pair(peerNodeId: NodeId, operationalServerAddress: ServerAddressIp, discoveryData?: DiscoveryData) {\n        const { ip, port } = operationalServerAddress;\n        // Do CASE pairing\n        const isIpv6Address = isIPv6(ip);\n        const operationalInterface = isIpv6Address ? this.netInterfaceIpv6 : this.netInterfaceIpv4;\n\n        if (operationalInterface === undefined) {\n            throw new PairRetransmissionLimitReachedError(\n                `IPv${\n                    isIpv6Address ? \"6\" : \"4\"\n                } interface not initialized for port ${port}. Cannot use ${ip} for pairing.`,\n            );\n        }\n\n        const operationalChannel = await operationalInterface.openChannel(operationalServerAddress);\n        const { sessionParameters } = this.findResumptionRecordByNodeId(peerNodeId) ?? {};\n        const unsecureSession = this.sessionManager.createUnsecureSession({\n            // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks\n            sessionParameters: {\n                idleIntervalMs: discoveryData?.SII ?? sessionParameters?.idleIntervalMs,\n                activeIntervalMs: discoveryData?.SAI ?? sessionParameters?.activeIntervalMs,\n                activeThresholdMs: discoveryData?.SAT ?? sessionParameters?.activeThresholdMs,\n            },\n            isInitiator: true,\n        });\n        const operationalUnsecureMessageExchange = new MessageChannel(operationalChannel, unsecureSession);\n        let operationalSecureSession;\n        try {\n            const exchange = this.exchangeManager.initiateExchangeWithChannel(\n                operationalUnsecureMessageExchange,\n                SECURE_CHANNEL_PROTOCOL_ID,\n            );\n\n            try {\n                operationalSecureSession = await this.caseClient.pair(this, exchange, this.fabric, peerNodeId);\n            } catch (e) {\n                await exchange.close();\n                throw e;\n            }\n        } catch (e) {\n            RetransmissionLimitReachedError.accept(e);\n\n            // Convert error\n            throw new PairRetransmissionLimitReachedError(e.message);\n        }\n        await unsecureSession.destroy();\n        const channel = new MessageChannel(operationalChannel, operationalSecureSession);\n        await this.channelManager.setChannel(this.fabric, peerNodeId, channel);\n        return channel;\n    }\n\n    isCommissioned() {\n        return this.commissionedNodes.size > 0;\n    }\n\n    getCommissionedNodes() {\n        return Array.from(this.commissionedNodes.keys());\n    }\n\n    getCommissionedNodesDetails() {\n        return Array.from(this.commissionedNodes.entries()).map(\n            ([nodeId, { operationalServerAddress, discoveryData, basicInformationData }]) => ({\n                nodeId,\n                operationalAddress: operationalServerAddress\n                    ? serverAddressToString(operationalServerAddress)\n                    : undefined,\n                advertisedName: discoveryData?.DN,\n                discoveryData,\n                basicInformationData,\n            }),\n        );\n    }\n\n    private async setOperationalDeviceData(\n        nodeId: NodeId,\n        operationalServerAddress: ServerAddressIp,\n        discoveryData?: DiscoveryData,\n    ) {\n        const nodeDetails = this.commissionedNodes.get(nodeId) ?? {};\n        nodeDetails.operationalServerAddress = operationalServerAddress;\n        if (discoveryData !== undefined) {\n            nodeDetails.discoveryData = {\n                ...nodeDetails.discoveryData,\n                ...discoveryData,\n            };\n        }\n        this.commissionedNodes.set(nodeId, nodeDetails);\n        await this.storeCommissionedNodes();\n    }\n\n    async enhanceCommissionedNodeDetails(\n        nodeId: NodeId,\n        data: { basicInformationData: Record<string, SupportedStorageTypes> },\n    ) {\n        const nodeDetails = this.commissionedNodes.get(nodeId);\n        if (nodeDetails === undefined) {\n            throw new Error(`Node ${nodeId} is not commissioned.`);\n        }\n        const { basicInformationData } = data;\n        nodeDetails.basicInformationData = basicInformationData;\n        this.commissionedNodes.set(nodeId, nodeDetails);\n        await this.storeCommissionedNodes();\n    }\n\n    private getLastOperationalAddress(nodeId: NodeId) {\n        return this.commissionedNodes.get(nodeId)?.operationalServerAddress;\n    }\n\n    private async storeCommissionedNodes() {\n        await this.nodesStorage.set(\"commissionedNodes\", Array.from(this.commissionedNodes.entries()));\n    }\n\n    /**\n     * Connect to the device by opening a channel and creating a new CASE session if necessary.\n     * Returns a InteractionClient on success.\n     */\n    async connect(peerNodeId: NodeId, timeoutSeconds?: number, discoveryData?: DiscoveryData) {\n        if (discoveryData == undefined) {\n            discoveryData = this.commissionedNodes.get(peerNodeId)?.discoveryData;\n        }\n\n        let channel: MessageChannel<any>;\n        try {\n            channel = this.channelManager.getChannel(this.fabric, peerNodeId);\n        } catch (error) {\n            NoChannelError.accept(error);\n\n            channel = await this.resume(peerNodeId, timeoutSeconds, discoveryData);\n        }\n        return new InteractionClient(\n            new ExchangeProvider(this.exchangeManager, channel, async () => {\n                await this.channelManager.removeAllNodeChannels(this.fabric, peerNodeId);\n                await this.resume(peerNodeId, 60); // Channel reconnection only waits limited time\n                return this.channelManager.getChannel(this.fabric, peerNodeId);\n            }),\n            peerNodeId,\n        );\n    }\n\n    async getNextAvailableSessionId() {\n        return this.sessionManager.getNextAvailableSessionId();\n    }\n\n    getResumptionRecord(resumptionId: ByteArray) {\n        return this.sessionManager.findResumptionRecordById(resumptionId);\n    }\n\n    findResumptionRecordByNodeId(nodeId: NodeId) {\n        return this.sessionManager.findResumptionRecordByNodeId(nodeId);\n    }\n\n    async saveResumptionRecord(resumptionRecord: ResumptionRecord) {\n        return this.sessionManager.saveResumptionRecord(resumptionRecord);\n    }\n\n    announce() {\n        // nothing TODO maybe with UDC\n    }\n\n    async close() {\n        await this.exchangeManager.close();\n        await this.sessionManager.close();\n        await this.channelManager.close();\n        await this.netInterfaceBle?.close();\n        await this.netInterfaceIpv4?.close();\n        await this.netInterfaceIpv6?.close();\n    }\n\n    getActiveSessionInformation() {\n        return this.sessionManager.getActiveSessionInformation();\n    }\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
