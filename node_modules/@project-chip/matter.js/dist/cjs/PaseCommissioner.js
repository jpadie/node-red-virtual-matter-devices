"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PaseCommissioner_exports = {};
__export(PaseCommissioner_exports, {
  PaseCommissioner: () => PaseCommissioner
});
module.exports = __toCommonJS(PaseCommissioner_exports);
var import_MatterController = require("./MatterController.js");
var import_MatterError = require("./common/MatterError.js");
var import_MdnsService = require("./environment/MdnsService.js");
var import_Logger = require("./log/Logger.js");
var import_Network = require("./net/Network.js");
var import_UdpInterface = require("./net/UdpInterface.js");
var import_ControllerDiscovery = require("./protocol/ControllerDiscovery.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = new import_Logger.Logger("PaseCommissioner");
class PaseCommissioner {
  /**
   * Creates a new CommissioningController instance
   *
   * @param options The options for the CommissioningController
   */
  constructor(options) {
    this.options = options;
    if (options.environment === void 0) {
      throw new import_MatterError.ImplementationError("You need to prove an environment for the commissioner.");
    }
    const { environment } = options.environment;
    this.environment = environment;
  }
  environment;
  controllerInstance;
  get nodeId() {
    return this.controllerInstance?.nodeId;
  }
  assertControllerIsStarted(errorText) {
    if (this.controllerInstance === void 0) {
      throw new import_MatterError.ImplementationError(
        errorText ?? "Controller instance not yet started. Please call start() first."
      );
    }
    return this.controllerInstance;
  }
  /** Internal method to initialize a MatterController instance. */
  async initializeController() {
    if (this.controllerInstance !== void 0) {
      return this.controllerInstance;
    }
    const { localPort, listeningAddressIpv4, listeningAddressIpv6, rootCertificateData, fabricData } = this.options;
    let mdnsScanner;
    let ipv4Disabled = false;
    let netInterfaceIpv4;
    let netInterfaceIpv6;
    try {
      const mdnsService = await this.environment.load(import_MdnsService.MdnsService);
      ipv4Disabled = !mdnsService.enableIpv4;
      mdnsScanner = mdnsService.scanner;
      if (!ipv4Disabled) {
        netInterfaceIpv4 = await import_UdpInterface.UdpInterface.create(import_Network.Network.get(), "udp4", localPort, listeningAddressIpv4);
      }
      netInterfaceIpv6 = await import_UdpInterface.UdpInterface.create(import_Network.Network.get(), "udp6", localPort, listeningAddressIpv6);
    } catch {
      logger.debug("No networking available, using only BLE");
    }
    return await import_MatterController.MatterController.createAsPaseCommissioner({
      rootCertificateData,
      fabricData,
      netInterfaceIpv4,
      netInterfaceIpv6,
      mdnsScanner
    });
  }
  /**
   * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned node.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commissionNode(nodeOptions, completeCommissioningCallback) {
    const controller = this.assertControllerIsStarted();
    return await controller.commission(nodeOptions, completeCommissioningCallback);
  }
  /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */
  async close() {
    await this.controllerInstance?.close();
    this.controllerInstance = void 0;
  }
  /** Initialize the controller. */
  async start() {
    const runtime = this.environment.runtime;
    runtime.add(this);
    if (this.controllerInstance === void 0) {
      this.controllerInstance = await this.initializeController();
    }
  }
  cancelCommissionableDeviceDiscovery(identifierData, discoveryCapabilities) {
    const controller = this.assertControllerIsStarted();
    controller.collectScanners(discoveryCapabilities).forEach(
      (scanner) => import_ControllerDiscovery.ControllerDiscovery.cancelCommissionableDeviceDiscovery(scanner, identifierData)
    );
  }
  async discoverCommissionableDevices(identifierData, discoveryCapabilities, discoveredCallback, timeoutSeconds = 900) {
    const controller = this.assertControllerIsStarted();
    return await import_ControllerDiscovery.ControllerDiscovery.discoverCommissionableDevices(
      controller.collectScanners(discoveryCapabilities),
      timeoutSeconds,
      identifierData,
      discoveredCallback
    );
  }
}
//# sourceMappingURL=PaseCommissioner.js.map
