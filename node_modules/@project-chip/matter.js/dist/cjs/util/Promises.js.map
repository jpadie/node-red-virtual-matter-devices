{
  "version": 3,
  "sources": ["../../../src/util/Promises.ts"],
  "sourcesContent": ["/**\n * Utils for promises.\n *\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError, MatterError } from \"../common/MatterError.js\";\nimport { Time } from \"../time/Time.js\";\n\n/**\n * Obtain a promise with functions to resolve and reject.\n */\nexport function createPromise<T>(): {\n    promise: Promise<T>;\n    resolver: (value: T) => void;\n    rejecter: (reason?: any) => void;\n} {\n    let resolver, rejecter;\n    const promise = new Promise<T>((resolve, reject) => {\n        resolver = resolve;\n        rejecter = reject;\n    });\n\n    if (!resolver || !rejecter) {\n        // This doesn't happen but asserts that resolver and rejecter are defined.\n        throw new InternalError(\"Failed to extract resolve/reject from Promise context\");\n    }\n\n    return {\n        promise,\n        resolver,\n        rejecter,\n    };\n}\n\n/**\n * Use all promises or promise returning methods and return the first resolved promise or reject when all promises\n * rejected\n */\nexport function anyPromise<T>(promises: ((() => Promise<T>) | Promise<T>)[]): Promise<T> {\n    return new Promise((resolve, reject) => {\n        let numberRejected = 0;\n        let wasResolved = false;\n        for (const entry of promises) {\n            const promise = typeof entry === \"function\" ? entry() : entry;\n            promise\n                .then(value => {\n                    if (!wasResolved) {\n                        wasResolved = true;\n                        resolve(value);\n                    }\n                })\n                .catch(reason => {\n                    numberRejected++;\n                    if (!wasResolved && numberRejected === promises.length) {\n                        reject(reason);\n                    }\n                });\n        }\n    });\n}\n\n/**\n * Thrown when a timed promise times out.\n */\nexport class PromiseTimeoutError extends MatterError {\n    constructor(message = \"Operation timed out\") {\n        super(message);\n    }\n}\n\n/**\n * Create a promise with a timeout.\n *\n * By default rejects with {@link PromiseTimeoutError} on timeout but you can override by supplying {@link cancel}.\n *\n * @param timeoutMs the timeout in milliseconds\n * @param promise a promise that resolves or rejects when the timed task completes\n * @param cancel invoked on timeout (default implementation throws {@link PromiseTimeoutError})\n */\nexport async function withTimeout<T>(\n    timeoutMs: number,\n    promise: Promise<T>,\n    cancel?: AbortController | (() => void),\n): Promise<T> {\n    let cancelFn;\n    if (typeof cancel === \"function\") {\n        cancelFn = cancel;\n    } else if (typeof cancel?.abort === \"function\") {\n        cancelFn = () => cancel.abort();\n    } else {\n        cancelFn = () => {\n            throw new PromiseTimeoutError();\n        };\n    }\n\n    let cancelTimer: undefined | (() => void);\n\n    // Sub-promise 1, the timer\n    const timeout = new Promise<void>((resolve, reject) => {\n        const timer = Time.getTimer(\"promise-timeout\", timeoutMs, () => reject(cancelFn));\n\n        cancelTimer = () => {\n            timer.stop();\n            resolve();\n        };\n\n        timer.start();\n    });\n\n    let result: undefined | T;\n\n    // Sub-promise 2, captures result and cancels timer\n    const producer = promise.then(\n        r => {\n            cancelTimer?.();\n            result = r;\n        },\n        e => {\n            cancelTimer?.();\n            throw e;\n        },\n    );\n\n    // Output promise, resolves like input promise unless timed out\n    await Promise.all([timeout, producer]);\n\n    return result as T;\n}\n\n/**\n * Return type for functions that are optionally asynchronous.\n *\n * TODO - as currently defined MaybePromise of a Promise incorrectly wraps as a Promise of a Promise\n */\nexport type MaybePromise<T = void> = T | PromiseLike<T>;\n\n/**\n * Promise-like version of above.\n */\nexport type MaybePromiseLike<T = void> = T | PromiseLike<T>;\n\nexport const MaybePromise = {\n    /**\n     * Determine whether a {@link MaybePromiseLike} is a {@link Promise}.\n     */\n    is<T>(value: MaybePromise<T>): value is PromiseLike<T> {\n        // We cannot use isObject because this could collide with valid values here\n        return typeof value === \"object\" && value !== null && typeof (value as { then?: unknown }).then === \"function\";\n    },\n\n    /**\n     * Chained MaybePromise.  Invokes the resolve function immediately if the {@link MaybePromise} is not a\n     * {@link Promise}, otherwise the same as a normal {@link Promise.then}.\n     */\n    then<I, O1 = never, O2 = never>(\n        producer: MaybePromise<I> | (() => MaybePromise<I>),\n        resolve?: ((input: I) => MaybePromise<O1>) | null,\n        reject?: ((error: any) => MaybePromise<O2>) | null,\n    ): MaybePromise<O1 | O2> {\n        let rejected = false;\n\n        try {\n            let value;\n            if (producer instanceof Function) {\n                value = producer();\n            } else {\n                value = producer;\n            }\n            if (MaybePromise.is(value)) {\n                return value.then(\n                    resolve,\n                    reject\n                        ? error => {\n                              // If reject() is not async then we will catch rejection errors below but should not\n                              // reject again\n                              rejected = true;\n\n                              return reject?.(error);\n                          }\n                        : undefined,\n                );\n            }\n            if (resolve) {\n                return resolve(value);\n            }\n        } catch (e) {\n            if (reject && !rejected) {\n                return reject(e);\n            }\n            throw e;\n        }\n\n        // Make TypeScript happy\n        return undefined as MaybePromise<O1 | O2>;\n    },\n\n    /**\n     * Equivalent of {@link Promise.catch}.\n     */\n    catch<T, TResult = never>(\n        producer: MaybePromise<T> | (() => MaybePromise<T>),\n        onrejected?: ((reason: any) => MaybePromise<TResult>) | undefined | null,\n    ) {\n        return this.then(producer, undefined, onrejected);\n    },\n\n    /**\n     * Equivalent of {@link Promise.finally}.\n     */\n    finally<T>(\n        producer: MaybePromise<T> | (() => MaybePromise<T>),\n        onfinally?: (() => MaybePromise<void>) | undefined | null,\n    ): MaybePromise<T> {\n        let result: MaybePromise<T> | undefined;\n        try {\n            if (typeof producer === \"function\") {\n                result = (producer as () => MaybePromise<T>)();\n            } else {\n                result = producer;\n            }\n        } finally {\n            if (MaybePromise.is(result)) {\n                // Use native finally or fake via then\n                if (typeof (result as Promise<any>).finally === \"function\") {\n                    // TypeScript's types are wrong for finally, they specify the callback as () => void rather than\n                    // accepting a promise return.  TS itself somehow doesn't mind this because a function returning\n                    // something can be assigned to a promise returning void.\n                    //\n                    // The TS folks rationalize this here:\n                    //\n                    //      https://github.com/microsoft/TypeScript/issues/44980\n                    //\n                    // Eslint used to work around this sometimes (was never sure when or whether it was intentional) but\n                    // something broke when we updated typescript-eslint to 7.1.1.\n                    //\n                    // The eslint folks blow this off here.  Includes a comment referencing a TS playground that\n                    // demonstrates eslint behavior is incorrect:\n                    //\n                    //      https://github.com/typescript-eslint/typescript-eslint/issues/7276\n                    //\n                    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                    result = (result as Promise<T>).finally(onfinally);\n                } else {\n                    result = result.then(\n                        value =>\n                            MaybePromise.then(\n                                () => onfinally?.(),\n                                () => value,\n                            ),\n                        error =>\n                            MaybePromise.then(\n                                () => onfinally?.(),\n                                () => {\n                                    throw error;\n                                },\n                            ),\n                    );\n                }\n            } else {\n                // The only return value from onfinally that should affect results is a rejected promise, so if we\n                // receive a return value chain such that it either throws or we return the actual result\n                const finallyResult = onfinally?.();\n                if (MaybePromise.is(finallyResult)) {\n                    const actualResult = result as T;\n                    result = finallyResult.then(() => actualResult);\n                }\n            }\n        }\n        return result;\n    },\n\n    [Symbol.toStringTag]: \"MaybePromise\",\n};\n\nMaybePromise.toString = () => \"MaybePromise\";\n"],
  "mappings": "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",
  "names": []
}
