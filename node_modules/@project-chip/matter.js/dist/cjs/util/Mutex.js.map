{
  "version": 3,
  "sources": ["../../../src/util/Mutex.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Logger } from \"../log/Logger.js\";\n\nconst logger = Logger.get(\"Mutex\");\n\n/**\n * A mutex is a task queue where at most one task is active at a time.\n */\nexport class Mutex implements PromiseLike<unknown> {\n    #owner: {};\n    #cancel?: () => void;\n    #canceled = false;\n    #promise?: Promise<unknown>;\n\n    constructor(owner: {}, initial?: PromiseLike<unknown>) {\n        this.#owner = owner;\n        if (initial) {\n            this.run(() => initial);\n        }\n    }\n\n    /**\n     * As a PromiseLike, you can await the Mutex.  This promise resolves when current activity completes but the mutex\n     * may engage in another activity immediately thereafter.  So the mutex is not guaranteed to be available after an\n     * await.\n     */\n    then<TResult1 = void, TResult2 = never>(\n        onfulfilled?: ((value: unknown) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n    ): PromiseLike<TResult1 | TResult2> {\n        return (this.#promise || Promise.resolve()).then(onfulfilled, onrejected);\n    }\n\n    /**\n     * Enqueue additional work.\n     *\n     * If {@link task} is a function it runs when current activity completes.  If it is a promise then the mutex will\n     * not clear until {@link task} resolves.\n     */\n    run(task: PromiseLike<unknown> | (() => PromiseLike<unknown>), cancel?: () => void) {\n        if (this.#canceled) {\n            cancel?.();\n            return;\n        }\n\n        if (!this.#promise) {\n            this.#promise = this.initiateTask(task);\n        } else {\n            this.#promise = this.#promise.then(() => {\n                if (this.#canceled) {\n                    cancel?.();\n                    return;\n                }\n\n                this.#cancel = cancel;\n                return this.initiateTask(task).finally(() => {\n                    this.#cancel = undefined;\n                });\n            });\n        }\n    }\n\n    /**\n     * Cancel remaining work and perform one last task with the Mutex held.\n     */\n    terminate(cleanup?: () => PromiseLike<void>) {\n        if (this.#canceled) {\n            return;\n        }\n\n        this.#canceled = true;\n\n        if (this.#cancel) {\n            this.#cancel();\n        }\n\n        if (cleanup) {\n            if (!this.#promise) {\n                this.#promise = this.initiateTask(cleanup);\n            } else {\n                this.#promise = this.#promise.then(() => this.initiateTask(cleanup));\n            }\n        }\n    }\n\n    /**\n     * Execute a task immediately if it is a function.\n     */\n    protected async initiateTask(task: PromiseLike<unknown> | (() => PromiseLike<unknown>)) {\n        if (typeof task === \"function\") {\n            task = task();\n        }\n        return Promise.resolve(task).catch(cause => logger.error(`Error initializing ${this.#owner} worker:`, cause));\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,oBAAuB;AANvB;AAAA;AAAA;AAAA;AAAA;AAQA,MAAM,SAAS,qBAAO,IAAI,OAAO;AAK1B,MAAM,MAAsC;AAAA,EAC/C;AAAA,EACA;AAAA,EACA,YAAY;AAAA,EACZ;AAAA,EAEA,YAAY,OAAW,SAAgC;AACnD,SAAK,SAAS;AACd,QAAI,SAAS;AACT,WAAK,IAAI,MAAM,OAAO;AAAA,IAC1B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KACI,aACA,YACgC;AAChC,YAAQ,KAAK,YAAY,QAAQ,QAAQ,GAAG,KAAK,aAAa,UAAU;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,MAA2D,QAAqB;AAChF,QAAI,KAAK,WAAW;AAChB,eAAS;AACT;AAAA,IACJ;AAEA,QAAI,CAAC,KAAK,UAAU;AAChB,WAAK,WAAW,KAAK,aAAa,IAAI;AAAA,IAC1C,OAAO;AACH,WAAK,WAAW,KAAK,SAAS,KAAK,MAAM;AACrC,YAAI,KAAK,WAAW;AAChB,mBAAS;AACT;AAAA,QACJ;AAEA,aAAK,UAAU;AACf,eAAO,KAAK,aAAa,IAAI,EAAE,QAAQ,MAAM;AACzC,eAAK,UAAU;AAAA,QACnB,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,SAAmC;AACzC,QAAI,KAAK,WAAW;AAChB;AAAA,IACJ;AAEA,SAAK,YAAY;AAEjB,QAAI,KAAK,SAAS;AACd,WAAK,QAAQ;AAAA,IACjB;AAEA,QAAI,SAAS;AACT,UAAI,CAAC,KAAK,UAAU;AAChB,aAAK,WAAW,KAAK,aAAa,OAAO;AAAA,MAC7C,OAAO;AACH,aAAK,WAAW,KAAK,SAAS,KAAK,MAAM,KAAK,aAAa,OAAO,CAAC;AAAA,MACvE;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,aAAa,MAA2D;AACpF,QAAI,OAAO,SAAS,YAAY;AAC5B,aAAO,KAAK;AAAA,IAChB;AACA,WAAO,QAAQ,QAAQ,IAAI,EAAE,MAAM,WAAS,OAAO,MAAM,sBAAsB,KAAK,MAAM,YAAY,KAAK,CAAC;AAAA,EAChH;AACJ;",
  "names": []
}
