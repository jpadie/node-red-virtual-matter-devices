"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ByteArray_exports = {};
__export(ByteArray_exports, {
  ByteArray: () => ByteArray,
  Endian: () => Endian
});
module.exports = __toCommonJS(ByteArray_exports);
var import_MatterError = require("../common/MatterError.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
Uint8Array.prototype.toHex = function() {
  const hexArray = new Array();
  hexArray.length = this.length;
  this.forEach((byte) => hexArray.push(byte.toString(16).padStart(2, "0")));
  return hexArray.join("");
};
Uint8Array.prototype.toBase64 = function() {
  let result = "";
  this.forEach((byte) => result += String.fromCharCode(byte));
  return btoa(result);
};
Uint8Array.prototype.getDataView = function() {
  return new DataView(this.buffer, this.byteOffset, this.byteLength);
};
Uint8Array.prototype.equals = function(other) {
  if (other.length !== this.length) return false;
  return this.every((value, index) => other[index] === value);
};
Uint8Array.fromHex = function(hexString) {
  if (hexString.length === 0) return new ByteArray(0);
  if (hexString.length % 2 !== 0) throw new import_MatterError.UnexpectedDataError("Hex string should have an even length.");
  const bytes = hexString.match(/.{1,2}/g)?.map((byteHex) => parseInt(byteHex, 16));
  if (bytes === void 0) throw new import_MatterError.UnexpectedDataError("Failed to parse the hex string.");
  return ByteArray.from(bytes);
};
Uint8Array.fromBase64 = function(base64String) {
  const raw = atob(base64String);
  let result = "";
  for (let i = 0; i < raw.length; i++) {
    const hex = raw.charCodeAt(i).toString(16);
    result += hex.length === 2 ? hex : "0" + hex;
  }
  return this.fromHex(result);
};
Uint8Array.fromString = function(string) {
  return new TextEncoder().encode(string);
};
Uint8Array.concat = function(...arrays) {
  let length = 0;
  arrays.forEach((array) => length += array.length);
  const result = new Uint8Array(length);
  let offset = 0;
  arrays.forEach((array) => {
    result.set(array, offset);
    offset += array.length;
  });
  return result;
};
const ByteArray = Uint8Array;
var Endian = /* @__PURE__ */ ((Endian2) => {
  Endian2[Endian2["Little"] = 0] = "Little";
  Endian2[Endian2["Big"] = 1] = "Big";
  return Endian2;
})(Endian || {});
//# sourceMappingURL=ByteArray.js.map
