{
  "version": 3,
  "sources": ["../../../src/util/GeneratedClass.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../common/MatterError.js\";\n\n/**\n * Helper function for class generation.\n *\n * This factory does not offer TypeScript types for the resulting class.  You must cast separately.\n */\nexport function GeneratedClass(options: GeneratedClass.Options) {\n    const { base, name, args, mixins } = options;\n\n    // Options + any additional mixins defines complete functionality\n    const allMixins = mixins ? [...mixins, options] : [options];\n\n    // Create the constructor function\n    const type = createConstructor({\n        name: name ?? (base ? `${base.name}$` : \"GeneratedClass\"),\n        base,\n        args,\n        mixins: allMixins,\n    });\n\n    // Install properties\n    for (const mixin of allMixins) {\n        applyMixin(type, mixin);\n    }\n\n    return type;\n}\n\nfunction applyMixin(\n    constructor: new (...args: any) => any,\n    { staticProperties, staticDescriptors, instanceDescriptors }: GeneratedClass.Mixin,\n) {\n    if (staticProperties) {\n        Object.assign(constructor, staticProperties);\n    }\n    if (staticDescriptors) {\n        Object.defineProperties(constructor, staticDescriptors);\n    }\n    if (instanceDescriptors) {\n        Object.defineProperties(constructor.prototype, instanceDescriptors);\n    }\n}\n\nexport namespace GeneratedClass {\n    /**\n     * These fields control class behavior.\n     */\n    export interface Mixin {\n        /**\n         * A function that performs initialization after instantiation.  \"this\" will be the object and arguments are the\n         * arguments to the constructor.\n         */\n        initialize?: (...args: any[]) => void;\n\n        /**\n         * Instance properties.\n         */\n        instanceProperties?: object;\n\n        /**\n         * Instance properties defined using descriptors.\n         */\n        instanceDescriptors?: PropertyDescriptorMap;\n\n        /**\n         * Static properties.\n         */\n        staticProperties?: object;\n\n        /**\n         * Static properties defined using descriptors.\n         */\n        staticDescriptors?: PropertyDescriptorMap;\n    }\n\n    /**\n     * Input to {@link GeneratedClass}.\n     */\n    export interface Options extends Mixin {\n        /**\n         * The name of the class.\n         */\n        name?: string;\n\n        /**\n         * The base class, if any.\n         */\n        base?: new (...args: any) => any;\n\n        /**\n         * A preprocessor for arguments.  Derivatives may use this to transform arguments prior to call to super() and\n         * initialize().\n         */\n        args?: (...args: any[]) => any[];\n\n        /**\n         * Options is a default mixin but you can provide others here.\n         */\n        mixins?: Mixin[];\n    }\n}\n\ninterface ConstructorOptions {\n    name: string;\n    mixins: GeneratedClass.Mixin[];\n    base?: new (...args: any[]) => any;\n    args?: (...args: any[]) => any[];\n}\n\nfunction createConstructor({ name, base, args, mixins }: ConstructorOptions) {\n    // CJS Transpilation renames this symbol so bring it local to access\n    const _InternalError = InternalError;\n    _InternalError;\n\n    // Have to use eval if we don't want every class to be called \"GeneratedClass\" in the debugger but we can ensure\n    // this won't be abused.\n    //\n    // \"name\" is the only input to this function that appears textually in the eval.  We limit it to letters, numbers,\n    // \"$\" and \"_\".\n    if (!name.match(/^(?:\\p{L}|[0-9$_])+$/u)) {\n        throw new InternalError(\"Refusing to generate class with untrustworthy name\");\n    }\n\n    let ext;\n    if (base) {\n        ext = `extends base `;\n    } else {\n        ext = \"\";\n    }\n\n    const code = [`class ${name} ${ext}{`];\n\n    // Consolidate mixins to a single initialize and instanceProperties\n    let initialize: undefined | GeneratedClass.Options[\"initialize\"];\n    let instanceProperties: undefined | GeneratedClass.Options[\"instanceProperties\"];\n\n    for (const mixin of mixins) {\n        const mixinInitialize = mixin.initialize;\n\n        // Add initializer\n        if (mixinInitialize) {\n            if (initialize) {\n                const baseInitialize = initialize;\n                initialize = function (this: any, ...args) {\n                    baseInitialize.call(this, ...args);\n                    mixinInitialize.call(this, ...args);\n                };\n            } else {\n                initialize = mixinInitialize;\n            }\n        }\n\n        // Add instance properties\n        if (mixin.instanceProperties) {\n            if (instanceProperties) {\n                instanceProperties = {\n                    ...instanceProperties,\n                    ...mixin.instanceProperties,\n                };\n            } else {\n                instanceProperties = mixin.instanceProperties;\n            }\n        }\n    }\n\n    // If we need a constructor, add it\n    if (args || initialize || instanceProperties) {\n        code.push(\"constructor() {\");\n\n        let argsName;\n        if (args) {\n            argsName = \"a\";\n            code.push(`const a = args(...arguments)`);\n        } else {\n            argsName = \"arguments\";\n        }\n\n        if (base) {\n            code.push(`super(...${argsName})`);\n        }\n\n        if (instanceProperties) {\n            // Do not use Object.assign because we want to support accessors\n            code.push(`for (const k in instanceProperties) this[k] = instanceProperties[k]`);\n        }\n\n        if (initialize) {\n            code.push(`initialize.apply(this, ${argsName})`);\n        }\n\n        code.push(\"}\");\n    }\n\n    code.push(\"}\", name);\n\n    return eval(code.join(\"\\n\")) as new (...args: any) => any;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,yBAA8B;AAN9B;AAAA;AAAA;AAAA;AAAA;AAaO,SAAS,eAAe,SAAiC;AAC5D,QAAM,EAAE,MAAAA,OAAM,MAAAC,OAAM,MAAAC,OAAM,QAAAC,QAAO,IAAI;AAGrC,QAAM,YAAYA,UAAS,CAAC,GAAGA,SAAQ,OAAO,IAAI,CAAC,OAAO;AAG1D,QAAM,OAAO,kBAAkB;AAAA,IAC3B,MAAMF,UAASD,QAAO,GAAGA,MAAK,IAAI,MAAM;AAAA,IACxC,MAAAA;AAAA,IACA,MAAAE;AAAA,IACA,QAAQ;AAAA,EACZ,CAAC;AAGD,aAAW,SAAS,WAAW;AAC3B,eAAW,MAAM,KAAK;AAAA,EAC1B;AAEA,SAAO;AACX;AAEA,SAAS,WACL,aACA,EAAE,kBAAkB,mBAAmB,oBAAoB,GAC7D;AACE,MAAI,kBAAkB;AAClB,WAAO,OAAO,aAAa,gBAAgB;AAAA,EAC/C;AACA,MAAI,mBAAmB;AACnB,WAAO,iBAAiB,aAAa,iBAAiB;AAAA,EAC1D;AACA,MAAI,qBAAqB;AACrB,WAAO,iBAAiB,YAAY,WAAW,mBAAmB;AAAA,EACtE;AACJ;AAoEA,SAAS,kBAAkB,EAAE,MAAM,MAAM,MAAM,OAAO,GAAuB;AAEzE,QAAM,iBAAiB;AACvB;AAOA,MAAI,CAAC,KAAK,MAAM,uBAAuB,GAAG;AACtC,UAAM,IAAI,iCAAc,oDAAoD;AAAA,EAChF;AAEA,MAAI;AACJ,MAAI,MAAM;AACN,UAAM;AAAA,EACV,OAAO;AACH,UAAM;AAAA,EACV;AAEA,QAAM,OAAO,CAAC,SAAS,IAAI,IAAI,GAAG,GAAG;AAGrC,MAAI;AACJ,MAAI;AAEJ,aAAW,SAAS,QAAQ;AACxB,UAAM,kBAAkB,MAAM;AAG9B,QAAI,iBAAiB;AACjB,UAAI,YAAY;AACZ,cAAM,iBAAiB;AACvB,qBAAa,YAAwBA,OAAM;AACvC,yBAAe,KAAK,MAAM,GAAGA,KAAI;AACjC,0BAAgB,KAAK,MAAM,GAAGA,KAAI;AAAA,QACtC;AAAA,MACJ,OAAO;AACH,qBAAa;AAAA,MACjB;AAAA,IACJ;AAGA,QAAI,MAAM,oBAAoB;AAC1B,UAAI,oBAAoB;AACpB,6BAAqB;AAAA,UACjB,GAAG;AAAA,UACH,GAAG,MAAM;AAAA,QACb;AAAA,MACJ,OAAO;AACH,6BAAqB,MAAM;AAAA,MAC/B;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,QAAQ,cAAc,oBAAoB;AAC1C,SAAK,KAAK,iBAAiB;AAE3B,QAAI;AACJ,QAAI,MAAM;AACN,iBAAW;AACX,WAAK,KAAK,8BAA8B;AAAA,IAC5C,OAAO;AACH,iBAAW;AAAA,IACf;AAEA,QAAI,MAAM;AACN,WAAK,KAAK,YAAY,QAAQ,GAAG;AAAA,IACrC;AAEA,QAAI,oBAAoB;AAEpB,WAAK,KAAK,qEAAqE;AAAA,IACnF;AAEA,QAAI,YAAY;AACZ,WAAK,KAAK,0BAA0B,QAAQ,GAAG;AAAA,IACnD;AAEA,SAAK,KAAK,GAAG;AAAA,EACjB;AAEA,OAAK,KAAK,KAAK,IAAI;AAEnB,SAAO,KAAK,KAAK,KAAK,IAAI,CAAC;AAC/B;",
  "names": ["base", "name", "args", "mixins"]
}
