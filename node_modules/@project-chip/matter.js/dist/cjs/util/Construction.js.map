{
  "version": 3,
  "sources": ["../../../src/util/Construction.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CrashedDependenciesError, CrashedDependencyError, Lifecycle } from \"../common/Lifecycle.js\";\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { errorOf } from \"./Error.js\";\nimport { Observable } from \"./Observable.js\";\nimport { MaybePromise } from \"./Promises.js\";\n\n/**\n * Create an instance of a class implementing the {@link Constructable} pattern.\n */\nexport async function asyncNew<const A extends any[], const C extends new (...args: A) => Constructable<any>>(\n    constructor: C,\n    ...args: A\n): Promise<InstanceType<C>> {\n    const subject = new constructor(...args);\n\n    // If construction of the subject is not initiated you cannot use asyncNew because something needs to invoke\n    // Construction#start.\n    if (subject.construction.status === Lifecycle.Status.Inactive) {\n        throw new ImplementationError(\n            `You cannot use asyncNew on ${constructor.name} because its construction is controlled by another component`,\n        );\n    }\n\n    await subject.construction.ready;\n\n    return subject as InstanceType<C>;\n}\n\n/**\n * A pattern for asynchronous object initialization and cleanup of a target object, called the \"subject\".\n *\n * Construction happens in the initializer parameter of {@link Construction} or via {@link Construction.construct} on\n * the subject.  You invoke in your constructor and place in a property called \"construction\".\n *\n * Destruciton is optional and happens in the destructor parameter of {@link Construction#close} or via\n * {@link Construction.destruct} on the subject.  Typically you invoke in a \"close\" method of the subject.\n *\n * If construction or destruction is not asynchronous (does not return a Promise) then they complete synchronously,\n * including throwing exceptions.\n *\n * To ensure an instance is initialized prior to use you may await construction, so e.g. `await new\n * MyConstructable().construction`. {@link asyncNew} is shorthand for this.  The creation code path can instead await\n * {@link Construction.ready} to ensure handling of the root cause.\n *\n * Public APIs should provide a static async create() that performs an asyncNew().  The class will then adhere to\n * Matter.js conventions and library users can ignore the complexities associated with async creation.\n */\nexport interface Constructable<T = object> {\n    readonly construction: Construction<T>;\n}\n\nexport module Constructable {\n    /**\n     * An {@link Constructable} that supports deferred construction.\n     *\n     * This supports use cases where initialization initiates separately from construction and/or reinitialization is\n     * possible.\n     */\n    export interface Deferred<T, A extends unknown[]> extends Constructable<T> {\n        /**\n         * Perform deferred construction.\n         */\n        [Construction.construct](...args: A): MaybePromise<void>;\n    }\n\n    /**\n     * An object that supports destruction.\n     */\n    export interface Destructable {\n        /**\n         * Perform destruction. This is used invoked by {@link Constructable#close} after transitioning to\n         * {@link Lifecycle.Status.Destroying} but before transitioning to {@link Lifecycle.Status.Destroyed}.\n         *\n         * This is separate from {@link Symbol.dispose}/{@link Symbol.asyncDispose} so those can invoke\n         * {@link Constructable#close}.\n         */\n        [Construction.destruct](): MaybePromise<void>;\n    }\n}\n\n/**\n * The promise implementing by an {@link Constructable#construction}.\n */\nexport interface Construction<T> extends Promise<T> {\n    /**\n     * If construction ends with an error, the error is saved here.\n     */\n    readonly error?: Error;\n\n    /**\n     * Status of the constructed object.\n     */\n    readonly status: Lifecycle.Status;\n\n    /**\n     * Notifications of state change.  Normally you just await construction but this offers more granular events and\n     * repeating events.\n     */\n    readonly change: Observable<[status: Lifecycle.Status, subject: T]>;\n\n    /**\n     * True iff the primary error has been or will be reported.\n     */\n    readonly isErrorHandled: boolean;\n\n    /**\n     * Resolves when construction completes; rejects if construction crashes.\n     *\n     * Behaves identically to {@link Construction} but always throws the primary cause rather than\n     * {@link CrashedDependencyError}.\n     *\n     * Handling errors on this promise will prevent other handlers from seeing the primary cause.\n     */\n    readonly ready: Promise<T>;\n\n    /**\n     * Resolves when destruction completes; rejects if the component crashes.\n     *\n     * Handling errors on this promise will prevent other handlers from seeing the primary cause.\n     */\n    readonly closed: Promise<T>;\n\n    /**\n     * If you omit the initializer parameter to {@link Construction} execution is deferred until you invoke this\n     * method to initiate construction via the {@link Constructable.Deferred} interface.\n     *\n     * Unlike the initializer, errors are always reported via the PromiseLike interface even if the constructable throws\n     * an error synchronously.\n     */\n    start<const T, const A extends unknown[], const This extends Construction<Constructable.Deferred<T, A>>>(\n        this: This,\n        ...args: A\n    ): void;\n\n    /**\n     * Invoke destruction logic then move to destroyed status.\n     *\n     * Typically you invoke this in the subject's \"close\" method.\n     *\n     * Use of this function is optional.  It provides these benefits:\n     *\n     *   - Ensures the subject is fully initialized before closing.\n     *\n     *   - Handles and logs errors, ensuring close() always completes successfully.\n     *\n     *   - Makes destruction observable via {@link change} and {@link closed}.\n     */\n    close(destructor?: () => MaybePromise): MaybePromise;\n\n    /**\n     * Throws an error if construction is ongoing or incomplete.\n     */\n    assert(description?: string): void;\n\n    /**\n     * Asserts construction is complete and that an object is defined.\n     */\n    assert<T>(description: string, dependency: T | undefined): T;\n\n    /**\n     * Manually force a specific {@link status}.\n     *\n     * This offers flexibility in component lifecycle management including resetting component to inactive state and\n     * broadcasting lifecycle changes.  On reset listeners are also reset and must be reinstalled.\n     *\n     * This method fails if initialization is ongoing; await completion first.\n     */\n    setStatus(status: Lifecycle.Status): void;\n\n    /**\n     * Move subject to \"crashed\" state, optionally setting the cause.\n     *\n     * This happens automatically if there is an error during construction.  It is also useful for post-construction\n     * errors to convey crashed state to components such as the environmental runtime service.\n     */\n    crash(cause?: any): void;\n\n    /**\n     * Invoke a method after construction completes successfully.\n     *\n     * Errors thrown by this callback are logged but otherwise ignored.\n     */\n    onSuccess(actor: () => MaybePromise<void>): void;\n\n    /**\n     * Invoke a method after construction completes unsuccessfully.\n     *\n     * If you register an onError handler then the default error handler will not log the error.\n     *\n     * Errors thrown by this callback are logged but otherwise ignored.\n     */\n    onError(actor: (error: Error) => MaybePromise<void>): void;\n\n    /**\n     * Invoke a method after construction completes successfully or onsuccessfully.\n     *\n     * Errors thrown by this callback are logged but otherwise ignored.\n     */\n    onCompletion(actor: () => void): void;\n\n    toString(): string;\n}\n\n/**\n * Create an {@link Constructable} and optionally begin async construction.\n */\nexport function Construction<const T extends Constructable>(\n    subject: T,\n    initializer?: () => MaybePromise,\n): Construction<T> {\n    if (!initializer) {\n        assertDeferred(subject);\n    }\n\n    // The promise returned by the initializer if initialization is async\n    let initializerPromise: MaybePromise<void>;\n\n    // The promise we use to implement Construction.then() and Construction.ready\n    let awaiterPromise: undefined | Promise<T>;\n    let awaiterResolve: undefined | ((subject: T) => void);\n    let awaiterReject: undefined | ((error: any) => void);\n\n    // The promise we use to implement Constructable.close\n    let closedPromise: undefined | Promise<void>;\n    let closedResolve: undefined | (() => void);\n    let closedReject: undefined | ((error: any) => void);\n\n    let error: undefined | Error;\n    let primaryCauseHandled = false;\n    let status = Lifecycle.Status.Inactive;\n    let change: Observable<[status: Lifecycle.Status, subject: T]> | undefined;\n\n    const self: Construction<any> = {\n        [Symbol.toStringTag]: \"AsyncConstruction\",\n\n        get error() {\n            return error;\n        },\n\n        get status() {\n            return status;\n        },\n\n        get change() {\n            if (change === undefined) {\n                change = Observable();\n            }\n            return change;\n        },\n\n        get isErrorHandled() {\n            return primaryCauseHandled;\n        },\n\n        start<const T, const A extends [], const This extends Construction<Constructable.Deferred<T, A>>>(\n            this: This,\n            ...args: A\n        ) {\n            if (status !== Lifecycle.Status.Inactive) {\n                throw new ImplementationError(`Cannot initialize ${subject} because it is already active`);\n            }\n\n            assertDeferred(subject);\n\n            status = Lifecycle.Status.Initializing;\n\n            try {\n                const initializeDeferred = () => subject[Construction.construct](...args);\n                invokeInitializer(initializeDeferred);\n            } catch (e) {\n                rejected(e);\n                return;\n            }\n        },\n\n        assert(description?: string, dependency?: any) {\n            Lifecycle.assertActive(status, description ?? subject.constructor.name);\n\n            if (arguments.length < 2) {\n                return;\n            }\n\n            try {\n                if (dependency === undefined) {\n                    throw new ImplementationError(`Property is undefined`);\n                }\n            } catch (e) {\n                let error;\n                if (e instanceof Error) {\n                    error = e;\n                } else {\n                    error = new ImplementationError(e?.toString() ?? \"(unknown error)\");\n                }\n                error.message = `Cannot access ${description}: ${error.message}`;\n                throw error;\n            }\n            return dependency;\n        },\n\n        then<TResult1 = T, TResult2 = never>(\n            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n        ): Promise<TResult1 | TResult2> {\n            const handleRejection = onrejected ? () => onrejected?.(crashedError()) as TResult2 : undefined;\n            if (status === Lifecycle.Status.Inactive || status === Lifecycle.Status.Initializing) {\n                if (!awaiterPromise) {\n                    awaiterPromise = new Promise<T>((resolve, reject) => {\n                        awaiterResolve = resolve;\n                        awaiterReject = reject;\n                    });\n                }\n\n                return awaiterPromise.then(onfulfilled, handleRejection);\n            }\n\n            const promise = error ? Promise.reject(crashedError()) : Promise.resolve(subject);\n            return promise.then(onfulfilled, handleRejection);\n        },\n\n        catch<TResult = never>(\n            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n        ): Promise<T | TResult> {\n            return this.then(undefined, onrejected);\n        },\n\n        onSuccess(actor: () => MaybePromise<void>) {\n            const onSuccess = () => {\n                const errorHandler = createErrorHandler(\"onSuccess\");\n\n                try {\n                    const result = actor();\n                    if (MaybePromise.is(result)) {\n                        return Promise.resolve(result).catch(errorHandler);\n                    }\n                } catch (e) {\n                    errorHandler(e);\n                }\n            };\n\n            this.then(onSuccess).catch(e => {\n                // Failure should result in a CrashedDependencyError which simply means initialization failed.  The\n                // actual error is logged so we can safely ignore.  If the error was not a CrashedDependencyError then\n                // it is unexpected.  We rethrow which will result in the process exiting with an unexpected error\n                CrashedDependencyError.accept(e);\n            });\n        },\n\n        onError(actor: (error: Error) => MaybePromise<void>) {\n            const onError = (error: unknown) => {\n                const errorHandler = createErrorHandler(\"onError\");\n\n                try {\n                    const result = actor(errorOf(error));\n                    if (MaybePromise.is(result)) {\n                        return result.then(undefined, errorHandler);\n                    }\n                } catch (e) {\n                    errorHandler(e);\n                }\n            };\n\n            this.ready.catch(onError);\n        },\n\n        onCompletion(actor: () => void) {\n            const onCompletion = () => {\n                const errorHandler = createErrorHandler(\"onCompletion\");\n\n                try {\n                    actor();\n                } catch (e) {\n                    errorHandler(e);\n                }\n            };\n\n            // Do not use finally() because eslint rule doesn't like it\n            this.then(onCompletion, onCompletion);\n        },\n\n        close(destructor): MaybePromise {\n            const destructorError = createErrorHandler(\"destructor\");\n\n            // Destruction phase 4 - move to destroyed state\n            function destroyed() {\n                setStatus(Lifecycle.Status.Destroyed);\n                if (closedResolve) {\n                    closedResolve();\n                    closedResolve = closedReject = undefined;\n                }\n            }\n\n            // Destruction phase 3 - invoke AsyncDestructable.destruct if present\n            const destruct = (subject as Partial<Constructable.Destructable>)[Construction.destruct];\n            const invokeDestruct = destruct\n                ? function invokeDestruct() {\n                      try {\n                          const promise = destruct.bind(subject)();\n                          if (promise) {\n                              return promise.then(undefined, destructorError).then(destroyed);\n                          }\n                      } catch (e) {\n                          destructorError(e);\n                      }\n                      destroyed();\n                  }\n                : destroyed;\n\n            // Destruction phase 2 - invoke destructor function if present\n            const invokeDestructor = destructor\n                ? function invokeDestructor() {\n                      try {\n                          const promise = destructor();\n                          if (promise) {\n                              return promise.then(undefined, destructorError).then(invokeDestruct);\n                          }\n                      } catch (e) {\n                          destructorError(e);\n                      }\n                      invokeDestruct();\n                  }\n                : invokeDestruct;\n\n            // Destruction phase 1 - move to destroyed state\n            function beginDestruction() {\n                if (status === Lifecycle.Status.Destroying || status === Lifecycle.Status.Destroyed) {\n                    return self.closed;\n                }\n                setStatus(Lifecycle.Status.Destroying);\n                return invokeDestructor();\n            }\n\n            if (status === Lifecycle.Status.Initializing) {\n                return this.then(beginDestruction, beginDestruction);\n            }\n\n            return beginDestruction();\n        },\n\n        finally(onfinally: () => void): Promise<T> {\n            return Promise.prototype.finally.call(this, onfinally);\n        },\n\n        setStatus(newStatus: Lifecycle.Status) {\n            if (this.status === newStatus) {\n                return;\n            }\n\n            switch (status) {\n                case newStatus:\n                    return;\n\n                case Lifecycle.Status.Destroying:\n                    if (newStatus !== Lifecycle.Status.Destroyed) {\n                        throw new ImplementationError(\"Cannog change status because destruction is ongoing\");\n                    }\n                    break;\n\n                case Lifecycle.Status.Destroyed:\n                    throw new ImplementationError(\"Cannot change status because destruction is final\");\n\n                case Lifecycle.Status.Initializing:\n                    throw new ImplementationError(\"Cannot change status because initialization is ongoing\");\n            }\n\n            switch (newStatus) {\n                case Lifecycle.Status.Inactive:\n                    awaiterPromise = closedPromise = undefined;\n                    primaryCauseHandled = false;\n                    error = undefined;\n                    break;\n\n                case Lifecycle.Status.Active:\n                    awaiterPromise = closedPromise = undefined;\n                    error = undefined;\n                    break;\n\n                default:\n                    break;\n            }\n\n            setStatus(newStatus);\n        },\n\n        crash(newError?: Error) {\n            error = newError;\n            setStatus(Lifecycle.Status.Crashed);\n        },\n\n        get ready() {\n            return {\n                [Symbol.toStringTag]: \"AsyncConstruction#primary\",\n\n                then<TResult1 = T, TResult2 = never>(\n                    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n                    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n                ): Promise<TResult1 | TResult2> {\n                    let rejectionHandler: undefined | typeof onrejected;\n                    if (onrejected) {\n                        primaryCauseHandled = true;\n                        rejectionHandler = () => onrejected(errorOf(error));\n                    }\n\n                    return self.then(onfulfilled, rejectionHandler);\n                },\n\n                catch<TResult = never>(\n                    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n                ): Promise<T | TResult> {\n                    return this.then(undefined, onrejected);\n                },\n\n                finally(onfinally: () => void): Promise<T> {\n                    return Promise.prototype.finally.call(this, onfinally);\n                },\n            };\n        },\n\n        get closed() {\n            if (closedPromise === undefined) {\n                closedPromise = new Promise((resolve, reject) => {\n                    closedResolve = resolve;\n                    closedReject = reject;\n                });\n            }\n\n            return {\n                [Symbol.toStringTag]: \"AsyncConstruction#primary\",\n\n                then<TResult1 = void, TResult2 = never>(\n                    onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n                    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n                ): Promise<TResult1 | TResult2> {\n                    let rejectionHandler: undefined | typeof onrejected;\n                    if (onrejected) {\n                        primaryCauseHandled = true;\n                        rejectionHandler = () => onrejected(errorOf(error));\n                    }\n\n                    return (closedPromise as Promise<void>).then(onfulfilled, rejectionHandler);\n                },\n\n                catch<TResult = never>(\n                    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n                ): Promise<T | TResult> {\n                    return this.then(undefined, onrejected);\n                },\n\n                finally(onfinally: () => void): Promise<T> {\n                    return Promise.prototype.finally.call(this, onfinally);\n                },\n            };\n        },\n    };\n\n    if (initializer) {\n        invokeInitializer(initializer);\n    }\n\n    return self;\n\n    // Begin initialization.  May throw synchronously or asynchronously\n    function invokeInitializer(initializer: () => MaybePromise<void>) {\n        status = Lifecycle.Status.Initializing;\n\n        initializerPromise = initializer();\n\n        if (MaybePromise.is(initializerPromise)) {\n            initializerPromise.then(resolved, rejected);\n        } else {\n            resolved();\n        }\n    }\n\n    // We return the original error for the first rejection.  The stack trace will point to the source of the error.\n    // This means that the owner of the object should register error handling first.\n    //\n    // For subsequent rejections we throw a new CrashedDependencyError for each listener.  This prevents the logs from\n    // filling with redundant stack traces and ensures the stack trace details the listener's stack rather than the\n    // original error's stack.\n    function crashedError() {\n        if (!primaryCauseHandled && error) {\n            primaryCauseHandled = true;\n            return error;\n        }\n\n        let what;\n        if (subject.toString === Object.prototype.toString) {\n            what = subject.constructor.name;\n        } else {\n            what = subject.toString();\n        }\n\n        const crashError = new CrashedDependencyError(what, \"unavailable due to initialization error\");\n        crashError.subject = subject;\n        return crashError;\n    }\n\n    function setStatus(newStatus: Lifecycle.Status) {\n        if (status === newStatus) {\n            return;\n        }\n\n        status = newStatus;\n\n        if (change) {\n            change.emit(status, subject);\n        }\n    }\n\n    function resolved() {\n        if (status === Lifecycle.Status.Initializing) {\n            setStatus(Lifecycle.Status.Active);\n        }\n\n        if (awaiterResolve) {\n            const resolve = awaiterResolve;\n            awaiterResolve = awaiterReject = undefined;\n            resolve(subject);\n        }\n    }\n\n    function rejected(cause: any) {\n        if (status !== Lifecycle.Status.Destroying && status !== Lifecycle.Status.Destroyed) {\n            error = cause;\n            setStatus(Lifecycle.Status.Crashed);\n        }\n\n        if (awaiterReject) {\n            const reject = awaiterReject;\n            awaiterResolve = awaiterReject = undefined;\n            reject(crashedError());\n        }\n\n        if (closedReject) {\n            primaryCauseHandled = true;\n            const reject = closedReject;\n            closedResolve = closedReject = undefined;\n            reject(cause);\n        }\n\n        if (!primaryCauseHandled) {\n            unhandledError(cause);\n        }\n    }\n\n    function unhandledError(...args: any[]) {\n        const logger = Logger.get(subject.constructor.name);\n        logger.error(...args);\n    }\n\n    function createErrorHandler(name: string) {\n        return (e: any) => {\n            unhandledError(`Unhandled error in ${self} ${name}:`, e);\n        };\n    }\n}\n\nexport namespace Construction {\n    /**\n     * Ensure a pool of {@link Constructable}s are initialized.  Returns a promise if any constructables are still\n     * initializing or there is an error.\n     *\n     * @param subjects the constructables to monitor; may mutate whilst construction is ongoing\n     * @param onError error handler; if returns error it is thrown; if omitted throws CrashedDependenciesError\n     */\n    export function all<T extends Constructable>(\n        subjects: Iterable<T>,\n        onError?: (errored: Iterable<T>) => void | Error,\n    ): MaybePromise {\n        if (onError === undefined) {\n            onError = errors => new CrashedDependenciesError(errors);\n        }\n\n        const subjectArray = [...subjects];\n\n        const uninitialized = subjectArray.filter(\n            subject => subject.construction.status === Lifecycle.Status.Initializing,\n        );\n        if (uninitialized.length) {\n            return Promise.allSettled(uninitialized.map(backing => backing.construction)).then(() =>\n                // Recurse to ensure subjects added subsequent to initial \"all\" settle\n                all(subjects, onError),\n            );\n        }\n\n        const crashed = Object.values(subjectArray).filter(\n            backing => backing.construction.status === Lifecycle.Status.Crashed,\n        );\n        if (crashed.length) {\n            let error;\n            try {\n                error = onError(crashed);\n            } catch (e) {\n                error = e;\n            }\n            if (error) {\n                return Promise.reject(error);\n            }\n        }\n    }\n\n    export const construct = Symbol(\"construct\");\n    export const destruct = Symbol(\"destruct\");\n}\n\nfunction assertDeferred<T>(subject: Constructable<T>): asserts subject is Constructable.Deferred<T, any> {\n    if (typeof (subject as Constructable.Deferred<any, any>)?.[Construction.construct] !== \"function\") {\n        throw new ImplementationError(`No initializer defined for ${subject}`);\n    }\n}\n"],
  "mappings": "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",
  "names": ["error", "invokeDestruct", "invokeDestructor", "initializer", "Construction"]
}
