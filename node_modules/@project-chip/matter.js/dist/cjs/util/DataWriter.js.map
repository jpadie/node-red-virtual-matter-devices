{
  "version": 3,
  "sources": ["../../../src/util/DataWriter.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ByteArray, Endian } from \"./ByteArray.js\";\nimport { toBigInt, toNumber } from \"./Number.js\";\n\n/** Writer that auto-increments its offset after each write. */\n// TODO: some research should be done to make sure this is most performant implementation.\nexport class DataWriter<E extends Endian> {\n    private readonly littleEndian: boolean;\n    private length = 0;\n    private readonly chunks = new Array<ByteArray>();\n\n    constructor(endian: E) {\n        this.littleEndian = endian === Endian.Little;\n    }\n\n    writeUInt8(value: number | bigint) {\n        this.chunks.push(new ByteArray([toNumber(value)]));\n        this.length += 1;\n    }\n\n    writeUInt16(value: number | bigint) {\n        const chunk = new ByteArray(2);\n        new DataView(chunk.buffer, 0, 2).setUint16(0, toNumber(value), this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 2;\n    }\n\n    writeUInt32(value: number | bigint) {\n        const chunk = new ByteArray(4);\n        new DataView(chunk.buffer, 0, 4).setUint32(0, toNumber(value), this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 4;\n    }\n\n    writeUInt64(value: number | bigint) {\n        const chunk = new ByteArray(8);\n        new DataView(chunk.buffer, 0, 8).setBigUint64(0, toBigInt(value), this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 8;\n    }\n\n    writeInt8(value: number | bigint) {\n        const chunk = new ByteArray(1);\n        new DataView(chunk.buffer, 0, 1).setInt8(0, toNumber(value));\n        this.chunks.push(chunk);\n        this.length += 1;\n    }\n\n    writeInt16(value: number | bigint) {\n        const chunk = new ByteArray(2);\n        new DataView(chunk.buffer, 0, 2).setInt16(0, toNumber(value), this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 2;\n    }\n\n    writeInt32(value: number | bigint) {\n        const chunk = new ByteArray(4);\n        new DataView(chunk.buffer, 0, 4).setInt32(0, toNumber(value), this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 4;\n    }\n\n    writeInt64(value: number | bigint) {\n        const chunk = new ByteArray(8);\n        new DataView(chunk.buffer, 0, 8).setBigInt64(0, toBigInt(value), this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 8;\n    }\n\n    writeFloat(value: number) {\n        const chunk = new ByteArray(4);\n        new DataView(chunk.buffer, 0, 4).setFloat32(0, value, this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 4;\n    }\n\n    writeDouble(value: number) {\n        const chunk = new ByteArray(8);\n        new DataView(chunk.buffer, 0, 8).setFloat64(0, value, this.littleEndian);\n        this.chunks.push(chunk);\n        this.length += 8;\n    }\n\n    writeByteArray(value: ByteArray) {\n        this.chunks.push(value);\n        this.length += value.byteLength;\n    }\n\n    toByteArray() {\n        if (this.chunks.length === 0) return new ByteArray(0);\n        if (this.chunks.length === 1) return this.chunks[0];\n\n        const result = new ByteArray(this.length);\n        let offset = 0;\n        this.chunks.forEach(chunk => {\n            result.set(chunk, offset);\n            offset += chunk.byteLength;\n        });\n        this.chunks.length = 0;\n        this.chunks.push(result);\n\n        return result;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
