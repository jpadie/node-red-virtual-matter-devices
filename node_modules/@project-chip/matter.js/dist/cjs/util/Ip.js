"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Ip_exports = {};
__export(Ip_exports, {
  iPv4ToArray: () => iPv4ToArray,
  iPv4ToByteArray: () => iPv4ToByteArray,
  iPv4ToNumber: () => iPv4ToNumber,
  iPv6ToArray: () => iPv6ToArray,
  iPv6ToByteArray: () => iPv6ToByteArray,
  isIPv4: () => isIPv4,
  isIPv6: () => isIPv6,
  onSameNetwork: () => onSameNetwork
});
module.exports = __toCommonJS(Ip_exports);
var import_ByteArray = require("./ByteArray.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function isIPv4(ip) {
  return ip.includes(".");
}
function isIPv6(ip) {
  return ip.includes(":");
}
function iPv4ToNumber(ip) {
  const dataView = iPv4ToArray(ip).getDataView();
  return dataView.getUint32(0);
}
function iPv4ToArray(ip) {
  const array = new Uint8Array(4);
  const ipParts = ip.split(".");
  for (let i = 0; i < 4; i++) {
    array[i] = parseInt(ipParts[i]);
  }
  return array;
}
function iPv4ToByteArray(ip) {
  return import_ByteArray.ByteArray.from(iPv4ToArray(ip));
}
function iPv6ToArray(ip) {
  const array = new Uint16Array(8);
  let ipParts = ip.split(":");
  const valueCount = ipParts.filter((value) => value !== "").length;
  if (valueCount !== 8) {
    ipParts = ip.replace("::", ":".padEnd((8 - valueCount) * 2 + 1, "0:")).split(":");
  }
  let index = 0;
  ipParts.forEach((part) => {
    if (part === "") return;
    array[index++] = parseInt(part, 16);
  });
  return array;
}
function iPv6ToByteArray(ip) {
  return import_ByteArray.ByteArray.from(Array.from(iPv6ToArray(ip)).flatMap((value) => [value >> 8, value & 255]));
}
function onSameNetwork(ip1, ip2, mask) {
  if (isIPv4(ip1)) {
    if (!isIPv4(ip2) || !isIPv4(mask)) return false;
    const ip1Number = iPv4ToNumber(ip1);
    const ip2Number = iPv4ToNumber(ip2);
    const maskNumber = iPv4ToNumber(mask);
    return (ip1Number & maskNumber) === (ip2Number & maskNumber);
  } else {
    if (isIPv4(ip2) || isIPv4(mask)) return false;
    const ip1Array = iPv6ToArray(ip1);
    const ip2Array = iPv6ToArray(ip2);
    const maskArray = iPv6ToArray(mask);
    for (let i = 0; i < 16; i++) {
      const mask2 = maskArray[i];
      if (mask2 === 0) return true;
      if ((ip1Array[i] & mask2) !== (ip2Array[i] & mask2)) return false;
    }
  }
}
//# sourceMappingURL=Ip.js.map
