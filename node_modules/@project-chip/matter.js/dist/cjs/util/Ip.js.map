{
  "version": 3,
  "sources": ["../../../src/util/Ip.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ByteArray } from \"./ByteArray.js\";\n\nexport function isIPv4(ip: string) {\n    return ip.includes(\".\");\n}\n\nexport function isIPv6(ip: string) {\n    return ip.includes(\":\");\n}\n\nexport function iPv4ToNumber(ip: string) {\n    const dataView = iPv4ToArray(ip).getDataView();\n    return dataView.getUint32(0);\n}\n\nexport function iPv4ToArray(ip: string) {\n    const array = new Uint8Array(4);\n    const ipParts = ip.split(\".\");\n    for (let i = 0; i < 4; i++) {\n        array[i] = parseInt(ipParts[i]);\n    }\n    return array;\n}\n\nexport function iPv4ToByteArray(ip: string) {\n    return ByteArray.from(iPv4ToArray(ip));\n}\n\nexport function iPv6ToArray(ip: string) {\n    const array = new Uint16Array(8);\n    let ipParts = ip.split(\":\");\n    const valueCount = ipParts.filter(value => value !== \"\").length;\n    if (valueCount !== 8) {\n        ipParts = ip.replace(\"::\", \":\".padEnd((8 - valueCount) * 2 + 1, \"0:\")).split(\":\");\n    }\n    let index = 0;\n    ipParts.forEach(part => {\n        if (part === \"\") return;\n        array[index++] = parseInt(part, 16);\n    });\n    return array;\n}\n\nexport function iPv6ToByteArray(ip: string) {\n    return ByteArray.from(Array.from(iPv6ToArray(ip)).flatMap(value => [value >> 8, value & 0xff]));\n}\n\nexport function onSameNetwork(ip1: string, ip2: string, mask: string) {\n    if (isIPv4(ip1)) {\n        // IPv4 addresses\n        if (!isIPv4(ip2) || !isIPv4(mask)) return false;\n        const ip1Number = iPv4ToNumber(ip1);\n        const ip2Number = iPv4ToNumber(ip2);\n        const maskNumber = iPv4ToNumber(mask);\n\n        return (ip1Number & maskNumber) === (ip2Number & maskNumber);\n    } else {\n        // IPv6 addresses\n        if (isIPv4(ip2) || isIPv4(mask)) return false;\n        const ip1Array = iPv6ToArray(ip1);\n        const ip2Array = iPv6ToArray(ip2);\n        const maskArray = iPv6ToArray(mask);\n\n        for (let i = 0; i < 16; i++) {\n            const mask = maskArray[i];\n            if (mask === 0) return true;\n            if ((ip1Array[i] & mask) !== (ip2Array[i] & mask)) return false;\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,uBAA0B;AAL1B;AAAA;AAAA;AAAA;AAAA;AAOO,SAAS,OAAO,IAAY;AAC/B,SAAO,GAAG,SAAS,GAAG;AAC1B;AAEO,SAAS,OAAO,IAAY;AAC/B,SAAO,GAAG,SAAS,GAAG;AAC1B;AAEO,SAAS,aAAa,IAAY;AACrC,QAAM,WAAW,YAAY,EAAE,EAAE,YAAY;AAC7C,SAAO,SAAS,UAAU,CAAC;AAC/B;AAEO,SAAS,YAAY,IAAY;AACpC,QAAM,QAAQ,IAAI,WAAW,CAAC;AAC9B,QAAM,UAAU,GAAG,MAAM,GAAG;AAC5B,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAM,CAAC,IAAI,SAAS,QAAQ,CAAC,CAAC;AAAA,EAClC;AACA,SAAO;AACX;AAEO,SAAS,gBAAgB,IAAY;AACxC,SAAO,2BAAU,KAAK,YAAY,EAAE,CAAC;AACzC;AAEO,SAAS,YAAY,IAAY;AACpC,QAAM,QAAQ,IAAI,YAAY,CAAC;AAC/B,MAAI,UAAU,GAAG,MAAM,GAAG;AAC1B,QAAM,aAAa,QAAQ,OAAO,WAAS,UAAU,EAAE,EAAE;AACzD,MAAI,eAAe,GAAG;AAClB,cAAU,GAAG,QAAQ,MAAM,IAAI,QAAQ,IAAI,cAAc,IAAI,GAAG,IAAI,CAAC,EAAE,MAAM,GAAG;AAAA,EACpF;AACA,MAAI,QAAQ;AACZ,UAAQ,QAAQ,UAAQ;AACpB,QAAI,SAAS,GAAI;AACjB,UAAM,OAAO,IAAI,SAAS,MAAM,EAAE;AAAA,EACtC,CAAC;AACD,SAAO;AACX;AAEO,SAAS,gBAAgB,IAAY;AACxC,SAAO,2BAAU,KAAK,MAAM,KAAK,YAAY,EAAE,CAAC,EAAE,QAAQ,WAAS,CAAC,SAAS,GAAG,QAAQ,GAAI,CAAC,CAAC;AAClG;AAEO,SAAS,cAAc,KAAa,KAAa,MAAc;AAClE,MAAI,OAAO,GAAG,GAAG;AAEb,QAAI,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,IAAI,EAAG,QAAO;AAC1C,UAAM,YAAY,aAAa,GAAG;AAClC,UAAM,YAAY,aAAa,GAAG;AAClC,UAAM,aAAa,aAAa,IAAI;AAEpC,YAAQ,YAAY,iBAAiB,YAAY;AAAA,EACrD,OAAO;AAEH,QAAI,OAAO,GAAG,KAAK,OAAO,IAAI,EAAG,QAAO;AACxC,UAAM,WAAW,YAAY,GAAG;AAChC,UAAM,WAAW,YAAY,GAAG;AAChC,UAAM,YAAY,YAAY,IAAI;AAElC,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AACzB,YAAMA,QAAO,UAAU,CAAC;AACxB,UAAIA,UAAS,EAAG,QAAO;AACvB,WAAK,SAAS,CAAC,IAAIA,YAAW,SAAS,CAAC,IAAIA,OAAO,QAAO;AAAA,IAC9D;AAAA,EACJ;AACJ;",
  "names": ["mask"]
}
