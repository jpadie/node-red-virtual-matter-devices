{
  "version": 3,
  "sources": ["../../../src/util/Type.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport type Properties = { [key: string]: any };\n\n/** Merges two types into one. */\nexport type Merge<A extends Properties, B extends Properties> = {\n    [K in keyof A as K extends keyof B ? never : K]: A[K];\n} & B;\n\nexport function Merge<A extends Properties, B extends Properties>(a: A, b: B): Merge<A, B> {\n    return { ...a, ...b };\n}\n\n/** Type that represents a class constructor of a defined type or extend of it */\nexport type ClassExtends<C> = { new (...args: any[]): C };\n\n/** Merge an array of objects into one.  Currently assumes unique elements */\nexport type MergeAll<T> = T extends [infer O extends Properties | undefined, ...infer R]\n    ? O extends undefined\n        ? MergeAll<R>\n        : O & MergeAll<R>\n    : T extends []\n      ? {}\n      : never;\n\nexport function MergeAll<T extends (Properties | undefined)[]>(...objects: readonly [...T]): MergeAll<T> {\n    return Object.assign({}, ...objects);\n}\n\n/** Pluck an item from an array of objects if present */\nexport type Pluck<K, T extends readonly [...any]> = T extends [infer O, ...infer R]\n    ? K extends keyof O\n        ? [O[K], ...Pluck<K, R>]\n        : Pluck<K, R>\n    : T extends []\n      ? T\n      : never;\n\nexport function Pluck<T extends Properties[], K extends keyof T[number]>(\n    key: K,\n    ...objects: readonly [...T]\n): Pluck<K, T> {\n    return objects.map(o => (o as any)[key]).filter(o => o !== undefined) as any;\n}\n\n/** Same as \"a == undefined\" but keeps the kids happy */\nexport function isNullish(a: any) {\n    return a === undefined || a === null;\n}\n\nexport type MakeMandatory<T> = Exclude<T, undefined>;\n\n/** Create a branded type */\ndeclare const __brand: unique symbol;\n// Don't think it should be necessary to export Brand<B> but it will cause\n// the following error under some circumstances:\n//\n//   Exported variable 'XXX' has or is using name '__brand' from external\n//   module \"../src/util/Type\" but cannot be named.ts(4023)\n//\n// Specifically this occurs with the reference to Cluster.id in the \"complete\"\n// cluster definitions\nexport type Brand<B> = { [__brand]: B };\nexport type Branded<T, B> = T & Brand<B>;\n\n/**\n * Make a type immutable.\n *\n * TODO - might need to extend depending type (e.g. doesn't handle Maps, Sets or Promises yet)\n *\n * Good reference implementation here:\n *\n *     https://github.com/ts-essentials/ts-essentials/blob/master/lib/deep-readonly/index.ts\n */\nexport type Immutable<T> = T extends (...args: any[]) => any\n    ? T\n    : T extends number // Necessary for our \"branded\" IDs\n      ? T\n      : T extends bigint\n        ? T\n        : T extends object\n          ? { readonly [K in keyof T]: Immutable<T[K]> }\n          : T;\n\nexport type Mutable<T> = T extends (...args: any[]) => any\n    ? T\n    : T extends number // Necessary for our \"branded\" IDs\n      ? T\n      : T extends bigint\n        ? T\n        : T extends object\n          ? { -readonly [K in keyof T]: Mutable<T[K]> }\n          : T;\n\nexport function Mutable<T>(value: Immutable<T>): Mutable<T> {\n    return value as Mutable<T>;\n}\n\n/**\n * Convert a union to an interface.\n *\n * @see {@link https://stackoverflow.com/questions/50374908}\n */\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\n\n/**\n * An identity type.\n *\n * You can't do:\n *\n *     interface Foo extends typeof Bar {}\n *\n * But you can do:\n *\n *     interface Foo extends Identity<typeof Bar> {}\n *\n * Without this type you'd have to do:\n *\n *     interface FooType = typeof Bar;\n *     interface Foo extends FooType {};\n *\n * We have to do this a lot because we generate complex objects with detailed\n * type information.  When exported, TS (as of 5.2) inlines the type of these\n * objects in declarations which makes our declarations massive.  To avoid this\n * we create an interface from the type then cast to the interface for export.\n */\nexport type Identity<T> = T;\n\n/**\n * Tests whether the given variable is a real object and not an Array\n * @param it The variable to test\n * @returns true if it is Record<string, any>\n */\nexport function isObject(it: unknown): it is Record<string, unknown> {\n    // This is necessary because:\n    // typeof null === 'object'\n    // typeof [] === 'object'\n    // [] instanceof Object === true\n    return Object.prototype.toString.call(it) === \"[object Object]\"; // this code is 25% faster than below one\n    // return it && typeof it === 'object' && !(it instanceof Array);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaO,SAAS,MAAkD,GAAM,GAAmB;AACvF,SAAO,EAAE,GAAG,GAAG,GAAG,EAAE;AACxB;AAcO,SAAS,YAAkD,SAAuC;AACrG,SAAO,OAAO,OAAO,CAAC,GAAG,GAAG,OAAO;AACvC;AAWO,SAAS,MACZ,QACG,SACQ;AACX,SAAO,QAAQ,IAAI,OAAM,EAAU,GAAG,CAAC,EAAE,OAAO,OAAK,MAAM,MAAS;AACxE;AAGO,SAAS,UAAU,GAAQ;AAC9B,SAAO,MAAM,UAAa,MAAM;AACpC;AA8CO,SAAS,QAAW,OAAiC;AACxD,SAAO;AACX;AAqCO,SAAS,SAAS,IAA4C;AAKjE,SAAO,OAAO,UAAU,SAAS,KAAK,EAAE,MAAM;AAElD;",
  "names": []
}
