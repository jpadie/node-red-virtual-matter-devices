{
  "version": 3,
  "sources": ["../../../src/mdns/MdnsServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    DnsCodec,\n    DnsMessage,\n    DnsMessagePartiallyPreEncoded,\n    DnsMessageType,\n    DnsRecord,\n    DnsRecordType,\n    MAX_MDNS_MESSAGE_SIZE,\n} from \"../codec/DnsCodec.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { Network } from \"../net/Network.js\";\nimport { UdpMulticastServer } from \"../net/UdpMulticastServer.js\";\nimport { Time } from \"../time/Time.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { AsyncCache } from \"../util/Cache.js\";\nimport { isDeepEqual } from \"../util/DeepEqual.js\";\n\nconst logger = Logger.get(\"MdnsServer\");\n\nexport const MDNS_BROADCAST_IPV4 = \"224.0.0.251\";\nexport const MDNS_BROADCAST_IPV6 = \"ff02::fb\";\nexport const MDNS_BROADCAST_PORT = 5353;\n\nexport enum AnnouncementType {\n    Commissionable,\n    Operative,\n}\n\nexport class MdnsServer {\n    static async create(network: Network, options?: { enableIpv4?: boolean; netInterface?: string }) {\n        const { enableIpv4 = true, netInterface } = options ?? {};\n        return new MdnsServer(\n            network,\n            await UdpMulticastServer.create({\n                network,\n                netInterface,\n                broadcastAddressIpv4: enableIpv4 ? MDNS_BROADCAST_IPV4 : undefined,\n                broadcastAddressIpv6: MDNS_BROADCAST_IPV6,\n                listeningPort: MDNS_BROADCAST_PORT,\n            }),\n            netInterface,\n        );\n    }\n\n    #recordsGenerator = new Map<string, (netInterface: string) => Promise<DnsRecord<any>[]>>();\n    readonly #records = new AsyncCache<Map<string, DnsRecord<any>[]>>(\n        \"MDNS discovery\",\n        async (multicastInterface: string) => {\n            const portTypeMap = new Map<string, DnsRecord<any>[]>();\n            for (const [announceTypePort, generator] of this.#recordsGenerator) {\n                portTypeMap.set(announceTypePort, await generator(multicastInterface));\n            }\n            return portTypeMap;\n        },\n        15 * 60 * 1000 /* 15mn - also matches maximum commissioning window time. */,\n    );\n    readonly #recordLastSentAsMulticastAnswer = new Map<string, number>();\n\n    readonly #network: Network;\n    readonly #multicastServer: UdpMulticastServer;\n    readonly #netInterface: string | undefined;\n\n    constructor(network: Network, multicastServer: UdpMulticastServer, netInterface: string | undefined) {\n        multicastServer.onMessage(\n            (message, remoteIp, netInterface) => void this.#handleDnsMessage(message, remoteIp, netInterface),\n        );\n        this.#network = network;\n        this.#multicastServer = multicastServer;\n        this.#netInterface = netInterface;\n    }\n\n    buildDnsRecordKey(record: DnsRecord<any>, netInterface?: string) {\n        return `${record.name}-${record.recordClass}-${record.recordType}-${netInterface}`;\n    }\n\n    buildTypePortKey(type: AnnouncementType, port: number) {\n        return `${port}-${type}`;\n    }\n\n    isKeyForPort(key: string, port: number) {\n        return key.startsWith(`${port}-`);\n    }\n\n    async #handleDnsMessage(messageBytes: ByteArray, remoteIp: string, netInterface: string) {\n        // This message was on a subnet not supported by this device\n        if (netInterface === undefined) return;\n        const records = await this.#records.get(netInterface);\n\n        // No need to process the DNS message if there are no records to serve\n        if (records.size === 0) return;\n\n        const message = DnsCodec.decode(messageBytes);\n        if (message === undefined) return; // The message cannot be parsed\n        const { transactionId, messageType, queries, answers: knownAnswers } = message;\n        if (messageType !== DnsMessageType.Query && messageType !== DnsMessageType.TruncatedQuery) return;\n        if (queries.length === 0) return; // No queries to answer, can happen in a TruncatedQuery, let's ignore for now\n        for (const portRecords of records.values()) {\n            let answers = queries.flatMap(query => this.#queryRecords(query, portRecords));\n            if (answers.length === 0) continue;\n\n            // Only send additional records if the query is not for A or AAAA records\n            let additionalRecords =\n                queries.find(\n                    query => query.recordType !== DnsRecordType.A && query.recordType !== DnsRecordType.AAAA,\n                ) !== undefined\n                    ? portRecords.filter(record => !answers.includes(record) && record.recordType !== DnsRecordType.PTR)\n                    : [];\n            if (knownAnswers.length > 0) {\n                for (const knownAnswersRecord of knownAnswers) {\n                    answers = answers.filter(record => !isDeepEqual(record, knownAnswersRecord));\n                    if (answers.length === 0) break; // Nothing to send\n                }\n                if (answers.length === 0) continue; // Nothing to send\n                if (additionalRecords.length > 0) {\n                    for (const knownAnswersRecord of knownAnswers) {\n                        additionalRecords = additionalRecords.filter(\n                            record => !isDeepEqual(record, knownAnswersRecord),\n                        );\n                    }\n                }\n            }\n\n            const now = Time.nowMs();\n            let uniCastResponse = queries.filter(query => !query.uniCastResponse).length === 0;\n            const answersTimeSinceLastMultiCast = answers.map(answer => ({\n                timeSinceLastMultiCast:\n                    now -\n                    (this.#recordLastSentAsMulticastAnswer.get(this.buildDnsRecordKey(answer, netInterface)) ?? 0),\n                ttl: answer.ttl,\n            }));\n            if (\n                uniCastResponse &&\n                answersTimeSinceLastMultiCast.filter(\n                    ({ timeSinceLastMultiCast, ttl }) => timeSinceLastMultiCast > (ttl / 4) * 1000,\n                ).length > 0\n            ) {\n                // If the query is for unicast response, still send as multicast if they were last sent as multicast longer then 1/4 of their ttl\n                uniCastResponse = false;\n            }\n            if (!uniCastResponse) {\n                answers = answers.filter(\n                    (_, index) => answersTimeSinceLastMultiCast[index].timeSinceLastMultiCast > 1000,\n                );\n                if (answers.length === 0) continue; // Nothing to send\n\n                answers.forEach(answer =>\n                    this.#recordLastSentAsMulticastAnswer.set(this.buildDnsRecordKey(answer, netInterface), now),\n                );\n            }\n\n            this.#sendRecords(\n                {\n                    messageType: DnsMessageType.Response,\n                    transactionId,\n                    answers,\n                    additionalRecords,\n                },\n                netInterface,\n                uniCastResponse ? remoteIp : undefined,\n            ).catch(error => {\n                logger.warn(`Failed to send mDNS response to ${remoteIp}`, error);\n            });\n            await Time.sleep(\"MDNS delay\", 20 + Math.floor(Math.random() * 100)); // as per DNS-SD spec wait 20-120ms before sending more packets\n        }\n    }\n\n    async #announceRecordsForInterface(netInterface: string, records: DnsRecord<any>[]) {\n        const answers = records.filter(({ recordType }) => recordType === DnsRecordType.PTR);\n        const additionalRecords = records.filter(({ recordType }) => recordType !== DnsRecordType.PTR);\n\n        await this.#sendRecords(\n            {\n                messageType: DnsMessageType.Response,\n                answers,\n                additionalRecords,\n            },\n            netInterface,\n        );\n    }\n\n    async #sendRecords(dnsMessageData: Partial<DnsMessage>, netInterface: string, unicastTarget?: string) {\n        const { answers = [], additionalRecords = [] } = dnsMessageData;\n        const answersToSend = [...answers];\n        const additionalRecordsToSend = [...additionalRecords];\n\n        const dnsMessageDataToSend = {\n            ...dnsMessageData,\n            answers: [],\n            additionalRecords: [],\n        } as DnsMessagePartiallyPreEncoded;\n\n        const emptyDnsMessage = DnsCodec.encode(dnsMessageDataToSend);\n        let dnsMessageSize = emptyDnsMessage.length;\n\n        while (true) {\n            if (answersToSend.length > 0) {\n                const nextAnswer = answersToSend.shift();\n                if (nextAnswer === undefined) {\n                    break;\n                }\n\n                const nextAnswerEncoded = DnsCodec.encodeRecord(nextAnswer);\n                dnsMessageSize += nextAnswerEncoded.length; // Add additional record as long as size is ok\n\n                if (dnsMessageSize > MAX_MDNS_MESSAGE_SIZE) {\n                    // New answer do not fit anymore, send out the message\n                    await this.#multicastServer.send(\n                        DnsCodec.encode(dnsMessageDataToSend),\n                        netInterface,\n                        unicastTarget,\n                    );\n\n                    // Reset the message, length counter and included answers to count for next message\n                    dnsMessageDataToSend.answers.length = 0;\n                    dnsMessageSize = emptyDnsMessage.length + nextAnswerEncoded.length;\n                }\n                dnsMessageDataToSend.answers.push(nextAnswerEncoded);\n            } else {\n                break;\n            }\n        }\n\n        for (const additionalRecord of additionalRecordsToSend) {\n            const additionalRecordEncoded = DnsCodec.encodeRecord(additionalRecord);\n            dnsMessageSize += additionalRecordEncoded.length; // Add additional record as long as size is ok\n            if (dnsMessageSize > MAX_MDNS_MESSAGE_SIZE) {\n                break;\n            }\n            dnsMessageDataToSend.additionalRecords.push(additionalRecordEncoded);\n        }\n\n        await this.#multicastServer.send(DnsCodec.encode(dnsMessageDataToSend), netInterface, unicastTarget);\n    }\n\n    async announce(announcedNetPort?: number) {\n        await Promise.all(\n            (await this.#getMulticastInterfacesForAnnounce()).map(async ({ name: netInterface }) => {\n                const records = await this.#records.get(netInterface);\n                for (const [portType, portTypeRecords] of records) {\n                    if (announcedNetPort !== undefined && !this.isKeyForPort(portType, announcedNetPort)) continue;\n\n                    // TODO: try to combine the messages to avoid sending multiple messages but keep under 1500 bytes per message\n                    await this.#announceRecordsForInterface(netInterface, portTypeRecords);\n                    await Time.sleep(\"MDNS delay\", 20 + Math.floor(Math.random() * 100)); // as per DNS-SD spec wait 20-120ms before sending more packets\n                }\n            }),\n        );\n    }\n\n    async expireAnnouncements(announcedNetPort?: number, type?: AnnouncementType) {\n        await Promise.all(\n            this.#records.keys().map(async netInterface => {\n                const records = await this.#records.get(netInterface);\n                for (const [portType, portTypeRecords] of records) {\n                    if (announcedNetPort !== undefined && !this.isKeyForPort(portType, announcedNetPort)) continue;\n                    if (\n                        announcedNetPort !== undefined &&\n                        type !== undefined &&\n                        portType !== this.buildTypePortKey(type, announcedNetPort)\n                    )\n                        continue;\n                    let instanceName: string | undefined;\n                    portTypeRecords.forEach(record => {\n                        record.ttl = 0;\n                        if (instanceName === undefined && record.recordType === DnsRecordType.TXT) {\n                            instanceName = record.name;\n                        }\n                    });\n                    logger.debug(\n                        `Expiring records`,\n                        Diagnostic.dict({\n                            instanceName,\n                            port: announcedNetPort,\n                            netInterface,\n                        }),\n                    );\n\n                    // TODO: try to combine the messages to avoid sending multiple messages but keep under 1500 bytes per message\n                    await this.#announceRecordsForInterface(netInterface, portTypeRecords);\n                    this.#recordsGenerator.delete(portType);\n                    await Time.sleep(\"MDNS delay\", 20 + Math.floor(Math.random() * 100)); // as per DNS-SD spec wait 20-120ms before sending more packets\n                }\n            }),\n        );\n        await this.#records.clear();\n        this.#recordLastSentAsMulticastAnswer.clear();\n    }\n\n    async setRecordsGenerator(\n        hostPort: number,\n        type: AnnouncementType,\n        generator: (netInterface: string) => Promise<DnsRecord<any>[]>,\n    ) {\n        await this.#records.clear();\n        this.#recordLastSentAsMulticastAnswer.clear();\n        this.#recordsGenerator.set(this.buildTypePortKey(type, hostPort), generator);\n    }\n\n    async close() {\n        await this.#records.close();\n        this.#recordLastSentAsMulticastAnswer.clear();\n        await this.#multicastServer.close();\n    }\n\n    #getMulticastInterfacesForAnnounce() {\n        return this.#netInterface === undefined ? this.#network.getNetInterfaces() : [{ name: this.#netInterface }];\n    }\n\n    #queryRecords({ name, recordType }: { name: string; recordType: DnsRecordType }, records: DnsRecord<any>[]) {\n        if (recordType === DnsRecordType.ANY) {\n            return records.filter(record => record.name === name);\n        } else {\n            return records.filter(record => record.name === name && record.recordType === recordType);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["AnnouncementType", "netInterface"]
}
