{
  "version": 3,
  "sources": ["../../../src/mdns/MdnsBroadcaster.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { AAAARecord, ARecord, DnsRecord, PtrRecord, SrvRecord, TxtRecord } from \"../codec/DnsCodec.js\";\nimport {\n    CommissionerInstanceData,\n    CommissioningModeInstanceData,\n    OperationalInstanceData,\n    PairingHintBitmap,\n    PairingHintBitmapSchema,\n} from \"../common/InstanceBroadcaster.js\";\nimport { ImplementationError } from \"../common/MatterError.js\";\nimport { Crypto } from \"../crypto/Crypto.js\";\nimport { FabricIndex } from \"../datatype/FabricIndex.js\";\nimport { NodeId } from \"../datatype/NodeId.js\";\nimport { Fabric } from \"../fabric/Fabric.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { Network } from \"../net/Network.js\";\nimport { TypeFromPartialBitSchema } from \"../schema/BitmapSchema.js\";\nimport {\n    SESSION_ACTIVE_INTERVAL_MS,\n    SESSION_ACTIVE_THRESHOLD_MS,\n    SESSION_IDLE_INTERVAL_MS,\n} from \"../session/Session.js\";\nimport { isIPv4, isIPv6 } from \"../util/Ip.js\";\nimport { BasicSet } from \"../util/Set.js\";\nimport {\n    MATTER_COMMISSIONER_SERVICE_QNAME,\n    MATTER_COMMISSION_SERVICE_QNAME,\n    MATTER_SERVICE_QNAME,\n    SERVICE_DISCOVERY_QNAME,\n    getCommissioningModeQname,\n    getDeviceInstanceQname,\n    getDeviceMatterQname,\n    getDeviceTypeQname,\n    getFabricQname,\n    getLongDiscriminatorQname,\n    getShortDiscriminatorQname,\n    getVendorQname,\n} from \"./MdnsConsts.js\";\nimport { MdnsInstanceBroadcaster } from \"./MdnsInstanceBroadcaster.js\";\nimport { AnnouncementType, MdnsServer } from \"./MdnsServer.js\";\n\nconst logger = Logger.get(\"MdnsBroadcaster\");\n\n//const TCP_SUPPORTED = 0;\n//const ICD_SUPPORTED = 0; // TODO: Implement ICD later\nconst DEFAULT_PAIRING_HINT = {\n    powerCycle: true,\n    deviceManual: true,\n};\n\n/**\n * This class is handing MDNS Announcements for multiple instances/devices\n */\nexport class MdnsBroadcaster {\n    readonly #activeCommissioningAnnouncements = new Set<number>();\n    readonly #activeOperationalAnnouncements = new Map<number, FabricIndex[]>();\n    readonly #network: Network;\n    readonly #mdnsServer: MdnsServer;\n    readonly #enableIpv4?: boolean;\n    readonly #instances = new BasicSet<MdnsInstanceBroadcaster>();\n\n    static async create(network: Network, options?: { enableIpv4?: boolean; multicastInterface?: string }) {\n        const { enableIpv4, multicastInterface } = options ?? {};\n        return new MdnsBroadcaster(\n            network,\n            await MdnsServer.create(network, { enableIpv4, netInterface: multicastInterface }),\n            enableIpv4,\n        );\n    }\n\n    constructor(network: Network, mdnsServer: MdnsServer, enableIpv4?: boolean) {\n        this.#network = network;\n        this.#mdnsServer = mdnsServer;\n        this.#enableIpv4 = enableIpv4;\n    }\n\n    createInstanceBroadcaster(port: number) {\n        const instance = new MdnsInstanceBroadcaster(port, this, () => {\n            this.#instances.delete(instance);\n        });\n        this.#instances.add(instance);\n\n        return instance;\n    }\n\n    #validateCommissioningData(data: CommissioningModeInstanceData) {\n        const { sessionIdleInterval, sessionActiveInterval, sessionActiveThreshold } = data;\n\n        if (sessionIdleInterval !== undefined && sessionIdleInterval > 3_600_000) {\n            throw new ImplementationError(\"Session Idle Interval must be less than 1 hour\");\n        }\n        if (sessionActiveInterval !== undefined && sessionActiveInterval > 3_600_000) {\n            throw new ImplementationError(\"Session Active Interval must be less than 1 hour\");\n        }\n        if (sessionActiveThreshold !== undefined && sessionActiveThreshold > 65_535) {\n            throw new ImplementationError(\"Session Active Threshold must be less than 65535 seconds\");\n        }\n    }\n\n    #validatePairingInstructions(\n        pairingHint: TypeFromPartialBitSchema<typeof PairingHintBitmap>,\n        pairingInstructions: string,\n    ) {\n        const needsInstructions = [\n            \"customInstruction\",\n            \"pressRestButtonForNumberOfSeconds\",\n            \"pressResetButtonUntilLightBlinks\",\n            \"pressResetButtonForNumberOfSecondsWithApplicationOfPower\",\n            \"pressResetButtonUntilLightBlinksWithApplicationOfPower\",\n            \"pressResetButtonNumberOfTimes\",\n            \"pressSetupButtonForNumberOfSeconds\",\n            \"pressSetupButtonUntilLightBlinks\",\n            \"pressSetupButtonForNumberOfSecondsWithApplicationOfPower\",\n            \"pressSetupButtonUntilLightBlinksWithApplicationOfPower\",\n            \"pressSetupButtonNumberOfTimes\",\n        ].find(hint => (pairingHint as any)[hint] === true);\n        if (needsInstructions && pairingInstructions.length === 0) {\n            throw new ImplementationError(\n                `Pairing instructions required for Pairing Hint of type \"${needsInstructions}\"`,\n            );\n        }\n    }\n\n    #getIpRecords(hostname: string, ips: string[]) {\n        const records = new Array<DnsRecord<any>>();\n        ips.forEach(ip => {\n            if (isIPv6(ip)) {\n                records.push(AAAARecord(hostname, ip));\n            } else if (isIPv4(ip)) {\n                if (this.#enableIpv4) {\n                    records.push(ARecord(hostname, ip));\n                }\n            } else {\n                logger.warn(`Unknown IP address type: ${ip}`);\n            }\n        });\n        return records;\n    }\n\n    /** Set the Broadcaster data to announce a device ready for commissioning in a special mode */\n    async setCommissionMode(\n        announcedNetPort: number,\n        mode: number,\n        commissioningModeData: CommissioningModeInstanceData,\n    ) {\n        this.#validateCommissioningData(commissioningModeData); // Throws error if invalid!\n\n        const {\n            name: deviceName,\n            deviceType,\n            vendorId,\n            productId,\n            discriminator,\n            sessionIdleInterval = SESSION_IDLE_INTERVAL_MS,\n            sessionActiveInterval = SESSION_ACTIVE_INTERVAL_MS,\n            sessionActiveThreshold = SESSION_ACTIVE_THRESHOLD_MS,\n            pairingHint = DEFAULT_PAIRING_HINT,\n            pairingInstructions = \"\",\n        } = commissioningModeData;\n        this.#validatePairingInstructions(pairingHint, pairingInstructions); // Throws error if invalid!\n\n        // When doing a commission announcement, we need to expire any previous commissioning announcements\n        await this.expireCommissioningAnnouncement(announcedNetPort);\n\n        logger.debug(\n            `Announce commissioning mode ${mode} ${deviceName} ${deviceType} ${vendorId} ${productId} ${discriminator} ${announcedNetPort}`,\n        );\n        this.#activeCommissioningAnnouncements.add(announcedNetPort);\n\n        const shortDiscriminator = (discriminator >> 8) & 0x0f;\n        const instanceId = Crypto.getRandomData(8).toHex().toUpperCase();\n        const vendorQname = getVendorQname(vendorId);\n        const deviceTypeQname = getDeviceTypeQname(deviceType);\n        const shortDiscriminatorQname = getShortDiscriminatorQname(shortDiscriminator);\n        const longDiscriminatorQname = getLongDiscriminatorQname(discriminator);\n        const commissionModeQname = getCommissioningModeQname();\n        const deviceQname = getDeviceInstanceQname(instanceId);\n\n        await this.#mdnsServer.setRecordsGenerator(\n            announcedNetPort,\n            AnnouncementType.Commissionable,\n            async netInterface => {\n                const ipMac = await this.#network.getIpMac(netInterface);\n                if (ipMac === undefined) return [];\n                const { mac, ipV4, ipV6 } = ipMac;\n                const hostname = mac.replace(/:/g, \"\").toUpperCase() + \"0000.local\";\n\n                logger.debug(\n                    \"Announcement Generator: Commission mode \",\n                    Diagnostic.dict({\n                        mode,\n                        qname: deviceQname,\n                        port: announcedNetPort,\n                        interface: netInterface,\n                    }),\n                );\n\n                const records = [\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, MATTER_COMMISSION_SERVICE_QNAME),\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, vendorQname),\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, deviceTypeQname),\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, shortDiscriminatorQname),\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, longDiscriminatorQname),\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, commissionModeQname),\n                    PtrRecord(MATTER_COMMISSION_SERVICE_QNAME, deviceQname),\n                    PtrRecord(vendorQname, deviceQname),\n                    PtrRecord(deviceTypeQname, deviceQname),\n                    PtrRecord(shortDiscriminatorQname, deviceQname),\n                    PtrRecord(longDiscriminatorQname, deviceQname),\n                    PtrRecord(commissionModeQname, deviceQname),\n                    SrvRecord(deviceQname, { priority: 0, weight: 0, port: announcedNetPort, target: hostname }),\n                    TxtRecord(deviceQname, [\n                        `VP=${vendorId}+${productId}` /* Vendor / Product */,\n                        `DT=${deviceType}` /* Device Type */,\n                        `DN=${deviceName}` /* Device Name */,\n                        `SII=${sessionIdleInterval}` /* Session Idle Interval */,\n                        `SAI=${sessionActiveInterval}` /* Session Active Interval */,\n                        `SAT=${sessionActiveThreshold}` /* Session Active Threshold */,\n                        //`T=${TCP_SUPPORTED}` /* TCP not supported */,\n                        `D=${discriminator}` /* Discriminator */,\n                        `CM=${mode}` /* Commission Mode */,\n                        `PH=${PairingHintBitmapSchema.encode(pairingHint)}` /* Pairing Hint */,\n                        `PI=${pairingInstructions}` /* Pairing Instruction */,\n                        //`ICD=${ICD_SUPPORTED}` /* ICD not supported */,\n                    ]),\n                ];\n                records.push(...this.#getIpRecords(hostname, [...ipV6, ...ipV4]));\n                return records;\n            },\n        );\n    }\n\n    /** Set the Broadcaster Data to announce a device for operative discovery (aka \"already paired\") */\n    async setFabrics(\n        announcedNetPort: number,\n        fabrics: Fabric[],\n        {\n            sessionIdleInterval = SESSION_IDLE_INTERVAL_MS,\n            sessionActiveInterval = SESSION_ACTIVE_INTERVAL_MS,\n            sessionActiveThreshold = SESSION_ACTIVE_THRESHOLD_MS,\n        }: OperationalInstanceData = {},\n    ) {\n        const currentOperationalFabrics = this.#activeOperationalAnnouncements.get(announcedNetPort);\n        if (currentOperationalFabrics !== undefined) {\n            const fabricIndexesSet = new Set(fabrics.map(f => f.fabricIndex));\n\n            // Expire Fabric announcements if any entry got removed\n            if (!currentOperationalFabrics.every(fabricIndex => fabricIndexesSet.has(fabricIndex))) {\n                await this.expireFabricAnnouncement(announcedNetPort);\n            }\n        }\n\n        this.#activeOperationalAnnouncements.set(\n            announcedNetPort,\n            fabrics.map(f => f.fabricIndex),\n        );\n\n        await this.#mdnsServer.setRecordsGenerator(announcedNetPort, AnnouncementType.Operative, async netInterface => {\n            const ipMac = await this.#network.getIpMac(netInterface);\n            if (ipMac === undefined) return [];\n            const { mac, ipV4, ipV6 } = ipMac;\n            const hostname = mac.replace(/:/g, \"\").toUpperCase() + \"0000.local\";\n\n            const records: DnsRecord<any>[] = [PtrRecord(SERVICE_DISCOVERY_QNAME, MATTER_SERVICE_QNAME)];\n            fabrics.forEach(fabric => {\n                const { operationalId, nodeId } = fabric;\n                const operationalIdString = operationalId.toHex().toUpperCase();\n                const fabricQname = getFabricQname(operationalIdString);\n                const deviceMatterQname = getDeviceMatterQname(operationalIdString, NodeId.toHexString(nodeId));\n\n                logger.debug(\n                    \"Announcement Generator: Fabric\",\n                    Diagnostic.dict({\n                        id: `${operationalId.toHex()}/${nodeId}`,\n                        qname: deviceMatterQname,\n                        port: announcedNetPort,\n                        interface: netInterface,\n                    }),\n                );\n                const fabricRecords = [\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, fabricQname),\n                    PtrRecord(MATTER_SERVICE_QNAME, deviceMatterQname),\n                    PtrRecord(fabricQname, deviceMatterQname),\n                    SrvRecord(deviceMatterQname, { priority: 0, weight: 0, port: announcedNetPort, target: hostname }),\n                    TxtRecord(deviceMatterQname, [\n                        `SII=${sessionIdleInterval}` /* Session Idle Interval */,\n                        `SAI=${sessionActiveInterval}` /* Session Active Interval */,\n                        `SAT=${sessionActiveThreshold}` /* Session Active Threshold */,\n                        //`T=${TCP_SUPPORTED}` /* TCP not supported */,\n                        //`ICD=${ICD_SUPPORTED}` /* ICD not supported */,\n                    ]),\n                ];\n                records.push(...fabricRecords);\n            });\n            records.push(...this.#getIpRecords(hostname, [...ipV6, ...ipV4]));\n            return records;\n        });\n    }\n\n    /** Set the Broadcaster data to announce a Commissioner (aka Commissioner discovery) */\n    async setCommissionerInfo(\n        announcedNetPort: number,\n        {\n            deviceName,\n            deviceType,\n            vendorId,\n            productId,\n            sessionIdleInterval = SESSION_IDLE_INTERVAL_MS,\n            sessionActiveInterval = SESSION_ACTIVE_INTERVAL_MS,\n            sessionActiveThreshold = SESSION_ACTIVE_THRESHOLD_MS,\n        }: CommissionerInstanceData,\n    ) {\n        logger.debug(\n            \"Announcement: Commissioner\",\n            Diagnostic.dict({\n                port: announcedNetPort,\n                deviceType,\n            }),\n        );\n\n        const instanceId = Crypto.getRandomData(8).toHex().toUpperCase();\n        const deviceTypeQname = `_T${deviceType}._sub.${MATTER_COMMISSIONER_SERVICE_QNAME}`;\n        const vendorQname = `_V${vendorId}._sub.${MATTER_COMMISSIONER_SERVICE_QNAME}`;\n        const deviceQname = `${instanceId}.${MATTER_COMMISSIONER_SERVICE_QNAME}`;\n\n        this.#activeCommissioningAnnouncements.add(announcedNetPort);\n\n        await this.#mdnsServer.setRecordsGenerator(\n            announcedNetPort,\n            AnnouncementType.Commissionable,\n            async netInterface => {\n                const ipMac = await this.#network.getIpMac(netInterface);\n                if (ipMac === undefined) return [];\n                const { mac, ipV4, ipV6 } = ipMac;\n                const hostname = mac.replace(/:/g, \"\").toUpperCase() + \"0000.local\";\n                const records = [\n                    PtrRecord(SERVICE_DISCOVERY_QNAME, MATTER_COMMISSIONER_SERVICE_QNAME),\n                    PtrRecord(MATTER_COMMISSIONER_SERVICE_QNAME, vendorQname),\n                    PtrRecord(vendorQname, deviceQname),\n                    SrvRecord(deviceQname, { priority: 0, weight: 0, port: announcedNetPort, target: hostname }),\n                    TxtRecord(deviceQname, [\n                        `VP=${vendorId}+${productId}` /* Vendor / Product */,\n                        `DT=${deviceType}` /* Device Type */,\n                        `DN=${deviceName}` /* Device Name */,\n                        `SII=${sessionIdleInterval}` /* Session Idle Interval */,\n                        `SAI=${sessionActiveInterval}` /* Session Active Interval */,\n                        `SAT=${sessionActiveThreshold}` /* Session Active Threshold */,\n                        //`T=${TCP_SUPPORTED}` /* TCP not supported */,\n                        //`ICD=${ICD_SUPPORTED}` /* ICD not supported */,\n                    ]),\n                ];\n                if (deviceType !== undefined) {\n                    records.push(PtrRecord(SERVICE_DISCOVERY_QNAME, deviceTypeQname));\n                    records.push(PtrRecord(deviceTypeQname, deviceQname));\n                }\n\n                records.push(...this.#getIpRecords(hostname, [...ipV6, ...ipV4]));\n                return records;\n            },\n        );\n    }\n\n    async announce(announcementPort: number) {\n        this.#mdnsServer.announce(announcementPort).catch(error => logger.error(error));\n    }\n\n    async expireFabricAnnouncement(announcementPort: number) {\n        if (this.#activeOperationalAnnouncements.has(announcementPort)) {\n            await this.#mdnsServer.expireAnnouncements(announcementPort, AnnouncementType.Operative);\n            this.#activeOperationalAnnouncements.delete(announcementPort);\n        }\n    }\n\n    async expireCommissioningAnnouncement(announcementPort: number) {\n        if (this.#activeCommissioningAnnouncements.has(announcementPort)) {\n            await this.#mdnsServer.expireAnnouncements(announcementPort, AnnouncementType.Commissionable);\n            this.#activeCommissioningAnnouncements.delete(announcementPort);\n        }\n    }\n\n    async expireAllAnnouncements(announcementPort: number) {\n        if (\n            !this.#activeCommissioningAnnouncements.has(announcementPort) &&\n            !this.#activeOperationalAnnouncements.has(announcementPort)\n        )\n            return;\n        await this.#mdnsServer.expireAnnouncements(announcementPort);\n        this.#activeCommissioningAnnouncements.delete(announcementPort);\n        this.#activeOperationalAnnouncements.delete(announcementPort);\n    }\n\n    async close() {\n        while (this.#instances.size) {\n            await this.#instances.deleted;\n        }\n\n        await this.#mdnsServer.expireAnnouncements();\n        this.#activeCommissioningAnnouncements.clear();\n        this.#activeOperationalAnnouncements.clear();\n        await this.#mdnsServer.close();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
