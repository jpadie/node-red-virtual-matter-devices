{
  "version": 3,
  "sources": ["../../../src/environment/RuntimeService.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Cancellable, Destructable, Lifecycle } from \"../common/Lifecycle.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { DiagnosticSource } from \"../log/DiagnosticSource.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport { Construction, type Constructable } from \"../util/Construction.js\";\nimport { Multiplex } from \"../util/Multiplex.js\";\nimport { Observable } from \"../util/Observable.js\";\nimport type { Environment } from \"./Environment.js\";\nimport { Environmental } from \"./Environmental.js\";\n\nconst logger = Logger.get(\"Runtime\");\n\n/**\n * Handles lifecycle management of other components.\n */\nexport class RuntimeService implements Multiplex {\n    #workers = new Set<RuntimeService.Worker>();\n    #cancelled = new Set<RuntimeService.Worker>();\n    #workerDeleted = Observable<[]>();\n    #canceled = false;\n    #started = Observable<[]>();\n    #stopped = Observable<[]>();\n    #crashed = Observable<[cause: any]>();\n\n    constructor(environment: Environment) {\n        environment.set(RuntimeService, this);\n        DiagnosticSource.add(this);\n    }\n\n    /**\n     * Add a {@link Worker}.\n     *\n     * The runtime considers itself \"active\" if there are one or more workers installed.\n     *\n     * A worker must either be {@link PromiseLike} or {@link Constructable} for the runtime to detect completion. On\n     * completion the worker is removed and destroyed if the worker is {@link Destructable}.\n     *\n     * Once added, the {@link worker} is owned by the RuntimeService until closed, resolved or removed via\n     * {@link delete}.\n     */\n    add(worker: RuntimeService.Worker | void) {\n        if (!worker) {\n            return;\n        }\n\n        if (this.#workers.has(worker)) {\n            return;\n        }\n\n        this.#workers.add(worker);\n        if (this.#workers.size === 1) {\n            this.#started.emit();\n        }\n\n        // For PromiseLike just track until resolution\n        if (worker.then) {\n            Promise.resolve(worker)\n                .catch(error => this.#crash(error))\n                .finally(() => this.delete(worker));\n            return;\n        }\n\n        if (worker.construction?.change) {\n            // Constructable\n            worker.construction.change.on(status => {\n                switch (status) {\n                    case Lifecycle.Status.Crashed:\n                        this.#crash();\n                        break;\n\n                    case Lifecycle.Status.Destroyed:\n                        this.delete(worker);\n                        break;\n                }\n            });\n        } else if (worker.then) {\n            if (worker.then) {\n                Promise.resolve(worker)\n                    .catch(error => this.#crash(error))\n                    .finally(() => this.delete(worker));\n            }\n        }\n    }\n\n    /**\n     * Remove a worker.\n     */\n    delete(worker: RuntimeService.Worker) {\n        if (!this.#workers.has(worker)) {\n            return;\n        }\n\n        // Remove the worker\n        this.#workers.delete(worker);\n        this.#cancelled.delete(worker);\n        this.#workerDeleted.emit();\n\n        // If there are still non-helper workers, remain in active state\n        if (this.#workers.size) {\n            return;\n        }\n\n        // No workers except helpers; cancel helpers and exit\n        this.cancel();\n\n        // Emit stopped event when all activity stops.  Safe to ignore rejection because this promise can't reject\n        void this.inactive.finally(() => this.#stopped.emit());\n    }\n\n    /**\n     * Emits when a worker is added when previously there were none.\n     */\n    get started() {\n        return this.#started;\n    }\n\n    /**\n     * Emits when the last worker departs.\n     */\n    get stopped() {\n        return this.#stopped;\n    }\n\n    /**\n     * Emits when a worker experiences an unhandled error.\n     */\n    get crashed() {\n        return this.#crashed;\n    }\n\n    static [Environmental.create](environment: Environment) {\n        return new this(environment);\n    }\n\n    /**\n     * Cancel execution.\n     *\n     * On cancel the runtime destroys all workers.\n     */\n    cancel() {\n        if (this.#canceled) {\n            return;\n        }\n        this.#canceled = true;\n        logger.notice(\"Shutting down\");\n\n        for (const worker of this.#workers) {\n            const disposal = this.#cancelWorker(worker);\n            if (disposal) {\n                this.add(disposal);\n            }\n        }\n    }\n\n    /**\n     * Resolves when no workers are active.\n     */\n    get inactive() {\n        if (!this.#workers.size) {\n            return Promise.resolve();\n        }\n\n        return new Promise<void>(resolve => {\n            const listener = () => {\n                if (!this.#workers.size) {\n                    this.#workerDeleted.off(listener);\n                    resolve();\n                }\n            };\n            this.#workerDeleted.on(listener);\n        });\n    }\n\n    async close() {\n        this.cancel();\n        await this.inactive;\n        DiagnosticSource.delete(this);\n    }\n\n    [Symbol.asyncDispose]() {\n        return this.close();\n    }\n\n    get [Diagnostic.value]() {\n        return Diagnostic.node(\"\uD83D\uDEE0\", \"Workers\", {\n            children: [...this.#workers].map(worker => {\n                let diagnostic: unknown = worker[RuntimeService.label];\n\n                if (diagnostic === undefined) {\n                    diagnostic = worker[Diagnostic.value];\n\n                    if (diagnostic === undefined) {\n                        diagnostic = worker.toString();\n                    }\n                }\n\n                return diagnostic;\n            }),\n        });\n    }\n\n    #cancelWorker(worker: RuntimeService.Worker) {\n        if (this.#cancelled.has(worker)) {\n            return;\n        }\n\n        const cancel = () => {\n            this.#cancelled.add(worker);\n\n            if (worker.close) {\n                this.#cancelled.add(worker);\n                return Promise.resolve(worker.close()).finally(() => this.delete(worker));\n            }\n\n            if (worker[Symbol.asyncDispose]) {\n                this.#cancelled.add(worker);\n                return Promise.resolve(worker[Symbol.asyncDispose]?.()).finally(() => this.delete(worker));\n            }\n\n            if (worker[Symbol.dispose]) {\n                worker[Symbol.dispose]?.();\n                this.delete(worker);\n                return;\n            }\n\n            // No means of cancellation so we just need to wait for the worker to exit\n        };\n\n        if (worker.construction) {\n            worker.construction.onSuccess(cancel);\n            return;\n        }\n\n        return cancel();\n    }\n\n    #crash(cause?: Error) {\n        if (cause) {\n            logger.error(cause);\n        }\n        this.crashed.emit(cause);\n        this.cancel();\n    }\n}\n\nexport namespace RuntimeService {\n    export const label = Symbol(\"label\");\n\n    /**\n     * The runtime tracks individual discrete tasks as \"workers\".\n     *\n     * The state of the runtime is dependent on installed workers.  Any JS object may be a worker but the runtime's\n     * interaction with workers varies as documented here.\n     *\n     * If a worker is a {@link PromiseLike} the runtime will delete and/or destroy it on completion.\n     */\n    export interface Worker extends Partial<PromiseLike<any>>, Partial<Cancellable>, Partial<Destructable> {\n        /**\n         * If the worker supports {@link Construction}, the runtime will monitor the worker's lifecycle:\n         *\n         *   - If the worker crashed (e.g. experiences an error during initialization) the runtime will cancel all\n         *     workers and exit\n         *\n         *   - If the worker is destroyed the runtime deletes it from the set of known workers\n         */\n        construction?: Construction<any>;\n\n        /**\n         * If the worker supports {@link Symbol.asyncDispose} the runtime will invoke when the worker is no longer\n         * needed.  This happens if:\n         *\n         *   - The worker is a {@link PromiseLike} that resolves\n         *\n         *   - The worker's {@link construction} status changed as noted above\n         *\n         *   - The runtime is canceled via {@link RuntimeService.cancel}\n         */\n        [Symbol.asyncDispose]?: () => void | Promise<void>;\n\n        /**\n         * Workers may implement {@link Symbol.dispose} to handle disposal.  Works the same as the async equivalent.\n         */\n        [Symbol.dispose]?: () => void;\n\n        /**\n         * If label is present, it will be presented in diagnostics.  This takes precedence over [Diagnostic.value].\n         */\n        [label]?: unknown;\n\n        /**\n         * In diagnostics workers render using toString() unless they provide explicit diagnostics.\n         */\n        [Diagnostic.value]?: unknown;\n    }\n}\n"],
  "mappings": "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",
  "names": ["RuntimeService"]
}
