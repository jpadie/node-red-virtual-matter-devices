"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MdnsService_exports = {};
__export(MdnsService_exports, {
  MdnsService: () => MdnsService
});
module.exports = __toCommonJS(MdnsService_exports);
var import_Diagnostic = require("../log/Diagnostic.js");
var import_Logger = require("../log/Logger.js");
var import_MdnsBroadcaster = require("../mdns/MdnsBroadcaster.js");
var import_MdnsScanner = require("../mdns/MdnsScanner.js");
var import_Network = require("../net/Network.js");
var import_Construction = require("../util/Construction.js");
var import_Promises = require("../util/Promises.js");
var import_Environmental = require("./Environmental.js");
var import_VariableService = require("./VariableService.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("MDNS");
class MdnsService {
  #broadcaster;
  #scanner;
  #construction;
  #enableIpv4;
  limitedToNetInterface;
  get enableIpv4() {
    return this.#enableIpv4;
  }
  constructor(environment, options) {
    environment.set(MdnsService, this);
    environment.runtime.add(this);
    const vars = environment.get(import_VariableService.VariableService);
    this.#enableIpv4 = vars.boolean("mdns.ipv4") ?? options?.ipv4 ?? true;
    this.limitedToNetInterface = vars.get("mdns.networkInterface", options?.networkInterface);
    this.#construction = (0, import_Construction.Construction)(this, async () => {
      const network = environment.get(import_Network.Network);
      this.#broadcaster = await import_MdnsBroadcaster.MdnsBroadcaster.create(network, {
        enableIpv4: this.enableIpv4,
        multicastInterface: this.limitedToNetInterface
      });
      this.#scanner = await import_MdnsScanner.MdnsScanner.create(network, {
        enableIpv4: this.enableIpv4,
        netInterface: this.limitedToNetInterface
      });
    });
  }
  static [import_Environmental.Environmental.create](environment) {
    return new this(environment);
  }
  createInstanceBroadcaster(port) {
    return this.broadcaster.createInstanceBroadcaster(port);
  }
  get broadcaster() {
    return this.#construction.assert("MDNS broadcaster", this.#broadcaster);
  }
  get scanner() {
    return this.#construction.assert("MDNS scanner", this.#scanner);
  }
  get [import_Diagnostic.Diagnostic.value]() {
    return "MDNS";
  }
  get construction() {
    return this.#construction;
  }
  async [Symbol.asyncDispose]() {
    await this.#construction.close(async () => {
      const broadcasterDisposal = import_Promises.MaybePromise.then(
        this.#broadcaster?.close(),
        void 0,
        (e) => logger.error("Error disposing of MDNS broadcaster", e)
      );
      const scannerDisposal = import_Promises.MaybePromise.then(
        this.#scanner?.close(),
        void 0,
        (e) => logger.error("Error disposing of MDNS scanner", e)
      );
      await Promise.all([broadcasterDisposal, scannerDisposal]);
      this.#broadcaster = this.#scanner = void 0;
    });
  }
}
//# sourceMappingURL=MdnsService.js.map
