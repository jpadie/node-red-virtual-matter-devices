{
  "version": 3,
  "sources": ["../../../src/environment/Environment.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { UnsupportedDependencyError } from \"../common/Lifecycle.js\";\nimport { DiagnosticSource } from \"../log/DiagnosticSource.js\";\nimport { Logger } from \"../log/Logger.js\";\nimport \"../polyfills/disposable.js\";\nimport { Time } from \"../time/Time.js\";\nimport { Observable } from \"../util/Observable.js\";\nimport { Environmental } from \"./Environmental.js\";\nimport { RuntimeService } from \"./RuntimeService.js\";\nimport { VariableService } from \"./VariableService.js\";\n\nconst logger = Logger.get(\"Environment\");\n\n/**\n * Access to general platform-dependent features.\n *\n * The following variables are defined by this class:\n * * `log.level` - Log level to use {@link Logger.LEVEL}\n * * `log.format` - Log format to use {@link Logger.FORMAT}\n * * `log.stack.limit` - Stack trace limit, see https://nodejs.org/api/errors.html#errorstacktracelimit\n * * `mdns.networkInterface` - Network interface to use for MDNS broadcasts and scanning, default are all available interfaces\n * * `mdns.ipv4` - Also announce/scan on IPv4 interfaces\n * * `network.interface` - Map of interface names to types, expected to be defined as object with name as key and of `{type: string|number}` objects with types: 1=Wifi, 2=Ethernet, 3=Cellular, 4=Thread (strings or numbers can be used). Can also be provided via env or cli like `MATTER_NETWORK_INTERFACE_ETH0_TYPE=Ethernet`\n *\n * TODO - could remove global singletons by moving here\n */\nexport class Environment {\n    #services?: Map<abstract new (...args: any[]) => any, Environmental.Service>;\n    #name: string;\n    #parent?: Environment;\n    #added = Observable<[type: abstract new (...args: any[]) => {}, instance: {}]>();\n    #deleted = Observable<[type: abstract new (...args: any[]) => {}, instance: {}]>();\n    #serviceEvents = new Map<abstract new (...args: any[]) => any, Environmental.ServiceEvents<any>>();\n\n    constructor(name: string, parent?: Environment) {\n        this.#name = name;\n        this.#parent = parent;\n    }\n\n    /**\n     * Determine if an environmental service is available.\n     */\n    has(type: abstract new (...args: any[]) => any): boolean {\n        return this.#services?.get(type) !== undefined || (this.#parent?.has(type) ?? false);\n    }\n\n    /**\n     * Access an environmental service.\n     */\n    get<T extends object>(type: abstract new (...args: any[]) => T): T {\n        let instance = this.#services?.get(type) ?? this.#parent?.get(type);\n\n        if (instance) {\n            return instance as T;\n        }\n\n        if ((type as Environmental.Factory<T>)[Environmental.create]) {\n            this.set(type, (instance = (type as any)[Environmental.create](this)));\n            return instance as T;\n        }\n\n        throw new UnsupportedDependencyError(`Required dependency ${type.name}`, \"is not available\");\n    }\n\n    /**\n     * Remove an environmental service.\n     *\n     * @param type the class of the service to remove\n     * @param instance optional instance expected, if existing instance does not match it is not deleted\n     */\n    delete(type: abstract new (...args: any[]) => any, instance?: any) {\n        if (instance !== undefined && this.#services?.get(type) !== instance) {\n            return;\n        }\n        this.#services?.delete(type);\n        this.#parent?.delete(type);\n\n        this.#deleted.emit(type, instance);\n\n        const serviceEvents = this.#serviceEvents.get(type);\n        if (serviceEvents) {\n            serviceEvents.deleted.emit(instance);\n        }\n    }\n\n    /**\n     * Access an environmental service, waiting for any async initialization to complete.\n     */\n    async load<T extends Environmental.Service>(type: Environmental.Factory<T>) {\n        const instance = this.get(type);\n        await instance.construction;\n        return instance;\n    }\n\n    /**\n     * Install a preinitialized version of an environmental service.\n     */\n    set<T extends {}>(type: abstract new (...args: any[]) => T, instance: T) {\n        if (!this.#services) {\n            this.#services = new Map();\n        }\n        this.#services.set(type, instance as Environmental.Service);\n        this.#added.emit(type, instance);\n        const serviceEvents = this.#serviceEvents.get(type);\n        if (serviceEvents) {\n            serviceEvents.added.emit(instance);\n        }\n    }\n\n    /**\n     * Name of the environment.\n     */\n    get name() {\n        return this.#name;\n    }\n\n    /**\n     * Emits on service add.\n     *\n     * Currently only emits for services owned directly by this environment.\n     */\n    get added() {\n        return this.#added;\n    }\n\n    /**\n     * Emits on service delete.\n     *\n     * Currently only emits for services owned directly by this environment.\n     */\n    get deleted() {\n        return this.#deleted;\n    }\n\n    /**\n     * Obtain an object with events that trigger when a specific service is added or deleted.\n     *\n     * This is a more convenient way to observe a specific service than {@link added} and {@link deleted}.\n     */\n    eventsFor<T extends Environmental.Factory<any>>(type: T) {\n        let events = this.#serviceEvents.get(type);\n        if (events === undefined) {\n            events = {\n                added: new Observable(),\n                deleted: new Observable(),\n            };\n            this.#serviceEvents.set(type, events);\n        }\n        return events as Environmental.ServiceEvents<T>;\n    }\n\n    /**\n     * The default environment.\n     *\n     * Currently only emits for services owned directly by this environment.\n     */\n    static get default() {\n        return global;\n    }\n\n    /**\n     * Set the default environment.\n     */\n    static set default(env: Environment) {\n        global = env;\n\n        env.vars.use(() => {\n            Logger.level = env.vars.get(\"log.level\", Logger.level);\n            Logger.format = env.vars.get(\"log.format\", Logger.format);\n\n            const stackLimit = global.vars.number(\"log.stack.limit\");\n            if (stackLimit !== undefined) {\n                (Error as { stackTraceLimit?: number }).stackTraceLimit = stackLimit;\n            }\n        });\n    }\n\n    /**\n     * Shortcut for accessing {@link VariableService.vars}.\n     */\n    get vars() {\n        return this.get(VariableService);\n    }\n\n    /**\n     * Shortcut for accessing {@link RuntimeService}.\n     */\n    get runtime() {\n        return this.get(RuntimeService);\n    }\n\n    /**\n     * Display tasks that supply diagnostics.\n     */\n    diagnose() {\n        Time.getTimer(\"Diagnostics\", 0, () => {\n            try {\n                logger.notice(\"Diagnostics follow\", DiagnosticSource);\n            } catch (e) {\n                logger.error(`Unhandled error gathering diagnostics:`, e);\n            }\n        }).start();\n    }\n\n    protected loadVariables(): Record<string, any> {\n        return {};\n    }\n}\n\nlet global: Environment = new Environment(\"default\");\n"],
  "mappings": "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",
  "names": []
}
