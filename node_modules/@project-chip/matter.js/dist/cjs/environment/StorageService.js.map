{
  "version": 3,
  "sources": ["../../../src/environment/StorageService.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NoProviderError } from \"../common/MatterError.js\";\nimport { Diagnostic } from \"../log/Diagnostic.js\";\nimport { Storage } from \"../storage/Storage.js\";\nimport { StorageManager } from \"../storage/StorageManager.js\";\nimport { Environment } from \"./Environment.js\";\nimport { Environmental } from \"./Environmental.js\";\n\n/**\n * Service adapter for the Matter.js storage API.\n */\nexport class StorageService {\n    #factory?: (namespace: string) => Storage;\n    #location?: string;\n\n    constructor(environment: Environment, factory?: (namespace: string) => Storage) {\n        environment.set(StorageService, this);\n        this.#factory = factory;\n    }\n\n    static [Environmental.create](environment: Environment) {\n        return new this(environment);\n    }\n\n    /**\n     * Open storage.  The storage is initialized but the caller must take ownership.\n     *\n     * @param namespace a unique namespace identifier such as a root node ID\n     */\n    async open(namespace: string) {\n        if (this.#factory === undefined) {\n            throw new NoProviderError(\"Storage is unavailable because no platform implementation is installed\");\n        }\n\n        const storage = this.#factory(namespace);\n        const manager = new StorageManager(storage);\n        await manager.initialize();\n        return manager;\n    }\n\n    /**\n     * Install a factory for opening storage.  Without such a factory storage is unavailable.\n     */\n    set factory(factory: (namespace: string) => Storage) {\n        this.#factory = factory;\n    }\n\n    /**\n     * The storage location.  Only used for diagnostic purposes.\n     */\n    get location() {\n        return this.#location;\n    }\n\n    set location(location: string | undefined) {\n        this.#location = location;\n    }\n\n    [Diagnostic.value]() {\n        return [\n            \"Persistence\",\n            Diagnostic.dict({\n                location: location ?? \"(unknown)\",\n                available: !!this.#factory,\n            }),\n        ];\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,yBAAgC;AAChC,wBAA2B;AAE3B,4BAA+B;AAE/B,2BAA8B;AAX9B;AAAA;AAAA;AAAA;AAAA;AAgBO,MAAM,eAAe;AAAA,EACxB;AAAA,EACA;AAAA,EAEA,YAAY,aAA0B,SAA0C;AAC5E,gBAAY,IAAI,gBAAgB,IAAI;AACpC,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,QAAQ,mCAAc,MAAM,EAAE,aAA0B;AACpD,WAAO,IAAI,KAAK,WAAW;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,WAAmB;AAC1B,QAAI,KAAK,aAAa,QAAW;AAC7B,YAAM,IAAI,mCAAgB,wEAAwE;AAAA,IACtG;AAEA,UAAM,UAAU,KAAK,SAAS,SAAS;AACvC,UAAM,UAAU,IAAI,qCAAe,OAAO;AAC1C,UAAM,QAAQ,WAAW;AACzB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAAQ,SAAyC;AACjD,SAAK,WAAW;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAW;AACX,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,SAASA,WAA8B;AACvC,SAAK,YAAYA;AAAA,EACrB;AAAA,EAEA,CAAC,6BAAW,KAAK,IAAI;AACjB,WAAO;AAAA,MACH;AAAA,MACA,6BAAW,KAAK;AAAA,QACZ,UAAU,YAAY;AAAA,QACtB,WAAW,CAAC,CAAC,KAAK;AAAA,MACtB,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;",
  "names": ["location"]
}
