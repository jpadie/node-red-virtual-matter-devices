{
  "version": 3,
  "sources": ["../../../../src/model/definitions/FieldValue.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { UnexpectedDataError } from \"../../common/MatterError.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport { serialize as stringSerialize } from \"../../util/String.js\";\nimport type { Metatype } from \"./Metatype.js\";\n\n/**\n * A FieldValue represents a concrete value for a datatype.  Most values are primitives but some values we encode with\n * specialized typed objects so we can capture the original semantic meaning.\n */\nexport type FieldValue =\n    | null\n    | string\n    | number\n    | bigint\n    | boolean\n    | Date\n    | FieldValue[]\n    | FieldValue.Properties\n    | FieldValue.Reference\n    | FieldValue.Percent\n    | FieldValue.Celsius\n    | FieldValue.Bytes;\n\nexport namespace FieldValue {\n    // Typing with constants should be just as type safe as using an enum but simplifies type definitions\n\n    export const percent = \"percent\";\n    export type percent = typeof percent;\n\n    export const celsius = \"celsius\";\n    export type celsius = typeof celsius;\n\n    export const reference = \"reference\";\n    export type reference = typeof reference;\n\n    export const properties = \"properties\";\n    export type properties = typeof properties;\n\n    export const bytes = \"bytes\";\n    export type bytes = typeof bytes;\n\n    /**\n     * If a field value isn't a primitive type, it's an object with a type field indicating one of these types.\n     */\n    export type Type = percent | celsius | reference | properties | bytes;\n\n    /**\n     * Test for one of the special placeholder types.\n     */\n    export function is(value: FieldValue | undefined, type: Type) {\n        return value && (value as any).type === type;\n    }\n\n    /**\n     * Flag for an invalid value.  Not part of the FieldValue union but returned when casting to a field value if the\n     * cast is impossible\n     */\n    export const Invalid: unique symbol = Symbol(\"invalid\");\n    export type Invalid = typeof Invalid;\n\n    /**\n     * Reference to a named field\n     */\n    export type Reference = {\n        type: reference;\n        name: string;\n    };\n\n    export function Reference(name: string): Reference {\n        return { type: reference, name };\n    }\n\n    /**\n     * Celsius value, typically .1\u00B0C or .01\u00B0C\n     */\n    export type Celsius = {\n        type: celsius;\n        value: number;\n    };\n\n    export function Celsius(value: number): Celsius {\n        return { type: celsius, value };\n    }\n\n    /**\n     * Percent value, units of either 1% (.01) or .01% (.0001)\n     */\n    export type Percent = {\n        type: percent;\n        value: number;\n    };\n\n    export function Percent(value: number): Percent {\n        return { type: percent, value };\n    }\n\n    /**\n     * A set of struct property values keyed by name.\n     */\n    export type Properties = {\n        type: properties;\n        properties: { [name: string]: FieldValue };\n    };\n\n    /**\n     * Byte value, encoded as hex string.\n     */\n    export type Bytes = {\n        type: bytes;\n        value: string;\n    };\n\n    export function Bytes(value: ByteArray | string): Bytes {\n        return { type: bytes, value: ArrayBuffer.isView(value) ? value.toHex() : value };\n    }\n\n    /**\n     * Convert the field value to a \"defacto-standard\" form.\n     */\n    export function serialize(value: FieldValue): string {\n        if (value === null) {\n            return \"null\";\n        }\n        if (is(value, reference)) {\n            return (value as Reference).name;\n        }\n        if (is(value, celsius)) {\n            return `${(value as Celsius).value}\u00B0C`;\n        }\n        if (is(value, percent)) {\n            return `${(value as Percent).value}%';`;\n        }\n        if (is(value, properties)) {\n            return stringSerialize((value as Properties).properties) ?? \"?\";\n        }\n        return value.toString();\n    }\n\n    /**\n     * Given a type name as a hint, do our best to convert a field value to a number.\n     */\n    export function numericValue(value: FieldValue | undefined, typeName?: string) {\n        if (typeof value === \"boolean\") {\n            return value ? 1 : 0;\n        }\n\n        if (typeof value === \"number\") {\n            return value;\n        }\n\n        if (is(value, celsius)) {\n            switch (typeName) {\n                case \"temperature\":\n                case \"temp-diff\":\n                    return (value as Celsius).value * 100;\n\n                case \"temp-u8\":\n                case \"temp-s8\":\n                    return (value as Celsius).value * 10;\n            }\n\n            // Not sure how to interpret the value\n            return;\n        }\n\n        if (is(value, percent)) {\n            switch (typeName) {\n                case \"percent100ths\":\n                    return (value as Percent).value * 100;\n\n                default:\n                    return (value as Percent).value;\n            }\n        }\n    }\n\n    /**\n     * Extract object properties from the value.\n     */\n    export function objectValue(value: FieldValue | undefined) {\n        if (is(value, properties)) {\n            return (value as Properties).properties;\n        }\n    }\n\n    /**\n     * Unwrap wrapped values, leave others as-is.\n     */\n    export function unwrap(value: FieldValue | undefined, typeName?: string) {\n        if (value === null || typeof value !== \"object\" || Array.isArray(value) || value instanceof Date) {\n            return value;\n        }\n\n        const type = value.type;\n        switch (type) {\n            case \"properties\":\n                return objectValue(value);\n\n            case \"reference\":\n                // This needs to be handled at a higher level\n                return;\n\n            case \"percent\":\n            case \"celsius\":\n                return numericValue(value, typeName);\n\n            case undefined:\n                throw new UnexpectedDataError(`Field value objects must be wrappers with \"type\" field`);\n\n            default:\n                throw new UnexpectedDataError(`Unsupported wrapped object type \"${type}\"`);\n        }\n    }\n\n    /**\n     * Get the referenced name if the FieldValue is a reference.\n     */\n    export function referenced(value: FieldValue | undefined) {\n        if (is(value, reference)) {\n            return (value as Reference).name;\n        }\n    }\n\n    /**\n     * Convert an arbitrary value to a proper FieldValue.\n     *\n     * @param type casts to a native equivalent of this type\n     * @param value value to cast\n     *\n     * @returns the cast value or FieldValue.Invalid if cast is not possible\n     */\n    export function cast(type: Metatype, value: any): FieldValue | FieldValue.Invalid | undefined {\n        if (value === undefined || value === null || type === \"any\") {\n            return value;\n        }\n\n        if (value === \"null\") {\n            return null;\n        }\n\n        if (value === \"\") {\n            if (type === \"string\") {\n                return \"\";\n            }\n            return undefined;\n        }\n\n        if (FieldValue.is(value, FieldValue.reference)) {\n            return value;\n        }\n\n        switch (type) {\n            case \"string\":\n                return value.toString();\n\n            case \"boolean\":\n                if (typeof value === \"string\") {\n                    value = value.trim().toLowerCase();\n                }\n                return value !== \"false\" && value !== \"no\" && !!value;\n\n            case \"bitmap\":\n            case \"enum\":\n                if (FieldValue.is(value, FieldValue.properties) && type === \"bitmap\") {\n                    return value;\n                }\n\n                const id = Number(value);\n                if (Number.isNaN(id)) {\n                    if (typeof value === \"string\") {\n                        // Key name\n                        return value;\n                    }\n                    return;\n                }\n\n                // Value\n                return id;\n\n            case \"integer\":\n                if (typeof value === \"string\") {\n                    // Specialized support for percentages and temperatures\n                    let type: FieldValue.celsius | FieldValue.percent | undefined;\n                    if (value.endsWith(\"\u00B0C\")) {\n                        type = FieldValue.celsius;\n                    } else if (value.endsWith(\"%\")) {\n                        type = FieldValue.percent;\n                    }\n                    if (type) {\n                        value = Number.parseInt(value);\n                        if (Number.isNaN(value)) {\n                            return FieldValue.Invalid;\n                        }\n                        return { type, value };\n                    }\n\n                    // Strip off extra garbage like Number.parseInt would but BigInt doesn't\n                    const match = value.match(/^(0x[0-9a-f]+|0b[01]+|\\d+)/i);\n                    if (match) {\n                        value = match[1];\n                    }\n                }\n\n                try {\n                    switch (typeof value) {\n                        case \"string\":\n                        case \"number\":\n                        case \"bigint\":\n                        case \"boolean\":\n                            break;\n\n                        default:\n                            if (FieldValue.is(value, FieldValue.celsius) || FieldValue.is(value, FieldValue.percent)) {\n                                return value;\n                            }\n                            return FieldValue.Invalid;\n                    }\n                    const i = BigInt(value);\n                    const n = Number(i);\n                    if (BigInt(n) === i) {\n                        return n;\n                    }\n                    return i;\n                } catch (e) {\n                    if (e instanceof SyntaxError) {\n                        return FieldValue.Invalid;\n                    }\n                    throw e;\n                }\n\n            case \"float\":\n                const float = Number(value);\n                if (Number.isNaN(float)) {\n                    return FieldValue.Invalid;\n                }\n                return float.valueOf();\n\n            case \"date\":\n                if (value instanceof Date) {\n                    return value;\n                }\n                if (typeof value !== \"string\") {\n                    return FieldValue.Invalid;\n                }\n                value = new Date(value);\n                if (Number.isNaN(value.valueOf())) {\n                    return FieldValue.Invalid;\n                }\n                return value;\n\n            case \"object\":\n                if (FieldValue.is(value, FieldValue.properties)) {\n                    return value;\n                }\n                break;\n\n            case \"bytes\":\n                if (value === \"empty\") {\n                    return undefined;\n                }\n                if (FieldValue.is(value, FieldValue.bytes)) {\n                    return value;\n                }\n                if (typeof value === \"string\" || value instanceof Uint8Array) {\n                    return Bytes(value);\n                }\n                break;\n\n            case \"array\":\n                // Eject garbage we've seen in the spec\n                if (value === \"0\" || value === \"{0,0}\") {\n                    return;\n                }\n                if (value === \"empty\" || value === \"[]\" || value === \"{}\") {\n                    return [];\n                }\n                if (Array.isArray(value)) {\n                    return value;\n                }\n\n                // The only supported literal is an empty array\n                return FieldValue.Invalid;\n        }\n\n        return FieldValue.Invalid;\n    }\n}\n"],
  "mappings": "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",
  "names": ["FieldValue", "stringSerialize", "type"]
}
