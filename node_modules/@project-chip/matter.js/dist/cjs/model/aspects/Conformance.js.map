{
  "version": 3,
  "sources": ["../../../../src/model/aspects/Conformance.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Lexer } from \"../../parser/Lexer.js\";\nimport { BasicToken } from \"../../parser/Token.js\";\nimport { TokenStream } from \"../../parser/TokenStream.js\";\nimport { FieldValue } from \"../definitions/index.js\";\nimport { Aspect } from \"./Aspect.js\";\n\n/**\n * An operational view of conformance as defined by the Matter Specification.\n *\n * We extend the specification's syntax to add \">\", \"<\", \">=\" and \"<=\".  These are required to encode some portions of\n * the specification that are described in prose.\n *\n * \"Conformance\" controls when a data field or cluster element is allowed or required.\n */\nexport class Conformance extends Aspect<Conformance.Definition> {\n    ast: Conformance.Ast;\n\n    get type() {\n        return this.ast.type;\n    }\n\n    override get empty() {\n        return this.type === Conformance.Special.Empty;\n    }\n\n    /**\n     * Initialize from a Conformance.Definition or the conformance DSL defined by the Matter Specification.\n     */\n    constructor(definition: Conformance.Definition) {\n        super(definition);\n\n        if (definition === undefined) {\n            this.ast = { type: Conformance.Special.Empty };\n            return;\n        }\n\n        let ast: Conformance.Ast;\n        if (typeof definition === \"string\") {\n            ast = ParsedAst(this, definition);\n        } else if (Array.isArray(definition)) {\n            const asts = definition.map(def => ParsedAst(this, def));\n            if (asts.length === 1) {\n                ast = asts[0];\n            } else {\n                ast = {\n                    type: Conformance.Special.Group,\n                    param: asts,\n                };\n            }\n        } else {\n            ast = definition.ast;\n        }\n        this.ast = ast;\n    }\n\n    validateReferences(lookup: Conformance.ReferenceResolver<boolean>) {\n        return Conformance.validateReferences(this, this.ast, lookup);\n    }\n\n    /**\n     * Is the associated element mandatory?\n     *\n     * This supports a limited subset of conformance and is only appropriate for field and requirement conformance.\n     */\n    get isMandatory() {\n        const conformance = this.ast;\n        if (conformance.type === Conformance.Flag.Mandatory) {\n            return true;\n        }\n        if (conformance.type === Conformance.Special.Group) {\n            for (const c of conformance.param) {\n                if (c.type === Conformance.Flag.Provisional) {\n                    return false;\n                }\n                if (c.type === Conformance.Flag.Mandatory) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Perform limited conformance evaluation to determine whether this conformance is applicable given a feature\n     * combination.\n     *\n     * Ignores subexpressions that reference field values.\n     *\n     * This is useful for filtering elements at compile time.  For complete accuracy you then need to filter at runtime\n     * once field values are known.\n     */\n    isApplicable(features: Iterable<string>, supportedFeatures: Iterable<string>) {\n        const fset = features instanceof Set ? (features as Set<string>) : new Set(features);\n        const sfset =\n            supportedFeatures instanceof Set ? (supportedFeatures as Set<string>) : new Set(supportedFeatures);\n        return computeApplicability(fset, sfset, this.ast) !== false;\n    }\n\n    override toString() {\n        return Conformance.serialize(this.ast);\n    }\n\n    override freeze() {\n        freezeAst(this.ast);\n        super.freeze();\n    }\n}\n\nexport namespace Conformance {\n    export type AstParam =\n        | Ast.Name\n        | Ast.Value\n        | Ast.Option\n        // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n        | Ast.UnaryOperand\n        | Ast.BinaryOperands\n        | Ast.Group\n        | Ast.Choice;\n\n    export type Ast =\n        | {\n              type: Special.Empty | Special.Desc | Flag;\n          }\n        | {\n              type: Special.Name;\n              param: Ast.Name;\n          }\n        | {\n              type: Special.Value;\n              param: Ast.Value;\n          }\n        | {\n              type: Special.Choice;\n              param: Ast.Choice;\n          }\n        | {\n              type: Special.Group;\n              param: Ast.Group;\n          }\n        | {\n              type: Special.OptionalIf;\n              param: Ast.Option;\n          }\n        | {\n              type:\n                  | Operator.AND\n                  | Operator.OR\n                  | Operator.XOR\n                  | Operator.EQ\n                  | Operator.NE\n                  | Operator.LT\n                  | Operator.GT\n                  | Operator.LTE\n                  | Operator.GTE;\n              param: Ast.BinaryOperands;\n          }\n        | {\n              type: Operator.NOT;\n              param: Ast.UnaryOperand;\n          };\n\n    export namespace Ast {\n        export type Name = string;\n        export type Value = FieldValue;\n        export type Option = Ast;\n        export type UnaryOperand = Ast;\n        export type BinaryOperands = {\n            lhs: Ast;\n            rhs: Ast;\n        };\n        export type Group = Ast[];\n        export type Choice = {\n            name: ChoiceName;\n            num: number;\n            orMore?: boolean;\n            expr: Ast;\n        };\n    }\n\n    export enum Special {\n        Empty = \"empty\",\n        Desc = \"desc\",\n        Name = \"name\",\n        Value = \"value\",\n        Choice = \"choice\",\n        Group = \"group\",\n        OptionalIf = \"optionalIf\",\n    }\n\n    export enum Flag {\n        Mandatory = \"M\",\n        Optional = \"O\",\n        Provisional = \"P\",\n        Deprecated = \"D\",\n        Disallowed = \"X\",\n    }\n\n    export enum Operator {\n        NOT = \"!\",\n        EQ = \"==\",\n        NE = \"!=\",\n        OR = \"|\",\n        XOR = \"^\",\n        AND = \"&\",\n        DOT = \".\",\n        GT = \">\",\n        LT = \"<\",\n        GTE = \">=\",\n        LTE = \"<=\",\n    }\n\n    export const M = Flag.Mandatory;\n    export const O = Flag.Optional;\n    export const P = Flag.Provisional;\n    export const D = Flag.Deprecated;\n    export const X = Flag.Disallowed;\n    export const EQ = Operator.EQ;\n    export const NE = Operator.NE;\n    export const OR = Operator.OR;\n    export const XOR = Operator.XOR;\n    export const AND = Operator.AND;\n    export const DOT = Operator.DOT;\n    export const GT = Operator.GT;\n    export const LT = Operator.LT;\n    export const GTE = Operator.GTE;\n    export const LTE = Operator.LTE;\n\n    export type Name = string;\n\n    export type Number = number;\n\n    export type ChoiceName =\n        | \"a\"\n        | \"b\"\n        | \"c\"\n        | \"d\"\n        | \"e\"\n        | \"f\"\n        | \"g\"\n        | \"h\"\n        | \"i\"\n        | \"j\"\n        | \"k\"\n        | \"l\"\n        | \"m\"\n        | \"n\"\n        | \"o\"\n        | \"p\"\n        | \"q\"\n        | \"r\"\n        | \"s\"\n        | \"t\"\n        | \"u\"\n        | \"v\"\n        | \"w\"\n        | \"x\"\n        | \"y\"\n        | \"z\";\n\n    export type ReferenceResolver<T> = (name: string) => T;\n\n    /**\n     * Supported ways of expressing conformance (conceptually union should include Flag but that is covered by string).\n     */\n    export type Definition = string | string[] | { ast: Conformance.Ast } | undefined;\n\n    // Serialize with parenthesis if necessary to make the expression atomic\n    function serializeAtomic(ast: Ast, otherOperator?: Operator) {\n        const serialized = serialize(ast);\n        if (\n            ast.type === Conformance.Special.Group ||\n            (otherOperator !== undefined && isHigherPrecedence(otherOperator, ast.type))\n        ) {\n            return `(${serialized})`;\n        }\n        return serialized;\n    }\n\n    export function validateReferences(conformance: Conformance, ast: Ast, resolver: ReferenceResolver<boolean>) {\n        switch (ast.type) {\n            case Operator.OR:\n            case Operator.XOR:\n            case Operator.AND:\n            case Operator.EQ:\n            case Operator.NE:\n            case Operator.GT:\n            case Operator.LT:\n            case Operator.GTE:\n            case Operator.LTE:\n                validateReferences(conformance, ast.param.lhs, resolver);\n                validateReferences(conformance, ast.param.rhs, resolver);\n                break;\n\n            case Operator.NOT:\n                validateReferences(conformance, ast.param, resolver);\n                break;\n\n            case Special.Group:\n                for (const a of ast.param) {\n                    validateReferences(conformance, a, resolver);\n                }\n                break;\n\n            case Special.Name:\n                if (!resolver(ast.param)) {\n                    conformance.error(\n                        `UNRESOLVED_CONFORMANCE_${ast.type.toUpperCase()}`,\n                        `Conformance ${ast.type} reference \"${ast.param}\" does not resolve`,\n                    );\n                }\n                break;\n        }\n    }\n\n    export function serialize(ast: Ast): string {\n        switch (ast.type) {\n            case Operator.OR:\n            case Operator.XOR:\n            case Operator.AND:\n            case Operator.EQ:\n            case Operator.NE:\n            case Operator.GT:\n            case Operator.LT:\n            case Operator.GTE:\n            case Operator.LTE:\n                const lhs = serializeAtomic(ast.param.lhs, ast.type);\n                const rhs = serializeAtomic(ast.param.rhs, ast.type);\n                return `${lhs} ${ast.type} ${rhs}`;\n\n            case Operator.NOT:\n                return `!${serializeAtomic(ast.param)}`;\n\n            case Special.Empty:\n                return \"\";\n\n            case Special.Desc:\n                return \"desc\";\n\n            case Special.Choice:\n                let result = `${serializeAtomic(ast.param.expr)}.${ast.param.name}`;\n                if (ast.param.num > 1) {\n                    result = `${result}${ast.param.num}`;\n                }\n                if (ast.param.orMore) {\n                    result = `${result}+`;\n                }\n                return result;\n\n            case Special.Group:\n                return ast.param.map(d => serialize(d)).join(\", \");\n\n            case Special.OptionalIf:\n                return `[${serialize(ast.param)}]`;\n\n            case Special.Name:\n            case Special.Value:\n                // Name or value\n                return FieldValue.serialize(ast.param);\n\n            default:\n                // Flag\n                return ast.type;\n        }\n    }\n\n    export function isBinaryOperator(type: Ast[\"type\"] | Operator): type is Operator {\n        return Parser.BinaryOperators.has(type as any);\n    }\n\n    export function precedenceOf(operator: Ast[\"type\"] | Operator) {\n        const index = Parser.BinaryOperatorPrecedence.findIndex(ops => ops.indexOf(operator as any) != -1);\n        return index === -1 ? undefined : index;\n    }\n\n    export function isHigherPrecedence(operator: Ast[\"type\"] | Operator, other: Ast[\"type\"] | Operator) {\n        const precedence1 = precedenceOf(operator);\n        if (precedence1 === undefined) {\n            return false;\n        }\n\n        const precedence2 = precedenceOf(other);\n        if (precedence2 === undefined) {\n            return false;\n        }\n\n        return precedence1 < precedence2;\n    }\n}\n\nconst flags = new Set(Object.values(Conformance.Flag));\n\n// The DSL is *almost* complex enough to warrant a proper parser library.  Not quite though...\nfunction ParsedAst(conformance: Conformance, definition: string) {\n    definition = definition.replace(\" or \", \" | \");\n    const tokens = TokenStream(Lexer.Basic.lex(definition, (code, message) => conformance.error(code, message)));\n    return parseGroup();\n\n    function parseGroup(end?: BasicToken.Operator): Conformance.Ast {\n        const group = [] as Conformance.Ast[];\n\n        function groupAsAst(): Conformance.Ast {\n            if (group.length === 1) {\n                return group[0];\n            }\n\n            return {\n                type: Conformance.Special.Group,\n                param: group,\n            };\n        }\n\n        while (true) {\n            if (tokens.done) {\n                if (end) {\n                    conformance.error(\"UNTERMINATED_CONFORMANCE_GROUPING\", \"Unterminated conformance grouping\");\n                }\n                return groupAsAst();\n            }\n\n            // Optional brackets are only allowed at the top-level\n            const optional = !end && atOperator(\"[\");\n\n            if (optional) {\n                tokens.next();\n                let expr: Conformance.Ast = {\n                    type: Conformance.Special.OptionalIf,\n                    param: parseGroup(\"]\"),\n                };\n                expr = parseChoice(expr);\n                group.push(expr);\n            } else {\n                const expr = parseExpression();\n                if (expr) {\n                    group.push(expr);\n                }\n            }\n\n            if (atOperator(\",\")) {\n                tokens.next();\n            } else if (end && atOperator(end)) {\n                tokens.next();\n                return groupAsAst();\n            }\n        }\n    }\n\n    function atOperator(operator: BasicToken.Operator) {\n        const { token } = tokens;\n        return token && token.type === operator;\n    }\n\n    function parseExpression() {\n        const elements = [] as (BasicToken.Operator | Conformance.Ast | string)[];\n\n        // Collect binary expressions into an array so we can back up and\n        // apply operator precedence\n        let expr = parseAtomicExpression();\n        if (expr) {\n            elements.push(expr);\n        }\n        while (tokens.token && Parser.BinaryOperators.has(tokens.token.type)) {\n            elements.push(tokens.token.type);\n            tokens.next();\n            expr = parseAtomicExpression();\n            if (expr) {\n                elements.push(expr);\n            }\n        }\n\n        // Convert binary operators into AST nodes in order of precedence\n        Parser.BinaryOperatorPrecedence.forEach(operators => {\n            for (let i = 0; i < elements.length; i++) {\n                if (operators.indexOf(elements[i + 1] as BasicToken.Operator) !== -1) {\n                    const [lhs, op, rhs] = elements.splice(i, 3);\n                    elements.splice(i, 0, {\n                        type: op,\n                        param: { lhs, rhs },\n                    } as Conformance.Ast);\n                    i--;\n                }\n            }\n        });\n\n        return elements[0] as Conformance.Ast;\n    }\n\n    function extractChoiceNameAndNumber(text: string): { name: Conformance.ChoiceName; num: number } {\n        let name = text[0];\n        let num;\n        if (name[0] < \"a\" || name[0] > \"z\") {\n            conformance.error(\"INVALID_CHOICE\", \"Choice indicator is not a lowercase letter\");\n            name = \"?\";\n            num = 1;\n        } else if (text.length > 1) {\n            num = Number.parseInt(text[1]);\n            if (Number.isNaN(num) || num < 0 || num > 9) {\n                conformance.error(\"INVALID_CHOICE\", \"Choice indicator may only be a single lowercase letter\");\n                name = \"?\";\n                num = 1;\n            } else if (name.length > 2) {\n                conformance.error(\"INVALID_CHOICE\", \"Choice number followed by unexpected word characters\");\n                name = \"?\";\n            }\n        } else {\n            num = 1;\n        }\n\n        return { name: name as Conformance.ChoiceName, num };\n    }\n\n    function parseChoice(expr: Conformance.Ast): Conformance.Ast {\n        if (!atOperator(\".\")) {\n            return expr;\n        }\n\n        tokens.next();\n\n        let name, num;\n        if (tokens.token?.type !== \"word\") {\n            conformance.error(\"INVALID_CHOICE\", 'Choice indicator (\".\") not followed by identifier');\n            name = \"?\" as Conformance.ChoiceName;\n            num = 1;\n        } else {\n            ({ name, num } = extractChoiceNameAndNumber(tokens.token.value));\n            tokens.next();\n        }\n\n        const choice: Conformance.Ast.Choice = { name, expr, num };\n        if (atOperator(\"+\")) {\n            choice.orMore = true;\n            tokens.next();\n        }\n\n        return {\n            type: Conformance.Special.Choice,\n            param: choice,\n        };\n    }\n\n    function parseAtomicExpression(): string | Conformance.Ast | undefined {\n        const expr = parseAtomicExpressionWithoutChoice();\n        if (!expr) {\n            return;\n        }\n\n        return parseChoice(expr);\n    }\n\n    function parseAtomicExpressionWithoutChoice(): Conformance.Ast | undefined {\n        if (!tokens.token) {\n            conformance.error(\"PREMATURE_CONFORMANCE_TERMINATION\", \"Terminated with expression expected\");\n            return;\n        }\n\n        if (tokens.token.type === \"word\") {\n            const name = tokens.token.value;\n            tokens.next();\n\n            if (flags.has(name as Conformance.Flag)) {\n                return { type: name as Conformance.Flag };\n            }\n\n            if (name.toLowerCase() === \"desc\") {\n                return { type: Conformance.Special.Desc };\n            }\n\n            if (name === \"null\") {\n                return { type: Conformance.Special.Value, param: null };\n            }\n\n            return { type: Conformance.Special.Name, param: name };\n        }\n\n        if (tokens.token.type === \"value\") {\n            const value = tokens.token.value;\n            tokens.next();\n            return { type: Conformance.Special.Value, param: value };\n        }\n\n        if (atOperator(\"!\")) {\n            tokens.next();\n            return { type: Conformance.Operator.NOT, param: parseAtomicExpression() as Conformance.Ast };\n        }\n\n        if (atOperator(\"(\")) {\n            tokens.next();\n            return parseGroup(\")\");\n        }\n\n        conformance.error(\"UNEXPECTED_CONFORMANCE_TOKEN\", `Unexpected \"${tokens.token.type}\"`);\n        tokens.next();\n    }\n}\n\nnamespace Parser {\n    // Highest precedence first\n    export const BinaryOperatorPrecedence = [[\"&\"], [\"|\", \"^\"], [\">\", \"<\", \">=\", \"<=\"], [\"==\", \"!=\"]];\n\n    export const BinaryOperators = new Set(BinaryOperatorPrecedence.flat());\n}\n\nfunction computeApplicability(features: Set<string>, supportedFeatures: Set<string>, ast: Conformance.Ast) {\n    function processNode(ast: Conformance.Ast): boolean {\n        switch (ast.type) {\n            case Conformance.Special.Name:\n                if (features.has(ast.param)) {\n                    return supportedFeatures.has(ast.param);\n                }\n                break;\n\n            case Conformance.Operator.NOT:\n                const subvalue = processNode(ast.param);\n                if (typeof subvalue === \"boolean\") {\n                    return !subvalue;\n                }\n                break;\n\n            case Conformance.Operator.AND:\n                if (!processNode(ast.param.lhs) || !processNode(ast.param.rhs)) {\n                    return false;\n                }\n                break;\n\n            case Conformance.Operator.OR:\n                if (!processNode(ast.param.lhs) && !processNode(ast.param.rhs)) {\n                    return false;\n                }\n                break;\n\n            case Conformance.Flag.Disallowed:\n                return false;\n\n            case Conformance.Special.OptionalIf:\n                return processNode(ast.param);\n\n            case Conformance.Special.Group:\n                for (const child of ast.param) {\n                    if (processNode(child)) {\n                        return true;\n                    }\n                }\n                return false;\n        }\n        return true;\n    }\n    return processNode(ast);\n}\n\nfunction freezeAst(ast: Conformance.Ast) {\n    switch (ast.type) {\n        case Conformance.Operator.OR:\n        case Conformance.Operator.XOR:\n        case Conformance.Operator.AND:\n        case Conformance.Operator.EQ:\n        case Conformance.Operator.NE:\n        case Conformance.Operator.GT:\n        case Conformance.Operator.LT:\n        case Conformance.Operator.GTE:\n        case Conformance.Operator.LTE:\n            freezeAst(ast.param.lhs);\n            freezeAst(ast.param.rhs);\n            Object.freeze(ast.param);\n            break;\n\n        case Conformance.Operator.NOT:\n        case Conformance.Special.OptionalIf:\n            freezeAst(ast.param);\n            break;\n\n        case Conformance.Special.Value:\n            if (typeof ast.param === \"object\" && ast.param !== null) {\n                Object.freeze(ast.param);\n            }\n            break;\n\n        case Conformance.Special.Choice:\n            freezeAst(ast.param.expr);\n            Object.freeze(ast.param);\n            break;\n\n        case Conformance.Special.Group:\n            for (const entry of ast.param) {\n                freezeAst(entry);\n            }\n            Object.freeze(ast.param);\n            break;\n    }\n\n    Object.freeze(ast);\n}\n"],
  "mappings": "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",
  "names": ["Conformance", "Special", "Flag", "Operator", "Parser", "ast"]
}
