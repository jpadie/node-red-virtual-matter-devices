{
  "version": 3,
  "sources": ["../../../../src/model/models/Children.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImplementationError } from \"../../common/MatterError.js\";\nimport { AnyElement, ElementTag } from \"../index.js\";\nimport { Model } from \"./Model.js\";\n\n/**\n * Children of a model.  This is a {@link Model} array with some specialization for model-specific operations.\n *\n * @template M Model types accepted as children\n * @template E Element types accepted as children\n */\nexport interface Children<M extends Model = Model, E extends AnyElement = AnyElement> extends Array<M> {\n    /**\n     * Add a child.\n     *\n     * Operates like a standard array push but we adjust the type to allow insertion of elements as well as models.\n     */\n    push(...children: (M | E)[]): number;\n\n    /**\n     * Array splice.\n     *\n     * Allows splicing in elements or models.\n     */\n    splice(index: number, deleteCount?: number, ...toAdd: (M | E)[]): M[];\n\n    /**\n     * Access a model of specific type by ID or name.  This is an optimized operation that uses internal index lookup.\n     */\n    get<T extends Model>(type: Model.Type<T>, idOrName: number | string): T | undefined;\n\n    /**\n     * Access all models of a specific type, optionally filtered to a specific ID or number.  Even if filtered there\n     * may be multiple return values if there are different variants of the element defined.\n     */\n    all<T extends Model>(type: Model.Type<T>, idOrName?: number | string): T[];\n\n    /**\n     * Access a model using a {@link Children.Selector}.  This is an optimized primitive used by various tree traversal\n     * algorithms.\n     */\n    select(selector: Children.Selector, allowedTags?: Children.TagSelector, except?: Set<Model>): Model | undefined;\n\n    /**\n     * Like {@link select} but retrieves all models for which selection applies.\n     */\n    selectAll(selector: Children.Selector, allowedTags?: Children.TagSelector, except?: Set<Model>): Model[];\n\n    /**\n     * Models invoke this when their ID changes so we can update internal bookkeeping.\n     */\n    updateId(child: Model, oldId: number | undefined): void;\n\n    /**\n     * Models invoke this when their name changes so we can update internal bookkeeping.\n     */\n    updateName(child: Model, oldName: string): void;\n\n    /**\n     * Freeze the set of children.\n     */\n    freeze(): void;\n}\n\ntype IndexEntry = Model | Model[];\n\n/**\n * Invoked by {@link Model} to instantiate a new child array.\n */\nexport function Children<M extends Model = Model, E extends AnyElement = AnyElement>(\n    initial: Iterable<M | AnyElement>,\n    adopt: (child: Model) => void,\n    disown: (child: Model) => boolean,\n) {\n    // The actual list of children.  We maintain children as elements until they're accessed.  This allows us to build\n    // the full model without instantiating thousands of Models we may never use\n    const children = Array<Model | AnyElement>();\n\n    // Set to true when we are using the list of children operationally.  After reification the \"children\" array\n    // contains only models\n    let reified = false;\n\n    // Index data.  This is a map of constructor -> (ID index, name index)\n    //\n    // There is an index for any constructor for which lookup has been performed.  Note that models may appear in more\n    // than one constructor slot because we support lookup by any class in the inheritance hierarchy.  E.g.\n    // AttributeModel could appear in an index for both AttributeModel and ValueModel.\n    //\n    // ID indices are sparse arrays.  Name indices are objects.\n    //\n    // We allow for an array in the index slot because we allow duplicate IDs or names.  This may be illegal but we\n    // catch this in validation.  We only return the first entry on index lookup but this way the index remains correct\n    // if e.g. a duplicate entry is inserted temporarily then deleted.\n    //\n    // We also allow for a single Model in the index slot because name/ID duplicates are very uncommon so we can avoid\n    // the array > 99% of the time.\n    let indices:\n        | undefined\n        | Map<\n              abstract new (...args: any[]) => Model,\n              {\n                  byId: IndexEntry[];\n                  byName: Record<string, IndexEntry>;\n              }\n          >;\n\n    /**\n     * Enter \"reified\" mode (see comment above).\n     */\n    function reify() {\n        if (reified) {\n            return;\n        }\n        for (let i = 0; i < children.length; i++) {\n            let child = children[i];\n            if (child instanceof Model) {\n                continue;\n            }\n            child = Model.create(child);\n            adopt(child);\n            children[i] = child;\n        }\n        reified = true;\n    }\n\n    /**\n     * Determine if an element has any Model children.  If so we need to upgrade to a model on insertion.\n     */\n    function hasModel(child: AnyElement) {\n        if (child instanceof Model) {\n            return true;\n        }\n        return child.children?.some(hasModel);\n    }\n\n    /**\n     * Convert a new child to \"insertion\" form.  The input may be an element or model.  If we are reified, we upgrade\n     * elements to models.  If child or any descendents is a model, we reify so models will have the correct parent\n     * after insertion.\n     */\n    function insertionFormOf(child: Model | AnyElement) {\n        if (child instanceof Model) {\n            return child;\n        }\n\n        if (reified || hasModel(child)) {\n            return Model.create(child);\n        }\n\n        return child;\n    }\n\n    /**\n     * Add a model to a name or ID index.\n     */\n    function indexInsert<K extends number | string>(index: Record<K, IndexEntry>, key: K, model: Model) {\n        const existing = index[key];\n        if (existing) {\n            if (Array.isArray(existing)) {\n                existing.push(model);\n            } else {\n                index[key] = [existing, model];\n            }\n        } else {\n            index[key] = model;\n        }\n    }\n\n    /**\n     * Remove a model from a name or ID index.\n     */\n    function indexDelete<K extends number | string>(index: Record<K, IndexEntry>, key: K, model: Model) {\n        const existing = index[key];\n        if (existing === model) {\n            delete index[key];\n        }\n        if (Array.isArray(existing)) {\n            const pos = existing.indexOf(model);\n            if (pos === -1) {\n                return;\n            }\n            existing.splice(pos, 1);\n            if (existing.length === 1) {\n                index[key] = existing[0];\n            }\n            return;\n        }\n    }\n\n    /**\n     * Populate id and name indices for a specific child type.\n     */\n    function buildIndex(type: Model.Type) {\n        reify();\n\n        const byId = Array<Model>();\n        const byName = {} as Record<string, Model>;\n\n        for (const child of children) {\n            if (child instanceof type) {\n                // By caching effectiveId we're assuming that models without an ID do not shift position within their\n                // parent.  As this is effectively static data it should be OK\n                const id = child.effectiveId;\n                if (id !== undefined) {\n                    indexInsert(byId, id, child);\n                }\n                indexInsert(byName, child.name, child);\n            }\n        }\n\n        const slot = { byId, byName };\n\n        if (!indices) {\n            indices = new Map();\n        }\n        indices.set(type, slot);\n\n        return slot;\n    }\n\n    /**\n     * Remove a child of the model.  Clears model from indices and clears \"parent\" field.\n     */\n    function deleteChild(child: Model) {\n        if (indices) {\n            for (const [type, slot] of indices.entries()) {\n                if (child instanceof type) {\n                    if (child.id) {\n                        indexDelete(slot.byId, child.id, child);\n                    }\n                    indexDelete(slot.byName, child.name, child);\n                }\n            }\n        }\n\n        disown(child);\n    }\n\n    /**\n     * Add a child of the model.  Adopts the mdodel and adds to any applicable indices.\n     */\n    function addChild(child: Model) {\n        if (child.parent?.children === children) {\n            return;\n        }\n\n        if (indices) {\n            for (const [type, slot] of indices.entries()) {\n                if (child instanceof type) {\n                    if (child.id) {\n                        indexInsert(slot.byId, child.id, child);\n                    }\n                    indexInsert(slot.byName, child.name, child);\n                }\n            }\n        }\n\n        adopt(child);\n    }\n\n    function get(type: typeof Model, idOrName: number | string) {\n        const value = all(type, idOrName);\n        if (Array.isArray(value)) {\n            return value[0];\n        }\n        return value;\n    }\n\n    function all(type: typeof Model, idOrName?: number | string) {\n        const slot = indices?.get(type) ?? buildIndex(type);\n        if (idOrName === undefined) {\n            return Object.values(slot.byName).flatMap(entry => entry);\n        }\n\n        let result;\n        if (typeof idOrName === \"number\") {\n            result = slot.byId[idOrName];\n        } else {\n            result = slot.byName[idOrName];\n        }\n\n        if (result === undefined) {\n            return [];\n        }\n\n        if (Array.isArray(result)) {\n            return result;\n        }\n\n        return [result];\n    }\n\n    function selectTypes(tags: Children.TagSelector): Model.Type[] {\n        if (tags === undefined || tags === \"*\") {\n            return [Model];\n        }\n\n        if (typeof tags === \"string\") {\n            tags = [tags];\n        }\n\n        const result = Array<Model.Type>();\n        for (const tag of tags) {\n            const type = Model.types[tag];\n            if (type === undefined) {\n                throw new ImplementationError(`Unknown element tag \"${tag}\"`);\n            }\n            result.push(type);\n        }\n\n        return result;\n    }\n\n    function indexLookup<T>(\n        selector: number | string,\n        indexName: \"byId\" | \"byName\",\n        allowedTags: Children.TagSelector,\n        except: Set<Model> | undefined,\n        processor: (model: Model) => T,\n    ) {\n        for (const type of selectTypes(allowedTags)) {\n            let slot = indices?.get(type);\n            if (slot === undefined) {\n                slot = buildIndex(type);\n            }\n\n            const index = slot[indexName] as Record<number | string, Model | Model[]>;\n            const entry = index[selector];\n\n            if (Array.isArray(entry)) {\n                for (const subentry of entry) {\n                    if (except?.has(subentry)) {\n                        continue;\n                    }\n                    const result = processor(subentry);\n                    if (result !== undefined) {\n                        return result;\n                    }\n                }\n                continue;\n            }\n\n            if (entry) {\n                if (except?.has(entry)) {\n                    continue;\n                }\n                const result = processor(entry);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    function indexApply(selector: (child: Model) => boolean, allowedTags: Children.TagSelector, except?: Set<Model>) {\n        for (const type of selectTypes(allowedTags)) {\n            let index = indices?.get(type)?.byName;\n            if (!index) {\n                index = buildIndex(type).byName;\n            }\n\n            for (const key in index) {\n                const entry = index[key];\n                if (Array.isArray(entry)) {\n                    for (const subentry of entry) {\n                        if (except?.has(subentry)) {\n                            continue;\n                        }\n                        if (selector(subentry)) {\n                            return subentry;\n                        }\n                    }\n                    continue;\n                }\n\n                if (except?.has(entry)) {\n                    continue;\n                }\n\n                if (selector(entry)) {\n                    return entry;\n                }\n            }\n        }\n    }\n\n    function select(selector: Children.Selector, allowedTags?: Children.TagSelector, except?: Set<Model>) {\n        reify();\n\n        if (typeof selector === \"string\") {\n            return indexLookup(selector, \"byName\", allowedTags, except, model => model);\n        }\n\n        if (typeof selector === \"number\") {\n            return indexLookup(selector, \"byId\", allowedTags, except, model => model);\n        }\n\n        return indexApply(selector, allowedTags, except);\n    }\n\n    function selectAll(\n        selector: Exclude<Children.Selector, (args: any) => any>,\n        allowedTags?: Children.TagSelector,\n        except?: Set<Model>,\n    ) {\n        reify();\n\n        const results = Array<Model>();\n\n        if (typeof selector === \"string\") {\n            indexLookup(selector, \"byName\", allowedTags, except, model => {\n                results.push(model);\n            });\n        } else {\n            indexLookup(selector, \"byId\", allowedTags, except, model => {\n                results.push(model);\n            });\n        }\n\n        return results;\n    }\n\n    function updateId(child: Model, oldId: number | undefined) {\n        if (!indices) {\n            return;\n        }\n        for (const [type, slot] of indices.entries()) {\n            if (child instanceof type) {\n                if (oldId !== undefined) {\n                    indexDelete(slot.byId, oldId, child);\n                }\n                if (child.id !== undefined) {\n                    indexInsert(slot.byId, child.id, child);\n                }\n            }\n        }\n    }\n\n    function updateName(child: Model, oldName: string) {\n        if (!indices) {\n            return;\n        }\n        for (const [type, slot] of indices.entries()) {\n            if (child instanceof type) {\n                if (oldName !== undefined) {\n                    indexDelete(slot.byName, oldName, child);\n                }\n                if (child.name !== undefined) {\n                    indexInsert(slot.byName, child.name, child);\n                }\n            }\n        }\n    }\n\n    // We implement \"splice\" for efficiency...  The default implementation moves elements one at a time, forcing us to\n    // search the array to see if it's already present each time\n    function splice(index: number, deleteCount?: number, ...toAdd: (AnyElement | Model)[]) {\n        // Upgrade elements as necessary and adopt any new models\n        toAdd = toAdd.map(child => {\n            child = insertionFormOf(child);\n            if (child instanceof Model) {\n                adopt(child);\n            }\n            return child;\n        });\n\n        // Perform the actual splice\n        const result = children.splice(index, deleteCount ?? 0, ...toAdd);\n\n        // Convert deleted elements to models and disown elements that are already models\n        return result.map(child => {\n            if (child instanceof Model) {\n                disown(child);\n            } else {\n                child = Model.create(child);\n            }\n            return child;\n        });\n    }\n\n    function freeze() {\n        for (const child of self) {\n            (child as Model).freeze();\n        }\n        Object.freeze(children);\n    }\n\n    const self = new Proxy(children, {\n        get: (_target, p, receiver) => {\n            if (typeof p === \"string\" && p.match(/^[0-9]+$/)) {\n                let child = children[p as unknown as number];\n                if (child && !(child instanceof Model)) {\n                    child = Model.create(child);\n                    addChild(child);\n                    children[p as unknown as number] = child;\n                }\n\n                return child;\n            }\n\n            switch (p) {\n                case \"get\":\n                    return get;\n\n                case \"all\":\n                    return all;\n\n                case \"select\":\n                    return select;\n\n                case \"selectAll\":\n                    return selectAll;\n\n                case \"updateId\":\n                    return updateId;\n\n                case \"updateName\":\n                    return updateName;\n\n                case \"splice\":\n                    return splice;\n\n                case \"freeze\":\n                    return freeze;\n\n                case \"toString\":\n                    return () => `[Children: ${children.length}]`;\n            }\n\n            return Reflect.get(children, p, receiver);\n        },\n\n        set: (_target, p, newValue, receiver) => {\n            if (typeof p !== \"string\" || !p.match(/^[0-9]+$/)) {\n                return Reflect.set(children, p, newValue, receiver);\n            }\n\n            if (typeof newValue !== \"object\" || newValue === null || !newValue.tag) {\n                throw new ImplementationError(\"Child must be Model or AnyElement\");\n            }\n\n            const existing = children[p as unknown as number];\n            if (existing !== undefined) {\n                if (existing === newValue) {\n                    return true;\n                }\n                if (existing instanceof Model) {\n                    deleteChild(existing);\n                }\n            }\n\n            if (newValue.parent?.children === self) {\n                const currentIndex = children.indexOf(newValue);\n                if (currentIndex !== -1) {\n                    children.splice(currentIndex, 1);\n                }\n                return true;\n            }\n\n            newValue = insertionFormOf(newValue);\n\n            children[p as unknown as number] = newValue;\n            if (newValue instanceof Model) {\n                addChild(newValue);\n            }\n\n            return true;\n        },\n\n        deleteProperty: (_target, p) => {\n            let child;\n\n            if (typeof p === \"string\" && p.match(/^[0-9]+$/)) {\n                child = children[p as unknown as number];\n            }\n\n            delete children[p as unknown as number];\n\n            // Child may have been added elsewhere in the index so only delete if not still present\n            if (child instanceof Model && !children.includes(child)) {\n                deleteChild(child);\n            }\n\n            return true;\n        },\n    });\n\n    // Clone child array because if it references a former parent they'll disappear as we add\n    initial = [...initial];\n\n    self.push(...initial);\n\n    return self as Children<M>;\n}\n\nexport namespace Children {\n    /**\n     * A model selector designates models for retrieval.  It may be a model name, number, or a predicate function.\n     */\n    export type Selector = string | number | ((child: Model) => boolean);\n\n    /**\n     * A tag selector filters models based on type.  It may be a tag name, a list of tag names, or \"*\" or undefined to\n     * disable type filtering.\n     */\n    export type TagSelector = undefined | ElementTag | \"*\" | ElementTag[];\n}\n"],
  "mappings": "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",
  "names": []
}
