{
  "version": 3,
  "sources": ["../../../../src/model/models/ValueModel.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Access, Aspect, Conformance, Constraint, Quality } from \"../aspects/index.js\";\nimport { ElementTag, FieldValue, Metatype } from \"../definitions/index.js\";\nimport { AnyElement, FieldElement, ValueElement } from \"../elements/index.js\";\nimport { ModelTraversal } from \"../logic/ModelTraversal.js\";\nimport { Aspects } from \"./Aspects.js\";\nimport { Children } from \"./Children.js\";\nimport { Model } from \"./Model.js\";\nimport { PropertyModel } from \"./PropertyModel.js\";\n\n// These are circular dependencies so just to be safe we only import the types.  We also need the class, though, at\n// runtime.  So we use the references in the Model.constructors factory pool.\nimport { camelize } from \"../../util/String.js\";\nimport { DefaultValue } from \"../logic/DefaultValue.js\";\nimport { type ClusterModel } from \"./ClusterModel.js\";\nimport { type FieldModel } from \"./FieldModel.js\";\n\nconst CONSTRAINT: unique symbol = Symbol(\"constraint\");\nconst CONFORMANCE: unique symbol = Symbol(\"conformance\");\nconst ACCESS: unique symbol = Symbol(\"access\");\nconst QUALITY: unique symbol = Symbol(\"quality\");\n\n/**\n * Each {@link ValueElement} type has a corresponding implementation that derives from this class.\n */\nexport abstract class ValueModel extends Model implements ValueElement {\n    declare byteSize?: ValueElement.ByteSize;\n    declare default?: FieldValue;\n    declare metatype?: Metatype;\n    override isType? = true;\n\n    override get children(): Children<FieldModel, FieldElement> {\n        return super.children as any;\n    }\n\n    override set children(children: (FieldModel | FieldElement)[]) {\n        super.children = children;\n    }\n\n    get constraint(): Constraint {\n        return Aspects.getAspect(this, CONSTRAINT, Constraint);\n    }\n    set constraint(definition: Constraint | Constraint.Definition) {\n        Aspects.setAspect(this, CONSTRAINT, Constraint, definition);\n    }\n    get effectiveConstraint(): Constraint {\n        return new ModelTraversal().findConstraint(this, CONSTRAINT) || this.constraint;\n    }\n\n    get conformance(): Conformance {\n        return Aspects.getAspect(this, CONFORMANCE, Conformance);\n    }\n    set conformance(definition: Conformance | Conformance.Definition) {\n        Aspects.setAspect(this, CONFORMANCE, Conformance, definition);\n    }\n    get effectiveConformance(): Conformance {\n        return Aspects.getEffectiveAspect(this, CONFORMANCE, Conformance);\n    }\n\n    get access(): Access {\n        return Aspects.getAspect(this, ACCESS, Access);\n    }\n    set access(definition: Access | Access.Definition) {\n        Aspects.setAspect(this, ACCESS, Access, definition);\n    }\n    get effectiveAccess(): Access {\n        return new ModelTraversal().findAccess(this, ACCESS, ValueModel);\n    }\n\n    get quality(): Quality {\n        return Aspects.getAspect(this, QUALITY, Quality);\n    }\n    set quality(definition: Quality | Quality.Definition) {\n        Aspects.setAspect(this, QUALITY, Quality, definition);\n    }\n    get effectiveQuality(): Quality {\n        return Aspects.getEffectiveAspect(this, QUALITY, Quality);\n    }\n\n    /**\n     * Metatype is only present on global types with specific semantic meaning. This model is significant because it\n     * gives us information about how to manipulate the data.  This accessor retrieves this model.\n     */\n    get metabase(): ValueModel | undefined {\n        return new ModelTraversal().findMetabase(this) as ValueModel | undefined;\n    }\n\n    /**\n     * Get the primitive type for this value model.  This is an integer type for enums and bitmaps.  Otherwise it's the\n     * metabase.\n     */\n    get primitiveBase(): ValueModel | undefined {\n        const metabase = this.metabase;\n        if (!metabase) {\n            return;\n        }\n\n        // Enum is a derived type so we can just return its base\n        if (metabase.metatype === Metatype.enum) {\n            return metabase.base;\n        }\n\n        // Bitmaps are not derived types so we have to map manually\n        if (metabase.metatype === Metatype.bitmap) {\n            const primitiveName = metabase.name.replace(\"map\", \"uint\");\n            return metabase.parent?.children.find(c => c.name === primitiveName) as ValueModel | undefined;\n        }\n\n        return metabase;\n    }\n\n    /**\n     * The \"effective type\" may be inferred from context.\n     */\n    override get effectiveType(): string | undefined {\n        const type = super.effectiveType;\n        if (type) {\n            return type;\n        }\n        return new ModelTraversal().getTypeName(this);\n    }\n\n    /**\n     * The working metatype for this object.\n     */\n    get effectiveMetatype() {\n        const metaBase = this.metabase;\n        if (metaBase) {\n            return metaBase.metatype;\n        }\n    }\n\n    /**\n     * The value to use as a default.  The \"default\" field has a manually supplied value but this property decodes the\n     * default and/or generates a default from subfields.\n     */\n    get effectiveDefault() {\n        return DefaultValue(this);\n    }\n\n    /**\n     * Get the first derived ancestor with children, if any.\n     */\n    get definingModel() {\n        return new ModelTraversal().findDefiningModel(this);\n    }\n\n    /**\n     * Get the entry type for lists, if any.\n     */\n    get listEntry() {\n        return this.member(\"entry\", [ElementTag.Field]) as FieldModel | undefined;\n    }\n\n    /**\n     * ValueModels may only derive from ValueModels.\n     */\n    override get base() {\n        return super.base as ValueModel | undefined;\n    }\n\n    /**\n     * ValueModels may derive from models of the same type or from generic Datatype models.\n     */\n    override get allowedBaseTags() {\n        if (this.tag === ElementTag.Field) {\n            // Allow fields to derive from attributes.  We use this for referencing options in masks and bitmaps\n            return [ElementTag.Field, ElementTag.Datatype, ElementTag.Attribute];\n        }\n        return [this.tag, ElementTag.Datatype];\n    }\n\n    /**\n     * All {@link FieldModel} children}.\n     */\n    get members(): PropertyModel[] {\n        return new ModelTraversal().findChildren(this, [ElementTag.Field]) as PropertyModel[];\n    }\n\n    /**\n     * A subset of {@link members} with conflicts resolved by conformance.\n     */\n    get activeMembers() {\n        const cluster = this.owner(Model.types[ElementTag.Cluster]) as ClusterModel | undefined;\n        return new ModelTraversal().findActiveMembers(this, false, cluster);\n    }\n\n    /**\n     * The subset of {@link members} that are conformant.\n     */\n    get conformantMembers() {\n        const cluster = this.owner(Model.types[ElementTag.Cluster]) as ClusterModel | undefined;\n        return new ModelTraversal().findActiveMembers(this, true, cluster);\n    }\n\n    /**\n     * Active members keyed by property name.\n     */\n    get fields() {\n        const members = this.activeMembers;\n        return Object.fromEntries(members.map(member => [camelize(member.name), member]));\n    }\n\n    /**\n     * Collect constraints and conformance for this type and all base types.\n     */\n    get validationAspects() {\n        const aspects = Array<Aspect<any>>();\n\n        new ModelTraversal().visitInheritance(this, model => {\n            if (model instanceof ValueModel) {\n                if (!model.conformance.empty && model.conformance.type !== Conformance.Special.Desc) {\n                    aspects.push(model.conformance);\n                }\n                if (!model.constraint.empty && !model.constraint.desc) {\n                    aspects.push(model.constraint);\n                }\n                if (model.quality.nullable === false) {\n                    aspects.push(model.quality);\n                }\n            }\n        });\n\n        return aspects;\n    }\n\n    /**\n     * Is this model deprecated?\n     */\n    get isDeprecated() {\n        return this.effectiveConformance.type === Conformance.Flag.Deprecated;\n    }\n\n    /**\n     * Is this model disallowed?\n     */\n    get isDisallowed() {\n        return this.effectiveConformance.type === Conformance.Flag.Disallowed;\n    }\n\n    /**\n     * Can this model be omitted?\n     */\n    get nullable() {\n        return !!this.effectiveQuality.nullable;\n    }\n\n    /**\n     * Is the model mandatory?\n     */\n    get mandatory() {\n        return this.effectiveConformance.isMandatory;\n    }\n\n    /**\n     * Determine whether this element overrides key properties of its shadow.\n     */\n    get overridesShadow() {\n        const shadow = this.shadow;\n        if (!shadow || !(shadow instanceof ValueModel)) {\n            return;\n        }\n\n        if (this.type && this.type !== shadow.type) {\n            return true;\n        }\n        if (!this.conformance.empty && !this.conformance.equals(shadow.conformance)) {\n            return true;\n        }\n        if (!this.quality.empty && !this.quality.equals(shadow.quality)) {\n            return true;\n        }\n        if (!this.constraint.empty && !this.constraint.equals(shadow.constraint)) {\n            return true;\n        }\n        if (!this.access.empty && !this.access.equals(shadow.access)) {\n            return true;\n        }\n    }\n\n    /**\n     * Search the inheritance chain for a bitmap field defining a specific bit.\n     */\n    bitDefinition(bit: number) {\n        return new ModelTraversal().findBitDefinition(this, bit);\n    }\n\n    override valueOf() {\n        const result = super.valueOf() as any;\n        for (const k of [\"conformance\", \"access\", \"quality\", \"constraint\"]) {\n            const v = (this as any)[k] as Aspect<any>;\n            if (v && !v.empty) {\n                result[k] = v.valueOf();\n            }\n        }\n        if (result.default === undefined) {\n            delete result.default;\n        }\n        return result as AnyElement;\n    }\n\n    override freeze() {\n        this.constraint.freeze();\n        this.conformance.freeze();\n        this.access.freeze();\n        this.quality.freeze();\n        super.freeze();\n    }\n\n    constructor(definition: ValueElement.Properties) {\n        super(definition);\n\n        const match = this.type?.match(/^list\\[(.*)\\]$/);\n        if (match) {\n            this.type = \"list\";\n            this.children.push(new Model.types.field({ name: \"entry\", type: match[1] }) as FieldModel);\n        }\n\n        if (definition instanceof Model) {\n            Aspects.cloneAspects(definition, this, CONSTRAINT, CONFORMANCE, ACCESS, QUALITY);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
