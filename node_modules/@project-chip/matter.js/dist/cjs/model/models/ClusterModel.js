"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClusterModel_exports = {};
__export(ClusterModel_exports, {
  ClusterModel: () => ClusterModel
});
module.exports = __toCommonJS(ClusterModel_exports);
var import_String = require("../../util/String.js");
var import_Access = require("../aspects/Access.js");
var import_Quality = require("../aspects/Quality.js");
var import_errors = require("../definitions/errors.js");
var import_definitions = require("../definitions/index.js");
var import_elements = require("../elements/index.js");
var import_ModelTraversal = require("../logic/ModelTraversal.js");
var import_ClusterRevision = require("../standard/elements/ClusterRevision.js");
var import_FeatureMap = require("../standard/elements/FeatureMap.js");
var import_Aspects = require("./Aspects.js");
var import_AttributeModel = require("./AttributeModel.js");
var import_CommandModel = require("./CommandModel.js");
var import_DatatypeModel = require("./DatatypeModel.js");
var import_EventModel = require("./EventModel.js");
var import_Model = require("./Model.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const QUALITY = Symbol("quality");
class ClusterModel extends import_Model.Model {
  tag = import_elements.ClusterElement.Tag;
  isTypeScope = true;
  get diagnostics() {
    return this.effectiveQuality.diagnostics;
  }
  get quality() {
    return import_Aspects.Aspects.getAspect(this, QUALITY, import_Quality.Quality);
  }
  set quality(definition) {
    import_Aspects.Aspects.setAspect(this, QUALITY, import_Quality.Quality, definition);
  }
  get effectiveQuality() {
    return import_Aspects.Aspects.getEffectiveAspect(this, QUALITY, import_Quality.Quality);
  }
  get attributes() {
    return this.all(import_AttributeModel.AttributeModel);
  }
  get commands() {
    return this.all(import_CommandModel.CommandModel);
  }
  get events() {
    return this.all(import_EventModel.EventModel);
  }
  get datatypes() {
    return this.all(import_DatatypeModel.DatatypeModel);
  }
  get members() {
    const traversal = new import_ModelTraversal.ModelTraversal();
    const members = traversal.findChildren(this, [import_definitions.ElementTag.Field, import_definitions.ElementTag.Attribute]);
    const missingGlobalIds = new Set(import_AttributeModel.AttributeModel.globalIds);
    for (const m of members) {
      if (m instanceof import_AttributeModel.AttributeModel && m.id) {
        missingGlobalIds.delete(m.id);
      }
    }
    if (missingGlobalIds.size) {
      const root = traversal.findRoot(this);
      if (root) {
        for (const id of missingGlobalIds) {
          const global = root.get(import_AttributeModel.AttributeModel, id);
          if (global) {
            members.push(global);
          }
        }
      }
    }
    return members;
  }
  get activeMembers() {
    return new import_ModelTraversal.ModelTraversal().findActiveMembers(this, false, this);
  }
  get conformantMembers() {
    return new import_ModelTraversal.ModelTraversal().findActiveMembers(this, true, this);
  }
  /**
   * Get attributes, commands and events whether inherited or defined directly in this model.
   */
  get allAces() {
    return new import_ModelTraversal.ModelTraversal().findChildren(this, [
      import_definitions.ElementTag.Attribute,
      import_definitions.ElementTag.Command,
      import_definitions.ElementTag.Event
    ]);
  }
  get revision() {
    let revision = 1;
    const revisionAttr = this.get(import_AttributeModel.AttributeModel, import_ClusterRevision.ClusterRevision.id);
    if (typeof revisionAttr?.default === "number") {
      revision = revisionAttr.default;
    }
    return revision;
  }
  get features() {
    return this.featureMap.children ?? [];
  }
  get featureMap() {
    return this.member(import_FeatureMap.FeatureMap.id, [import_definitions.ElementTag.Attribute]) ?? new import_AttributeModel.AttributeModel(import_FeatureMap.FeatureMap);
  }
  get featureNames() {
    return new import_definitions.FeatureSet(this.features.map((feature) => feature.name));
  }
  get supportedFeatures() {
    const supported = {};
    for (const feature of this.features) {
      if (feature.default) {
        supported[feature.name] = true;
      }
    }
    return new import_definitions.FeatureSet(supported);
  }
  set supportedFeatures(features) {
    const featureSet = new import_definitions.FeatureSet(features);
    let featureMap = this.featureMap;
    if (featureMap.parent !== this) {
      featureMap = featureMap.clone();
      this.add(featureMap);
    }
    for (const feature of featureMap.children) {
      const desc = feature.description && (0, import_String.camelize)(feature.description);
      if (desc !== void 0 && featureSet.has(desc)) {
        feature.default = true;
        featureSet.delete(desc);
        continue;
      }
      if (featureSet.has(feature.name)) {
        featureSet.delete(feature.name);
        feature.default = true;
        continue;
      }
      feature.default = void 0;
    }
    if (featureSet.size) {
      throw new import_errors.SchemaImplementationError(
        this,
        `Cannot set unknown feature${featureSet.size > 1 ? "s" : ""} ${(0, import_String.describeList)("and", ...featureSet)}`
      );
    }
  }
  get children() {
    return super.children;
  }
  set children(children) {
    super.children = children;
  }
  get effectiveMetatype() {
    return import_definitions.Metatype.object;
  }
  get effectiveAccess() {
    return import_Access.Access.Default;
  }
  valueOf() {
    const result = super.valueOf();
    if (this.quality && !this.quality.empty) {
      result.quality = this.quality.valueOf();
    }
    return result;
  }
  freeze() {
    this.quality.freeze();
    super.freeze();
  }
  constructor(definition) {
    super(definition);
    if (definition instanceof import_Model.Model) {
      import_Aspects.Aspects.cloneAspects(definition, this, QUALITY);
    }
  }
  static Tag = import_elements.ClusterElement.Tag;
  static {
    import_Model.Model.types[this.Tag] = this;
  }
}
//# sourceMappingURL=ClusterModel.js.map
