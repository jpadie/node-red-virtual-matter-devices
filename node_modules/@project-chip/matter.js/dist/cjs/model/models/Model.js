"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Model_exports = {};
__export(Model_exports, {
  Model: () => Model
});
module.exports = __toCommonJS(Model_exports);
var import_MatterError = require("../../common/MatterError.js");
var import_String = require("../../util/String.js");
var import_definitions = require("../definitions/index.js");
var import_ModelTraversal = require("../logic/ModelTraversal.js");
var import_Children = require("./Children.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class Model {
  #id = void 0;
  #name;
  /**
   * Indicates that an element may have type definitions as children.
   */
  isTypeScope;
  /**
   * Indicates that an element defines a datatype.
   */
  isType;
  #children;
  #parent;
  /**
   * Did validation find errors?
   */
  get valid() {
    return !this.errors;
  }
  /**
   * The path ("." delimited) in the Matter tree.
   *
   * This is informational and generally tries to adhere to JS API conventions.
   */
  get path() {
    if (this.parent && this.parent.tag !== import_definitions.ElementTag.Matter) {
      if (this.parent.tag === import_definitions.ElementTag.Field) {
        return `${this.parent.path}.${(0, import_String.camelize)(this.name)}`;
      }
      if (this.parent.tag === import_definitions.ElementTag.Cluster) {
        switch (this.tag) {
          case import_definitions.ElementTag.Attribute:
            return `${this.parent.path}.state.${(0, import_String.camelize)(this.name, false)}`;
          case import_definitions.ElementTag.Command:
            return `${this.parent.path}.${(0, import_String.camelize)(this.name, false)}`;
          case import_definitions.ElementTag.Event:
            return `${this.parent.path}.events.${(0, import_String.camelize)(this.name, false)}`;
        }
      }
      const parent = this.parent;
      if (parent.tag !== import_definitions.ElementTag.Cluster) {
        const parentMetatype = parent?.effectiveMetatype;
        if (parentMetatype === import_definitions.Metatype.object || parentMetatype === import_definitions.Metatype.array) {
          return `${parent.path}.${(0, import_String.camelize)(this.name, false)}`;
        }
      }
      return `${parent.path}.${this.name}`;
    } else {
      return this.name;
    }
  }
  /**
   * Determine if this model resides in the global namespace.
   */
  get isGlobal() {
    return this.tag === "matter" || this.parent?.tag === "matter";
  }
  /**
   * The structural parent.  This is the model for the element that contains this element's definition.
   */
  get parent() {
    return this.#parent;
  }
  set parent(parent) {
    if (this.parent === parent) {
      return;
    }
    if (this.parent) {
      const index = this.parent.children.indexOf(this);
      if (index !== -1) {
        this.parent.children.splice(index, 1);
      }
    }
    if (parent) {
      parent.children.push(this);
    }
  }
  /**
   * Allows subclasses to pull a working ID from an alternate source.
   */
  get effectiveId() {
    return this.id;
  }
  /**
   * Get a string that uniquely identifies this model.  This is normally the effective ID but some models require a
   * generated identifier.
   */
  get key() {
    const key = this.effectiveId?.toString();
    if (key === void 0) {
      return key;
    }
    const discriminator = this.discriminator;
    if (discriminator === void 0) {
      return key;
    }
    return `${key}\u241C${discriminator}`;
  }
  /**
   * Obtain a discriminator that differentiates different models with the same name
   */
  get discriminator() {
    return;
  }
  /**
   * Children of models are always models.
   */
  get children() {
    if (!this.#children) {
      this.children = [];
    }
    return this.#children;
  }
  /**
   * Children can be added as models or elements.
   */
  set children(children) {
    this.#children = (0, import_Children.Children)(
      children,
      (child) => {
        if (child.#parent === this) {
          return;
        }
        if (child.#parent) {
          const position = child.#parent.children.indexOf(child);
          if (position !== -1) {
            child.#parent.children.splice(position, 1);
          }
          child.#parent = void 0;
        }
        child.#parent = this;
      },
      (child) => {
        if (child.#parent === this) {
          child.#parent = void 0;
          return true;
        }
        return false;
      }
    );
  }
  /**
   * Factory support.  Populated by derivatives upon definition.
   */
  static types = {};
  /**
   * In some circumstances the base type can be inferred.  This inference happens here.
   *
   * Does not recurse so only returns the direct base type.
   */
  get effectiveType() {
    return this.type;
  }
  /**
   * Get a Model for my base type, if any.
   */
  get base() {
    return new import_ModelTraversal.ModelTraversal().findBase(this);
  }
  /**
   * Get shadow model, if any.  A "shadow" is an element in my parent's inheritance hierarchy that I override.
   */
  get shadow() {
    return new import_ModelTraversal.ModelTraversal().findShadow(this);
  }
  /**
   * Get the first global base type.  This may have semantic meaning more specific than the base primitive type.
   */
  get globalBase() {
    return new import_ModelTraversal.ModelTraversal().findGlobalBase(this);
  }
  /**
   * A local or parent xref.
   */
  get effectiveXref() {
    return new import_ModelTraversal.ModelTraversal().findXref(this);
  }
  /**
   * The set of tags from which this model may derive.
   */
  get allowedBaseTags() {
    return [this.tag];
  }
  /**
   * Determine whether this element applies to a specific revision.
   */
  appliesTo(revision) {
    return (this.asOf === void 0 || revision >= this.asOf) && (this.until === void 0 || revision < this.until);
  }
  /**
   * Add a child.  children.push works too but only accepts models.
   */
  add(...children) {
    this.children.push(...children);
  }
  /**
   * Create a model for an element.
   */
  static create(definition) {
    if (typeof definition !== "object") {
      throw new import_MatterError.InternalError(`Model definition must be object, not ${typeof definition}`);
    }
    const t = definition["tag"];
    const constructor = Model.types[t];
    if (!constructor) {
      throw new import_MatterError.InternalError(`Unknown element tag "${t}"`);
    }
    return new constructor(definition);
  }
  /**
   * Retrieve all models of a specific element type from local scope.
   *
   * @param constructor model class or a predicate object
   * @param key filters to models matching a specific type
   */
  all(constructor, key) {
    return this.children.all(constructor, key);
  }
  /**
   * Retrieve a specific model by ID or name.
   */
  get(type, key) {
    return this.children.get(type, key);
  }
  /**
   * Retrieve a model of a specific type from the ownership hierarchy.
   */
  owner(constructor) {
    return new import_ModelTraversal.ModelTraversal().findOwner(constructor, this);
  }
  /**
   * Record a validation error for this model.
   */
  error(code, message) {
    if (!this.errors) {
      this.errors = [];
    }
    this.errors.push({
      code,
      source: this.path,
      message,
      xref: this.effectiveXref?.toString()
    });
  }
  /**
   * Convert model to JSON.
   */
  toJSON() {
    return this.valueOf();
  }
  /**
   * Convert to non-class structure.
   */
  valueOf() {
    const result = {};
    for (const key in this) {
      switch (key) {
        case "parent":
        case "errors":
        case "isTypeScope":
        case "isType":
          continue;
        default:
          result[key] = this[key];
      }
    }
    return result;
  }
  /**
   * Apply a function to all tree elements.
   */
  visit(visitor) {
    return new import_ModelTraversal.ModelTraversal().visit(this, visitor);
  }
  /**
   * Find all children that reference a specific type.
   */
  references(type) {
    return new import_ModelTraversal.ModelTraversal().findReferences(this, type);
  }
  /**
   * Search the inheritance chain for a child property.
   */
  member(key, allowedTags = [import_definitions.ElementTag.Field, import_definitions.ElementTag.Attribute]) {
    return new import_ModelTraversal.ModelTraversal().findMember(this, key, allowedTags);
  }
  /**
   * Does this model derive from another?
   */
  instanceOf(other) {
    return new import_ModelTraversal.ModelTraversal().instanceOf(this, other);
  }
  /**
   * Clone the model.  This deep copies all descendant child models but not other properties.
   */
  clone() {
    const Type = this.constructor;
    return new Type(this);
  }
  constructor(definition) {
    const isClone = definition instanceof Model;
    this.#id = definition.id;
    this.#name = definition.name;
    for (const [k, v] of Object.entries(definition)) {
      if (k === "id" || k === "name" || k === "parent" || k === "isGlobal") {
        continue;
      }
      if (v !== void 0) {
        this[k] = v;
      }
    }
    if (this.xref) {
      this.xref = Model.CrossReference.get(this.xref);
    }
    if (isClone) {
      for (const child of definition.children) {
        this.children.push(child.clone());
      }
    }
  }
  /**
   * Freeze the model hierarchy rooted at this model.
   *
   * When using a model as operational schema we implement various optimizations that assume the schema is immutable.
   * This function enforces that assumption.
   *
   * To make changes to a frozen model use {@link clone}.
   */
  freeze() {
    Object.freeze(this);
    this.children.freeze();
    this.base?.freeze();
  }
  toString() {
    return `${this.tag}${this.type ? `<${this.type}>` : ""}#${this.path}`;
  }
  static {
    Object.defineProperties(Model.prototype, {
      id: {
        get() {
          return this.#id;
        },
        set(value) {
          const oldId = this.effectiveId;
          this.#id = value;
          this.#parent?.children.updateId(this, oldId);
        },
        enumerable: true
      },
      name: {
        get() {
          return this.#name;
        },
        set(value) {
          const oldName = this.#name;
          this.#name = value;
          this.#parent?.children.updateName(this, oldName);
        },
        enumerable: true
      }
    });
  }
}
((Model2) => {
  class CrossReference {
    document;
    section;
    static instances = {};
    constructor({ document, section }) {
      this.document = document;
      this.section = section;
    }
    toString() {
      return `${this.document}\xA7${this.section}`;
    }
    static get(xref) {
      const key = `${xref.document}:${xref.section}`;
      const canonical = this.instances[key];
      if (canonical) {
        return canonical;
      }
      return this.instances[key] = new CrossReference(xref);
    }
  }
  Model2.CrossReference = CrossReference;
})(Model || (Model = {}));
//# sourceMappingURL=Model.js.map
