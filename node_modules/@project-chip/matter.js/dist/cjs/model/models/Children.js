"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Children_exports = {};
__export(Children_exports, {
  Children: () => Children
});
module.exports = __toCommonJS(Children_exports);
var import_MatterError = require("../../common/MatterError.js");
var import_Model = require("./Model.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function Children(initial, adopt, disown) {
  const children = Array();
  let reified = false;
  let indices;
  function reify() {
    if (reified) {
      return;
    }
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      if (child instanceof import_Model.Model) {
        continue;
      }
      child = import_Model.Model.create(child);
      adopt(child);
      children[i] = child;
    }
    reified = true;
  }
  function hasModel(child) {
    if (child instanceof import_Model.Model) {
      return true;
    }
    return child.children?.some(hasModel);
  }
  function insertionFormOf(child) {
    if (child instanceof import_Model.Model) {
      return child;
    }
    if (reified || hasModel(child)) {
      return import_Model.Model.create(child);
    }
    return child;
  }
  function indexInsert(index, key, model) {
    const existing = index[key];
    if (existing) {
      if (Array.isArray(existing)) {
        existing.push(model);
      } else {
        index[key] = [existing, model];
      }
    } else {
      index[key] = model;
    }
  }
  function indexDelete(index, key, model) {
    const existing = index[key];
    if (existing === model) {
      delete index[key];
    }
    if (Array.isArray(existing)) {
      const pos = existing.indexOf(model);
      if (pos === -1) {
        return;
      }
      existing.splice(pos, 1);
      if (existing.length === 1) {
        index[key] = existing[0];
      }
      return;
    }
  }
  function buildIndex(type) {
    reify();
    const byId = Array();
    const byName = {};
    for (const child of children) {
      if (child instanceof type) {
        const id = child.effectiveId;
        if (id !== void 0) {
          indexInsert(byId, id, child);
        }
        indexInsert(byName, child.name, child);
      }
    }
    const slot = { byId, byName };
    if (!indices) {
      indices = /* @__PURE__ */ new Map();
    }
    indices.set(type, slot);
    return slot;
  }
  function deleteChild(child) {
    if (indices) {
      for (const [type, slot] of indices.entries()) {
        if (child instanceof type) {
          if (child.id) {
            indexDelete(slot.byId, child.id, child);
          }
          indexDelete(slot.byName, child.name, child);
        }
      }
    }
    disown(child);
  }
  function addChild(child) {
    if (child.parent?.children === children) {
      return;
    }
    if (indices) {
      for (const [type, slot] of indices.entries()) {
        if (child instanceof type) {
          if (child.id) {
            indexInsert(slot.byId, child.id, child);
          }
          indexInsert(slot.byName, child.name, child);
        }
      }
    }
    adopt(child);
  }
  function get(type, idOrName) {
    const value = all(type, idOrName);
    if (Array.isArray(value)) {
      return value[0];
    }
    return value;
  }
  function all(type, idOrName) {
    const slot = indices?.get(type) ?? buildIndex(type);
    if (idOrName === void 0) {
      return Object.values(slot.byName).flatMap((entry) => entry);
    }
    let result;
    if (typeof idOrName === "number") {
      result = slot.byId[idOrName];
    } else {
      result = slot.byName[idOrName];
    }
    if (result === void 0) {
      return [];
    }
    if (Array.isArray(result)) {
      return result;
    }
    return [result];
  }
  function selectTypes(tags) {
    if (tags === void 0 || tags === "*") {
      return [import_Model.Model];
    }
    if (typeof tags === "string") {
      tags = [tags];
    }
    const result = Array();
    for (const tag of tags) {
      const type = import_Model.Model.types[tag];
      if (type === void 0) {
        throw new import_MatterError.ImplementationError(`Unknown element tag "${tag}"`);
      }
      result.push(type);
    }
    return result;
  }
  function indexLookup(selector, indexName, allowedTags, except, processor) {
    for (const type of selectTypes(allowedTags)) {
      let slot = indices?.get(type);
      if (slot === void 0) {
        slot = buildIndex(type);
      }
      const index = slot[indexName];
      const entry = index[selector];
      if (Array.isArray(entry)) {
        for (const subentry of entry) {
          if (except?.has(subentry)) {
            continue;
          }
          const result = processor(subentry);
          if (result !== void 0) {
            return result;
          }
        }
        continue;
      }
      if (entry) {
        if (except?.has(entry)) {
          continue;
        }
        const result = processor(entry);
        if (result) {
          return result;
        }
      }
    }
  }
  function indexApply(selector, allowedTags, except) {
    for (const type of selectTypes(allowedTags)) {
      let index = indices?.get(type)?.byName;
      if (!index) {
        index = buildIndex(type).byName;
      }
      for (const key in index) {
        const entry = index[key];
        if (Array.isArray(entry)) {
          for (const subentry of entry) {
            if (except?.has(subentry)) {
              continue;
            }
            if (selector(subentry)) {
              return subentry;
            }
          }
          continue;
        }
        if (except?.has(entry)) {
          continue;
        }
        if (selector(entry)) {
          return entry;
        }
      }
    }
  }
  function select(selector, allowedTags, except) {
    reify();
    if (typeof selector === "string") {
      return indexLookup(selector, "byName", allowedTags, except, (model) => model);
    }
    if (typeof selector === "number") {
      return indexLookup(selector, "byId", allowedTags, except, (model) => model);
    }
    return indexApply(selector, allowedTags, except);
  }
  function selectAll(selector, allowedTags, except) {
    reify();
    const results = Array();
    if (typeof selector === "string") {
      indexLookup(selector, "byName", allowedTags, except, (model) => {
        results.push(model);
      });
    } else {
      indexLookup(selector, "byId", allowedTags, except, (model) => {
        results.push(model);
      });
    }
    return results;
  }
  function updateId(child, oldId) {
    if (!indices) {
      return;
    }
    for (const [type, slot] of indices.entries()) {
      if (child instanceof type) {
        if (oldId !== void 0) {
          indexDelete(slot.byId, oldId, child);
        }
        if (child.id !== void 0) {
          indexInsert(slot.byId, child.id, child);
        }
      }
    }
  }
  function updateName(child, oldName) {
    if (!indices) {
      return;
    }
    for (const [type, slot] of indices.entries()) {
      if (child instanceof type) {
        if (oldName !== void 0) {
          indexDelete(slot.byName, oldName, child);
        }
        if (child.name !== void 0) {
          indexInsert(slot.byName, child.name, child);
        }
      }
    }
  }
  function splice(index, deleteCount, ...toAdd) {
    toAdd = toAdd.map((child) => {
      child = insertionFormOf(child);
      if (child instanceof import_Model.Model) {
        adopt(child);
      }
      return child;
    });
    const result = children.splice(index, deleteCount ?? 0, ...toAdd);
    return result.map((child) => {
      if (child instanceof import_Model.Model) {
        disown(child);
      } else {
        child = import_Model.Model.create(child);
      }
      return child;
    });
  }
  function freeze() {
    for (const child of self) {
      child.freeze();
    }
    Object.freeze(children);
  }
  const self = new Proxy(children, {
    get: (_target, p, receiver) => {
      if (typeof p === "string" && p.match(/^[0-9]+$/)) {
        let child = children[p];
        if (child && !(child instanceof import_Model.Model)) {
          child = import_Model.Model.create(child);
          addChild(child);
          children[p] = child;
        }
        return child;
      }
      switch (p) {
        case "get":
          return get;
        case "all":
          return all;
        case "select":
          return select;
        case "selectAll":
          return selectAll;
        case "updateId":
          return updateId;
        case "updateName":
          return updateName;
        case "splice":
          return splice;
        case "freeze":
          return freeze;
        case "toString":
          return () => `[Children: ${children.length}]`;
      }
      return Reflect.get(children, p, receiver);
    },
    set: (_target, p, newValue, receiver) => {
      if (typeof p !== "string" || !p.match(/^[0-9]+$/)) {
        return Reflect.set(children, p, newValue, receiver);
      }
      if (typeof newValue !== "object" || newValue === null || !newValue.tag) {
        throw new import_MatterError.ImplementationError("Child must be Model or AnyElement");
      }
      const existing = children[p];
      if (existing !== void 0) {
        if (existing === newValue) {
          return true;
        }
        if (existing instanceof import_Model.Model) {
          deleteChild(existing);
        }
      }
      if (newValue.parent?.children === self) {
        const currentIndex = children.indexOf(newValue);
        if (currentIndex !== -1) {
          children.splice(currentIndex, 1);
        }
        return true;
      }
      newValue = insertionFormOf(newValue);
      children[p] = newValue;
      if (newValue instanceof import_Model.Model) {
        addChild(newValue);
      }
      return true;
    },
    deleteProperty: (_target, p) => {
      let child;
      if (typeof p === "string" && p.match(/^[0-9]+$/)) {
        child = children[p];
      }
      delete children[p];
      if (child instanceof import_Model.Model && !children.includes(child)) {
        deleteChild(child);
      }
      return true;
    }
  });
  initial = [...initial];
  self.push(...initial);
  return self;
}
//# sourceMappingURL=Children.js.map
