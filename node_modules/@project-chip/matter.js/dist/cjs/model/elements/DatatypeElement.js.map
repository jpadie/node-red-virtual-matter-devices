{
  "version": 3,
  "sources": ["../../../../src/model/elements/DatatypeElement.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ElementTag, Metatype } from \"../definitions/index.js\";\nimport { BaseElement } from \"./BaseElement.js\";\nimport { FieldElement } from \"./FieldElement.js\";\nimport { ValueElement } from \"./ValueElement.js\";\n\n/**\n * A datatype represents a named, standalone type definition.\n */\nexport interface DatatypeElement extends ValueElement {\n    tag: `${DatatypeElement.Tag}`;\n\n    /**\n     * A \"metatype\" provides enough semantics for us to translate a value into\n     * a native datatype.  Metatype is only required on global datatypes, and\n     * only when the datatype should map directly to a specific native (JS)\n     * type.\n     */\n    metatype?: `${Metatype}`;\n\n    /**\n     * You can only reference a datatype by name.  It does not have an ID.\n     */\n    id?: undefined;\n\n    children?: FieldElement[];\n}\n\nexport function DatatypeElement(definition: DatatypeElement.Properties) {\n    return ValueElement(DatatypeElement.Tag, definition) as DatatypeElement;\n}\n\nexport namespace DatatypeElement {\n    export const Tag = ElementTag.Datatype;\n    export type Tag = typeof ElementTag.Datatype;\n    export type Properties = BaseElement.Properties<DatatypeElement>;\n\n    /**\n     * Convert a TypeScript enum to Matter enum values.\n     *\n     * Matter enums include conformance and other metadata.  They may also have\n     * multiple definitions of the same value selectable by conformance.  So\n     * we can't use a TypeScript enum directly.\n     */\n    export function ListValues(values: ValueMap): ListValues {\n        const result = Array<FieldElement>();\n\n        for (const [k, v] of Object.entries(values)) {\n            if (typeof v === \"number\") {\n                result.push(\n                    FieldElement({\n                        id: v,\n                        name: k,\n                        type: \"uint8\",\n                        default: v,\n                    }),\n                );\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * We express enum values as IntElements as this gives us conformance\n     * and other metadata.\n     */\n    export type ListValues = FieldElement[];\n\n    /**\n     * Per the Matter specification, enums are named integers.  The following\n     * allows TypeScript enums to be supplied for translation into Matter\n     * enums.  To do so, we must accept both numeric and string values.  For\n     * generating the Matter enum we ignore the string keys.\n     */\n    export type ValueMap = { [name: string]: number | string };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,yBAAqC;AAErC,0BAA6B;AAC7B,0BAA6B;AAT7B;AAAA;AAAA;AAAA;AAAA;AAiCO,SAAS,gBAAgB,YAAwC;AACpE,aAAO,kCAAa,gBAAgB,KAAK,UAAU;AACvD;AAAA,CAEO,CAAUA,qBAAV;AACI,EAAMA,iBAAA,MAAM,8BAAW;AAWvB,WAAS,WAAW,QAA8B;AACrD,UAAM,SAAS,MAAoB;AAEnC,eAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,MAAM,GAAG;AACzC,UAAI,OAAO,MAAM,UAAU;AACvB,eAAO;AAAA,cACH,kCAAa;AAAA,YACT,IAAI;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,YACN,SAAS;AAAA,UACb,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAjBO,EAAAA,iBAAS;AAAA,GAZH;",
  "names": ["DatatypeElement"]
}
