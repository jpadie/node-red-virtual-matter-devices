{
  "version": 3,
  "sources": ["../../../../src/model/logic/DefaultValue.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { NotImplementedError } from \"../../common/MatterError.js\";\nimport { ByteArray } from \"../../util/ByteArray.js\";\nimport { camelize } from \"../../util/String.js\";\nimport { AttributeModel, FieldValue, Metatype } from \"../index.js\";\nimport { ValueModel } from \"../models/index.js\";\nimport { FeatureMap } from \"../standard/elements/FeatureMap.js\";\n\n/**\n * Obtain a native JS default value for a ValueModel.\n *\n * This code assumes defaults have been previously validated (e.g. by model validator).  It throws errors for a few\n * structural issues but generally returns undefined if the model's default value cannot be converted to the correct\n * type.\n *\n * @param model the model from which the default value is extracted\n * @param ifValid some structs only have partial defaults defined so would be invalid; do not return these\n */\nexport function DefaultValue(model: ValueModel, ifValid = false): any {\n    const value = castValue(model, model.default);\n    if (value === undefined) {\n        return buildValue(model, ifValid);\n    }\n    return value;\n}\n\n/**\n * When an explicit value is present, cast to native JS type.\n */\nfunction castValue(model: ValueModel, modelDefault?: FieldValue): unknown {\n    if (modelDefault === undefined) {\n        return;\n    }\n\n    if (modelDefault === null) {\n        if (model.nullable) {\n            return null;\n        }\n        return;\n    }\n\n    const metatype = model.effectiveMetatype;\n    switch (metatype) {\n        case undefined:\n        case Metatype.any:\n            return FieldValue.unwrap(modelDefault);\n\n        case Metatype.integer:\n        case Metatype.float:\n            return FieldValue.numericValue(modelDefault, model.type);\n\n        case Metatype.enum:\n            let enumValueModel;\n            if (typeof modelDefault === \"number\" || typeof modelDefault === \"string\") {\n                enumValueModel = model.member(modelDefault);\n            }\n            if (enumValueModel) {\n                return enumValueModel.effectiveId;\n            }\n            return;\n\n        case Metatype.bitmap:\n            // Bitmaps defaults may be encoded three ways - number, bitfield k/v object, or via defaults on individual\n            // bit fields (composed above)\n            if (typeof modelDefault === \"number\" || typeof modelDefault === \"bigint\") {\n                // Default value is a number\n                return decodeBitmap(model, modelDefault);\n            }\n\n            // Default value may be an object\n            return FieldValue.objectValue(modelDefault);\n\n        case Metatype.object:\n            return FieldValue.objectValue(modelDefault);\n\n        case Metatype.string:\n            return `${modelDefault}`;\n\n        case Metatype.bytes:\n            if (ArrayBuffer.isView(modelDefault)) {\n                return new ByteArray(modelDefault.buffer, modelDefault.byteOffset, modelDefault.byteLength);\n            }\n            if (typeof modelDefault === \"string\") {\n                return ByteArray.fromHex(modelDefault);\n            }\n            return;\n\n        case Metatype.date:\n            if (modelDefault instanceof Date) {\n                return modelDefault;\n            }\n            if (typeof modelDefault === \"number\" || typeof modelDefault === \"string\") return new Date(modelDefault);\n            return;\n\n        case Metatype.array:\n            if (Array.isArray(modelDefault)) {\n                const entry = model.member(\"entry\");\n                if (entry instanceof ValueModel) {\n                    return modelDefault.map(value => castValue(entry, value));\n                }\n                return modelDefault;\n            }\n            return;\n\n        case Metatype.boolean:\n            return !!modelDefault;\n\n        default:\n            throw new NotImplementedError(`Unsupported metatype \"${metatype}\"`);\n    }\n}\n\n/**\n * When an explicit default value is not present, for some types we generate a default from the structure.\n */\nfunction buildValue(model: ValueModel, ifValid: boolean) {\n    switch (model.effectiveMetatype) {\n        case Metatype.array:\n            // We don't really build default array values except in the case of non-nullable arrays where zero items is\n            // allowed; then we create an empty array\n            if (\n                !model.nullable &&\n                model.effectiveMetatype === Metatype.array &&\n                !model.constraint.min &&\n                !model.constraint.value\n            ) {\n                return [];\n            }\n            return;\n\n        case Metatype.object:\n            return buildObject(model, ifValid);\n\n        case Metatype.bitmap:\n            return buildBitmap(model);\n    }\n}\n\nfunction buildObject(model: ValueModel, ifValid: boolean) {\n    let result: { [key: string]: any } | undefined;\n\n    for (const child of model.conformantMembers) {\n        const name = camelize(child.name);\n        if (result && result[name] !== undefined) {\n            continue;\n        }\n\n        const value = child.effectiveDefault;\n        if (value !== undefined) {\n            if (!result) {\n                result = {};\n            }\n\n            result[name] = value;\n            continue;\n        }\n\n        if (ifValid && !child.nullable) {\n            // We can't create a valid default object because we don't have default values for all nullable fields\n            return;\n        }\n    }\n\n    return result;\n}\n\nfunction buildBitmap(model: ValueModel) {\n    let result;\n    let fieldsDefined = 0;\n\n    for (const m of model.conformantMembers) {\n        const defaultValue = FieldValue.numericValue(m.default);\n        if (defaultValue === undefined) {\n            continue;\n        }\n\n        if (result === undefined) {\n            result = 0;\n        }\n\n        let minBit, maxBit;\n\n        const constraintValue = FieldValue.numericValue(m.constraint.value);\n        if (constraintValue !== undefined) {\n            minBit = constraintValue;\n            maxBit = constraintValue + 1;\n        } else {\n            minBit = FieldValue.numericValue(m.constraint.min);\n            maxBit = FieldValue.numericValue(m.constraint.max);\n        }\n\n        if (minBit === undefined) {\n            minBit = 0;\n        }\n        if (maxBit === undefined) {\n            maxBit = Math.trunc(Math.log2(defaultValue)) + 1;\n        }\n\n        for (let i = 0, mask = 1 << minBit; i < maxBit - minBit; i++, mask << 1) {\n            if (fieldsDefined & mask) {\n                continue;\n            }\n            fieldsDefined |= mask;\n            if (defaultValue & (1 << i)) {\n                result |= mask;\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction decodeBitmap(model: ValueModel, value: number | bigint) {\n    const fields = new Map<ValueModel, number | boolean>();\n\n    // Test each bit.  If set, install appropriate value into object\n    for (let bit = 0; Math.pow(bit, 2) <= value; bit++) {\n        if (typeof value === \"bigint\") {\n            if (!(value & (1n << BigInt(bit)))) {\n                continue;\n            }\n        } else if (!(value & (1 << bit))) {\n            continue;\n        }\n\n        const definition = model.bitDefinition(bit);\n        if (!definition || definition.isDeprecated) {\n            continue;\n        }\n\n        const constraint = definition.effectiveConstraint;\n        if (constraint.value !== undefined) {\n            // Bit flag\n            fields.set(definition, true);\n        } else if (constraint.min !== undefined) {\n            // Bit range\n            const fieldBit = 1 << (bit - (constraint.min as number));\n            fields.set(definition, ((fields.get(definition) as number) ?? 0) & fieldBit);\n        }\n    }\n\n    let nameGenerator;\n    if (model instanceof AttributeModel && model.id === FeatureMap.id) {\n        // Special case for feature map; use the description as the key rather than the name\n        nameGenerator = (model: ValueModel) =>\n            model.description === undefined ? camelize(model.name) : camelize(model.description);\n    } else {\n        nameGenerator = (model: ValueModel) => camelize(model.name);\n    }\n\n    return Object.fromEntries([...fields.entries()].map(([k, v]) => [nameGenerator(k), v]));\n}\n"],
  "mappings": "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",
  "names": ["model"]
}
