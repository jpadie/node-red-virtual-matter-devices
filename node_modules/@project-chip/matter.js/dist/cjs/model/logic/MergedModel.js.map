{
  "version": 3,
  "sources": ["../../../../src/model/logic/MergedModel.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { Constraint } from \"../aspects/index.js\";\nimport { ElementTag, Metatype, Specification } from \"../definitions/index.js\";\nimport { AnyElement } from \"../elements/index.js\";\nimport { Model, ValueModel } from \"../models/index.js\";\nimport { ModelVariantTraversal, TraverseMap, VariantDetail } from \"./ModelVariantTraversal.js\";\n\n/**\n * Merge multiple variants of an element into a single element.\n */\nexport function MergedModel(\n    revision: Specification.Revision,\n    variants: TraverseMap,\n    priorities = MergedModel.DefaultPriorities,\n): Model {\n    const priority = new PriorityHandler(priorities || MergedModel.DefaultPriorities);\n    const visitor = new MergeTraversal<Model>(revision, priority, (variants, recurse) => {\n        const merged = merge(variants);\n\n        if (variants.tag === ElementTag.Cluster) {\n            reparentToCanonicalParent(revision, priority, variants);\n        }\n\n        // If the manual override specifies a type but no children, ignore children from other variants.  This allows us\n        // to override to a type that doesn't have children\n        const manual = priority.get(variants.tag, \"type\")[0];\n        if (merged.type && variants.map[manual]?.type === merged.type && !variants.map[manual].children?.length) {\n            return merged;\n        }\n\n        // Update the type for any untyped variant.  This allows model logic relying on parent type to work without\n        // overrides specifying the type explicitly\n        if (merged.type) {\n            for (const variant of Object.values(variants.map)) {\n                if (variant.type === undefined) {\n                    variant.type = merged.type;\n                }\n            }\n        }\n\n        merged.children = recurse();\n\n        return merged;\n    });\n    return visitor.traverse(variants);\n\n    /**\n     * Merge the fields (excluding children) of a specific model.\n     */\n    function merge(variants: VariantDetail): Model {\n        const variantValues = Object.fromEntries(\n            Object.entries(variants.map).map(([variantName, variant]) => [variantName, variant.valueOf()]),\n        );\n\n        const keys = new Set(Object.values(variantValues).flatMap(v => Object.keys(v)));\n        keys.delete(\"children\");\n\n        const properties = Object.fromEntries([...keys].map(k => [k, visitor.pluck(variants.tag, k, variantValues)]));\n\n        // Specialized support for type\n        if (properties.type) {\n            const type = visitor.chooseType(variants);\n            if (type?.type !== undefined && type?.type !== null) {\n                properties.type = type.type;\n            }\n        }\n\n        // Specialized support for constraint -- non-empty constraints should override \"desc\"\n        const constraint = new Constraint(properties.constraint);\n        if (constraint.desc) {\n            for (const key of priority.get(\"*\", \"constraint\")) {\n                const definition = (variants.map[key] as ValueModel | undefined)?.constraint;\n                const constraint = new Constraint(definition);\n                if (!constraint?.empty && !constraint?.desc) {\n                    properties.constraint = definition;\n                    break;\n                }\n            }\n        }\n\n        return Model.create(properties as AnyElement);\n    }\n}\n\n/**\n * Specialized tree traversal supporting element merge.\n */\nclass MergeTraversal<S> extends ModelVariantTraversal<S> {\n    constructor(\n        revision: Specification.Revision,\n        public priority: PriorityHandler,\n        public visitor: (variants: VariantDetail, recurse: () => S[]) => S,\n    ) {\n        super(revision, priority.get(\"*\", \"type\"));\n    }\n\n    visit(variants: VariantDetail, recurse: () => S[]) {\n        return this.visitor(variants, recurse);\n    }\n\n    /**\n     * Use priority rules to select a single value from available variants.\n     */\n    pluck(\n        tag: ElementTag | \"*\",\n        fieldName: string,\n        variantValues: { [variantName: string]: { [fieldName: string]: any } },\n    ) {\n        const variantPriorities = this.priority.get(tag, fieldName);\n\n        for (const variantName of variantPriorities) {\n            const variantValue = variantValues[variantName]?.[fieldName];\n            if (variantValue !== undefined) {\n                return variantValue;\n            }\n        }\n    }\n\n    /**\n     * Type selection is more complicated than other fields.\n     */\n    chooseType(variants: VariantDetail) {\n        const variantPriorities = this.priority.get(variants.tag, \"type\");\n\n        let type: Model | undefined;\n        let metatype: Metatype | undefined;\n        for (const sourceName of variantPriorities) {\n            const variant = variants.map[sourceName];\n            if (!variant) {\n                continue;\n            }\n\n            if (sourceName === variantPriorities[0]) {\n                // Always prefer highest priority variant which is presumably a hand edit\n                return variant;\n            }\n\n            if (!type) {\n                type = variant;\n                if (type instanceof ValueModel) {\n                    metatype = type.effectiveMetatype;\n                }\n                continue;\n            }\n            if (!(type instanceof ValueModel) || !(variant instanceof ValueModel)) {\n                continue;\n            }\n\n            let overridePriority;\n            const variantMetatype = variant.effectiveMetatype;\n            if (!metatype) {\n                if (variantMetatype) {\n                    // This is not the highest priority type but it's actually useful\n                    overridePriority = true;\n                }\n            } else if (metatype === Metatype.integer) {\n                const variantMetatype = variant.effectiveMetatype;\n                if (variantMetatype === Metatype.enum || variantMetatype === Metatype.bitmap) {\n                    // Even though this is not the highest priority type, it's more specific\n                    overridePriority = true;\n                }\n            }\n\n            if (overridePriority) {\n                type = variant;\n                metatype = variantMetatype;\n            }\n        }\n\n        return type;\n    }\n}\n\n/**\n * Utility class for working with merge priorities.\n */\nclass PriorityHandler {\n    constructor(private priorities: MergedModel.Priorities) {}\n\n    /**\n     * Get the priority for a specific tag and field.\n     */\n    get(typeName: string, fieldName: string) {\n        const priority =\n            this.priorities[typeName]?.[fieldName] ||\n            this.priorities[\"*\"]?.[fieldName] ||\n            this.priorities[typeName]?.[\"*\"] ||\n            this.priorities[\"*\"]?.[\"*\"];\n\n        if (!priority) {\n            throw new InternalError(\"No default (*, *) priority available\");\n        }\n\n        return priority;\n    }\n}\n\n/**\n * One complexity of merge is that types can either have children directly, or they can reference a type that contains\n * the children.  For example, the specification defines most attributes as enums and lists values without naming a\n * separate enum type.\n *\n * CHIP XML OTOH doesn't support this structure -- it makes up enum names if the spec doesn't define a separate type.\n *\n * We want to do whatever the spec does.  In this case this means we need to move the children from MyPropertyEnum into\n * MyPropertyAttribute if the final type will be enum8 rather than MyPropertyEnum.\n *\n * To keep things simple we do this in a separate preprocessing pass before performing the actual merge.\n *\n * Another simplifying assumption we make is that we will only ever move children *into* the direct parent from the\n * cluster-scoped type, not the other way around.  We know this is true because CHIP doesn't support direct children and\n * the structures we build ourselves are already in the preferred format.\n */\nfunction reparentToCanonicalParent(\n    revision: Specification.Revision,\n    priority: PriorityHandler,\n    variants: VariantDetail,\n) {\n    // Collect datatypes from which we move children so we can discard\n    const deparented = Array<Model>();\n\n    // Now visit the tree and reparent as necessary\n    const traversal = new MergeTraversal(revision, priority, (variants, recurse) => {\n        // Determine the canonical type for this element\n        const type = traversal.chooseType(variants);\n        if (!(type instanceof ValueModel)) {\n            recurse();\n            return;\n        }\n\n        // If the canonical type is a seed type that can have children, variants that reference a local type with\n        // children need to be rewritten\n        if (type.base?.isSeed && Metatype.hasChildren(type.effectiveMetatype)) {\n            for (const variantName in variants.map) {\n                // Skip if this is the canonical variant or this variant already has children\n                const variant = variants.map[variantName];\n                if (variant === type || variant.children.length) {\n                    continue;\n                }\n\n                // Skip if the base type is not local to the cluster or doesn't have children\n                const base = variant.base;\n                if (!(base instanceof ValueModel) || base.parent?.tag !== ElementTag.Cluster || !base.children.length) {\n                    continue;\n                }\n\n                // Skip if multiple models reference the type\n                if (base.parent?.references(base).length > 1) {\n                    continue;\n                }\n\n                // Rewrite\n                deparented.push(base);\n                variant.children = base.children;\n                variant.type = base.type;\n            }\n        }\n\n        recurse();\n    });\n    traversal.traverse(variants.map);\n\n    // Remove deparented datatypes.  We do this after recursing because removing from a set we're actively visiting may\n    // be problematic\n    deparented.forEach(m => (m.parent = undefined));\n\n    return variants;\n}\n\nexport namespace MergedModel {\n    /**\n     * Priorities define rules that control how values are merged.\n     */\n    export type Priorities = {\n        /**\n         * An element type or \"*\" to match all elements.\n         */\n        [typeName: string]: {\n            /**\n             * A field name or \"*\" to match all fields.\n             */\n            [fieldName: string]: string[];\n        };\n    };\n\n    /**\n     * A default set of priorities for the variants included with matter.js. We currently have \"chip\" as preferred over\n     * \"spec\" by default, but then have overridden to reverse this for a lot of fields.  Should probably revisit the\n     * default at some point.\n     */\n    export const DefaultPriorities: Priorities = {\n        \"*\": {\n            \"*\": [\"local\", \"chip\", \"spec\"],\n\n            // Prefer spec for elements that are insufficiently defined in chip\n            conformance: [\"local\", \"spec\", \"chip\"],\n            constraint: [\"local\", \"spec\", \"chip\"],\n            quality: [\"local\", \"spec\", \"chip\"],\n            access: [\"local\", \"spec\", \"chip\"],\n\n            // Prefer spec for element names\n            name: [\"local\", \"spec\", \"chip\"],\n\n            // Prefer spec for datatype names (must match element names)\n            type: [\"local\", \"spec\", \"chip\"],\n\n            // Prefer spec for detailed documentation\n            details: [\"local\", \"spec\", \"chip\"],\n\n            // Prefer spec for default values\n            default: [\"local\", \"spec\", \"chip\"],\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": ["variants", "constraint", "variantMetatype", "MergedModel"]
}
