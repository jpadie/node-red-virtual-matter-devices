{
  "version": 3,
  "sources": ["../../../../../src/model/logic/definition-validation/ValueValidator.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Access, Conformance, Constraint, Quality } from \"../../aspects/index.js\";\nimport { DefinitionError, FieldValue, Metatype } from \"../../definitions/index.js\";\nimport { ClusterModel, ValueModel } from \"../../models/index.js\";\nimport * as Elements from \"../../standard/elements/index.js\";\nimport { ModelValidator } from \"./ModelValidator.js\";\nimport { ValidationExceptions } from \"./ValidationExceptions.js\";\n\n/**\n * Validates models that extend DataModel.\n */\nexport class ValueValidator<T extends ValueModel> extends ModelValidator<T> {\n    override validate() {\n        this.validateProperty({ name: \"type\", type: \"string\" });\n        this.validateProperty({ name: \"byteSize\", type: \"number\" });\n        this.validateProperty({ name: \"constraint\", type: Constraint });\n        this.validateProperty({ name: \"conformance\", type: Conformance });\n        this.validateProperty({ name: \"access\", type: Access });\n        this.validateProperty({ name: \"quality\", type: Quality });\n        this.validateProperty({ name: \"metatype\", type: Metatype });\n\n        this.model.conformance.validateReferences(name => {\n            // Features are all caps, other names are field references\n            if (name.match(/^[A-Z0-9_$]+$/)) {\n                // Feature lookup\n                const cluster = this.model.owner(ClusterModel);\n                return !!cluster?.features.find(f => f.name === name);\n            } else {\n                // Field lookup\n                return !!this.model.parent?.member(name);\n            }\n        });\n\n        this.validateAspect(\"conformance\");\n        this.validateAspect(\"constraint\");\n        this.validateAspect(\"access\");\n        this.validateAspect(\"quality\");\n\n        this.validateType();\n        this.validateEntries();\n\n        super.validate();\n    }\n\n    private validateAspect(name: string) {\n        const aspect = (this.model as any)[name];\n        if (aspect?.errors) {\n            aspect.errors.forEach((e: DefinitionError) => this.model.error(e.code, e.message));\n        }\n    }\n\n    private validateType() {\n        if (this.model.effectiveType === undefined) {\n            if (this.model.metatype) {\n                // Not a derivative type\n                return;\n            }\n\n            // Spec does not always provide type information for deprecated fields\n            if (this.model.isDeprecated || this.model.isDisallowed) {\n                return;\n            }\n\n            // Non-global types must specify a base type\n            this.error(\"NO_TYPE\", \"No type information\");\n            return;\n        }\n\n        const base = this.model.base;\n        if (base === undefined) {\n            // Error is reported as ModelValidator TYPE_UNKNOWN\n            return;\n        }\n\n        const metabase = this.model.metabase;\n        if (metabase === undefined) {\n            this.error(\"METATYPE_UNKNOWN\", `No metatype for ${this.model.type}`);\n            return;\n        }\n        const metatype = metabase.metatype;\n        if (metatype === undefined) {\n            // This shouldn't happen because the presence of the metatype is what makes it a metabase.  But eslint\n            // doesn't know that\n            this.error(\"METATYPE_MISSING\", `Metabase ${metabase.name} has no metatype`);\n            return;\n        }\n\n        let defaultValue = this.model.default;\n        if (defaultValue === undefined) {\n            return;\n        }\n\n        if (this.validateSpecialDefault(metatype, defaultValue)) {\n            return;\n        }\n\n        // Convert value to proper type if possible\n        if (metatype === Metatype.string && defaultValue === \"empty\") {\n            // Metatype doesn't handle this case because otherwise you'd never be able to have a string called \"empty\".\n            // In this case though the data likely comes from the spec so we're going to take a flyer and say you can\n            // never have \"empty\" as a default value\n            delete this.model.default;\n            return;\n        }\n        const cast = FieldValue.cast(metatype, defaultValue);\n        if (cast === FieldValue.Invalid) {\n            this.error(\"INVALID_VALUE\", `Value \"${defaultValue}\" is not a ${metatype}`);\n            return;\n        }\n        defaultValue = cast;\n\n        // For enums convert string name to numeric ID\n        if (metatype === Metatype.enum) {\n            if (typeof defaultValue === \"string\") {\n                let member = this.model.member(defaultValue);\n\n                // If the name didn't match, try case-insensitive search\n                if (!member) {\n                    member = this.model.member(\n                        model => model.name.toLowerCase() === (defaultValue as string).toLowerCase(),\n                    );\n                }\n\n                if (member && member.effectiveId !== undefined) {\n                    defaultValue = member.effectiveId;\n                } else {\n                    this.error(\"INVALID_ENTRY\", `\"${defaultValue}\" is not in ${metatype} ${this.model.type}`);\n                }\n            }\n        }\n\n        this.model.default = defaultValue;\n    }\n\n    private validateEntries() {\n        // Note - these checks only apply for first-order derived types, so use direct metatype\n        const metatype =\n            this.model.type === undefined\n                ? undefined\n                : (Elements as unknown as Record<string, ValueModel>)[this.model.type]?.metatype;\n        switch (metatype) {\n            case Metatype.object:\n                if (!this.model.children.length) {\n                    this.error(\"CHILDLESS_STRUCT\", `struct element with no children`);\n                }\n                break;\n\n            case Metatype.enum:\n            case Metatype.bitmap:\n                // Only validate models that inherit directly from base enum types\n                const base = this.model.base;\n                if (!base || !base.isSeed || !base.name.startsWith(\"enum\") || this.model.parent?.name === \"semtag\") {\n                    break;\n                }\n\n                // Model must have members unless there is an explicit exception\n                if (!this.model.members.length && !ValidationExceptions.AllowedEmptyEnums.has(this.model.path)) {\n                    this.error(`CHILDLESS_${metatype.toUpperCase()}`, `${this.model.type} with no children`);\n                }\n\n                if (metatype == Metatype.enum) {\n                    this.validateEnumKeys();\n                } else {\n                    this.validateBitFields();\n                }\n                break;\n\n            case Metatype.array:\n                if (!this.model.children.length) {\n                    this.error(\"UNTYPED_ARRAY\", `array element with no entry type`);\n                } else if (this.model.children.length > 1) {\n                    this.error(\"OVERLY_TYPED_ARRAY\", `array element with multiple entry types`);\n                }\n                break;\n        }\n    }\n\n    private validateEnumKeys() {\n        const ids = new Set<number>();\n        const names = new Set<string>();\n        for (const c of this.model.children) {\n            if (c.id) {\n                if (ids.has(c.id)) {\n                    this.error(\n                        \"DUPLICATE_ENUM_ID\",\n                        `${this.model.type} ID 0x${c.id.toString(16)} appears more than once`,\n                    );\n                } else {\n                    ids.add(c.id);\n                }\n            }\n            if (names.has(c.name)) {\n                this.error(\"DUPLICATE_ENUM_NAME\", `${this.model.type} name \"${c.name}\" appears more than once`);\n            }\n        }\n    }\n\n    private validateBitFields() {\n        const ranges = Array<{ name: string; min: number; max: number }>();\n        for (const c of this.model.children) {\n            let min, max;\n\n            if (typeof c.constraint.value === \"number\") {\n                min = c.constraint.value;\n                max = c.constraint.value + 1;\n            } else {\n                min = c.constraint.min;\n                max = c.constraint.max;\n                if (typeof min !== \"number\" || typeof max !== \"number\" || min < 0 || min > max) {\n                    this.error(\n                        \"UNCONSTRAINED_BIT_RANGE\",\n                        `${this.model.type} bit field \"${c.name}\" is not properly constrained`,\n                    );\n                    continue;\n                }\n            }\n\n            for (const r of ranges) {\n                if (min < r.max && max > r.min) {\n                    this.error(\n                        \"OVERLAPPING_BIT_RANGE\",\n                        `${this.model.type} bit fields \"${r.name}\" and \"${c.name}\" overlap`,\n                    );\n                }\n            }\n\n            ranges.push({ name: c.name, min, max });\n        }\n    }\n\n    private validateSpecialDefault(metatype: Metatype, def: any) {\n        // Special \"reference\" object referencing another field by name\n        if (typeof def === \"object\" && FieldValue.is(def, FieldValue.reference)) {\n            const reference = (def as FieldValue.Reference).name;\n            const other = this.model.parent?.member(reference);\n            if (!other) {\n                this.error(\"MEMBER_UNKNOWN\", `Default value references unknown property ${reference}`);\n            }\n            return true;\n        }\n\n        // If the default value is a string referencing another field, convert to a reference object\n        if (typeof def === \"string\") {\n            const other = this.model.parent?.member(def);\n            if (other) {\n                this.model.default = FieldValue.Reference(other.name);\n                return true;\n            }\n        }\n\n        // If the default value for bitmaps is an array, treat as a set of flag names or IDs; validate as such\n        if (metatype === Metatype.bitmap && Array.isArray(def)) {\n            for (const value of def) {\n                if (typeof value !== \"string\" && typeof value !== \"number\") {\n                    this.error(\"INVALID_BIT_FLAG\", `Default bit flag ${def} is not a string or number`);\n                    continue;\n                }\n                if (!this.model.member(value)) {\n                    this.error(\"UNRESOLVED_BIT_FLAG\", `Default bit flag ${def} is not a valid bit value`);\n                }\n            }\n            return true;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
