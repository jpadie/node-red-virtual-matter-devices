{
  "version": 3,
  "sources": ["../../../src/crypto/Crypto.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as mod from \"@noble/curves/abstract/modular\";\nimport * as utils from \"@noble/curves/abstract/utils\";\nimport { p256 } from \"@noble/curves/p256\";\nimport { MatterError, NoProviderError } from \"../common/MatterError.js\";\nimport { ByteArray, Endian } from \"../util/ByteArray.js\";\nimport { DataReader } from \"../util/DataReader.js\";\nimport { PrivateKey } from \"./Key.js\";\n\nexport const ec = {\n    p256,\n    ...utils,\n    ...mod,\n};\n\nexport const CRYPTO_RANDOM_LENGTH = 32;\nexport const CRYPTO_ENCRYPT_ALGORITHM = \"aes-128-ccm\";\nexport const CRYPTO_HASH_ALGORITHM = \"sha256\";\nexport const CRYPTO_EC_CURVE = \"prime256v1\";\nexport const CRYPTO_EC_KEY_BYTES = 32;\nexport const CRYPTO_AUTH_TAG_LENGTH = 16;\nexport const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;\nexport type CryptoDsaEncoding = \"ieee-p1363\" | \"der\";\n\nexport class CryptoVerifyError extends MatterError {}\n\nexport abstract class Crypto {\n    static get: () => Crypto = () => {\n        throw new NoProviderError(\"No provider configured\");\n    };\n\n    abstract encrypt(key: ByteArray, data: ByteArray, nonce: ByteArray, aad?: ByteArray): ByteArray;\n    static readonly encrypt = (key: ByteArray, data: ByteArray, nonce: ByteArray, aad?: ByteArray): ByteArray =>\n        Crypto.get().encrypt(key, data, nonce, aad);\n\n    abstract decrypt(key: ByteArray, data: ByteArray, nonce: ByteArray, aad?: ByteArray): ByteArray;\n    static readonly decrypt = (key: ByteArray, data: ByteArray, nonce: ByteArray, aad?: ByteArray): ByteArray =>\n        Crypto.get().decrypt(key, data, nonce, aad);\n\n    abstract getRandomData(length: number): ByteArray;\n    static readonly getRandomData = (length: number): ByteArray => Crypto.get().getRandomData(length);\n\n    static readonly getRandom = (): ByteArray => Crypto.get().getRandomData(CRYPTO_RANDOM_LENGTH);\n\n    static readonly getRandomUInt16 = (): number =>\n        new DataReader(Crypto.get().getRandomData(2), Endian.Little).readUInt16();\n\n    static readonly getRandomUInt32 = (): number =>\n        new DataReader(Crypto.get().getRandomData(4), Endian.Little).readUInt32();\n\n    static readonly getRandomBigUInt64 = (): bigint =>\n        new DataReader(Crypto.get().getRandomData(8), Endian.Little).readUInt64();\n\n    static readonly getRandomBigInt = (size: number, maxValue?: bigint): bigint => {\n        const { bytesToNumberBE } = ec;\n        if (maxValue === undefined) {\n            return bytesToNumberBE(Crypto.getRandomData(size));\n        }\n        while (true) {\n            const random = bytesToNumberBE(Crypto.getRandomData(size));\n            if (random < maxValue) return random;\n        }\n    };\n\n    abstract ecdhGeneratePublicKey(): { publicKey: ByteArray; ecdh: any };\n    static readonly ecdhGeneratePublicKey = (): { publicKey: ByteArray; ecdh: any } =>\n        Crypto.get().ecdhGeneratePublicKey();\n\n    abstract ecdhGeneratePublicKeyAndSecret(peerPublicKey: ByteArray): {\n        publicKey: ByteArray;\n        sharedSecret: ByteArray;\n    };\n    static readonly ecdhGeneratePublicKeyAndSecret = (\n        peerPublicKey: ByteArray,\n    ): { publicKey: ByteArray; sharedSecret: ByteArray } => Crypto.get().ecdhGeneratePublicKeyAndSecret(peerPublicKey);\n\n    abstract ecdhGenerateSecret(peerPublicKey: ByteArray, ecdh: any): ByteArray;\n    static readonly ecdhGenerateSecret = (peerPublicKey: ByteArray, ecdh: any): ByteArray =>\n        Crypto.get().ecdhGenerateSecret(peerPublicKey, ecdh);\n\n    abstract hash(data: ByteArray | ByteArray[]): ByteArray;\n    static readonly hash = (data: ByteArray | ByteArray[]): ByteArray => Crypto.get().hash(data);\n\n    abstract pbkdf2(secret: ByteArray, salt: ByteArray, iteration: number, keyLength: number): Promise<ByteArray>;\n    static readonly pbkdf2 = (\n        secret: ByteArray,\n        salt: ByteArray,\n        iteration: number,\n        keyLength: number,\n    ): Promise<ByteArray> => Crypto.get().pbkdf2(secret, salt, iteration, keyLength);\n\n    abstract hkdf(secret: ByteArray, salt: ByteArray, info: ByteArray, length?: number): Promise<ByteArray>;\n    static readonly hkdf = (secret: ByteArray, salt: ByteArray, info: ByteArray, length?: number): Promise<ByteArray> =>\n        Crypto.get().hkdf(secret, salt, info, length);\n\n    abstract hmac(key: ByteArray, data: ByteArray): ByteArray;\n    static readonly hmac = (key: ByteArray, data: ByteArray): ByteArray => Crypto.get().hmac(key, data);\n\n    abstract sign(privateKey: JsonWebKey, data: ByteArray | ByteArray[], dsaEncoding?: CryptoDsaEncoding): ByteArray;\n    static readonly sign = (\n        privateKey: JsonWebKey,\n        data: ByteArray | ByteArray[],\n        dsaEncoding?: CryptoDsaEncoding,\n    ): ByteArray => Crypto.get().sign(privateKey, data, dsaEncoding);\n\n    abstract verify(\n        publicKey: JsonWebKey,\n        data: ByteArray,\n        signature: ByteArray,\n        dsaEncoding?: CryptoDsaEncoding,\n    ): void;\n    static readonly verify = (\n        publicKey: JsonWebKey,\n        data: ByteArray,\n        signature: ByteArray,\n        dsaEncoding?: CryptoDsaEncoding,\n    ): void => Crypto.get().verify(publicKey, data, signature, dsaEncoding);\n\n    abstract createKeyPair(): PrivateKey;\n    static readonly createKeyPair = (): PrivateKey => Crypto.get().createKeyPair();\n}\n\n// Hook for testing frameworks\nif (typeof MatterHooks !== \"undefined\") {\n    MatterHooks.cryptoSetup?.(Crypto);\n}\n"],
  "mappings": "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",
  "names": []
}
