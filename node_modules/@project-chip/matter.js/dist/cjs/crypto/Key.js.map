{
  "version": 3,
  "sources": ["../../../src/crypto/Key.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Base64 } from \"../codec/Base64Codec.js\";\nimport { DerCodec, DerNode, DerType } from \"../codec/DerCodec.js\";\nimport { MatterError, NotImplementedError } from \"../common/MatterError.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { ec } from \"./Crypto.js\";\n\nconst {\n    numberToBytesBE,\n    p256: { ProjectivePoint },\n} = ec;\n\nclass KeyError extends MatterError {}\n\nconst JWK_KEYS = [\n    \"crv\",\n    \"d\",\n    \"dp\",\n    \"dq\",\n    \"e\",\n    \"ext\",\n    \"k\",\n    \"key_ops\",\n    \"kty\",\n    \"n\",\n    \"oth\",\n    \"p\",\n    \"q\",\n    \"qi\",\n    \"use\",\n    \"x\",\n    \"y\",\n];\n\nexport enum KeyType {\n    EC = \"EC\",\n    RSA = \"RSA\",\n    oct = \"oct\",\n}\n\nexport enum CurveType {\n    p256 = \"P-256\",\n    p384 = \"P-384\",\n    p521 = \"P-521\",\n}\n\nenum Asn1ObjectID {\n    ecPublicKey = \"2a8648ce3d0201\",\n    prime256r1 = \"2a8648ce3d030107\",\n    prime384r1 = \"0103840022\",\n    prime521r1 = \"0103840023\",\n}\n\nconst CurveLookup = {\n    [Asn1ObjectID.prime256r1]: CurveType.p256,\n    [Asn1ObjectID.prime384r1]: CurveType.p384,\n    [Asn1ObjectID.prime521r1]: CurveType.p521,\n};\n\nexport type BinaryKeyPair = {\n    publicKey: ByteArray;\n    privateKey: ByteArray;\n};\n\n/**\n * Represents a cryptographic key.\n *\n * Models keys as JWK.  Advantages of this format:\n *\n *   - Standard\n *   - Widely supported\n *   - Fully models relevant key types\n *   - Where not supported, extracting constituent parts for translation is trivial\n */\nexport interface Key extends JsonWebKey {\n    /**\n     * The key algorithm, alias for JWK \"alg\" field.\n     */\n    algorithm?: Key[\"alg\"];\n\n    /**\n     * The elliptic curve type, alias for JWK \"crv\" field.\n     */\n    curve?: Key[\"crv\"];\n\n    /**\n     * The key type, alias for JWK \"kty\" field.\n     */\n    type?: Key[\"kty\"];\n\n    /**\n     * Operations supported by the key, alias for JWK \"key_ops\" field.\n     */\n    operations?: Key[\"key_ops\"];\n\n    /**\n     * The private key, alias for JWK \"d\" field.\n     */\n    private?: Key[\"d\"];\n\n    /**\n     * Indicates whether the private key is extractable, alias for JSK \"ext\"\n     * field.\n     */\n    extractable?: Key[\"ext\"];\n\n    alg?: string;\n    crv?: CurveType;\n    d?: string;\n    dp?: string;\n    dq?: string;\n    e?: string;\n    ext?: boolean;\n    k?: string;\n    key_ops?: string[]; // Ideally KeyUsage but any value is legal\n    kty?: KeyType;\n    n?: string;\n    oth?: RsaOtherPrimesInfo[];\n    p?: string;\n    q?: string;\n    qi?: string;\n    use?: string; // \"sig\" | \"enc\" are official values but any value is legal\n    x?: string;\n    y?: string;\n\n    /**\n     * Binary alias to private key field.  Automatically encodes/decodes the\n     * base-64 private key.\n     */\n    privateBits?: ByteArray;\n\n    /**\n     * Binary alias to the x field.  Automatically encodes/decodes the base-64\n     * x-point on EC public keys.\n     */\n    xBits?: ByteArray;\n\n    /**\n     * Binary alias to the y field.  Automatically encodes/decodes the base-64\n     * y-point on EC public keys.\n     */\n    yBits?: ByteArray;\n\n    /**\n     * Import (write-only) of private keys encoded in SEC1 format.\n     */\n    sec1?: ByteArray;\n\n    /**\n     * Import (write-only) of private keys encoded in PKCS #8 format.\n     */\n    pkcs8?: ByteArray;\n\n    /**\n     * Import (write-only) of public keys encoded in SPKI format.\n     */\n    spki?: ByteArray;\n\n    /**\n     * Import/export of EC public key in SEC1/SPKI format.  Maps to x & y\n     * fields internally.\n     */\n    publicBits?: ByteArray;\n\n    /**\n     * Import/export of BinaryKeyPair structure used as an alternate\n     * serialization format for legacy reasons.\n     */\n    keyPairBits?: BinaryKeyPair;\n\n    /**\n     * Alias for publicBits that throws if no public key is present.\n     */\n    publicKey: ByteArray;\n\n    /**\n     * Alias for privateBits that throws if no private key is present.\n     */\n    privateKey: ByteArray;\n\n    /**\n     * Alias for keyPairBits that throws if a complete key pair is not present.\n     */\n    keyPair: BinaryKeyPair;\n}\n\n/**\n * EC key without private fields.\n */\nexport interface PublicKey extends Key {\n    type: KeyType.EC;\n    curve: CurveType;\n    x: string;\n    y: string;\n    xBits: ByteArray;\n    yBits: ByteArray;\n    publicBits: ByteArray;\n}\n\n/**\n * EC key with extractable private fields.\n */\nexport interface PrivateKey extends PublicKey {\n    private: string;\n    d: string;\n    privateBits: ByteArray;\n    privateKey: ByteArray;\n    keyPair: BinaryKeyPair;\n    keyPairBits: BinaryKeyPair;\n}\n\n/**\n * Symmetric key.\n */\nexport interface SymmetricKey extends Key {\n    type: KeyType.oct;\n    private: string;\n    d: string;\n}\n\nfunction checkDerVersion(type: string, node: DerNode | undefined, version: number) {\n    const derVersion =\n        node && node._tag === DerType.Integer && node._bytes && node._bytes.length === 1 && node._bytes[0];\n\n    if (derVersion !== version) {\n        throw new KeyError(`${type} key version mismatch`);\n    }\n}\n\nfunction getDerObjectID(type: string, node?: DerNode) {\n    const id = node && node._tag === DerType.ObjectIdentifier && node._bytes?.length > 1 && node._bytes;\n\n    if (id) return id;\n\n    throw new KeyError(`Missing object in ${type} key`);\n}\n\nfunction getDerCurve(type: string, node?: DerNode) {\n    const oid = getDerObjectID(type, node);\n    const curve = (<any>CurveLookup)[oid.toHex()];\n    if (curve) return curve;\n    throw new KeyError(`Unsupported ${type} EC curve`);\n}\n\nfunction getDerKey(type: string, node?: DerNode, derType: DerType = DerType.OctetString) {\n    const key = node && node._tag === derType && node._bytes?.length > 1 && node._bytes;\n\n    if (key) return key;\n\n    throw new MatterError(`Missing ${type} key node`);\n}\n\n// These are private members of Key, each implementing a key import field\nnamespace Translators {\n    // Import SEC1 private key\n    export const sec1 = {\n        set: function (this: Key, input: ByteArray) {\n            const decoded = DerCodec.decode(input);\n\n            // Version\n            const versionNode = decoded?._elements?.[0];\n            checkDerVersion(\"SEC 1\", versionNode, 1);\n\n            // Curve\n            const curveNode = decoded?._elements?.[2]?._elements?.[0];\n            const curve = getDerCurve(\"SEC 1\", curveNode);\n\n            // Key\n            const keyNode = decoded?._elements?.[1];\n            const key = getDerKey(\"SEC 1\", keyNode);\n\n            this.type = KeyType.EC;\n            this.curve = curve;\n            this.privateBits = key;\n        },\n\n        get: function () {\n            throw new NotImplementedError(\"SEC1 export not implemented\");\n        },\n    };\n\n    // Import PKCS8 private key\n    export const pkcs8 = {\n        set: function (this: Key, input: ByteArray) {\n            const outer = DerCodec.decode(input);\n\n            // Version\n            const version = outer?._elements?.[0];\n            checkDerVersion(\"PKCS #8\", version, 0);\n\n            // Algorithm\n            const algorithmElements = outer?._elements?.[1]?._elements;\n            const algorithm = getDerObjectID(\"PKCS #8\", algorithmElements?.[0]);\n            if (algorithm?.toHex() !== Asn1ObjectID.ecPublicKey) {\n                throw new KeyError(\"Unsupported PKCS #8 decryption algorithm\");\n            }\n\n            // Curve\n            const curve = getDerCurve(\"PKCS #8\", algorithmElements?.[1]);\n\n            // Private key\n            const innerBytes = outer?._elements?.[2]._bytes;\n            if (innerBytes === undefined || innerBytes === null) {\n                throw new KeyError(\"Invalid PKCS #8 key\");\n            }\n            const inner = DerCodec.decode(innerBytes);\n            const key = getDerKey(\"PKCS #8\", inner?._elements?.[1]);\n\n            this.type = KeyType.EC;\n            this.curve = curve;\n            this.privateBits = key;\n        },\n\n        get: function () {\n            throw new NotImplementedError(\"PKCS #8 export not implemented\");\n        },\n    };\n\n    // Import SPKI public key\n    export const spki = {\n        set: function (this: Key, input: ByteArray) {\n            const decoded = DerCodec.decode(input);\n\n            const algorithmElements = decoded?._elements?.[0]?._elements;\n\n            // Algorithm\n            const algorithm = getDerObjectID(\"SPKI\", algorithmElements?.[0]);\n            if (algorithm?.toHex() !== Asn1ObjectID.ecPublicKey) {\n                throw new KeyError(\"Unsupported SPKI decryption algorithm\");\n            }\n\n            // Curve\n            const curve = getDerCurve(\"SPKI\", algorithmElements?.[1]);\n\n            // Key\n            const key = getDerKey(\"SPKI\", decoded?._elements?.[1], DerType.BitString);\n\n            this.type = KeyType.EC;\n            this.curve = curve;\n            this.publicBits = key;\n        },\n\n        get: function () {\n            throw new NotImplementedError(\"SPKI export not implemented\");\n        },\n    };\n\n    // Import public key bytes in SEC1/SPKI format\n    export const publicBits = {\n        set: function (this: Key, input: ByteArray) {\n            if (!(input.length % 2)) {\n                throw new KeyError(\"Invalid public key encoding\");\n            }\n\n            switch (input[0]) {\n                case 2:\n                case 3:\n                    throw new KeyError(\"Unsupported public key compression\");\n\n                case 4:\n                    break;\n\n                case 5:\n                    throw new KeyError(\"Illegal public key format specifier\");\n            }\n\n            const coordinateLength = (input.length - 1) / 2;\n\n            inferCurve(this, coordinateLength);\n\n            this.type = KeyType.EC;\n            this.xBits = input.slice(1, coordinateLength + 1);\n            this.yBits = input.slice(coordinateLength + 1);\n        },\n\n        get: function (this: Key) {\n            if (this.xBits === undefined || this.yBits === undefined) {\n                return undefined;\n            }\n\n            return new ByteArray([0x04, ...this.xBits, ...this.yBits]);\n        },\n    };\n\n    // Import/export from BinaryKeyPair\n    export const keyPairBits = {\n        set: function (this: Key, keyPair: BinaryKeyPair) {\n            this.publicBits = keyPair.publicKey;\n            this.privateBits = keyPair.privateKey;\n        },\n\n        get: function (this: Key): BinaryKeyPair | undefined {\n            const publicBits = this.publicBits;\n            const privateBits = this.privateBits;\n            if (publicBits === undefined || privateBits === undefined) {\n                return;\n            }\n            return {\n                publicKey: publicBits,\n                privateKey: privateBits,\n            };\n        },\n    };\n}\n\nenum Aliases {\n    algorithm = \"alg\",\n    curve = \"crv\",\n    type = \"kty\",\n    operations = \"key_ops\",\n    private = \"d\",\n    extractable = \"ext\",\n}\n\nenum Base64Codecs {\n    privateBits = \"d\",\n    xBits = \"x\",\n    yBits = \"y\",\n}\n\nenum AssertedAliases {\n    publicKey = \"publicBits\",\n    privateKey = \"privateBits\",\n    keyPair = \"keyPairBits\",\n}\n\nfunction inferCurve(key: Key, bytes: number) {\n    if (!key.curve) {\n        // Guess curve based on key length\n        switch (bytes) {\n            case 66:\n                key.curve = CurveType.p521;\n                break;\n\n            case 48:\n                key.curve = CurveType.p384;\n                break;\n\n            case 32:\n                key.curve = CurveType.p256;\n                break;\n\n            default:\n                throw new KeyError(`Cannot infer named curve from key length ${bytes}`);\n        }\n    }\n}\n\n/**\n * Generic key factory.\n */\nexport function Key(properties: Partial<Key>) {\n    const that = {} as Key;\n\n    // Assign base JWK properties.  All other properties are some form of alias\n    for (const key of JWK_KEYS) {\n        if ((properties as any)[key] !== undefined) (that as any)[key] = (properties as any)[key];\n    }\n    function assign(name: string) {\n        const d = Object.getOwnPropertyDescriptor(properties, name);\n        if (d && d.value !== undefined) {\n            (that as any)[name] = d.value;\n        }\n    }\n\n    // We implement the following in reverse-priority order\n\n    // Aliases map a readable name to the cryptic JWK equivalent\n    Object.entries(Aliases).forEach(([alias, target]) => {\n        Object.defineProperty(that, alias, {\n            get: () => that[target],\n            set: value => (that[target] = value),\n        });\n        assign(alias);\n    });\n\n    // Codecs allow for binary read/write on base-64 fields\n    Object.entries(Base64Codecs).forEach(([alias, target]) => {\n        Object.defineProperty(that, alias, {\n            get: () => that[target] !== undefined && Base64.decode(that[target]),\n            set: value => (that[target] = value === undefined ? undefined : Base64.encode(value, true)),\n        });\n        assign(alias);\n    });\n\n    // Importers translate external formats\n    Object.entries(Translators).forEach(([name, translator]) => {\n        Object.defineProperty(that, name, translator as any);\n    });\n\n    // Import invocation after all initializations due to dependencies\n    Object.keys(Translators).forEach(name => assign(name));\n\n    // Asserted aliases\n    Object.entries(AssertedAliases).forEach(([alias, target]) => {\n        Object.defineProperty(that, alias, {\n            get: () => {\n                const result = that[target];\n                if (result === undefined) {\n                    throw new KeyError(`Key field ${target} is not defined`);\n                }\n                return result;\n            },\n\n            set: (value: any) => {\n                that[target] = value;\n            },\n        });\n\n        assign(alias);\n    });\n\n    /** Compute public point from private EC key */\n    function derivePublicFromPrivate() {\n        if (that.type !== KeyType.EC) throw new KeyError(\"EC key type required to compute public point\");\n        if (!that.private) throw new KeyError(\"EC private key required to compute public point\");\n\n        const crv = that.crv;\n        let keyLength: number;\n\n        switch (crv) {\n            case CurveType.p256:\n                keyLength = 32;\n                // We can add the other point types easily by exposing more from @noble/curves\n                // case CurveType.p384:\n                // case CurveType.p521:\n                break;\n\n            default:\n                throw new KeyError(`Unsupported elliptic curve ${crv}`);\n        }\n\n        // Compute\n        const ecKey = ProjectivePoint.fromPrivateKey(that.privateKey);\n\n        // Install\n        that.xBits = numberToBytesBE(ecKey.x, keyLength);\n        that.yBits = numberToBytesBE(ecKey.y, keyLength);\n    }\n\n    if (that.type === KeyType.EC) {\n        if (that.d) {\n            inferCurve(that, that.privateKey.length);\n        } else if (that.xBits) {\n            inferCurve(that, that.xBits.length);\n        }\n\n        if (that.d && (!that.x || !that.y)) {\n            derivePublicFromPrivate();\n        }\n    }\n\n    return that;\n}\n\n/**\n * Private key factory.\n */\nexport function PrivateKey(privateKey: Uint8Array | BinaryKeyPair, options?: Partial<Key>) {\n    let priv, pub;\n    if (ArrayBuffer.isView(privateKey)) {\n        priv = privateKey;\n    } else {\n        priv = privateKey.privateKey;\n        pub = privateKey.publicKey;\n    }\n    return Key({\n        type: KeyType.EC,\n        privateKey: priv,\n        publicKey: pub,\n        ...options,\n    }) as PrivateKey;\n}\n\n/**\n * Public key factory.\n */\nexport function PublicKey(publicKey: Uint8Array, options?: Partial<Key>) {\n    return Key({\n        type: KeyType.EC,\n        publicKey,\n        ...options,\n    }) as PublicKey;\n}\n\n/**\n * Symmetric key factory.\n */\nexport function SymmetricKey(privateKey: Uint8Array, options?: Partial<Key>) {\n    return Key({\n        type: KeyType.oct,\n        privateKey: privateKey,\n        ...options,\n    });\n}\n"],
  "mappings": "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",
  "names": ["KeyType", "CurveType", "Asn1ObjectID", "Translators", "publicBits", "Aliases", "Base64Codecs", "AssertedAliases"]
}
