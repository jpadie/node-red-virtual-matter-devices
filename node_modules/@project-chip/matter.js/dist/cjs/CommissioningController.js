"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var CommissioningController_exports = {};
__export(CommissioningController_exports, {
  CommissioningController: () => CommissioningController
});
module.exports = __toCommonJS(CommissioningController_exports);
var import_MatterController = require("./MatterController.js");
var import_MatterNode = require("./MatterNode.js");
var import_Cluster = require("./cluster/Cluster.js");
var import_AttributeClient = require("./cluster/client/AttributeClient.js");
var import_BasicInformationCluster = require("./cluster/definitions/BasicInformationCluster.js");
var import_MatterError = require("./common/MatterError.js");
var import_EndpointNumber = require("./datatype/EndpointNumber.js");
var import_PairedNode = require("./device/PairedNode.js");
var import_MdnsService = require("./environment/MdnsService.js");
var import_Logger = require("./log/Logger.js");
var import_Network = require("./net/Network.js");
var import_UdpInterface = require("./net/UdpInterface.js");
var import_ControllerStore = require("./node/client/storage/ControllerStore.js");
var import_ControllerDiscovery = require("./protocol/ControllerDiscovery.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = new import_Logger.Logger("CommissioningController");
class CommissioningController extends import_MatterNode.MatterNode {
  /**
   * Creates a new CommissioningController instance
   *
   * @param options The options for the CommissioningController
   */
  constructor(options) {
    super();
    this.options = options;
  }
  started = false;
  ipv4Disabled;
  listeningAddressIpv4;
  listeningAddressIpv6;
  environment;
  // Set when new API was initialized correctly
  storage;
  mdnsScanner;
  controllerInstance;
  connectedNodes = /* @__PURE__ */ new Map();
  sessionDisconnectedHandler = /* @__PURE__ */ new Map();
  get nodeId() {
    return this.controllerInstance?.nodeId;
  }
  get paseCommissionerData() {
    const controller = this.assertControllerIsStarted(
      "The CommissioningController needs to be started to get the PASE commissioner data."
    );
    return {
      rootCertificateData: controller.rootCertificateData,
      fabricData: controller.fabricData
    };
  }
  assertIsAddedToMatterServer() {
    if (this.mdnsScanner === void 0 || this.storage === void 0 && this.environment === void 0) {
      throw new import_MatterError.ImplementationError("Add the node to the Matter instance before.");
    }
    if (!this.started) {
      throw new import_MatterError.ImplementationError("The node needs to be started before interacting with the controller.");
    }
    return { mdnsScanner: this.mdnsScanner, storage: this.storage, environment: this.environment };
  }
  assertControllerIsStarted(errorText) {
    if (this.controllerInstance === void 0) {
      throw new import_MatterError.ImplementationError(
        errorText ?? "Controller instance not yet started. Please call start() first."
      );
    }
    return this.controllerInstance;
  }
  /** Internal method to initialize a MatterController instance. */
  async initializeController() {
    const { mdnsScanner, storage, environment } = this.assertIsAddedToMatterServer();
    if (this.controllerInstance !== void 0) {
      return this.controllerInstance;
    }
    const { localPort, adminFabricId, adminVendorId, adminFabricIndex, caseAuthenticatedTags } = this.options;
    const environmentStore = environment !== void 0 ? environment.get(import_ControllerStore.ControllerStore) : void 0;
    const sessionStorage = environmentStore?.sessionStorage ?? storage?.createContext("SessionManager");
    const rootCertificateStorage = environmentStore?.credentialsStorage ?? storage?.createContext("RootCertificateManager");
    const fabricStorage = environmentStore?.credentialsStorage ?? storage?.createContext("MatterController");
    const nodesStorage = environmentStore?.nodesStorage ?? storage?.createContext("MatterController");
    if (sessionStorage === void 0 || rootCertificateStorage === void 0 || fabricStorage === void 0 || nodesStorage === void 0) {
      throw new import_MatterError.InternalError("Storage not initialized correctly.");
    }
    return await import_MatterController.MatterController.create({
      sessionStorage,
      rootCertificateStorage,
      fabricStorage,
      nodesStorage,
      mdnsScanner,
      netInterfaceIpv4: this.ipv4Disabled ? void 0 : await import_UdpInterface.UdpInterface.create(import_Network.Network.get(), "udp4", localPort, this.listeningAddressIpv4),
      netInterfaceIpv6: await import_UdpInterface.UdpInterface.create(import_Network.Network.get(), "udp6", localPort, this.listeningAddressIpv6),
      sessionClosedCallback: (peerNodeId) => {
        logger.info(`Session for peer node ${peerNodeId} disconnected ...`);
        const handler = this.sessionDisconnectedHandler.get(peerNodeId);
        if (handler !== void 0) {
          handler().catch((error) => logger.warn(`Error while handling session disconnect: ${error}`));
        }
      },
      adminVendorId,
      adminFabricId,
      adminFabricIndex,
      caseAuthenticatedTags
    });
  }
  /**
   * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned node.
   */
  async commissionNode(nodeOptions, connectNodeAfterCommissioning = true) {
    this.assertIsAddedToMatterServer();
    const controller = this.assertControllerIsStarted();
    const nodeId = await controller.commission(nodeOptions);
    if (connectNodeAfterCommissioning) {
      await this.connectNode(nodeId, {
        ...nodeOptions,
        autoSubscribe: nodeOptions.autoSubscribe ?? this.options.autoSubscribe,
        subscribeMinIntervalFloorSeconds: nodeOptions.subscribeMinIntervalFloorSeconds ?? this.options.subscribeMinIntervalFloorSeconds,
        subscribeMaxIntervalCeilingSeconds: nodeOptions.subscribeMaxIntervalCeilingSeconds ?? this.options.subscribeMaxIntervalCeilingSeconds
      });
    }
    return nodeId;
  }
  /**
   * Completes the commissioning process for a node when the initial commissioning process was done by a PASE
   * commissioner. This method should be called to discover the device operational and complete the commissioning
   * process.
   */
  completeCommissioningForNode(peerNodeId, discoveryData) {
    this.assertIsAddedToMatterServer();
    const controller = this.assertControllerIsStarted();
    return controller.completeCommissioning(peerNodeId, discoveryData);
  }
  /** Check if a given node id is commissioned on this controller. */
  isNodeCommissioned(nodeId) {
    const controller = this.assertControllerIsStarted();
    return controller.getCommissionedNodes().includes(nodeId) ?? false;
  }
  /**
   * Remove a Node id from the controller. This method should only be used if the decommission method on the
   * PairedNode instance returns an error. By default it tries to decommission the node from the controller but will
   * remove it also in case of an error during decommissioning. Ideally try to decommission the node before and only
   * use this in case of an error.
   */
  async removeNode(nodeId, tryDecommissioning = true) {
    const controller = this.assertControllerIsStarted();
    const node = this.connectedNodes.get(nodeId);
    if (tryDecommissioning) {
      try {
        if (node == void 0) {
          throw new import_MatterError.ImplementationError(`Node ${nodeId} is not connected.`);
        }
        await node.decommission();
      } catch (error) {
        logger.warn(`Decommissioning node ${nodeId} failed with error, remove node anyway: ${error}`);
      }
    }
    if (node !== void 0) {
      node.close();
    }
    await controller.removeNode(nodeId);
    this.connectedNodes.delete(nodeId);
  }
  async disconnectNode(nodeId) {
    const node = this.connectedNodes.get(nodeId);
    if (node === void 0) {
      throw new import_MatterError.ImplementationError(`Node ${nodeId} is not connected!`);
    }
    await this.controllerInstance?.disconnect(nodeId);
  }
  /**
   * Connect to an already paired Node.
   * After connection the endpoint data of the device is analyzed and an object structure is created.
   */
  async connectNode(nodeId, connectOptions) {
    const controller = this.assertControllerIsStarted();
    if (!controller.getCommissionedNodes().includes(nodeId)) {
      throw new import_MatterError.ImplementationError(`Node ${nodeId} is not commissioned!`);
    }
    const existingNode = this.connectedNodes.get(nodeId);
    if (existingNode !== void 0) {
      if (!existingNode.isConnected) {
        await existingNode.reconnect();
      }
      return existingNode;
    }
    const pairedNode = await import_PairedNode.PairedNode.create(
      nodeId,
      this,
      connectOptions,
      async () => this.createInteractionClient(nodeId),
      (handler) => this.sessionDisconnectedHandler.set(nodeId, handler)
    );
    this.connectedNodes.set(nodeId, pairedNode);
    if (connectOptions?.autoSubscribe !== false) {
      await this.enhanceDeviceDetailsFromCache(nodeId, pairedNode);
    } else {
      await this.enhanceDeviceDetailsFromRemote(nodeId, pairedNode);
    }
    return pairedNode;
  }
  async enhanceDeviceDetailsFromCache(nodeId, pairedNode) {
    const controller = this.assertControllerIsStarted();
    const globalAttributeKeys = Object.keys((0, import_Cluster.GlobalAttributes)({}));
    const basicInformationClient = pairedNode.getRootClusterClient(import_BasicInformationCluster.BasicInformation.Cluster);
    if (basicInformationClient === void 0) {
      logger.info(`No basic information cluster found for node ${nodeId}`);
      return;
    }
    const basicInformationData = {};
    for (const attributeName of Object.keys(basicInformationClient.attributes)) {
      if (globalAttributeKeys.includes(attributeName)) {
        continue;
      }
      const attribute = basicInformationClient.attributes[attributeName];
      if (attribute instanceof import_AttributeClient.SupportedAttributeClient) {
        try {
          basicInformationData[attributeName] = await attribute.get();
        } catch (error) {
          logger.info(`Error while getting attribute ${attributeName} for node ${nodeId}: ${error}`);
        }
      }
    }
    await controller.enhanceCommissionedNodeDetails(nodeId, { basicInformationData });
  }
  async enhanceDeviceDetailsFromRemote(nodeId, pairedNode) {
    const controller = this.assertControllerIsStarted();
    const globalAttributeKeys = Object.keys((0, import_Cluster.GlobalAttributes)({}));
    try {
      const interactionClient = await pairedNode.getInteractionClient();
      const basicInformationAttributes = await interactionClient.getMultipleAttributes({
        attributes: [{ endpointId: (0, import_EndpointNumber.EndpointNumber)(0), clusterId: import_BasicInformationCluster.BasicInformation.Cluster.id }]
      });
      const basicInformationData = {};
      for (const {
        path: { attributeName },
        value
      } of basicInformationAttributes) {
        if (!globalAttributeKeys.includes(attributeName)) {
          basicInformationData[attributeName] = value;
        }
      }
      await controller.enhanceCommissionedNodeDetails(nodeId, { basicInformationData });
    } catch (error) {
      logger.info(`Error while enhancing basic information for node ${nodeId}: ${error}`);
    }
  }
  /**
   * Connects to all paired nodes.
   * After connection the endpoint data of the device is analyzed and an object structure is created.
   */
  async connect(connectOptions) {
    const controller = this.assertControllerIsStarted();
    if (!controller.isCommissioned()) {
      throw new import_MatterError.ImplementationError(
        "Controller instance not yet paired with any device, so nothing to connect to."
      );
    }
    for (const nodeId of controller.getCommissionedNodes()) {
      await this.connectNode(nodeId, connectOptions);
    }
    return Array.from(this.connectedNodes.values());
  }
  /**
   * Set the MDNS Scanner instance. Should be only used internally
   *
   * @param mdnsScanner MdnsScanner instance
   */
  setMdnsScanner(mdnsScanner) {
    this.mdnsScanner = mdnsScanner;
  }
  /**
   * Set the MDNS Broadcaster instance. Should be only used internally
   *
   * @param _mdnsBroadcaster MdnsBroadcaster instance
   */
  setMdnsBroadcaster(_mdnsBroadcaster) {
  }
  /**
   * Set the Storage instance. Should be only used internally
   *
   * @param storage storage context to use
   */
  setStorage(storage) {
    this.storage = storage;
    this.environment = void 0;
  }
  /** Returns true if t least one node is commissioned/paired with this controller instance. */
  isCommissioned() {
    const controller = this.assertControllerIsStarted();
    return controller.isCommissioned();
  }
  /**
   * Creates and Return a new InteractionClient to communicate with a node. This is mainly used internally and should
   * not be used directly. See the PairedNode class for the public API.
   */
  async createInteractionClient(nodeId) {
    const controller = this.assertControllerIsStarted();
    return controller.connect(nodeId);
  }
  /** Returns the PairedNode instance for a given node id, if this node is connected. */
  getConnectedNode(nodeId) {
    return this.connectedNodes.get(nodeId);
  }
  /** Returns an array with the Node Ids for all commissioned nodes. */
  getCommissionedNodes() {
    const controller = this.assertControllerIsStarted();
    return controller.getCommissionedNodes() ?? [];
  }
  getCommissionedNodesDetails() {
    const controller = this.assertControllerIsStarted();
    return controller.getCommissionedNodesDetails() ?? [];
  }
  /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */
  async close() {
    for (const node of this.connectedNodes.values()) {
      node.close();
    }
    await this.controllerInstance?.close();
    this.controllerInstance = void 0;
    this.connectedNodes.clear();
    this.ipv4Disabled = void 0;
    this.started = false;
  }
  getPort() {
    return this.options.localPort;
  }
  initialize(ipv4Disabled) {
    if (this.started) {
      throw new import_MatterError.ImplementationError("Controller instance already started.");
    }
    if (this.ipv4Disabled !== void 0 && this.ipv4Disabled !== ipv4Disabled) {
      throw new import_MatterError.ImplementationError(
        "Changing the IPv4 disabled flag after starting the controller is not supported."
      );
    }
    this.ipv4Disabled = ipv4Disabled;
  }
  /** Initialize the controller and connect to all commissioned nodes if autoConnect is not set to false. */
  async start() {
    if (this.ipv4Disabled === void 0) {
      if (this.options.environment === void 0) {
        throw new import_MatterError.ImplementationError("Initialization not done. Add the controller to the MatterServer first.");
      }
      const { environment, id } = this.options.environment;
      const controllerStore = await import_ControllerStore.ControllerStore.create(environment, id);
      environment.set(import_ControllerStore.ControllerStore, controllerStore);
      const mdnsService = await environment.load(import_MdnsService.MdnsService);
      this.ipv4Disabled = !mdnsService.enableIpv4;
      this.setMdnsBroadcaster(mdnsService.broadcaster);
      this.setMdnsScanner(mdnsService.scanner);
      this.environment = environment;
      const runtime = environment.runtime;
      runtime.add(this);
    }
    this.started = true;
    if (this.controllerInstance === void 0) {
      this.controllerInstance = await this.initializeController();
    }
    if (this.options.autoConnect !== false && this.controllerInstance.isCommissioned()) {
      await this.connect();
    }
  }
  cancelCommissionableDeviceDiscovery(identifierData, discoveryCapabilities) {
    this.assertIsAddedToMatterServer();
    const controller = this.assertControllerIsStarted();
    controller.collectScanners(discoveryCapabilities).forEach((scanner) => import_ControllerDiscovery.ControllerDiscovery.cancelCommissionableDeviceDiscovery(scanner, identifierData));
  }
  async discoverCommissionableDevices(identifierData, discoveryCapabilities, discoveredCallback, timeoutSeconds = 900) {
    this.assertIsAddedToMatterServer();
    const controller = this.assertControllerIsStarted();
    return await import_ControllerDiscovery.ControllerDiscovery.discoverCommissionableDevices(
      controller.collectScanners(discoveryCapabilities),
      timeoutSeconds,
      identifierData,
      discoveredCallback
    );
  }
  async resetStorage() {
    this.assertControllerIsStarted(
      "Storage cannot be reset while the controller is operating! Please close the controller first."
    );
    const { storage, environment } = this.assertIsAddedToMatterServer();
    if (environment !== void 0) {
      const controllerStore = environment.get(import_ControllerStore.ControllerStore);
      await controllerStore.erase();
    } else if (storage !== void 0) {
      await storage.clearAll();
    } else {
      throw new import_MatterError.InternalError("Storage not initialized correctly.");
    }
  }
  /** Returns active session information for all connected nodes. */
  getActiveSessionInformation() {
    return this.controllerInstance?.getActiveSessionInformation() ?? [];
  }
}
//# sourceMappingURL=CommissioningController.js.map
