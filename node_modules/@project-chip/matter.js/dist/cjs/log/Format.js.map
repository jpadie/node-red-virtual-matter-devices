{
  "version": 3,
  "sources": ["../../../src/log/Format.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Lifecycle } from \"../common/Lifecycle.js\";\nimport { ImplementationError, InternalError, MatterError } from \"../common/MatterError.js\";\nimport { ByteArray } from \"../util/ByteArray.js\";\nimport { serialize } from \"../util/String.js\";\nimport { Diagnostic } from \"./Diagnostic.js\";\nimport { Level } from \"./Level.js\";\n\nconst INDENT_SPACES = 2;\n\n/**\n * Get a diagnostic formatter for the specified format.\n *\n * A \"diagnostic formatter\" converts arbitrary values into a formatted string.  Formatting is controlled by type and the\n * {@link Diagnostic.presentation} and {@link Diagnostic.value} properties.\n */\nexport function Format(format: string) {\n    if (format === undefined) {\n        format = Format.ANSI;\n    }\n\n    switch (format) {\n        case Format.PLAIN:\n            return Format.plain;\n\n        case Format.ANSI:\n            return Format.ansi;\n\n        case Format.HTML:\n            return Format.html;\n\n        default:\n            throw new ImplementationError(`Unsupported log format \"${format}\"`);\n    }\n}\n\n/**\n * Log stylization support.\n */\nexport namespace Format {\n    export type Type = typeof PLAIN | typeof ANSI | typeof HTML;\n\n    /** Generate text only */\n    export const PLAIN = \"plain\";\n\n    /** Format log messages using ANSI escape codes */\n    export const ANSI = \"ansi\";\n\n    /** Format log messages using HTML tags */\n    export const HTML = \"html\";\n\n    export const plain = formatPlain;\n    export const ansi = formatAnsi;\n    export const html = formatHtml;\n}\n\nexport type Producer = () => string;\n\ninterface Formatter {\n    message(message: Diagnostic.Message): string;\n    text(text: string): string;\n    indent(producer: Producer): string;\n    break(): string;\n    key(text: string): string;\n    value(producer: Producer): string;\n    strong(producer: Producer): string;\n    weak(producer: Producer): string;\n    error(producer: Producer): string;\n    status(status: Lifecycle.Status, producer: Producer): string;\n    via(text: string): string;\n}\n\nconst LifecycleIcons = {\n    [Lifecycle.Status.Unknown]: \"?\",\n    [Lifecycle.Status.Inactive]: \"\uD83D\uDCA4\",\n    [Lifecycle.Status.Initializing]: \"\u231B\",\n    [Lifecycle.Status.Active]: \"\u2714\",\n    [Lifecycle.Status.Crashed]: \"\u2718\",\n    [Lifecycle.Status.Destroying]: \"\u2620\uFE0E\",\n    [Lifecycle.Status.Destroyed]: \"\u2620\uFE0E\",\n};\n\n/**\n * Create a small utility shared by plain and ansi formats.\n */\nfunction plaintextCreator(indents: number) {\n    let broke = false;\n\n    return {\n        text(value: string) {\n            if (broke) {\n                broke = false;\n                return `\\n${\"\".padStart(indents * INDENT_SPACES)}${value}`;\n            }\n            return value;\n        },\n\n        break() {\n            broke = true;\n            return \"\";\n        },\n\n        indent(producer: () => string) {\n            indents++;\n            const result = producer();\n            indents--;\n            return result;\n        },\n    };\n}\n\nfunction statusIcon(status: Lifecycle.Status) {\n    return LifecycleIcons[status] ?? LifecycleIcons[Lifecycle.Status.Unknown];\n}\n\nfunction formatPlain(diagnostic: unknown, indents = 0) {\n    const creator = plaintextCreator(indents);\n\n    const formatter = {\n        ...creator,\n        message: message => {\n            const formattedValues = ensureIndented(renderDiagnostic(message.values, formatter));\n\n            return `${formatTime(message.now)} ${\n                Level[message.level]\n            } ${message.facility} ${message.prefix}${formattedValues}`;\n        },\n        key: text => creator.text(`${text}: `),\n        value: producer => creator.text(producer()),\n        strong: producer => creator.text(`*${producer()}*`),\n        weak: producer => creator.text(producer()),\n        error: producer => creator.text(producer()),\n        status: (status, producer) => `${creator.text(statusIcon(status))}${producer()}`,\n        via: text => creator.text(text),\n    } satisfies Formatter;\n\n    return renderDiagnostic(diagnostic, formatter);\n}\n\nconst ANSI_CODES = {\n    reset: 0,\n    bold: 1,\n    dim: 2,\n    red: 31,\n    green: 32,\n    yellow: 33,\n    blue: 34,\n    magenta: 35,\n    cyan: 36,\n    white: 37,\n    default: 39,\n    gray: 90,\n};\n\ntype AnsiCode = \"normal\" | keyof typeof ANSI_CODES;\n\nfunction ansiEscape(...codes: AnsiCode[]) {\n    const numbers = [];\n    for (const code of codes) {\n        if (code === \"normal\") {\n            continue;\n        }\n        const number = ANSI_CODES[code];\n        if (number === undefined) {\n            throw new InternalError(`Invalid ANSI code ${code}`);\n        }\n        numbers.push(number);\n    }\n    if (!numbers.length) {\n        return \"\";\n    }\n    return `\\u001b[${numbers.join(\";\")}m`;\n}\n\ninterface Style {\n    color?: \"default\" | keyof typeof ANSI_CODES;\n    dim?: boolean;\n    bold?: boolean;\n}\n\nconst Styles = {\n    default: { color: \"default\" },\n    prefix: { color: \"default\", dim: true },\n    facility: { color: \"gray\", bold: true },\n    debug: { color: \"gray\" },\n    info: { color: \"default\" },\n    notice: { color: \"green\" },\n    warn: { color: \"yellow\" },\n    error: { color: \"red\" },\n    fatal: { color: \"red\", bold: true },\n    key: { color: \"blue\" },\n    value: { color: \"default\", dim: true },\n    strong: { bold: true },\n    weak: { dim: true },\n    ballotCheck: { color: \"green\" },\n    ballotCross: { color: \"red\" },\n    unknown: { color: \"gray\" },\n    inactive: { color: \"gray\" },\n    initializing: { color: \"yellow\" },\n    active: { color: \"green\" },\n    crashed: { color: \"red\" },\n    destroying: { color: \"gray\" },\n    destroyed: { color: \"gray\" },\n    via: { color: \"magenta\" },\n} as const satisfies Record<string, Style>;\n\ntype StyleName = keyof typeof Styles;\n\nfunction formatAnsi(diagnostic: unknown, indents = 0) {\n    let baseStyleChanged = false;\n    const creator = plaintextCreator(indents);\n    const currentStyle: Style = {\n        color: \"default\",\n        dim: false,\n        bold: false,\n    };\n    const styles: StyleName[] = [\"default\"];\n\n    function normal(text: string) {\n        return style(styles[styles.length - 1] ?? \"default\", text);\n    }\n\n    const formatter = {\n        message: ({ now, level, facility, prefix: nestPrefix, values }) => {\n            baseStyleChanged = true;\n            styles[0] = (Level[level] ?? \"default\").toLowerCase() as StyleName;\n\n            const prefix = style(\"prefix\", `${formatTime(now)} ${Level[level].padEnd(6)}`);\n\n            facility = style(\n                \"facility\",\n                facility.length > 20\n                    ? `${facility.slice(0, 10)}~${facility.slice(facility.length - 9)}`\n                    : facility.padEnd(20),\n            );\n\n            if (nestPrefix) {\n                nestPrefix = style(\"prefix\", nestPrefix);\n            }\n\n            const formattedValues = ensureIndented(renderDiagnostic(values, formatter));\n\n            return `${prefix} ${facility} ${nestPrefix}${formattedValues}`;\n        },\n\n        text: text => creator.text(normal(text)),\n\n        indent: producer => creator.indent(producer),\n\n        break: () => {\n            // After the first line revert to default styling so e.g. stack traces aren't all red\n            if (baseStyleChanged) {\n                baseStyleChanged = false;\n                styles[0] = \"default\";\n            }\n\n            return creator.break();\n        },\n\n        key: text => creator.text(style(\"key\", `${text}: `)),\n\n        value: producer => {\n            styles.push(\"value\");\n            const result = producer();\n            styles.pop();\n            return result;\n        },\n\n        strong: producer => {\n            styles.push(\"strong\");\n            const result = producer();\n            styles.pop();\n            return result;\n        },\n\n        weak: producer => {\n            styles.push(\"weak\");\n            const result = producer();\n            styles.pop();\n            return result;\n        },\n\n        error: producer => {\n            styles.push(\"error\");\n            const result = producer();\n            styles.pop();\n            return result;\n        },\n\n        status: (status, producer) => {\n            styles.push(status);\n            const result = `${creator.text(style(status, statusIcon(status)))}${producer()}`;\n            styles.pop();\n            return result;\n        },\n\n        via: text => creator.text(style(\"via\", text)),\n    } satisfies Formatter;\n\n    return renderDiagnostic(diagnostic, formatter) + ansiEscape(\"reset\");\n\n    // Convert a style name into a set of escape codes to transition state\n    function escapes(styleName: StyleName) {\n        const style = Styles[styleName] as Style;\n        if (style === undefined) {\n            throw new InternalError(`Invalid ANSI style \"${styleName}\"`);\n        }\n\n        const targetDim = !!style.dim;\n        const targetBold = !!style.bold;\n        let targetColor = style.color;\n\n        // Compute target color from style stack if not explicit\n        if (!targetColor) {\n            for (let i = styles.length; i > 0; i--) {\n                const color = (Styles[styles[i - 1] ?? \"default\"] as Style).color;\n                if (color) {\n                    targetColor = color;\n                    break;\n                }\n            }\n        }\n\n        const codes = Array<AnsiCode>();\n\n        if ((!targetDim && currentStyle.dim) || (!targetBold && currentStyle.bold)) {\n            // Don't think we can reset dim/bold without full reset\n            codes.push(\"reset\");\n            currentStyle.dim = false;\n            currentStyle.bold = false;\n            currentStyle.color = \"default\";\n        }\n\n        if (targetDim !== currentStyle.dim) {\n            codes.push(\"dim\");\n            currentStyle.dim = true;\n        }\n\n        if (targetBold !== currentStyle.bold) {\n            codes.push(\"bold\");\n            currentStyle.bold = true;\n        }\n\n        if (targetColor && targetColor !== currentStyle.color) {\n            codes.push(targetColor);\n            currentStyle.color = targetColor;\n        }\n\n        return ansiEscape(...codes);\n    }\n\n    // Apply style codes.  Maintains color state (via escapes) so values must\n    // be rendered sequentially as they appear\n    function style(style: StyleName, text: string) {\n        if (text === \"\") {\n            return text;\n        }\n        const segments = text.match(/([^\u2713\u2714\u2717\u2718]+|[\u2713\u2714\u2717\u2718])/g);\n        if (segments === null) {\n            throw new InternalError(\"ANSI text processing regex failure\");\n        }\n        return segments\n            .map(segment => {\n                let esc;\n                switch (segment) {\n                    case \"\u2713\":\n                    case \"\u2714\":\n                        esc = escapes(\"ballotCheck\");\n                        break;\n\n                    case \"\u2717\":\n                    case \"\u2718\":\n                        esc = escapes(\"ballotCross\");\n                        break;\n\n                    default:\n                        esc = escapes(style);\n                        break;\n                }\n                return `${esc}${segment}`;\n            })\n            .join(\"\");\n    }\n}\n\nfunction htmlSpan(type: string, inner: string) {\n    return `<span class=\"matter-log-${type}\">${inner}</span>`;\n}\n\nfunction formatHtml(diagnostic: unknown) {\n    function escape(text: string) {\n        return text.toString().replace(/</g, \"&amp\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n\n    const formatter = {\n        message: ({ now, level, facility, prefix, values }) => {\n            prefix = prefix.replace(/ /g, \"&nbsp;\");\n            const formattedValues = renderDiagnostic(values, formatter);\n\n            return htmlSpan(\n                `line ${Level[level].toLowerCase()}`,\n                `${htmlSpan(\"time\", formatTime(now))} ${htmlSpan(\"level\", Level[level])} ${htmlSpan(\n                    \"facility\",\n                    facility,\n                )} ${prefix}${formattedValues}`,\n            );\n        },\n        text: escape,\n        break: () => \"<br/>\",\n        indent: producer => htmlSpan(\"indent\", producer()),\n        key: text => htmlSpan(\"key\", `${escape(text)}:`) + \" \",\n        value: producer => htmlSpan(\"value\", producer()),\n        strong: producer => `<em>${producer()}</em>`,\n        weak: producer => htmlSpan(\"weak\", producer()),\n        error: producer => htmlSpan(\"error\", producer()),\n        status: (status, producer) => htmlSpan(`status-${status}`, producer()),\n        via: text => htmlSpan(\"via\", escape(text)),\n    } satisfies Formatter;\n\n    return renderDiagnostic(diagnostic, formatter);\n}\n\n/**\n * Render a value based on its JS type.\n */\nfunction renderValue(value: unknown, formatter: Formatter, squash: boolean): string {\n    if (value === undefined) {\n        return formatter.text(\"undefined\");\n    }\n    if (value === null) {\n        return formatter.text(\"null\");\n    }\n    if (value instanceof ByteArray) {\n        return formatter.text(value.toHex());\n    }\n    if (value instanceof Error) {\n        return renderDiagnostic(Diagnostic.error(value), formatter);\n    }\n    if (typeof value === \"object\" && Symbol.iterator in value && !(value instanceof String)) {\n        const list = sequenceToList(value as Iterable<unknown>);\n        if (!list.length) {\n            return \"\";\n        }\n        if (list.length > 1) {\n            return renderList(list, formatter);\n        }\n        const first = valueFor(list[0]) as unknown[];\n        return first\n            .map(e => {\n                if (typeof e === \"string\" && !squash) {\n                    e = e.trim();\n                }\n                return renderDiagnostic(e, formatter);\n            })\n            .join(squash ? \"\" : \" \");\n    }\n    if (value instanceof Date) {\n        return formatter.text(formatTime(value));\n    }\n    if (typeof value === \"object\") {\n        if (value instanceof String) {\n            return value.toString();\n        }\n        return formatter.text(serialize(value) ?? \"undefined\");\n    }\n\n    const text = typeof value === \"string\" || value instanceof String ? value : value.toString().trim();\n    if (!text.includes(\"\\n\")) {\n        return formatter.text(text as string);\n    }\n\n    return renderList(text.split(\"\\n\"), formatter);\n}\n\nfunction renderList(value: Iterable<unknown>, formatter: Formatter) {\n    const parts = Array<string>();\n\n    for (const v of value) {\n        parts.push(renderDiagnostic(v, formatter));\n        formatter.break();\n    }\n\n    return parts.join(\"\");\n}\n\nfunction renderIndentedList(value: Iterable<unknown>, formatter: Formatter) {\n    return formatter.indent(() => {\n        return renderList(value, formatter);\n    });\n}\n\nfunction renderDictionary(value: object, formatter: Formatter) {\n    const entries = value instanceof Map ? value.entries() : Object.entries(value);\n\n    const parts = [];\n    for (const [k, v] of entries) {\n        if (parts.length) {\n            parts.push(\" \");\n        }\n        parts.push(formatter.key(k));\n        parts.push(formatter.value(() => renderDiagnostic(v, formatter)));\n    }\n\n    return parts.join(\"\");\n}\n\nfunction valueFor(value: unknown) {\n    if (typeof value !== \"object\" || value === null) {\n        return value;\n    }\n    const proxied = (value as Diagnostic)[Diagnostic.value];\n    if (proxied) {\n        if (proxied === value) {\n            throw new InternalError(\"Diagnostic value proxies to itself\");\n        }\n        return valueFor(proxied);\n    }\n    return value;\n}\n\nfunction presentationFor(value: unknown) {\n    if (typeof value !== \"object\" || value === null) {\n        return;\n    }\n    if (Diagnostic.presentation in (value as Diagnostic)) {\n        return (value as Diagnostic)[Diagnostic.presentation];\n    }\n    const proxied = (value as Diagnostic)[Diagnostic.value];\n    if (proxied && proxied !== value) {\n        if (proxied === value) {\n            throw new InternalError(\"Diagnostic value proxies to itself\");\n        }\n        return presentationFor(proxied);\n    }\n}\n\n/**\n * Render a value with presentation support\n */\nfunction renderDiagnostic(value: unknown, formatter: Formatter): string {\n    const presentation = presentationFor(value);\n    value = valueFor(value);\n\n    switch (presentation) {\n        case undefined:\n            return renderValue(value, formatter, false);\n\n        case Diagnostic.Presentation.Message:\n            if (value === undefined || value === null) {\n                throw new ImplementationError(\"Diagnostic message is not an object\");\n            }\n            return formatter.message(Diagnostic.message(value));\n\n        case Diagnostic.Presentation.List:\n            if (typeof (value as Iterable<unknown>)?.[Symbol.iterator] !== \"function\") {\n                throw new ImplementationError(\"Diagnostic list is not iterable\");\n            }\n            return renderIndentedList(value as Iterable<unknown>, formatter);\n\n        case Diagnostic.Presentation.Squash:\n            return renderValue(value, formatter, true);\n\n        case Diagnostic.Presentation.Strong:\n            return formatter.strong(() => renderDiagnostic(value, formatter));\n\n        case Diagnostic.Presentation.Weak:\n            return formatter.weak(() => renderDiagnostic(value, formatter));\n\n        case Diagnostic.Presentation.Error:\n            return formatter.error(() => renderDiagnostic(value, formatter));\n\n        case Diagnostic.Presentation.Via:\n            return formatter.via(`${value}`);\n\n        case Diagnostic.Presentation.Dictionary:\n            if (typeof value !== \"object\") {\n                throw new ImplementationError(\"Diagnostic dictionary is not an object\");\n            }\n            return renderDictionary(value as object, formatter);\n\n        case Lifecycle.Status.Unknown:\n        case Lifecycle.Status.Inactive:\n        case Lifecycle.Status.Initializing:\n        case Lifecycle.Status.Active:\n        case Lifecycle.Status.Crashed:\n        case Lifecycle.Status.Destroyed:\n            return formatter.status(presentation, () => renderDiagnostic(value, formatter));\n\n        default:\n            throw new ImplementationError(`Unsupported diagnostic presentation \"${presentation}\"`);\n    }\n}\n\n/**\n * Group items in an iterable based on their presentation.  The result is then\n * appropriate for rendering as a list.\n */\nfunction sequenceToList(sequence: Iterable<unknown>) {\n    let group: unknown[] | undefined;\n    const list = Array<unknown[]>();\n    for (const value of sequence) {\n        if (presentationFor(value) === Diagnostic.Presentation.List) {\n            group = undefined;\n            list.push(value as unknown[]);\n            continue;\n        }\n        if (!group) {\n            list.push((group = [value]));\n        } else {\n            group.push(value);\n        }\n    }\n    return list;\n}\n\nfunction formatTime(time: Date) {\n    return `${time.getFullYear()}-${(time.getMonth() + 1).toString().padStart(2, \"0\")}-${time\n        .getDate()\n        .toString()\n        .padStart(2, \"0\")} ${time.getHours().toString().padStart(2, \"0\")}:${time\n        .getMinutes()\n        .toString()\n        .padStart(2, \"0\")}:${time.getSeconds().toString().padStart(2, \"0\")}.${time\n        .getMilliseconds()\n        .toString()\n        .padStart(3, \"0\")}`;\n}\n\n/**\n * Multiline messages should always have whitespace as the first character after newlines.  Ensure this is so.\n */\nfunction ensureIndented(text: string) {\n    if (text.match(/\\n\\S/s)) {\n        return text.replace(/\\n/gs, \"\\n  \");\n    }\n    return text;\n}\n\nif (MatterError.formatterFor === MatterError.defaultFormatterFactory) {\n    MatterError.formatterFor = Format;\n}\n"],
  "mappings": "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",
  "names": ["Format", "style"]
}
