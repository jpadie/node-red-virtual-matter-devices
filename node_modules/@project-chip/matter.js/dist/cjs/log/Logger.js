"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Logger_exports = {};
__export(Logger_exports, {
  Logger: () => Logger,
  consoleLogger: () => consoleLogger
});
module.exports = __toCommonJS(Logger_exports);
var import_MatterError = require("../common/MatterError.js");
var import_Time = require("../time/Time.js");
var import_ByteArray = require("../util/ByteArray.js");
var import_Diagnostic = require("./Diagnostic.js");
var import_Format = require("./Format.js");
var import_Level = require("./Level.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function consoleLogger(level, formattedLog) {
  const console2 = consoleLogger.console;
  switch (level) {
    case import_Level.Level.DEBUG:
      console2.debug(formattedLog);
      break;
    case import_Level.Level.INFO:
      console2.info(formattedLog);
      break;
    case import_Level.Level.NOTICE:
      console2.info(formattedLog);
      break;
    case import_Level.Level.WARN:
      console2.warn(formattedLog);
      break;
    case import_Level.Level.ERROR:
      console2.error(formattedLog);
      break;
    case import_Level.Level.FATAL:
      console2.error(formattedLog);
      break;
  }
}
const globalConsole = console;
((consoleLogger2) => {
  consoleLogger2.console = globalConsole;
})(consoleLogger || (consoleLogger = {}));
function logFormatterFor(formatName) {
  const format = (0, import_Format.Format)(formatName);
  return (now, level, facility, prefix, ...values) => format(import_Diagnostic.Diagnostic.message({ now, level, facility, prefix, values }));
}
class Logger {
  constructor(name) {
    this.name = name;
  }
  static logger = new Array({
    logIdentifier: "default",
    logFormatter: import_Format.Format.plain,
    log: consoleLogger,
    defaultLogLevel: import_Level.Level.DEBUG,
    logLevels: {}
  });
  static nestingLevel = 0;
  /** Add additional logger to the list of loggers including the default configuration. */
  static addLogger(identifier, logger, options) {
    if (Logger.logger.some((logger2) => logger2.logIdentifier === identifier)) {
      throw new import_MatterError.NotImplementedError(`Logger "${identifier}" already exists`);
    }
    Logger.logger.push({
      logIdentifier: identifier,
      logFormatter: logFormatterFor(options?.logFormat ?? import_Format.Format.PLAIN),
      log: logger,
      defaultLogLevel: options?.defaultLogLevel ?? import_Level.Level.DEBUG,
      logLevels: options?.logLevels ?? {}
    });
  }
  static removeLogger(identifier) {
    const index = Logger.logger.findIndex((logger) => logger.logIdentifier === identifier);
    if (index === -1) {
      throw new import_MatterError.NotImplementedError(`Logger "${identifier}" does not exist`);
    }
    Logger.logger.splice(index, 1);
  }
  /**
   * Get the logger with the matching identifier.
   * @param identifier The identifier of the logger
   */
  static getLoggerforIdentifier(identifier) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger === void 0) {
      throw new import_MatterError.NotImplementedError(`Unknown logger "${identifier}"`);
    }
    return logger;
  }
  /**
   * Set log level using configuration-style level name for the default logger.
   */
  static set level(level) {
    if (level === void 0) {
      level = import_Level.Level.DEBUG;
    }
    let levelNum;
    if (typeof level === "string") {
      if (level.match(/^[0-9]+$/)) {
        levelNum = Number.parseInt(level);
      } else {
        levelNum = import_Level.Level[level.toUpperCase()];
        if (levelNum === void 0) {
          throw new import_MatterError.ImplementationError(`Unsupported log level "${level}"`);
        }
      }
    } else {
      levelNum = level;
    }
    if (import_Level.Level[levelNum] === void 0) {
      throw new import_MatterError.ImplementationError(`Unsupported log level "${level}"`);
    }
    Logger.defaultLogLevel = levelNum;
  }
  /**
   * Set logFormatter using configuration-style format name.
   *
   * @param format the name of the formatter (see Format enum)
   */
  static set format(format) {
    Logger.setLogFormatterForLogger("default", logFormatterFor(format));
  }
  /**
   * Set facility loglevels for the default logger.
   * @param levels The levels to set
   */
  static set logLevels(levels) {
    Logger.setLogLevelsForLogger("default", levels);
  }
  /**
   * Get facility loglevels for the default logger.
   */
  static get logLevels() {
    return Logger.getLoggerforIdentifier("default").logLevels;
  }
  /**
   * Set default loglevel for the default logger.
   *
   * @param level The level to set
   */
  static set defaultLogLevel(level) {
    Logger.setDefaultLoglevelForLogger("default", level);
  }
  /**
   * Get default loglevel for the default logger.
   */
  static get defaultLogLevel() {
    return Logger.getLoggerforIdentifier("default").defaultLogLevel;
  }
  /**
   * Set the log function for the default logger.
   *
   * @param log The log function to set
   */
  static set log(log) {
    Logger.setLogger("default", log);
  }
  /**
   * Get the log function for the default logger.
   */
  static get log() {
    return Logger.getLoggerforIdentifier("default").log;
  }
  /**
   * Set the log formatter for the default logger.
   *
   * @param logFormatter
   */
  static set logFormatter(logFormatter) {
    Logger.setLogFormatterForLogger("default", logFormatter);
  }
  /**
   * Get the log formatter for the default logger.
   */
  static get logFormatter() {
    return Logger.getLoggerforIdentifier("default").logFormatter;
  }
  /**
   * Set logFormatter using configuration-style format name for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param format the name of the formatter (see Format enum)
   */
  static setFormatForLogger(identifier, format) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.logFormatter = logFormatterFor(format);
    } else {
      throw new import_MatterError.NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set default loglevel for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param level The level to set
   */
  static setDefaultLoglevelForLogger(identifier, level) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.defaultLogLevel = level;
    } else {
      throw new import_MatterError.NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set facility loglevels for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param levels The levels to set
   */
  static setLogLevelsForLogger(identifier, levels) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.logLevels = levels;
    } else {
      throw new import_MatterError.NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set the log function for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param log The log function to set
   */
  static setLogger(identifier, log) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.log = log;
    } else {
      throw new import_MatterError.NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set the log formatter for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param logFormatter The log formatter to set
   */
  static setLogFormatterForLogger(identifier, logFormatter) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.logFormatter = logFormatter;
    } else {
      throw new import_MatterError.NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Create a new facility.
   *
   * @param name the name of the facility
   * @returns a new facility
   */
  static get(name) {
    return new Logger(name);
  }
  /**
   * Stringify a value (BigInt aware) as JSON.
   *
   * @param data the value to stringify
   * @returns the stringified value
   */
  static toJSON(data) {
    return JSON.stringify(data, (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      if (value instanceof import_ByteArray.ByteArray) {
        return value.toHex();
      }
      if (value === void 0) {
        return "undefined";
      }
      return value;
    });
  }
  /**
   * Mask a string with a given character. If unmaskedLength is provided then these number of characters will be
   * shown unmasked.
   *
   * @param str String to mask
   * @param maskChar character to mask with
   * @param unmaskedLength number of characters to show unmasked in the beginning
   */
  static maskString(str, maskChar = "*", unmaskedLength) {
    return str.substring(0, unmaskedLength ?? 0) + str.substring(unmaskedLength ?? 0).replace(/./g, maskChar);
  }
  /**
   * Perform operations in a nested logging context.  Messages will be
   * indented while the context executes.
   */
  static nest(context) {
    this.nestingLevel++;
    try {
      return context();
    } finally {
      this.nestingLevel--;
    }
  }
  /**
   * Async version of nest().
   */
  static async nestAsync(context) {
    this.nestingLevel++;
    try {
      return await context();
    } finally {
      this.nestingLevel--;
    }
  }
  /**
   * Unhandled error reporter.
   *
   * Some environments do not report full error details such as {@link Error#cause} and {@link AggregateError#errors}.
   *
   * To ensure these details are always recorded somewhere, unhandled errors may be reported here.
   *
   * To disable this behavior replace this function.
   */
  static reportUnhandledError(error) {
    try {
      Logger.get("Logger").fatal("Unhandled error detected:", error);
    } catch (e) {
    }
  }
  debug = (...values) => this.log(import_Level.Level.DEBUG, values);
  info = (...values) => this.log(import_Level.Level.INFO, values);
  notice = (...values) => this.log(import_Level.Level.NOTICE, values);
  warn = (...values) => this.log(import_Level.Level.WARN, values);
  error = (...values) => this.log(import_Level.Level.ERROR, values);
  fatal = (...values) => this.log(import_Level.Level.FATAL, values);
  log(level, values) {
    Logger.logger.forEach((logger) => {
      if (level < (logger.logLevels[this.name] ?? logger.defaultLogLevel)) return;
      logger.log(level, logger.logFormatter(import_Time.Time.now(), level, this.name, nestingPrefix(), values));
    });
  }
}
if (typeof MatterHooks !== "undefined") {
  MatterHooks.loggerSetup?.(Logger);
}
function nestingPrefix() {
  if (Logger.nestingLevel) {
    return "\u23B8".padEnd(Logger.nestingLevel * 2);
  }
  return "";
}
//# sourceMappingURL=Logger.js.map
