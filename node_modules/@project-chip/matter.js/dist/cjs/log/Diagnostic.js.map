{
  "version": 3,
  "sources": ["../../../src/log/Diagnostic.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type { Lifecycle } from \"../common/Lifecycle.js\";\nimport { Level } from \"./Level.js\";\n\n/**\n * Logged values may implement this interface to customize presentation.\n *\n * You can use the utility functions such as {@link Diagnostic.dict} to create\n * Diagnostics from common value types.\n */\nexport interface Diagnostic {\n    readonly [Diagnostic.presentation]?: Diagnostic.Presentation | Lifecycle.Status;\n    readonly [Diagnostic.value]?: unknown;\n}\n\n/**\n * Create a diagnostic giving a value a specific presentation.\n */\nexport function Diagnostic(presentation: Diagnostic.Presentation | Lifecycle.Status, value: unknown): Diagnostic {\n    return {\n        [Diagnostic.presentation]: presentation,\n        [Diagnostic.value]: value,\n    };\n}\n\nexport namespace Diagnostic {\n    export enum Presentation {\n        /**\n         * Render an object as a log message.\n         */\n        Message = \"message\",\n\n        /**\n         * By default iterables render as a single line with spaces separating.  The \"list\" presentation treats elements\n         * instead as separate entities which typically means presentation on different lines.\n         *\n         * Within an iterable, a list also serves to present contained items as subordinate to the previous item.\n         */\n        List = \"list\",\n\n        /**\n         * Render iterables without intervening spaces.\n         */\n        Squash = \"squash\",\n\n        /**\n         * An emphasized diagnostic.  Rendered to draw attention.\n         */\n        Strong = \"strong\",\n\n        /**\n         * A deemphasized diagnostic.  Rendered to draw less attention than default rendering.\n         */\n        Weak = \"weak\",\n\n        /**\n         * An error message diagnostic.\n         */\n        Error = \"error\",\n\n        /**\n         * A key/value diagnostic.  Rendered as a group of key/value pairs.\n         */\n        Dictionary = \"dictionary\",\n\n        /**\n         * Path, resource or session identifier.\n         */\n        Via = \"via\",\n    }\n\n    export const presentation = Symbol(\"presentation\");\n    export const value = Symbol(\"value\");\n\n    export interface Message {\n        [presentation]?: Presentation.Message;\n        now: Date;\n        level: Level;\n        facility: string;\n        prefix: string;\n        values: unknown[];\n    }\n\n    /**\n     * Create an object representing a log message.\n     */\n    export function message(value: Partial<Message>): Message {\n        const { now, level, facility, prefix: nestingPrefix, values } = value;\n\n        return {\n            [presentation]: Presentation.Message,\n            now: now ?? new Date(),\n            level: level ?? Level.INFO,\n            facility: facility ?? \"Diagnostic\",\n            prefix: nestingPrefix ?? \"\",\n            values: values ?? [],\n        } satisfies Message;\n    }\n\n    /**\n     * Create a value presented emphatically.\n     */\n    export function strong(value: unknown) {\n        return Diagnostic(Diagnostic.Presentation.Strong, value);\n    }\n\n    /**\n     * Create a value presented less emphatically than the default.\n     */\n    export function weak(value: unknown) {\n        return Diagnostic(Diagnostic.Presentation.Weak, value);\n    }\n\n    /**\n     * Create a value identifying the source of a diagnostic event.\n     */\n    export function via(value: string) {\n        if ((value as Diagnostic)[presentation]) {\n            return value;\n        }\n        const via = new String(value);\n        Object.defineProperty(via, presentation, { value: Presentation.Via });\n        return via as string;\n    }\n\n    /**\n     * A node in a diagnostic tree.  Top-level diagnostic sources registered with DiagnosticSource should present as\n     * nodes.\n     */\n    export function node(icon: string, label: unknown, detail: { self?: unknown; children?: unknown[] }) {\n        const result = [icon, Diagnostic.strong(label)] as unknown[];\n        if (detail?.self !== undefined) {\n            result.push(detail.self);\n        }\n        if (detail?.children !== undefined) {\n            result.push(Diagnostic.list(detail.children));\n        }\n        return result;\n    }\n\n    /**\n     * Create a value presenting as a list of separate lines.\n     */\n    export function list(value: Iterable<unknown>) {\n        return Diagnostic(Diagnostic.Presentation.List, value);\n    }\n\n    /**\n     * Create a value presenting as segments of the same string without intervening spaces.\n     */\n    export function squash(...values: unknown[]) {\n        return Diagnostic(Diagnostic.Presentation.Squash, values);\n    }\n\n    /**\n     * Create a K/V map that presents with formatted keys.\n     */\n    export function dict(entries: object): Record<string, unknown> & Diagnostic {\n        return {\n            ...entries,\n            [presentation]: Diagnostic.Presentation.Dictionary,\n        };\n    }\n\n    /**\n     * Create a Diagnostic for an error.\n     */\n    export function error(error: any) {\n        return formatError(error);\n    }\n\n    /**\n     * Create a diagnostic with a specific {@link Lifecycle}.\n     */\n    export function lifecycle(status: Lifecycle.Status, value: unknown) {\n        return Diagnostic(status, value);\n    }\n\n    /**\n     * Create a diagnostic for a {@link Lifecycle.Map}.\n     */\n    export function lifecycleList(map: Lifecycle.Map<any>) {\n        return Object.entries(map).map(([label, status]) => Diagnostic(status, label));\n    }\n\n    export interface Elapsed {\n        readonly startedAt: number;\n        readonly time: number;\n        toString(): string;\n    }\n\n    /**\n     * Convert an interval to text.\n     */\n    export function interval(ms: number) {\n        if (ms < 0) {\n            return `${(ms * 1000).toPrecision(3)}\u03BCs`;\n        } else if (ms < 1000) {\n            return `${ms.toPrecision(3)}ms`;\n        } else if (ms < 60000) {\n            return `${(ms / 1000).toPrecision(3)}s`;\n        }\n\n        let days;\n        if (ms > 86_400_000) {\n            days = `${Math.floor(ms / 86_400_000)}d `;\n            ms %= 86_400_000;\n        } else {\n            days = \"\";\n        }\n        const hours = Math.floor(ms / 3_600_000)\n            .toString()\n            .padStart(2, \"0\");\n        ms %= 3_600_000;\n        const minutes = Math.floor(ms / 60_000)\n            .toString()\n            .padStart(2, \"0\");\n        ms %= 60_000;\n        const seconds = Math.floor(ms).toString().padStart(2, \"0\");\n\n        return `${days}${hours}:${minutes}:${seconds}`;\n    }\n\n    /**\n     * Create a diagnostic that renders as elapsed time since creation.\n     */\n    export function elapsed(): Elapsed {\n        return {\n            startedAt: performance.now(),\n\n            get time() {\n                return performance.now() - this.startedAt;\n            },\n\n            toString() {\n                return interval(this.time);\n            },\n        };\n    }\n\n    /**\n     * Upgrade a value to support specialized diagnostic rendering.\n     */\n    export function upgrade<T>(value: boolean | number | string | object, diagnostic: unknown): T {\n        switch (typeof value) {\n            case \"boolean\":\n                value = new Boolean(value);\n                break;\n\n            case \"number\":\n                value = new Number(value);\n                break;\n\n            case \"string\":\n                value = new String(value);\n                break;\n        }\n\n        if (typeof diagnostic === \"function\") {\n            Object.defineProperty(value, Diagnostic.value, { get: diagnostic as () => unknown });\n        } else {\n            Object.defineProperty(value, Diagnostic.value, { value: diagnostic });\n        }\n\n        return value as T;\n    }\n\n    /**\n     * Convert a number or bigint to a hex string which is prefixed by \"0x\" for logging purposes\n     */\n    export function hex(value: number | bigint) {\n        return `0x${value.toString(16)}`;\n    }\n}\n\nfunction formatError(error: any, options: { messagePrefix?: string; parentStack?: string[] } = {}) {\n    const { messagePrefix, parentStack } = options;\n\n    const messageAndStack = messageAndStackFor(error, parentStack);\n    const { stack, stackLines } = messageAndStack;\n\n    let { message } = messageAndStack;\n    if (messagePrefix) {\n        message = `${messagePrefix} ${message}`;\n    }\n\n    message = Diagnostic.upgrade(message, Diagnostic(Diagnostic.Presentation.Error, message));\n\n    let cause, errors;\n    if (typeof error === \"object\" && error !== null) {\n        ({ cause, errors } = error);\n    }\n\n    if (stack === undefined && cause === undefined && errors === undefined) {\n        return message;\n    }\n\n    const list: Array<string | Diagnostic> = [message];\n    if (stack !== undefined) {\n        list.push(Diagnostic(Diagnostic.Presentation.List, stack));\n    }\n\n    // We render chained causes at the same level as the parent.  They are displayed atomically and there can be\n    // only one so this is not ambiguous.  If we did not do this we would end up with a lot of indent levels\n    for (; typeof cause === \"object\" && cause !== null; cause = cause.cause) {\n        let formatted = formatError(cause, { messagePrefix: \"Caused by:\", parentStack: stackLines });\n        if ((formatted as Diagnostic)[Diagnostic.presentation] === Diagnostic.Presentation.List) {\n            formatted = (formatted as Diagnostic)[Diagnostic.value] ?? formatted;\n        }\n\n        if (Array.isArray(formatted)) {\n            list.push(...formatted);\n        } else {\n            list.push(formatted);\n        }\n    }\n\n    // AggregateError support.  We render sub-errors as subordinate to the parent.  Otherwise the parent error would\n    // be ambiguous.  This means they get an extra indent level but since they will not tend to be nested as deeply as\n    // causes (I think) this is a decent tradeoff\n    if (Array.isArray(errors)) {\n        let cause = 0;\n        list.push(\n            Diagnostic.list(\n                errors.map(e => formatError(e, { messagePrefix: `Cause #${cause++}:`, parentStack: stackLines })),\n            ),\n        );\n    }\n\n    return list as Diagnostic;\n}\n\nfunction messageAndStackFor(error: any, parentStack?: string[]) {\n    let message: string | undefined;\n    let rawStack: string | undefined;\n    if (error !== undefined && error !== null) {\n        if (error instanceof Error) {\n            message = error.message;\n            rawStack = error.stack;\n        } else if (error.message) {\n            message = typeof error.message === \"string\" ? message : error.toString();\n        }\n    }\n    if (message === undefined || message === null || message === \"\") {\n        if (error instanceof Error) {\n            message = error.constructor.name;\n            if (message === \"Error\") {\n                message = \"(unknown error)\";\n            }\n        } else {\n            message = \"(unknown error)\";\n        }\n    }\n    if (!rawStack) {\n        return { message };\n    }\n\n    rawStack = rawStack.toString();\n\n    // Strip extra node garbage off stack from node asserts\n    rawStack = rawStack.replace(/^.*?\\n\\nError: /gs, \"Error: \");\n\n    // Strip off redundant error tag from v8\n    if (rawStack.startsWith(\"Error: \")) {\n        rawStack = rawStack.slice(7);\n    }\n\n    // Strip off redundant message from v8\n    const pos = rawStack.indexOf(message);\n    if (pos !== -1) {\n        rawStack = rawStack.slice(pos + message.length).trim();\n    }\n\n    // Extract raw lines\n    let stackLines = rawStack\n        .split(\"\\n\")\n        .map(line => line.trim())\n        .filter(line => line !== \"\");\n\n    // Node helpfully gives us this if there's no message.  It's not even the name of the error class, just \"Error\"\n    if (stackLines[0] === \"Error\") {\n        stackLines.shift();\n    }\n\n    // If there's a parent stack, identify the portion of the stack in common so we don't have to repeat it.  The stacks\n    // may be truncated by the VM so this is not 100% guaranteed correct with recursive functions, but accidental\n    // mismatches are unlikely\n    let truncatedToParent = false;\n    if (parentStack) {\n        let truncateTo = 0;\n\n        // For each line in the stack, find the line in the parent.  Skip the last two lines because truncating them\n        // won't save space\n        stackSearch: for (; truncateTo < stackLines.length - 1; truncateTo++) {\n            let parentPos = parentStack.indexOf(stackLines[truncateTo]);\n            if (parentPos === -1) {\n                continue;\n            }\n\n            // Found the line.  If all subsequent lines match then we truncate.  If either stack terminates before the\n            // other, assume the stacks are truncated and consider a match\n            parentPos++;\n            for (\n                let pos = truncateTo + 1;\n                pos < stackLines.length && parentPos < parentStack.length;\n                pos++, parentPos++\n            ) {\n                if (stackLines[pos] !== parentStack[parentPos]) {\n                    continue stackSearch;\n                }\n            }\n\n            // Found a match.  Truncate but leave the top-most shared frame to make it clear where the commonality\n            // with the parent starts\n            stackLines = stackLines.slice(0, truncateTo + 1);\n            truncatedToParent = true;\n            break;\n        }\n    }\n\n    // Spiff up stack lines a bit\n    const stack = Array<unknown>();\n    for (const line of stackLines) {\n        const match1 = line.match(/^at\\s+(?:(.+)\\s+\\(([^)]+)\\)|(<anonymous>))$/);\n        if (match1) {\n            const value = [Diagnostic.weak(\"at \"), match1[1] ?? match1[3]];\n            if (match1[2] !== undefined) {\n                value.push(Diagnostic.weak(\" (\"), Diagnostic.weak(match1[2]), Diagnostic.weak(\")\"));\n            }\n            stack.push(Diagnostic.squash(...value));\n            continue;\n        }\n\n        const match2 = line.match(/^at\\s+(.+)(:\\d+:\\d+)$/);\n        if (match2) {\n            stack.push(Diagnostic.squash(Diagnostic.weak(\"at \"), match2[1], Diagnostic.weak(match2[2])));\n            continue;\n        }\n\n        stack.push(line);\n    }\n\n    // Add truncation note\n    if (truncatedToParent) {\n        stack.push(Diagnostic.weak(\"(see parent frames)\"));\n    }\n\n    return { message, stack, stackLines };\n}\n"],
  "mappings": "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",
  "names": ["Diagnostic", "Presentation", "value", "via", "error", "cause", "pos"]
}
