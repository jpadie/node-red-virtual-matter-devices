/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { NetworkRuntime } from "../behavior/system/network/NetworkRuntime.js";
import { Endpoint } from "../endpoint/Endpoint.js";
import { RootEndpoint } from "../endpoint/definitions/system/RootEndpoint.js";
import { Environment } from "../environment/Environment.js";
import { RuntimeService } from "../environment/RuntimeService.js";
import { Diagnostic } from "../log/Diagnostic.js";
import { Construction } from "../util/Construction.js";
import { NodeLifecycle } from "./NodeLifecycle.js";
/**
 * A Matter Node.
 *
 * In Matter, a "node" is an individually addressable top-level network resource.
 */
export declare abstract class Node<T extends RootEndpoint = RootEndpoint> extends Endpoint<T> {
    #private;
    constructor(config: Node.Configuration<T>);
    get env(): Environment;
    /**
     * Lifecycle information.
     */
    createLifecycle(): NodeLifecycle;
    /**
     * Bring the node online.
     */
    start(): Promise<void>;
    /**
     * @deprecated use {@link start}
     */
    bringOnline(): Promise<void>;
    /**
     * Run the node in standalone mode.  Returns when the node is closed.
     */
    run(): Promise<void>;
    /**
     * Take the node offline but leave state and structure intact.  Happens automatically on close.
     *
     * Once the node is offline you may use {@link start} to bring the node online again.
     */
    cancel(): Promise<void>;
    close(): Promise<void>;
    /**
     * Create the network runtime.
     */
    protected abstract createRuntime(): NetworkRuntime;
    get [RuntimeService.label](): (string | Diagnostic)[];
    get [Diagnostic.value](): unknown;
    get lifecycle(): NodeLifecycle;
    protected statusUpdate(message: string): void;
    [Construction.destruct](): Promise<void>;
    /**
     * Normal endpoints must have an owner to complete construction but Nodes have no such precondition for
     * construction.
     */
    protected assertConstructable(): void;
}
export declare namespace Node {
    interface NodeOptions extends Endpoint.EndpointOptions {
        environment?: Environment;
    }
    type Options<T extends RootEndpoint = RootEndpoint> = Endpoint.Options<T, NodeOptions>;
    type Configuration<T extends RootEndpoint = RootEndpoint> = Endpoint.Configuration<T, NodeOptions>;
    function nodeConfigFor<T extends RootEndpoint>(defaultType: T, configuration: undefined | T | Configuration<T>, options?: Options<T>): Node.Configuration<T>;
}
//# sourceMappingURL=Node.d.ts.map