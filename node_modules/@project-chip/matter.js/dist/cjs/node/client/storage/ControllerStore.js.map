{
  "version": 3,
  "sources": ["../../../../../src/node/client/storage/ControllerStore.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Destructable } from \"../../../common/Lifecycle.js\";\nimport { ImplementationError } from \"../../../common/MatterError.js\";\nimport { Environment } from \"../../../environment/Environment.js\";\nimport { StorageService } from \"../../../environment/StorageService.js\";\nimport { Diagnostic } from \"../../../log/Diagnostic.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport { StorageContext } from \"../../../storage/StorageContext.js\";\nimport { StorageManager } from \"../../../storage/StorageManager.js\";\nimport { Construction, asyncNew } from \"../../../util/Construction.js\";\n\nconst logger = Logger.get(\"ControllerStore\");\n\n/**\n * Non-volatile state management for a {@link ControllerNode}.\n *\n * The default implementation for matter.js uses synchronous APIs for storage.\n * However, this will change in the future, and other implementations may be\n * backed by asynchronous storage.  So the public API is asynchronous.\n */\nexport class ControllerStore implements Destructable {\n    #location: string;\n    #nodeId: string;\n    #storageManager?: StorageManager;\n    #sessionStorage?: StorageContext;\n    #credentialsStorage?: StorageContext; // Root certificate and Fabric\n    #nodesStorage?: StorageContext; // Holds list of nodes in root level and then sub levels with data per client node?\n    #construction: Construction<ControllerStore>;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    /**\n     * Create a new store.\n     *\n     * TODO - implement conversion from 0.7 format so people can change API seamlessly\n     */\n    constructor(environment: Environment, nodeId?: string) {\n        if (nodeId === undefined) {\n            throw new ImplementationError(\"ServerStore must be created with a nodeId\");\n        }\n\n        const storage = environment.get(StorageService);\n        this.#location = storage.location ?? \"(unknown location)\";\n        this.#nodeId = nodeId;\n\n        const initializeStorage = async () => {\n            this.#storageManager = await storage.open(nodeId);\n\n            this.#logChange(\"Opened\");\n        };\n\n        this.#construction = Construction(this, initializeStorage);\n    }\n\n    static async create(environment: Environment, nodeId: string) {\n        return await asyncNew(this, environment, nodeId);\n    }\n\n    async erase() {\n        await this.#sessionStorage?.clearAll();\n        await this.#credentialsStorage?.clearAll();\n        await this.#nodesStorage?.clearAll();\n    }\n\n    async close() {\n        await this.#construction.close(async () => {\n            await this.#storageManager?.close();\n            this.#logChange(\"Closed\");\n        });\n    }\n\n    get sessionStorage() {\n        if (!this.#sessionStorage) {\n            this.#sessionStorage = this.storage.createContext(\"sessions\");\n        }\n        return this.#sessionStorage;\n    }\n\n    get credentialsStorage() {\n        if (!this.#credentialsStorage) {\n            this.#credentialsStorage = this.storage.createContext(\"credentials\");\n        }\n        return this.#credentialsStorage;\n    }\n\n    get nodesStorage() {\n        if (this.#nodesStorage === undefined) {\n            this.#nodesStorage = this.storage.createContext(\"nodes\");\n        }\n        return this.#nodesStorage;\n    }\n\n    get storage() {\n        if (this.#storageManager === undefined) {\n            throw new ImplementationError(\"Node storage accessed prior to initialization\");\n        }\n        return this.#storageManager;\n    }\n\n    #logChange(what: \"Opened\" | \"Closed\") {\n        logger.info(what, Diagnostic.strong(this.#nodeId ?? \"node\"), \"storage at\", `${this.#location}/${this.#nodeId}`);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,yBAAoC;AAEpC,4BAA+B;AAC/B,wBAA2B;AAC3B,oBAAuB;AAGvB,0BAAuC;AAdvC;AAAA;AAAA;AAAA;AAAA;AAgBA,MAAM,SAAS,qBAAO,IAAI,iBAAiB;AASpC,MAAM,gBAAwC;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA,EAEA,IAAI,eAAe;AACf,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,aAA0B,QAAiB;AACnD,QAAI,WAAW,QAAW;AACtB,YAAM,IAAI,uCAAoB,2CAA2C;AAAA,IAC7E;AAEA,UAAM,UAAU,YAAY,IAAI,oCAAc;AAC9C,SAAK,YAAY,QAAQ,YAAY;AACrC,SAAK,UAAU;AAEf,UAAM,oBAAoB,YAAY;AAClC,WAAK,kBAAkB,MAAM,QAAQ,KAAK,MAAM;AAEhD,WAAK,WAAW,QAAQ;AAAA,IAC5B;AAEA,SAAK,oBAAgB,kCAAa,MAAM,iBAAiB;AAAA,EAC7D;AAAA,EAEA,aAAa,OAAO,aAA0B,QAAgB;AAC1D,WAAO,UAAM,8BAAS,MAAM,aAAa,MAAM;AAAA,EACnD;AAAA,EAEA,MAAM,QAAQ;AACV,UAAM,KAAK,iBAAiB,SAAS;AACrC,UAAM,KAAK,qBAAqB,SAAS;AACzC,UAAM,KAAK,eAAe,SAAS;AAAA,EACvC;AAAA,EAEA,MAAM,QAAQ;AACV,UAAM,KAAK,cAAc,MAAM,YAAY;AACvC,YAAM,KAAK,iBAAiB,MAAM;AAClC,WAAK,WAAW,QAAQ;AAAA,IAC5B,CAAC;AAAA,EACL;AAAA,EAEA,IAAI,iBAAiB;AACjB,QAAI,CAAC,KAAK,iBAAiB;AACvB,WAAK,kBAAkB,KAAK,QAAQ,cAAc,UAAU;AAAA,IAChE;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,qBAAqB;AACrB,QAAI,CAAC,KAAK,qBAAqB;AAC3B,WAAK,sBAAsB,KAAK,QAAQ,cAAc,aAAa;AAAA,IACvE;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,eAAe;AACf,QAAI,KAAK,kBAAkB,QAAW;AAClC,WAAK,gBAAgB,KAAK,QAAQ,cAAc,OAAO;AAAA,IAC3D;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,UAAU;AACV,QAAI,KAAK,oBAAoB,QAAW;AACpC,YAAM,IAAI,uCAAoB,+CAA+C;AAAA,IACjF;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAW,MAA2B;AAClC,WAAO,KAAK,MAAM,6BAAW,OAAO,KAAK,WAAW,MAAM,GAAG,cAAc,GAAG,KAAK,SAAS,IAAI,KAAK,OAAO,EAAE;AAAA,EAClH;AACJ;",
  "names": []
}
