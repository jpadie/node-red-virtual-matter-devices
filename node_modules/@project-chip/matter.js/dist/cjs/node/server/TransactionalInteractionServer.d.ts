/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterDevice } from "../../MatterDevice.js";
import { AccessControlServer } from "../../behavior/definitions/access-control/AccessControlServer.js";
import { AnyAttributeServer, AttributeServer } from "../../cluster/server/AttributeServer.js";
import { CommandServer } from "../../cluster/server/CommandServer.js";
import { AnyEventServer } from "../../cluster/server/EventServer.js";
import { Message } from "../../codec/MessageCodec.js";
import { Endpoint } from "../../endpoint/Endpoint.js";
import { EndpointInterface } from "../../endpoint/EndpointInterface.js";
import { MessageExchange } from "../../protocol/MessageExchange.js";
import { EventStorageData } from "../../protocol/interaction/EventHandler.js";
import { WriteRequest, WriteResponse } from "../../protocol/interaction/InteractionMessenger.js";
import { TlvEventFilter } from "../../protocol/interaction/InteractionProtocol.js";
import { AttributePath, CommandPath, EventPath, InteractionServer } from "../../protocol/interaction/InteractionServer.js";
import { TypeFromSchema } from "../../tlv/TlvSchema.js";
import { ServerNode } from "../ServerNode.js";
/**
 * Wire up an InteractionServer that initializes an InvocationContext earlier than the cluster API supports.
 *
 * This is necessary for attributes because the ClusterServer attribute APIs are synchronous while transaction
 * management is asynchronous.
 *
 * It's not necessary for command handling because that API is entirely async.  We do it here, however, just for the
 * sake of consistency.
 *
 * This could be integrated directly into InteractionServer but this further refactoring is probably warranted there
 * regardless.  This keeps the touch light for now.
 */
export declare class TransactionalInteractionServer extends InteractionServer {
    #private;
    static create(endpoint: Endpoint<ServerNode.RootEndpoint>): Promise<TransactionalInteractionServer>;
    constructor(endpoint: Endpoint<ServerNode.RootEndpoint>, config: InteractionServer.Configuration);
    [Symbol.asyncDispose](): Promise<void>;
    blockNewActivity(): void;
    onNewExchange(exchange: MessageExchange<MatterDevice>): Promise<void>;
    get aclServer(): AccessControlServer;
    protected readAttribute(path: AttributePath, attribute: AnyAttributeServer<any>, exchange: MessageExchange<MatterDevice>, fabricFiltered: boolean, message: Message, endpoint: EndpointInterface): Promise<{
        version: number;
        value: any;
    }>;
    protected readEvent(path: EventPath, eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined, event: AnyEventServer<any, any>, exchange: MessageExchange<MatterDevice>, fabricFiltered: boolean, message: Message, endpoint: EndpointInterface): Promise<EventStorageData<any>[]>;
    handleWriteRequest(exchange: MessageExchange<MatterDevice>, writeRequest: WriteRequest, message: Message): Promise<WriteResponse>;
    protected writeAttribute(path: AttributePath, attribute: AttributeServer<any>, value: any, exchange: MessageExchange<MatterDevice>, message: Message, endpoint: EndpointInterface, timed?: boolean, isListWrite?: boolean): Promise<void>;
    protected invokeCommand(path: CommandPath, command: CommandServer<any, any>, exchange: MessageExchange<MatterDevice>, commandFields: any, message: Message, endpoint: EndpointInterface, timed?: boolean): Promise<{
        code: import("../../protocol/interaction/StatusCode.js").StatusCode;
        clusterCode?: number;
        responseId: import("../../datatype/CommandId.js").CommandId;
        response: import("../../tlv/TlvSchema.js").TlvStream;
    }>;
}
//# sourceMappingURL=TransactionalInteractionServer.d.ts.map