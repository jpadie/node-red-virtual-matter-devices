{
  "version": 3,
  "sources": ["../../../../src/node/server/TransactionalInteractionServer.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MatterDevice } from \"../../MatterDevice.js\";\nimport { AccessControl } from \"../../behavior/AccessControl.js\";\nimport { ActionContext } from \"../../behavior/context/ActionContext.js\";\nimport { ActionTracer } from \"../../behavior/context/ActionTracer.js\";\nimport { NodeActivity } from \"../../behavior/context/NodeActivity.js\";\nimport { OnlineContext } from \"../../behavior/context/server/OnlineContext.js\";\nimport { AccessControlServer } from \"../../behavior/definitions/access-control/AccessControlServer.js\";\nimport { BasicInformationServer } from \"../../behavior/definitions/basic-information/BasicInformationServer.js\";\nimport { AccessControlCluster } from \"../../cluster/definitions/AccessControlCluster.js\";\nimport { AnyAttributeServer, AttributeServer } from \"../../cluster/server/AttributeServer.js\";\nimport { CommandServer } from \"../../cluster/server/CommandServer.js\";\nimport { AnyEventServer } from \"../../cluster/server/EventServer.js\";\nimport { Message } from \"../../codec/MessageCodec.js\";\nimport { InternalError } from \"../../common/MatterError.js\";\nimport { Endpoint } from \"../../endpoint/Endpoint.js\";\nimport { EndpointInterface } from \"../../endpoint/EndpointInterface.js\";\nimport { EndpointServer } from \"../../endpoint/EndpointServer.js\";\nimport { EndpointLifecycle } from \"../../endpoint/properties/EndpointLifecycle.js\";\nimport { Diagnostic } from \"../../log/Diagnostic.js\";\nimport { MessageExchange } from \"../../protocol/MessageExchange.js\";\nimport { AccessDeniedError } from \"../../protocol/interaction/AccessControlManager.js\";\nimport { EventStorageData } from \"../../protocol/interaction/EventHandler.js\";\nimport { InteractionEndpointStructure } from \"../../protocol/interaction/InteractionEndpointStructure.js\";\nimport {\n    InteractionServerMessenger,\n    WriteRequest,\n    WriteResponse,\n} from \"../../protocol/interaction/InteractionMessenger.js\";\nimport { TlvEventFilter } from \"../../protocol/interaction/InteractionProtocol.js\";\nimport {\n    AttributePath,\n    CommandPath,\n    EventPath,\n    InteractionServer,\n} from \"../../protocol/interaction/InteractionServer.js\";\nimport { TypeFromSchema } from \"../../tlv/TlvSchema.js\";\nimport { MaybePromise } from \"../../util/Promises.js\";\nimport { ServerNode } from \"../ServerNode.js\";\n\nconst activityKey = Symbol(\"activity\");\n\ninterface WithActivity {\n    [activityKey]?: NodeActivity.Activity;\n}\n\nconst AclClusterId = AccessControlCluster.id;\nconst AclAttributeId = AccessControlCluster.attributes.acl.id;\n\n/**\n * Wire up an InteractionServer that initializes an InvocationContext earlier than the cluster API supports.\n *\n * This is necessary for attributes because the ClusterServer attribute APIs are synchronous while transaction\n * management is asynchronous.\n *\n * It's not necessary for command handling because that API is entirely async.  We do it here, however, just for the\n * sake of consistency.\n *\n * This could be integrated directly into InteractionServer but this further refactoring is probably warranted there\n * regardless.  This keeps the touch light for now.\n */\nexport class TransactionalInteractionServer extends InteractionServer {\n    #endpointStructure: InteractionEndpointStructure;\n    #changeListener: (type: EndpointLifecycle.Change) => void;\n    #endpoint: Endpoint<ServerNode.RootEndpoint>;\n    #activity: NodeActivity;\n    #newActivityBlocked = false;\n    #aclServer?: AccessControlServer;\n    #aclUpdateIsDelayed = false;\n\n    static async create(endpoint: Endpoint<ServerNode.RootEndpoint>) {\n        const endpointStructure = new InteractionEndpointStructure();\n\n        const maxPathsPerInvoke = await endpoint.act(\n            agent => agent.get(BasicInformationServer).state.maxPathsPerInvoke,\n        );\n\n        return new TransactionalInteractionServer(endpoint, {\n            endpointStructure,\n            subscriptionOptions: endpoint.state.network.subscriptionOptions,\n            maxPathsPerInvoke,\n        });\n    }\n\n    constructor(endpoint: Endpoint<ServerNode.RootEndpoint>, config: InteractionServer.Configuration) {\n        super(config);\n\n        const { endpointStructure } = config;\n\n        this.#activity = endpoint.env.get(NodeActivity);\n\n        this.#endpoint = endpoint;\n        this.#endpointStructure = endpointStructure;\n\n        // TODO - rewrite element lookup so we don't need to build the secondary endpoint structure cache\n        this.#updateStructure();\n        this.#changeListener = type => {\n            switch (type) {\n                case EndpointLifecycle.Change.PartsReady:\n                case EndpointLifecycle.Change.ClientsChanged:\n                case EndpointLifecycle.Change.ServersChanged:\n                case EndpointLifecycle.Change.Destroyed:\n                    this.#updateStructure();\n                    break;\n            }\n        };\n\n        endpoint.lifecycle.changed.on(this.#changeListener);\n    }\n\n    async [Symbol.asyncDispose]() {\n        this.#endpoint.lifecycle.changed.off(this.#changeListener);\n        await this.close();\n        this.#endpointStructure.close();\n    }\n\n    blockNewActivity() {\n        this.#newActivityBlocked = true;\n    }\n\n    override async onNewExchange(exchange: MessageExchange<MatterDevice>) {\n        // When closing, ignore anything newly incoming\n        if (this.#newActivityBlocked || this.isClosing) {\n            return;\n        }\n\n        // Activity tracking.  This provides diagnostic information and prevents the server from shutting down whilst\n        // the exchange is active\n        using activity = this.#activity.begin(`session#${exchange.session.id.toString(16)}`);\n        (exchange as WithActivity)[activityKey] = activity;\n\n        // Delegate to InteractionServerMessenger\n        return new InteractionServerMessenger(exchange)\n            .handleRequest(this)\n            .finally(() => delete (exchange as WithActivity)[activityKey]);\n    }\n\n    get aclServer() {\n        if (this.#aclServer !== undefined) {\n            return this.#aclServer;\n        }\n        const aclServer = this.#endpoint.act(agent => agent.get(AccessControlServer));\n        if (MaybePromise.is(aclServer)) {\n            throw new InternalError(\"AccessControlServer should already be initialized.\");\n        }\n        return (this.#aclServer = aclServer);\n    }\n\n    protected override async readAttribute(\n        path: AttributePath,\n        attribute: AnyAttributeServer<any>,\n        exchange: MessageExchange<MatterDevice>,\n        fabricFiltered: boolean,\n        message: Message,\n        endpoint: EndpointInterface,\n    ) {\n        const readAttribute = () => super.readAttribute(path, attribute, exchange, fabricFiltered, message, endpoint);\n\n        return OnlineContext({\n            activity: (exchange as WithActivity)[activityKey],\n            fabricFiltered,\n            message,\n            exchange,\n            tracer: this.#tracer,\n            actionType: ActionTracer.ActionType.Read,\n            endpoint,\n            root: this.#endpoint,\n        }).act(readAttribute);\n    }\n\n    protected override async readEvent(\n        path: EventPath,\n        eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined,\n        event: AnyEventServer<any, any>,\n        exchange: MessageExchange<MatterDevice>,\n        fabricFiltered: boolean,\n        message: Message,\n        endpoint: EndpointInterface,\n    ): Promise<EventStorageData<any>[]> {\n        const readEvent = (context: ActionContext) => {\n            if (!context.authorizedFor(event.readAcl, { cluster: path.clusterId } as AccessControl.Location)) {\n                throw new AccessDeniedError(\n                    `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`,\n                );\n            }\n            return super.readEvent(path, eventFilters, event, exchange, fabricFiltered, message, endpoint);\n        };\n\n        return OnlineContext({\n            activity: (exchange as WithActivity)[activityKey],\n            fabricFiltered,\n            message,\n            exchange,\n            tracer: this.#tracer,\n            actionType: ActionTracer.ActionType.Read,\n            endpoint,\n            root: this.#endpoint,\n        }).act(readEvent);\n    }\n\n    override async handleWriteRequest(\n        exchange: MessageExchange<MatterDevice>,\n        writeRequest: WriteRequest,\n        message: Message,\n    ): Promise<WriteResponse> {\n        const result = await super.handleWriteRequest(exchange, writeRequest, message);\n\n        // We delayed the ACL update during the write transaction, so we need to update it now that anything is written\n        if (this.#aclUpdateIsDelayed) {\n            this.aclServer.aclUpdateDelayed = false;\n            this.#aclUpdateIsDelayed = false;\n        }\n        return result;\n    }\n\n    protected override async writeAttribute(\n        path: AttributePath,\n        attribute: AttributeServer<any>,\n        value: any,\n        exchange: MessageExchange<MatterDevice>,\n        message: Message,\n        endpoint: EndpointInterface,\n        timed = false,\n        isListWrite?: boolean,\n    ) {\n        const writeAttribute = () =>\n            super.writeAttribute(path, attribute, value, exchange, message, endpoint, timed, isListWrite);\n\n        if (path.endpointId === 0 && path.clusterId === AclClusterId && path.attributeId === AclAttributeId) {\n            // This is a hack to prevent the ACL from updating while we are in the middle of a write transaction\n            // and is needed because Acl should not become effective during writing of the ACL itself.\n            this.aclServer.aclUpdateDelayed = true;\n            this.#aclUpdateIsDelayed = true;\n        } else if (this.#aclUpdateIsDelayed) {\n            // Ok it seems that acl was written, but we now write another path, so we can update Acl attribute now\n            this.aclServer.aclUpdateDelayed = false;\n            this.#aclUpdateIsDelayed = false;\n        }\n\n        return OnlineContext({\n            activity: (exchange as WithActivity)[activityKey],\n            timed,\n            message,\n            exchange,\n            fabricFiltered: true,\n            tracer: this.#tracer,\n            actionType: ActionTracer.ActionType.Write,\n            endpoint,\n            root: this.#endpoint,\n        }).act(writeAttribute);\n    }\n\n    protected override async invokeCommand(\n        path: CommandPath,\n        command: CommandServer<any, any>,\n        exchange: MessageExchange<MatterDevice>,\n        commandFields: any,\n        message: Message,\n        endpoint: EndpointInterface,\n        timed = false,\n    ) {\n        const invokeCommand = (context: ActionContext) => {\n            if (!context.authorizedFor(command.invokeAcl, { cluster: path.clusterId } as AccessControl.Location)) {\n                throw new AccessDeniedError(\n                    `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`,\n                );\n            }\n            return super.invokeCommand(path, command, exchange, commandFields, message, endpoint, timed);\n        };\n\n        return OnlineContext({\n            activity: (exchange as WithActivity)[activityKey],\n            command: true,\n            timed,\n            message,\n            exchange,\n            tracer: this.#tracer,\n            actionType: ActionTracer.ActionType.Invoke,\n            endpoint,\n            root: this.#endpoint,\n        }).act(invokeCommand);\n    }\n\n    get #tracer() {\n        if (this.#endpoint.env.has(ActionTracer)) {\n            return this.#endpoint.env.get(ActionTracer);\n        }\n    }\n\n    #updateStructure() {\n        if (this.#endpoint.lifecycle.isPartsReady) {\n            this.#endpointStructure.initializeFromEndpoint(EndpointServer.forEndpoint(this.#endpoint));\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AASA,0BAA6B;AAC7B,0BAA6B;AAC7B,2BAA8B;AAC9B,iCAAoC;AACpC,oCAAuC;AACvC,kCAAqC;AAKrC,yBAA8B;AAG9B,4BAA+B;AAC/B,+BAAkC;AAClC,wBAA2B;AAE3B,kCAAkC;AAElC,0CAA6C;AAC7C,kCAIO;AAEP,+BAKO;AAEP,sBAA6B;AA1C7B;AAAA;AAAA;AAAA;AAAA;AA6CA,MAAM,cAAc,OAAO,UAAU;AAMrC,MAAM,eAAe,iDAAqB;AAC1C,MAAM,iBAAiB,iDAAqB,WAAW,IAAI;AAcpD,MAAM,uCAAuC,2CAAkB;AAAA,EAClE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,sBAAsB;AAAA,EACtB;AAAA,EACA,sBAAsB;AAAA,EAEtB,aAAa,OAAO,UAA6C;AAC7D,UAAM,oBAAoB,IAAI,iEAA6B;AAE3D,UAAM,oBAAoB,MAAM,SAAS;AAAA,MACrC,WAAS,MAAM,IAAI,oDAAsB,EAAE,MAAM;AAAA,IACrD;AAEA,WAAO,IAAI,+BAA+B,UAAU;AAAA,MAChD;AAAA,MACA,qBAAqB,SAAS,MAAM,QAAQ;AAAA,MAC5C;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,YAAY,UAA6C,QAAyC;AAC9F,UAAM,MAAM;AAEZ,UAAM,EAAE,kBAAkB,IAAI;AAE9B,SAAK,YAAY,SAAS,IAAI,IAAI,gCAAY;AAE9C,SAAK,YAAY;AACjB,SAAK,qBAAqB;AAG1B,SAAK,iBAAiB;AACtB,SAAK,kBAAkB,UAAQ;AAC3B,cAAQ,MAAM;AAAA,QACV,KAAK,2CAAkB,OAAO;AAAA,QAC9B,KAAK,2CAAkB,OAAO;AAAA,QAC9B,KAAK,2CAAkB,OAAO;AAAA,QAC9B,KAAK,2CAAkB,OAAO;AAC1B,eAAK,iBAAiB;AACtB;AAAA,MACR;AAAA,IACJ;AAEA,aAAS,UAAU,QAAQ,GAAG,KAAK,eAAe;AAAA,EACtD;AAAA,EAEA,OAAO,OAAO,YAAY,IAAI;AAC1B,SAAK,UAAU,UAAU,QAAQ,IAAI,KAAK,eAAe;AACzD,UAAM,KAAK,MAAM;AACjB,SAAK,mBAAmB,MAAM;AAAA,EAClC;AAAA,EAEA,mBAAmB;AACf,SAAK,sBAAsB;AAAA,EAC/B;AAAA,EAEA,MAAe,cAAc,UAAyC;AAQlE;AAAA;AANA,UAAI,KAAK,uBAAuB,KAAK,WAAW;AAC5C;AAAA,MACJ;AAIA,YAAM,WAAW,qBAAK,UAAU,MAAM,WAAW,SAAS,QAAQ,GAAG,SAAS,EAAE,CAAC,EAAE;AACnF,MAAC,SAA0B,WAAW,IAAI;AAG1C,aAAO,IAAI,uDAA2B,QAAQ,EACzC,cAAc,IAAI,EAClB,QAAQ,MAAM,OAAQ,SAA0B,WAAW,CAAC;AAAA,aANjE;AAAA;AAAA;AAAA;AAAA;AAAA,EAOJ;AAAA,EAEA,IAAI,YAAY;AACZ,QAAI,KAAK,eAAe,QAAW;AAC/B,aAAO,KAAK;AAAA,IAChB;AACA,UAAM,YAAY,KAAK,UAAU,IAAI,WAAS,MAAM,IAAI,8CAAmB,CAAC;AAC5E,QAAI,6BAAa,GAAG,SAAS,GAAG;AAC5B,YAAM,IAAI,iCAAc,oDAAoD;AAAA,IAChF;AACA,WAAQ,KAAK,aAAa;AAAA,EAC9B;AAAA,EAEA,MAAyB,cACrB,MACA,WACA,UACA,gBACA,SACA,UACF;AACE,UAAM,gBAAgB,MAAM,MAAM,cAAc,MAAM,WAAW,UAAU,gBAAgB,SAAS,QAAQ;AAE5G,eAAO,oCAAc;AAAA,MACjB,UAAW,SAA0B,WAAW;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,KAAK;AAAA,MACb,YAAY,iCAAa,WAAW;AAAA,MACpC;AAAA,MACA,MAAM,KAAK;AAAA,IACf,CAAC,EAAE,IAAI,aAAa;AAAA,EACxB;AAAA,EAEA,MAAyB,UACrB,MACA,cACA,OACA,UACA,gBACA,SACA,UACgC;AAChC,UAAM,YAAY,CAAC,YAA2B;AAC1C,UAAI,CAAC,QAAQ,cAAc,MAAM,SAAS,EAAE,SAAS,KAAK,UAAU,CAA2B,GAAG;AAC9F,cAAM,IAAI;AAAA,UACN,aAAa,SAAS,MAAM,IAAI,6BAAW,IAAI,KAAK,SAAS,CAAC,cAAc,SAAS,QAAQ,IAAI;AAAA,QACrG;AAAA,MACJ;AACA,aAAO,MAAM,UAAU,MAAM,cAAc,OAAO,UAAU,gBAAgB,SAAS,QAAQ;AAAA,IACjG;AAEA,eAAO,oCAAc;AAAA,MACjB,UAAW,SAA0B,WAAW;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,KAAK;AAAA,MACb,YAAY,iCAAa,WAAW;AAAA,MACpC;AAAA,MACA,MAAM,KAAK;AAAA,IACf,CAAC,EAAE,IAAI,SAAS;AAAA,EACpB;AAAA,EAEA,MAAe,mBACX,UACA,cACA,SACsB;AACtB,UAAM,SAAS,MAAM,MAAM,mBAAmB,UAAU,cAAc,OAAO;AAG7E,QAAI,KAAK,qBAAqB;AAC1B,WAAK,UAAU,mBAAmB;AAClC,WAAK,sBAAsB;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA,EAEA,MAAyB,eACrB,MACA,WACA,OACA,UACA,SACA,UACA,QAAQ,OACR,aACF;AACE,UAAM,iBAAiB,MACnB,MAAM,eAAe,MAAM,WAAW,OAAO,UAAU,SAAS,UAAU,OAAO,WAAW;AAEhG,QAAI,KAAK,eAAe,KAAK,KAAK,cAAc,gBAAgB,KAAK,gBAAgB,gBAAgB;AAGjG,WAAK,UAAU,mBAAmB;AAClC,WAAK,sBAAsB;AAAA,IAC/B,WAAW,KAAK,qBAAqB;AAEjC,WAAK,UAAU,mBAAmB;AAClC,WAAK,sBAAsB;AAAA,IAC/B;AAEA,eAAO,oCAAc;AAAA,MACjB,UAAW,SAA0B,WAAW;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,MAChB,QAAQ,KAAK;AAAA,MACb,YAAY,iCAAa,WAAW;AAAA,MACpC;AAAA,MACA,MAAM,KAAK;AAAA,IACf,CAAC,EAAE,IAAI,cAAc;AAAA,EACzB;AAAA,EAEA,MAAyB,cACrB,MACA,SACA,UACA,eACA,SACA,UACA,QAAQ,OACV;AACE,UAAM,gBAAgB,CAAC,YAA2B;AAC9C,UAAI,CAAC,QAAQ,cAAc,QAAQ,WAAW,EAAE,SAAS,KAAK,UAAU,CAA2B,GAAG;AAClG,cAAM,IAAI;AAAA,UACN,aAAa,SAAS,MAAM,IAAI,6BAAW,IAAI,KAAK,SAAS,CAAC,cAAc,SAAS,QAAQ,IAAI;AAAA,QACrG;AAAA,MACJ;AACA,aAAO,MAAM,cAAc,MAAM,SAAS,UAAU,eAAe,SAAS,UAAU,KAAK;AAAA,IAC/F;AAEA,eAAO,oCAAc;AAAA,MACjB,UAAW,SAA0B,WAAW;AAAA,MAChD,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,KAAK;AAAA,MACb,YAAY,iCAAa,WAAW;AAAA,MACpC;AAAA,MACA,MAAM,KAAK;AAAA,IACf,CAAC,EAAE,IAAI,aAAa;AAAA,EACxB;AAAA,EAEA,IAAI,UAAU;AACV,QAAI,KAAK,UAAU,IAAI,IAAI,gCAAY,GAAG;AACtC,aAAO,KAAK,UAAU,IAAI,IAAI,gCAAY;AAAA,IAC9C;AAAA,EACJ;AAAA,EAEA,mBAAmB;AACf,QAAI,KAAK,UAAU,UAAU,cAAc;AACvC,WAAK,mBAAmB,uBAAuB,qCAAe,YAAY,KAAK,SAAS,CAAC;AAAA,IAC7F;AAAA,EACJ;AACJ;",
  "names": []
}
