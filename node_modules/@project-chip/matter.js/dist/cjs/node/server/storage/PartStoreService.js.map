{
  "version": 3,
  "sources": ["../../../../../src/node/server/storage/PartStoreService.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2024 Matter.js Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Lifecycle } from \"../../../common/Lifecycle.js\";\nimport { ImplementationError, InternalError } from \"../../../common/MatterError.js\";\nimport { Endpoint } from \"../../../endpoint/Endpoint.js\";\nimport { PartStore } from \"../../../endpoint/storage/PartStore.js\";\nimport { Logger } from \"../../../log/Logger.js\";\nimport type { StorageContext } from \"../../../storage/StorageContext.js\";\nimport { Construction, asyncNew } from \"../../../util/Construction.js\";\nimport { IdentityConflictError } from \"../IdentityService.js\";\nimport { ServerPartStore } from \"./ServerPartStore.js\";\n\nconst NEXT_NUMBER_KEY = \"__nextNumber__\";\n\nconst logger = Logger.get(\"PartStoreService\");\n\n/**\n * Manages all {@link ServerPartStore}s for a {@link NodeServer}.\n *\n * We eagerly load all available endpoint data from disk because this allows us to keep {@link Endpoint} initialization\n * more synchronous.  We can initialize most behaviors synchronously if their state is already in memory.\n *\n * TODO - cleanup of storage for permanently removed endpoints\n */\nexport abstract class PartStoreService {\n    /**\n     * Allocate an endpoint number.\n     *\n     * Either allocates a new number for a {@link Endpoint} or reserves the endpoint's number.  If the {@link Endpoint}\n     * already has a number but it is allocated to a different endpoint it is an error.\n     *\n     * We must persist the assigned number and next endpoint number.  We are fairly resilient to the small chance that\n     * persistence fails so we persist lazily and return synchronously.\n     */\n    abstract assignNumber(endpoint: Endpoint): void;\n\n    /**\n     * Obtain the store for a single {@link Endpoint}.\n     *\n     * These stores are cached internally by ID.\n     *\n     * TODO - when StorageContext becomes async we can keep this synchronous if we add \"StorageContext.subcontexts\" or\n     * somesuch\n     */\n    abstract storeForPart(endpoint: Endpoint): PartStore;\n}\n\nexport class PartStoreFactory extends PartStoreService {\n    #storage: StorageContext;\n    #allocatedNumbers = new Set<number>();\n    #construction: Construction<PartStoreFactory>;\n    #persistedNextNumber?: number;\n    #numbersPersisted?: Promise<void>;\n    #numbersToPersist?: Array<Endpoint>;\n    #nextNumber?: number;\n    #defaultNextNumber: number;\n    #root?: ServerPartStore;\n\n    get construction() {\n        return this.#construction;\n    }\n\n    constructor({ storage, nextNumber }: PartStoreService.Options) {\n        super();\n\n        this.#storage = storage;\n        this.#defaultNextNumber = nextNumber ?? 1;\n\n        this.#construction = Construction(this);\n        this.#construction.start();\n    }\n\n    async [Construction.construct]() {\n        // Load next number with excessive validation for the off-chance it somehow gets corrupted\n        this.#nextNumber = (await this.#storage.get(NEXT_NUMBER_KEY, this.#defaultNextNumber)) % 0xffff;\n\n        if (!this.#nextNumber) {\n            this.#nextNumber = 1;\n        } else {\n            this.#persistedNextNumber = this.#nextNumber;\n        }\n\n        // Preload stores so we can access synchronously going forward\n        this.#root = await asyncNew(ServerPartStore, this.#storage);\n    }\n\n    async erase() {\n        if (this.#numbersPersisted) {\n            await this.#numbersPersisted;\n        }\n\n        await this.#storage.clearAll();\n\n        this.#construction.setStatus(Lifecycle.Status.Inactive);\n        this.#construction.start();\n\n        this.#allocatedNumbers = new Set();\n        this.#persistedNextNumber = this.#nextNumber = (this.#defaultNextNumber ?? 1) % 0xffff;\n        this.#root = new ServerPartStore(this.#storage, false);\n\n        await this.construction;\n    }\n\n    async close() {\n        // We can't dispose until number persistence completes\n        if (this.#numbersPersisted) {\n            await this.#numbersPersisted;\n        }\n    }\n\n    assignNumber(endpoint: Endpoint) {\n        if (this.#nextNumber === undefined) {\n            throw new InternalError(\"Endpoint number assigned prior to store initialization\");\n        }\n\n        this.#construction.assert();\n\n        const store = this.storeForPart(endpoint);\n\n        if (endpoint.lifecycle.hasNumber) {\n            // Reserve number\n            if (this.#allocatedNumbers.has(endpoint.number)) {\n                if (this.storeForPart(endpoint).number !== endpoint.number) {\n                    throw new IdentityConflictError(\n                        `Endpoint ${endpoint.id} number ${endpoint.number} is allocated to another endpoint`,\n                    );\n                }\n                return;\n            }\n        } else {\n            // Allocate number\n            const knownNumber = store.number;\n            if (knownNumber) {\n                if (this.#allocatedNumbers.has(knownNumber)) {\n                    logger.warn(`Stored number ${knownNumber} is already allocated to another endpoint, ignoring`);\n                } else {\n                    endpoint.number = knownNumber;\n                    return;\n                }\n            }\n\n            const startNumber = this.#nextNumber;\n\n            while (this.#nextNumber < 1 || this.#allocatedNumbers.has(this.#nextNumber)) {\n                this.#nextNumber = (this.#nextNumber + 1) % 0xffff;\n                if (this.#nextNumber === startNumber) {\n                    throw new ImplementationError(\n                        \"Cannot add additional endpoints because endpoint numbers are exhausted\",\n                    );\n                }\n            }\n\n            const number = this.#nextNumber++;\n            endpoint.number = number;\n        }\n\n        this.#allocatedNumbers.add(endpoint.number);\n        store.number = endpoint.number;\n        this.#persistNumber(endpoint);\n    }\n\n    storeForPart(endpoint: Endpoint): ServerPartStore {\n        this.#construction.assert();\n\n        if (!endpoint.lifecycle.hasId) {\n            throw new InternalError(\"Endpoint storage access without assigned ID\");\n        }\n        if (endpoint.owner) {\n            return this.storeForPart(endpoint.owner).childStoreFor(endpoint);\n        }\n        if (endpoint.number !== 0) {\n            throw new InternalError(\n                \"Endpoint storage inaccessible because endpoint is not a node and is not owned by another endpoint\",\n            );\n        }\n        if (!this.#root) {\n            throw new InternalError(\"Endpoint storage accessed prior to initialization\");\n        }\n        return this.#root;\n    }\n\n    /**\n     * Lazily persist a newly allocated number and the next number.\n     */\n    #persistNumber(endpoint: Endpoint) {\n        // If there's already a set of numbers to persist there will be an outstanding promise that will do the work\n        // for us\n        if (this.#numbersToPersist) {\n            this.#numbersToPersist.push(endpoint);\n            return;\n        }\n\n        this.#numbersToPersist = [endpoint];\n\n        const numberPersister = async () => {\n            await this.#construction;\n\n            const numbersToPersist = this.#numbersToPersist;\n            if (!numbersToPersist) {\n                return;\n            }\n\n            this.#numbersToPersist = undefined;\n            for (const endpoint of numbersToPersist) {\n                const store = this.storeForPart(endpoint);\n                await store.saveNumber();\n            }\n\n            if (this.#nextNumber !== this.#persistedNextNumber) {\n                await this.#storage.set(NEXT_NUMBER_KEY, this.#nextNumber);\n                this.#persistedNextNumber = this.#nextNumber;\n            }\n        };\n\n        // There is a very small chance that there is an outstanding worker that is persisting numbers but hasn't yet\n        // completed.  If this is the case then wait our turn.  Otherwise there's an even smaller chance that\n        // this.#nextNumber gets persisted in the wrong order\n        if (this.#numbersPersisted) {\n            this.#numbersPersisted = this.#numbersPersisted.then(numberPersister);\n        } else {\n            this.#numbersPersisted = numberPersister();\n        }\n    }\n}\n\nexport namespace PartStoreService {\n    export interface Options {\n        storage: StorageContext;\n        nextNumber?: number;\n        load?: boolean;\n    }\n}\n"],
  "mappings": "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",
  "names": ["endpoint"]
}
