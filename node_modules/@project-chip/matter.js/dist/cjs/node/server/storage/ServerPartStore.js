"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ServerPartStore_exports = {};
__export(ServerPartStore_exports, {
  ServerPartStore: () => ServerPartStore
});
module.exports = __toCommonJS(ServerPartStore_exports);
var import_MatterError = require("../../../common/MatterError.js");
var import_DatasourceStore = require("../../../endpoint/storage/DatasourceStore.js");
var import_Construction = require("../../../util/Construction.js");
const NUMBER_KEY = "__number__";
class ServerPartStore {
  #storage;
  #initialValues = {};
  #number;
  #construction;
  #childStorage;
  #childStores = {};
  #knownBehaviors = /* @__PURE__ */ new Set();
  toString() {
    return `storage:${this.#storage.thisContexts.join(".")}`;
  }
  get construction() {
    return this.#construction;
  }
  get initialValues() {
    return this.#initialValues;
  }
  get number() {
    this.#construction.assert();
    return this.#number;
  }
  set number(number) {
    this.#construction.assert();
    if (this.#number !== number) {
      this.#number = number;
    }
  }
  constructor(storage, load = true) {
    this.#storage = storage;
    this.#childStorage = storage.createContext("parts");
    this.#construction = (0, import_Construction.Construction)(this, () => {
      if (!load) {
        return;
      }
      return this.#load();
    });
  }
  async #load() {
    this.#knownBehaviors = new Set(await this.#storage.contexts());
    for (const behaviorId of this.#knownBehaviors) {
      const behaviorValues = this.#initialValues[behaviorId] = {};
      const behaviorStorage = this.#storage.createContext(behaviorId);
      for (const key of await behaviorStorage.keys()) {
        behaviorValues[key] = await behaviorStorage.get(key);
      }
    }
    const number = await this.#storage.get(NUMBER_KEY, -1);
    if (number !== -1) {
      this.#number = number;
    }
    await this.#loadSubparts();
  }
  storeForBehavior(behaviorId) {
    this.#construction.assert();
    return (0, import_DatasourceStore.DatasourceStore)(this, behaviorId);
  }
  childStoreFor(endpoint) {
    if (!endpoint.lifecycle.hasId) {
      throw new import_MatterError.ImplementationError("Cannot access endpoint storage because endpoint has no assigned ID");
    }
    return this.#storeForPartId(endpoint.id);
  }
  #storeForPartId(partId) {
    this.#construction.assert();
    let store = this.#childStores[partId];
    if (store === void 0) {
      store = this.#childStores[partId] = new ServerPartStore(this.#childStorage.createContext(partId), false);
    }
    return store;
  }
  async saveNumber() {
    await this.#construction;
    await this.#storage.set(NUMBER_KEY, this.number);
  }
  async set(values) {
    await this.#construction;
    for (const behaviorId in values) {
      const behaviorValues = values[behaviorId];
      const behaviorStorage = this.#storage.createContext(behaviorId);
      if (behaviorValues === void 0) {
        if (this.#knownBehaviors.has(behaviorId)) {
          await behaviorStorage.clearAll();
          this.#knownBehaviors.delete(behaviorId);
        }
        continue;
      }
      if (!this.#knownBehaviors.has(behaviorId)) {
        this.#knownBehaviors.add(behaviorId);
      }
      for (const key in behaviorValues) {
        const value = behaviorValues[key];
        if (value === void 0) {
          await behaviorStorage.delete(key);
        } else {
          await behaviorStorage.set(key, behaviorValues[key]);
        }
      }
    }
  }
  async delete() {
    await this.#construction;
    await this.#storage.clearAll();
  }
  async #loadSubparts() {
    const knownParts = await this.#childStorage.contexts();
    for (const partId of knownParts) {
      await this.#loadKnownChildStores(partId);
    }
  }
  async #loadKnownChildStores(partId) {
    const partStore = new ServerPartStore(this.#childStorage.createContext(partId));
    this.#childStores[partId] = partStore;
    await partStore.construction;
  }
}
//# sourceMappingURL=ServerPartStore.js.map
